{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://E%3A/downloads/Hijraah/apps/web/src/instrumentation.ts"],"sourcesContent":["/**\n * Root instrumentation re-export\n */\n\nimport * as Sentry from \"@sentry/nextjs\";\n\n// Your existing instrumentation logic (or parts of it)\nfunction registerLegacyInstrumentation() {\n  // This was originally in src/_infrastructure/monitoring/instrumentation.ts\n  console.log(\"Legacy Instrumentation registered\");\n  // Add any other critical logic from your original register function here if needed\n}\n\nexport async function register() {\n  // Call your legacy instrumentation\n  registerLegacyInstrumentation();\n\n  // Sentry wizard's registration logic\n  if (process.env.NEXT_RUNTIME === \"nodejs\") {\n    // Dynamically import server config to avoid bundling it in edge runtime\n    await import(\"../../../sentry.server.config\"); // Path to root directory\n  }\n\n  if (process.env.NEXT_RUNTIME === \"edge\") {\n    // Dynamically import edge config to avoid bundling it in nodejs runtime\n    await import(\"../../../sentry.edge.config\"); // Path to root directory\n  }\n}\n\n// The Sentry wizard also suggested this for capturing errors during Next.js request handling\n// This might be useful if you have custom error handling in `NextResponse` or similar.\n// However, global-error.tsx and Sentry's general error capturing should catch most things.\n// You can uncomment if you find it necessary or if Sentry support recommends it for specific scenarios.\n// export const onRequestError = Sentry.captureRequestError;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAID,uDAAuD;AACvD,SAAS;IACP,2EAA2E;IAC3E,QAAQ,GAAG,CAAC;AACZ,mFAAmF;AACrF;AAEO,eAAe;IACpB,mCAAmC;IACnC;IAEA,qCAAqC;IACrC,wCAA2C;QACzC,wEAAwE;QACxE,+IAA+C,yBAAyB;IAC1E;IAEA,uCAAyC;;IAGzC;AACF,EAEA,6FAA6F;CAC7F,uFAAuF;CACvF,2FAA2F;CAC3F,wGAAwG;CACxG,4DAA4D","debugId":null}}]
}