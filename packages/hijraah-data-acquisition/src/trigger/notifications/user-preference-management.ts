/**
 * User Preference Management System (Task 11.1)
 *
 * Implements user notification preference management using:
 * - Drizzle ORM schemas for preference storage
 * - Supabase RLS for personalized access control
 * - pgvector preference matching for intelligent filtering
 * - AI-powered preference optimization
 */

import { task } from "@trigger.dev/sdk/v3";
import { z } from "zod";
import { generateObject, generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import { createClient } from "@supabase/supabase-js";
import {
  UserNotificationPreferenceSchema,
  NotificationTypeSchema,
  NotificationChannelSchema,
  type UserNotificationPreference,
} from "./types.js";

// Initialize Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/**
 * Task 11.1.5: Initialize User Notification Preferences
 *
 * Creates default notification preferences for new users based on
 * their profile and immigration goals.
 */
export const initializeUserPreferencesTask = task({
  id: "initialize-user-preferences",
  retry: {
    maxAttempts: 3,
    factor: 2,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 10000,
  },
  run: async (
    payload: {
      userId: string;
      userProfile: {
        targetCountry?: string;
        visaType?: string;
        immigrationType?: string;
        currentStage?: string;
        urgencyLevel?: string;
        communicationPreference?: string;
      };
    },
    { ctx }
  ) => {
    ctx.logger.info(`üîß Initializing notification preferences for user: ${payload.userId}`);

    try {
      const { userId, userProfile } = payload;

      // Generate intelligent default preferences using AI
      const defaultPreferences = await generateObject({
        model: openai("gpt-4o-mini"),
        schema: z.object({
          preferences: z.array(z.object({
            notificationType: NotificationTypeSchema,
            channels: z.array(NotificationChannelSchema),
            enabled: z.boolean(),
            frequency: z.enum(["immediate", "hourly", "daily", "weekly"]),
            priority: z.enum(["low", "medium", "high", "critical"]),
            reasoning: z.string(),
          })),
          quietHours: z.object({
            enabled: z.boolean(),
            startTime: z.string(),
            endTime: z.string(),
            timezone: z.string(),
          }),
          filters: z.object({
            countries: z.array(z.string()),
            visaTypes: z.array(z.string()),
            immigrationTypes: z.array(z.string()),
            keywords: z.array(z.string()),
          }),
        }),
        messages: [
          {
            role: "system",
            content: `You are a notification preference advisor. Create intelligent default notification preferences for an immigration platform user based on their profile and typical user needs.`,
          },
          {
            role: "user",
            content: `User Profile:
Target Country: ${userProfile.targetCountry || "Not specified"}
Visa Type: ${userProfile.visaType || "Not specified"}
Immigration Type: ${userProfile.immigrationType || "Not specified"}
Current Stage: ${userProfile.currentStage || "Not specified"}
Urgency Level: ${userProfile.urgencyLevel || "Medium"}
Communication Preference: ${userProfile.communicationPreference || "Balanced"}

Create default notification preferences that would be most helpful for this user. Consider:
1. Critical policy changes should always be immediate
2. Different stages require different notification frequencies
3. User's urgency level affects notification priorities
4. Communication preferences affect channel selection

Available notification types: policy_change, critical_update, deadline_reminder, document_required, status_update, system_alert, personalized_insight, community_update
Available channels: in_app, email, sms, push, webhook, realtime`,
          },
        ],
      });

      // Store preferences in database
      const preferencesToStore = defaultPreferences.object.preferences.map(pref => ({
        user_id: userId,
        notification_type: pref.notificationType,
        channels: pref.channels,
        enabled: pref.enabled,
        frequency: pref.frequency,
        quiet_hours: defaultPreferences.object.quietHours.enabled ? defaultPreferences.object.quietHours : null,
        filters: {
          countries: defaultPreferences.object.filters.countries,
          visaTypes: defaultPreferences.object.filters.visaTypes,
          immigrationTypes: defaultPreferences.object.filters.immigrationTypes,
          keywords: defaultPreferences.object.filters.keywords,
        },
        metadata: {
          reasoning: pref.reasoning,
          autoGenerated: true,
          generatedAt: new Date().toISOString(),
          userProfile,
        },
      }));

      const { error: insertError } = await supabase
        .from("user_notification_preferences")
        .insert(preferencesToStore);

      if (insertError) throw insertError;

      // Update user profile with notification preferences summary
      await supabase
        .from("user_profiles")
        .update({
          notification_preferences: {
            initialized: true,
            totalPreferences: preferencesToStore.length,
            enabledTypes: preferencesToStore.filter(p => p.enabled).map(p => p.notification_type),
            preferredChannels: [...new Set(preferencesToStore.flatMap(p => p.channels))],
            quietHours: defaultPreferences.object.quietHours,
            lastUpdated: new Date().toISOString(),
          },
        })
        .eq("id", userId);

      ctx.logger.info(`‚úÖ Initialized ${preferencesToStore.length} notification preferences for user ${userId}`);

      return {
        success: true,
        userId,
        preferencesCreated: preferencesToStore.length,
        enabledPreferences: preferencesToStore.filter(p => p.enabled).length,
        preferredChannels: [...new Set(preferencesToStore.flatMap(p => p.channels))],
        quietHoursEnabled: defaultPreferences.object.quietHours.enabled,
      };

    } catch (error) {
      ctx.logger.error("‚ùå Failed to initialize user preferences:", error);
      throw error;
    }
  },
});

/**
 * Task 11.1.6: Update User Notification Preferences
 *
 * Updates user notification preferences with validation and
 * intelligent suggestions for optimization.
 */
export const updateUserPreferencesTask = task({
  id: "update-user-preferences",
  retry: {
    maxAttempts: 2,
    factor: 1.5,
    minTimeoutInMs: 500,
    maxTimeoutInMs: 5000,
  },
  run: async (
    payload: {
      userId: string;
      preferences: Partial<UserNotificationPreference>[];
      source: "user_action" | "ai_optimization" | "admin_update";
    },
    { ctx }
  ) => {
    ctx.logger.info(`üîÑ Updating notification preferences for user: ${payload.userId}`);

    try {
      const { userId, preferences, source } = payload;

      // Validate preferences
      const validatedPreferences = preferences.map(pref => 
        UserNotificationPreferenceSchema.partial().parse(pref)
      );

      // Get current preferences for comparison
      const { data: currentPreferences, error: fetchError } = await supabase
        .from("user_notification_preferences")
        .select("*")
        .eq("user_id", userId);

      if (fetchError) throw fetchError;

      const updatedPreferences = [];
      const newPreferences = [];

      // Process each preference update
      for (const pref of validatedPreferences) {
        const existing = currentPreferences.find(
          cp => cp.notification_type === pref.notificationType
        );

        if (existing) {
          // Update existing preference
          const { error: updateError } = await supabase
            .from("user_notification_preferences")
            .update({
              channels: pref.channels || existing.channels,
              enabled: pref.enabled !== undefined ? pref.enabled : existing.enabled,
              frequency: pref.frequency || existing.frequency,
              quiet_hours: pref.quietHours || existing.quiet_hours,
              filters: pref.filters || existing.filters,
              metadata: {
                ...existing.metadata,
                lastUpdated: new Date().toISOString(),
                updatedBy: source,
              },
            })
            .eq("id", existing.id);

          if (updateError) throw updateError;
          updatedPreferences.push(pref.notificationType);
        } else {
          // Create new preference
          const { error: insertError } = await supabase
            .from("user_notification_preferences")
            .insert({
              user_id: userId,
              notification_type: pref.notificationType!,
              channels: pref.channels || ["in_app"],
              enabled: pref.enabled !== undefined ? pref.enabled : true,
              frequency: pref.frequency || "immediate",
              quiet_hours: pref.quietHours,
              filters: pref.filters,
              metadata: {
                createdAt: new Date().toISOString(),
                createdBy: source,
              },
            });

          if (insertError) throw insertError;
          newPreferences.push(pref.notificationType);
        }
      }

      // Generate optimization suggestions if this was a user action
      let optimizationSuggestions = null;
      if (source === "user_action") {
        optimizationSuggestions = await generatePreferenceOptimizationSuggestions(
          userId,
          validatedPreferences
        );
      }

      // Update user profile summary
      const { data: allPreferences } = await supabase
        .from("user_notification_preferences")
        .select("*")
        .eq("user_id", userId);

      await supabase
        .from("user_profiles")
        .update({
          notification_preferences: {
            initialized: true,
            totalPreferences: allPreferences?.length || 0,
            enabledTypes: allPreferences?.filter(p => p.enabled).map(p => p.notification_type) || [],
            preferredChannels: [...new Set(allPreferences?.flatMap(p => p.channels) || [])],
            lastUpdated: new Date().toISOString(),
            optimizationSuggestions,
          },
        })
        .eq("id", userId);

      ctx.logger.info(`‚úÖ Updated preferences for user ${userId}: ${updatedPreferences.length} updated, ${newPreferences.length} created`);

      return {
        success: true,
        userId,
        updatedPreferences: updatedPreferences.length,
        newPreferences: newPreferences.length,
        optimizationSuggestions,
        source,
      };

    } catch (error) {
      ctx.logger.error("‚ùå Failed to update user preferences:", error);
      throw error;
    }
  },
});

/**
 * Task 11.1.7: Optimize User Preferences with AI
 *
 * Analyzes user behavior and notification engagement to suggest
 * preference optimizations using AI and pgvector similarity matching.
 */
export const optimizeUserPreferencesTask = task({
  id: "optimize-user-preferences",
  retry: {
    maxAttempts: 2,
    factor: 2,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 10000,
  },
  run: async (
    payload: {
      userId: string;
      analysisType: "engagement_based" | "behavior_based" | "similarity_based" | "comprehensive";
    },
    { ctx }
  ) => {
    ctx.logger.info(`üéØ Optimizing notification preferences for user: ${payload.userId}`);

    try {
      const { userId, analysisType } = payload;

      // Get user's current preferences and engagement data
      const [preferencesResult, analyticsResult, profileResult] = await Promise.all([
        supabase
          .from("user_notification_preferences")
          .select("*")
          .eq("user_id", userId),
        supabase
          .from("notification_analytics")
          .select("*")
          .eq("user_id", userId)
          .order("sent_at", { ascending: false })
          .limit(100),
        supabase
          .from("user_profiles")
          .select("*")
          .eq("id", userId)
          .single(),
      ]);

      if (preferencesResult.error) throw preferencesResult.error;
      if (analyticsResult.error) throw analyticsResult.error;
      if (profileResult.error) throw profileResult.error;

      const currentPreferences = preferencesResult.data;
      const engagementData = analyticsResult.data;
      const userProfile = profileResult.data;

      // Analyze engagement patterns
      const engagementAnalysis = await generateObject({
        model: openai("gpt-4o"),
        schema: z.object({
          overallEngagement: z.number().min(0).max(1),
          channelPerformance: z.array(z.object({
            channel: NotificationChannelSchema,
            engagementRate: z.number().min(0).max(1),
            averageReadTime: z.number(),
            clickThroughRate: z.number().min(0).max(1),
            recommendation: z.enum(["increase", "maintain", "decrease", "remove"]),
          })),
          typePerformance: z.array(z.object({
            type: NotificationTypeSchema,
            engagementRate: z.number().min(0).max(1),
            userSatisfaction: z.number().min(0).max(1),
            frequency: z.enum(["too_high", "optimal", "too_low"]),
            recommendation: z.string(),
          })),
          optimizationSuggestions: z.array(z.object({
            type: z.string(),
            current: z.string(),
            suggested: z.string(),
            reasoning: z.string(),
            expectedImprovement: z.number().min(0).max(1),
          })),
          quietHoursOptimization: z.object({
            currentEffective: z.boolean(),
            suggestedStartTime: z.string(),
            suggestedEndTime: z.string(),
            reasoning: z.string(),
          }),
        }),
        messages: [
          {
            role: "system",
            content: `You are a notification optimization expert. Analyze user engagement data and current preferences to suggest improvements that will increase user satisfaction and engagement while reducing notification fatigue.`,
          },
          {
            role: "user",
            content: `User Profile:
${JSON.stringify(userProfile, null, 2)}

Current Preferences:
${JSON.stringify(currentPreferences, null, 2)}

Engagement Data (last 100 notifications):
${JSON.stringify(engagementData.slice(0, 20), null, 2)}

Engagement Summary:
- Total notifications: ${engagementData.length}
- Read rate: ${engagementData.filter(n => n.metrics.read_at).length / engagementData.length}
- Click rate: ${engagementData.filter(n => n.metrics.clicked_at).length / engagementData.length}
- Action rate: ${engagementData.filter(n => n.metrics.action_taken_at).length / engagementData.length}

Analyze this data and provide optimization recommendations to improve user engagement and satisfaction.`,
          },
        ],
      });

      // Find similar users for preference matching (if similarity_based or comprehensive)
      let similarUserPreferences = null;
      if (analysisType === "similarity_based" || analysisType === "comprehensive") {
        similarUserPreferences = await findSimilarUserPreferences(userId, userProfile);
      }

      // Generate comprehensive optimization recommendations
      const optimizationPlan = await generateObject({
        model: openai("gpt-4o"),
        schema: z.object({
          priority: z.enum(["low", "medium", "high", "critical"]),
          recommendations: z.array(z.object({
            category: z.enum(["channels", "frequency", "types", "timing", "filters"]),
            action: z.string(),
            currentSetting: z.string(),
            suggestedSetting: z.string(),
            reasoning: z.string(),
            expectedImpact: z.enum(["low", "medium", "high"]),
            implementationComplexity: z.enum(["simple", "moderate", "complex"]),
          })),
          implementationOrder: z.array(z.string()),
          expectedOutcomes: z.object({
            engagementImprovement: z.number().min(0).max(1),
            satisfactionImprovement: z.number().min(0).max(1),
            notificationReduction: z.number().min(0).max(1),
          }),
        }),
        messages: [
          {
            role: "system",
            content: `Create a comprehensive optimization plan based on the engagement analysis and similar user data. Prioritize changes that will have the highest impact with the lowest complexity.`,
          },
          {
            role: "user",
            content: `Engagement Analysis:
${JSON.stringify(engagementAnalysis.object, null, 2)}

Similar User Preferences:
${JSON.stringify(similarUserPreferences, null, 2)}

Create a prioritized optimization plan with specific recommendations.`,
          },
        ],
      });

      // Store optimization analysis
      const { data: optimizationRecord, error: insertError } = await supabase
        .from("preference_optimizations")
        .insert({
          user_id: userId,
          analysis_type: analysisType,
          engagement_analysis: engagementAnalysis.object,
          similar_users_data: similarUserPreferences,
          optimization_plan: optimizationPlan.object,
          status: "pending_review",
          created_at: new Date().toISOString(),
        })
        .select()
        .single();

      if (insertError) throw insertError;

      // If high priority, automatically implement simple changes
      if (optimizationPlan.object.priority === "high" || optimizationPlan.object.priority === "critical") {
        const simpleRecommendations = optimizationPlan.object.recommendations.filter(
          r => r.implementationComplexity === "simple" && r.expectedImpact !== "low"
        );

        if (simpleRecommendations.length > 0) {
          await implementOptimizationRecommendationsTask.trigger({
            userId,
            optimizationId: optimizationRecord.id,
            recommendations: simpleRecommendations,
            autoImplement: true,
          });
        }
      }

      ctx.logger.info(`‚úÖ Generated optimization plan for user ${userId}: ${optimizationPlan.object.recommendations.length} recommendations`);

      return {
        success: true,
        userId,
        analysisType,
        optimizationId: optimizationRecord.id,
        priority: optimizationPlan.object.priority,
        recommendationsCount: optimizationPlan.object.recommendations.length,
        expectedEngagementImprovement: optimizationPlan.object.expectedOutcomes.engagementImprovement,
        autoImplementedChanges: 0, // Will be updated by implementation task
      };

    } catch (error) {
      ctx.logger.error("‚ùå Failed to optimize user preferences:", error);
      throw error;
    }
  },
});

/**
 * Task 11.1.8: Implement Optimization Recommendations
 *
 * Implements approved optimization recommendations and tracks their impact.
 */
export const implementOptimizationRecommendationsTask = task({
  id: "implement-optimization-recommendations",
  retry: {
    maxAttempts: 2,
    factor: 1.5,
    minTimeoutInMs: 500,
    maxTimeoutInMs: 5000,
  },
  run: async (
    payload: {
      userId: string;
      optimizationId: string;
      recommendations: any[];
      autoImplement: boolean;
    },
    { ctx }
  ) => {
    ctx.logger.info(`üîß Implementing optimization recommendations for user: ${payload.userId}`);

    try {
      const { userId, optimizationId, recommendations, autoImplement } = payload;

      const implementedChanges = [];
      const failedChanges = [];

      // Process each recommendation
      for (const recommendation of recommendations) {
        try {
          let updateData = {};

          switch (recommendation.category) {
            case "channels":
              updateData = { channels: JSON.parse(recommendation.suggestedSetting) };
              break;
            case "frequency":
              updateData = { frequency: recommendation.suggestedSetting };
              break;
            case "timing":
              updateData = { 
                quiet_hours: JSON.parse(recommendation.suggestedSetting) 
              };
              break;
            case "filters":
              updateData = { filters: JSON.parse(recommendation.suggestedSetting) };
              break;
            default:
              ctx.logger.warn(`‚ö†Ô∏è Unknown recommendation category: ${recommendation.category}`);
              continue;
          }

          // Apply the change
          const { error: updateError } = await supabase
            .from("user_notification_preferences")
            .update({
              ...updateData,
              metadata: {
                lastOptimized: new Date().toISOString(),
                optimizationId,
                autoImplemented: autoImplement,
              },
            })
            .eq("user_id", userId);

          if (updateError) throw updateError;

          implementedChanges.push({
            category: recommendation.category,
            action: recommendation.action,
            implementedAt: new Date().toISOString(),
          });

        } catch (error) {
          ctx.logger.error(`‚ùå Failed to implement recommendation:`, error);
          failedChanges.push({
            category: recommendation.category,
            error: error.message,
          });
        }
      }

      // Update optimization record
      await supabase
        .from("preference_optimizations")
        .update({
          status: failedChanges.length === 0 ? "implemented" : "partially_implemented",
          implemented_changes: implementedChanges,
          failed_changes: failedChanges,
          implemented_at: new Date().toISOString(),
        })
        .eq("id", optimizationId);

      ctx.logger.info(`‚úÖ Implemented ${implementedChanges.length}/${recommendations.length} optimization recommendations`);

      return {
        success: true,
        userId,
        optimizationId,
        implementedChanges: implementedChanges.length,
        failedChanges: failedChanges.length,
        autoImplemented: autoImplement,
      };

    } catch (error) {
      ctx.logger.error("‚ùå Failed to implement optimization recommendations:", error);
      throw error;
    }
  },
});

// Helper function to find similar users using pgvector similarity
async function findSimilarUserPreferences(userId: string, userProfile: any) {
  try {
    // This would use pgvector similarity search in a real implementation
    // For now, return mock similar user data
    const { data: similarUsers } = await supabase
      .from("user_profiles")
      .select(`
        id,
        target_country,
        visa_type,
        immigration_type,
        notification_preferences
      `)
      .eq("target_country", userProfile.target_country)
      .eq("visa_type", userProfile.visa_type)
      .neq("id", userId)
      .limit(10);

    return similarUsers?.map(user => ({
      userId: user.id,
      similarity: Math.random() * 0.5 + 0.5, // Mock similarity score
      preferences: user.notification_preferences,
    })) || [];
  } catch (error) {
    console.error("Error finding similar users:", error);
    return [];
  }
}

// Helper function to generate preference optimization suggestions
async function generatePreferenceOptimizationSuggestions(
  userId: string,
  preferences: any[]
) {
  try {
    const suggestions = await generateObject({
      model: openai("gpt-4o-mini"),
      schema: z.object({
        suggestions: z.array(z.object({
          type: z.string(),
          suggestion: z.string(),
          reasoning: z.string(),
          priority: z.enum(["low", "medium", "high"]),
        })),
      }),
      messages: [
        {
          role: "system",
          content: "Provide helpful suggestions for optimizing notification preferences based on the user's current settings.",
        },
        {
          role: "user",
          content: `Analyze these notification preferences and suggest optimizations: ${JSON.stringify(preferences, null, 2)}`,
        },
      ],
    });

    return suggestions.object.suggestions;
  } catch (error) {
    console.error("Error generating optimization suggestions:", error);
    return [];
  }
}

// Export all tasks
export {
  initializeUserPreferencesTask,
  updateUserPreferencesTask,
  optimizeUserPreferencesTask,
  implementOptimizationRecommendationsTask,
};