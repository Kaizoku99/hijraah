{"version":3,"file":"2140.js","mappings":"qcUwHA,mNVxHO,SACP,cACA,wBACA,uBACA,CACA,SACA,yBACA,wBACA,CACA,YACA,6BACA,CACA,cACA,6BACA,CACA,QACA,wBACA,uBACA,CACA,CClBO,QACP,eACA,0BACA,YAAsB,CACtB,CACA,cACA,wBAGA,GACA,+BAEA,iBACA,CACA,QACA,eACA,CACA,iBACA,4BACA,CACA,YACA,0BACA,CACA,CCvBO,gBAA4B,EACnC,MAD2C,OAC3C,CACA,iBACA,gCACA,CACA,cACA,oBACA,cACA,6CAEA,gCAGA,mBAEA,CACA,mBACA,sCACA,CACA,CCSO,gBACP,0CACA,CACO,gBACP,wBACA,CACO,gBACP,YAAoB,WAAmB,KACvC,WACA,QACA,QAEA,CAEA,CC1CO,QACP,cACA,mBACA,CACA,YACA,0BACA,CACA,kBACA,OAAe,IAAI,KDKZ,KACP,eAfA,GACA,qBAEA,wBAEA,SAEA,eACA,qBACA,aAGA,QACA,EAEA,GACA,cAEA,iBAGA,YAAoB,EADpB,EACoB,OAA2B,KAC/C,WACA,QACA,QAEA,CAEA,ECnBmB,sCACnB,CACA,cACA,2BAEA,CCdA,uDACO,gBACA,cACA,KACP,8BAEA,uBAEA,iCAEA,6CAEO,qCACA,sBACA,wBACA,mCACA,yBAEA,sBACA,sBACA,qBAGA,kCACA,WACP,MACA,MACA,MACA,MACA,KAEO,uBC/BA,4BACA,OACP,YACA,OACA,UACO,MACP,SACA,KACA,YAAoB,WAAmB,KACvC,kBAEA,GADA,8BACA,CACA,OACA,IACA,QACA,CAEA,GADA,QACA,CACA,UACA,KACA,QACA,CACA,IACA,CACA,QAEA,OADA,UACA,CACA,ECzBA,oBACA,OACA,eACA,aACA,YACA,aACA,CACA,CACA,OACA,EAAyB,EAAW,iCACpC,EFkBO,mBElBkB,CFkBlB,EElB0B,4BACjC,2BACA,WAEA,+CACA,IAEA,EFEO,mBEFkB,GFElB,GEFwB,IFExB,aEFwB,0CAC/B,EFEO,mBEFkB,GAAO,gBAChC,OACA,YACA,mBAKA,OAHA,gCACA,UACS,EACT,CACA,CAAK,SACL,uBAMA,OALA,cACA,gBACA,gCACA,UACS,EACT,CACA,CAAK,EACL,EFrBO,mBEqBkB,IAAQ,oBAGjC,WAFA,8BACA,gCAGA,EAAyB,EAAK,MAG9B,kCACA,EAAyB,EAAK,yCAC9B,KAAgC,EAAU,IAAO,EAAU,EAAjB,CAAiB,YAC3D,EAAsB,GACtB,KADsB,CAGtB,IACA,WAGA,YAEK,QACL,mCACA,KACK,QACL,EF7BO,mBE6BkB,CAAK,qCAC9B,CACA,oBACA,OACA,eACA,aACA,YACA,aACA,CACA,CACA,eACA,EAAQ,EAAQ,IAChB,EADgB,EAChB,gCAIC,OAED,UADA,kCACA,CACC,2BACD,sCACA,MACA,oDAEA,QACA,CAAC,EACD,GACA,UACA,WACA,WACA,YACA,WACA,YACA,aACA,aACA,kBACA,gBACA,YACA,GACC,EAAI,EACL,IFtEO,kCEsEoD,OFtEpD,UEsEoD,wDAC3D,cACA,MACA,yDAEA,eACA,CAAC,EACM,sBACP,kBACA,8CAIA,CACA,iBAEA,SADA,6CACA,CACC,QACD,qDACA,MACA,OAAiB,MAEjB,SAIA,OAHA,cACA,UACK,EACL,CACA,CAAC,WACD,qCACA,MACA,oDAAgE,KAAK,oFAErE,kDACA,CAAC,EACD,WACA,gDACC,OAED,YADA,4CACA,MACC,OACD,8CACA,aACC,UACD,mDACA,MACA,0DAEA,uBACA,CAAC,EACD,YACO,UACP,MAAoC,EAAO,0BAC3C,KACA,OACA,uBACA,sBACA,EAEA,MAAiC,EAAO,0BACxC,KACA,OACA,uBACA,kBAIA,EACA,KACA,cACA,iBACA,CAAC,EACM,gBACP,GAAQ,EAAO,GACf,EADe,KACf,MACA,aACA,2BACA,aACA,2BACA,cACA,2BACA,mBACA,2BACA,SACA,yCACA,CAEA,CACA,WACA,MACA,0CAEA,yBACA,CACA,ECjMA,UACA,YACA,mCACA,eACA,UACA,SACA,IAEA,uBAEA,cACA,GAAQ,EAAQ,eAChB,sDAEA,GAAQ,EAAQ,eAChB,sDAEA,GAAQ,EAAQ,iBAChB,uDAEA,CACO,cACP,KACA,YAAoB,WAAiB,KAC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","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/double-indexed-kv.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/registry.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/class-registry.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/util.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/custom-transformer-registry.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/is.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/pathstringifier.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/transformer.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/accessDeep.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/plainer.js","webpack://@hijraah/web/../../node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/index.js"],"sourcesContent":["export class DoubleIndexedKV {\n    constructor() {\n        this.keyToValue = new Map();\n        this.valueToKey = new Map();\n    }\n    set(key, value) {\n        this.keyToValue.set(key, value);\n        this.valueToKey.set(value, key);\n    }\n    getByKey(key) {\n        return this.keyToValue.get(key);\n    }\n    getByValue(value) {\n        return this.valueToKey.get(value);\n    }\n    clear() {\n        this.keyToValue.clear();\n        this.valueToKey.clear();\n    }\n}\n//# sourceMappingURL=double-indexed-kv.js.map","import { DoubleIndexedKV } from './double-indexed-kv.js';\nexport class Registry {\n    constructor(generateIdentifier) {\n        this.generateIdentifier = generateIdentifier;\n        this.kv = new DoubleIndexedKV();\n    }\n    register(value, identifier) {\n        if (this.kv.getByValue(value)) {\n            return;\n        }\n        if (!identifier) {\n            identifier = this.generateIdentifier(value);\n        }\n        this.kv.set(identifier, value);\n    }\n    clear() {\n        this.kv.clear();\n    }\n    getIdentifier(value) {\n        return this.kv.getByValue(value);\n    }\n    getValue(identifier) {\n        return this.kv.getByKey(identifier);\n    }\n}\n//# sourceMappingURL=registry.js.map","import { Registry } from './registry.js';\nexport class ClassRegistry extends Registry {\n    constructor() {\n        super(c => c.name);\n        this.classToAllowedProps = new Map();\n    }\n    register(value, options) {\n        if (typeof options === 'object') {\n            if (options.allowProps) {\n                this.classToAllowedProps.set(value, options.allowProps);\n            }\n            super.register(value, options.identifier);\n        }\n        else {\n            super.register(value, options);\n        }\n    }\n    getAllowedProps(value) {\n        return this.classToAllowedProps.get(value);\n    }\n}\n//# sourceMappingURL=class-registry.js.map","function valuesOfObj(record) {\n    if ('values' in Object) {\n        // eslint-disable-next-line es5/no-es6-methods\n        return Object.values(record);\n    }\n    const values = [];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in record) {\n        if (record.hasOwnProperty(key)) {\n            values.push(record[key]);\n        }\n    }\n    return values;\n}\nexport function find(record, predicate) {\n    const values = valuesOfObj(record);\n    if ('find' in values) {\n        // eslint-disable-next-line es5/no-es6-methods\n        return values.find(predicate);\n    }\n    const valuesNotNever = values;\n    for (let i = 0; i < valuesNotNever.length; i++) {\n        const value = valuesNotNever[i];\n        if (predicate(value)) {\n            return value;\n        }\n    }\n    return undefined;\n}\nexport function forEach(record, run) {\n    Object.entries(record).forEach(([key, value]) => run(value, key));\n}\nexport function includes(arr, value) {\n    return arr.indexOf(value) !== -1;\n}\nexport function findArr(record, predicate) {\n    for (let i = 0; i < record.length; i++) {\n        const value = record[i];\n        if (predicate(value)) {\n            return value;\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=util.js.map","import { find } from './util.js';\nexport class CustomTransformerRegistry {\n    constructor() {\n        this.transfomers = {};\n    }\n    register(transformer) {\n        this.transfomers[transformer.name] = transformer;\n    }\n    findApplicable(v) {\n        return find(this.transfomers, transformer => transformer.isApplicable(v));\n    }\n    findByName(name) {\n        return this.transfomers[name];\n    }\n}\n//# sourceMappingURL=custom-transformer-registry.js.map","const getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);\nexport const isUndefined = (payload) => typeof payload === 'undefined';\nexport const isNull = (payload) => payload === null;\nexport const isPlainObject = (payload) => {\n    if (typeof payload !== 'object' || payload === null)\n        return false;\n    if (payload === Object.prototype)\n        return false;\n    if (Object.getPrototypeOf(payload) === null)\n        return true;\n    return Object.getPrototypeOf(payload) === Object.prototype;\n};\nexport const isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;\nexport const isArray = (payload) => Array.isArray(payload);\nexport const isString = (payload) => typeof payload === 'string';\nexport const isNumber = (payload) => typeof payload === 'number' && !isNaN(payload);\nexport const isBoolean = (payload) => typeof payload === 'boolean';\nexport const isRegExp = (payload) => payload instanceof RegExp;\nexport const isMap = (payload) => payload instanceof Map;\nexport const isSet = (payload) => payload instanceof Set;\nexport const isSymbol = (payload) => getType(payload) === 'Symbol';\nexport const isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());\nexport const isError = (payload) => payload instanceof Error;\nexport const isNaNValue = (payload) => typeof payload === 'number' && isNaN(payload);\nexport const isPrimitive = (payload) => isBoolean(payload) ||\n    isNull(payload) ||\n    isUndefined(payload) ||\n    isNumber(payload) ||\n    isString(payload) ||\n    isSymbol(payload);\nexport const isBigint = (payload) => typeof payload === 'bigint';\nexport const isInfinite = (payload) => payload === Infinity || payload === -Infinity;\nexport const isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);\nexport const isURL = (payload) => payload instanceof URL;\n//# sourceMappingURL=is.js.map","export const escapeKey = (key) => key.replace(/\\./g, '\\\\.');\nexport const stringifyPath = (path) => path\n    .map(String)\n    .map(escapeKey)\n    .join('.');\nexport const parsePath = (string) => {\n    const result = [];\n    let segment = '';\n    for (let i = 0; i < string.length; i++) {\n        let char = string.charAt(i);\n        const isEscapedDot = char === '\\\\' && string.charAt(i + 1) === '.';\n        if (isEscapedDot) {\n            segment += '.';\n            i++;\n            continue;\n        }\n        const isEndOfSegment = char === '.';\n        if (isEndOfSegment) {\n            result.push(segment);\n            segment = '';\n            continue;\n        }\n        segment += char;\n    }\n    const lastSegment = segment;\n    result.push(lastSegment);\n    return result;\n};\n//# sourceMappingURL=pathstringifier.js.map","import { isBigint, isDate, isInfinite, isMap, isNaNValue, isRegExp, isSet, isUndefined, isSymbol, isArray, isError, isTypedArray, isURL, } from './is.js';\nimport { findArr } from './util.js';\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n    return {\n        isApplicable,\n        annotation,\n        transform,\n        untransform,\n    };\n}\nconst simpleRules = [\n    simpleTransformation(isUndefined, 'undefined', () => null, () => undefined),\n    simpleTransformation(isBigint, 'bigint', v => v.toString(), v => {\n        if (typeof BigInt !== 'undefined') {\n            return BigInt(v);\n        }\n        console.error('Please add a BigInt polyfill.');\n        return v;\n    }),\n    simpleTransformation(isDate, 'Date', v => v.toISOString(), v => new Date(v)),\n    simpleTransformation(isError, 'Error', (v, superJson) => {\n        const baseError = {\n            name: v.name,\n            message: v.message,\n        };\n        superJson.allowedErrorProps.forEach(prop => {\n            baseError[prop] = v[prop];\n        });\n        return baseError;\n    }, (v, superJson) => {\n        const e = new Error(v.message);\n        e.name = v.name;\n        e.stack = v.stack;\n        superJson.allowedErrorProps.forEach(prop => {\n            e[prop] = v[prop];\n        });\n        return e;\n    }),\n    simpleTransformation(isRegExp, 'regexp', v => '' + v, regex => {\n        const body = regex.slice(1, regex.lastIndexOf('/'));\n        const flags = regex.slice(regex.lastIndexOf('/') + 1);\n        return new RegExp(body, flags);\n    }),\n    simpleTransformation(isSet, 'set', \n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    v => [...v.values()], v => new Set(v)),\n    simpleTransformation(isMap, 'map', v => [...v.entries()], v => new Map(v)),\n    simpleTransformation((v) => isNaNValue(v) || isInfinite(v), 'number', v => {\n        if (isNaNValue(v)) {\n            return 'NaN';\n        }\n        if (v > 0) {\n            return 'Infinity';\n        }\n        else {\n            return '-Infinity';\n        }\n    }, Number),\n    simpleTransformation((v) => v === 0 && 1 / v === -Infinity, 'number', () => {\n        return '-0';\n    }, Number),\n    simpleTransformation(isURL, 'URL', v => v.toString(), v => new URL(v)),\n];\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n    return {\n        isApplicable,\n        annotation,\n        transform,\n        untransform,\n    };\n}\nconst symbolRule = compositeTransformation((s, superJson) => {\n    if (isSymbol(s)) {\n        const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n        return isRegistered;\n    }\n    return false;\n}, (s, superJson) => {\n    const identifier = superJson.symbolRegistry.getIdentifier(s);\n    return ['symbol', identifier];\n}, v => v.description, (_, a, superJson) => {\n    const value = superJson.symbolRegistry.getValue(a[1]);\n    if (!value) {\n        throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n});\nconst constructorToName = [\n    Int8Array,\n    Uint8Array,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array,\n    Uint8ClampedArray,\n].reduce((obj, ctor) => {\n    obj[ctor.name] = ctor;\n    return obj;\n}, {});\nconst typedArrayRule = compositeTransformation(isTypedArray, v => ['typed-array', v.constructor.name], v => [...v], (v, a) => {\n    const ctor = constructorToName[a[1]];\n    if (!ctor) {\n        throw new Error('Trying to deserialize unknown typed array');\n    }\n    return new ctor(v);\n});\nexport function isInstanceOfRegisteredClass(potentialClass, superJson) {\n    if (potentialClass?.constructor) {\n        const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);\n        return isRegistered;\n    }\n    return false;\n}\nconst classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {\n    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier];\n}, (clazz, superJson) => {\n    const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);\n    if (!allowedProps) {\n        return { ...clazz };\n    }\n    const result = {};\n    allowedProps.forEach(prop => {\n        result[prop] = clazz[prop];\n    });\n    return result;\n}, (v, a, superJson) => {\n    const clazz = superJson.classRegistry.getValue(a[1]);\n    if (!clazz) {\n        throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);\n    }\n    return Object.assign(Object.create(clazz.prototype), v);\n});\nconst customRule = compositeTransformation((value, superJson) => {\n    return !!superJson.customTransformerRegistry.findApplicable(value);\n}, (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(value);\n    return ['custom', transformer.name];\n}, (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(value);\n    return transformer.serialize(value);\n}, (v, a, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findByName(a[1]);\n    if (!transformer) {\n        throw new Error('Trying to deserialize unknown custom value');\n    }\n    return transformer.deserialize(v);\n});\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\nexport const transformValue = (value, superJson) => {\n    const applicableCompositeRule = findArr(compositeRules, rule => rule.isApplicable(value, superJson));\n    if (applicableCompositeRule) {\n        return {\n            value: applicableCompositeRule.transform(value, superJson),\n            type: applicableCompositeRule.annotation(value, superJson),\n        };\n    }\n    const applicableSimpleRule = findArr(simpleRules, rule => rule.isApplicable(value, superJson));\n    if (applicableSimpleRule) {\n        return {\n            value: applicableSimpleRule.transform(value, superJson),\n            type: applicableSimpleRule.annotation,\n        };\n    }\n    return undefined;\n};\nconst simpleRulesByAnnotation = {};\nsimpleRules.forEach(rule => {\n    simpleRulesByAnnotation[rule.annotation] = rule;\n});\nexport const untransformValue = (json, type, superJson) => {\n    if (isArray(type)) {\n        switch (type[0]) {\n            case 'symbol':\n                return symbolRule.untransform(json, type, superJson);\n            case 'class':\n                return classRule.untransform(json, type, superJson);\n            case 'custom':\n                return customRule.untransform(json, type, superJson);\n            case 'typed-array':\n                return typedArrayRule.untransform(json, type, superJson);\n            default:\n                throw new Error('Unknown transformation: ' + type);\n        }\n    }\n    else {\n        const transformation = simpleRulesByAnnotation[type];\n        if (!transformation) {\n            throw new Error('Unknown transformation: ' + type);\n        }\n        return transformation.untransform(json, superJson);\n    }\n};\n//# sourceMappingURL=transformer.js.map","import { isMap, isArray, isPlainObject, isSet } from './is.js';\nimport { includes } from './util.js';\nconst getNthKey = (value, n) => {\n    if (n > value.size)\n        throw new Error('index out of bounds');\n    const keys = value.keys();\n    while (n > 0) {\n        keys.next();\n        n--;\n    }\n    return keys.next().value;\n};\nfunction validatePath(path) {\n    if (includes(path, '__proto__')) {\n        throw new Error('__proto__ is not allowed as a property');\n    }\n    if (includes(path, 'prototype')) {\n        throw new Error('prototype is not allowed as a property');\n    }\n    if (includes(path, 'constructor')) {\n        throw new Error('constructor is not allowed as a property');\n    }\n}\nexport const getDeep = (object, path) => {\n    validatePath(path);\n    for (let i = 0; i < path.length; i++) {\n        const key = path[i];\n        if (isSet(object)) {\n            object = getNthKey(object, +key);\n        }\n        else if (isMap(object)) {\n            const row = +key;\n            const type = +path[++i] === 0 ? 'key' : 'value';\n            const keyOfRow = getNthKey(object, row);\n            switch (type) {\n                case 'key':\n                    object = keyOfRow;\n                    break;\n                case 'value':\n                    object = object.get(keyOfRow);\n                    break;\n            }\n        }\n        else {\n            object = object[key];\n        }\n    }\n    return object;\n};\nexport const setDeep = (object, path, mapper) => {\n    validatePath(path);\n    if (path.length === 0) {\n        return mapper(object);\n    }\n    let parent = object;\n    for (let i = 0; i < path.length - 1; i++) {\n        const key = path[i];\n        if (isArray(parent)) {\n            const index = +key;\n            parent = parent[index];\n        }\n        else if (isPlainObject(parent)) {\n            parent = parent[key];\n        }\n        else if (isSet(parent)) {\n            const row = +key;\n            parent = getNthKey(parent, row);\n        }\n        else if (isMap(parent)) {\n            const isEnd = i === path.length - 2;\n            if (isEnd) {\n                break;\n            }\n            const row = +key;\n            const type = +path[++i] === 0 ? 'key' : 'value';\n            const keyOfRow = getNthKey(parent, row);\n            switch (type) {\n                case 'key':\n                    parent = keyOfRow;\n                    break;\n                case 'value':\n                    parent = parent.get(keyOfRow);\n                    break;\n            }\n        }\n    }\n    const lastKey = path[path.length - 1];\n    if (isArray(parent)) {\n        parent[+lastKey] = mapper(parent[+lastKey]);\n    }\n    else if (isPlainObject(parent)) {\n        parent[lastKey] = mapper(parent[lastKey]);\n    }\n    if (isSet(parent)) {\n        const oldValue = getNthKey(parent, +lastKey);\n        const newValue = mapper(oldValue);\n        if (oldValue !== newValue) {\n            parent.delete(oldValue);\n            parent.add(newValue);\n        }\n    }\n    if (isMap(parent)) {\n        const row = +path[path.length - 2];\n        const keyToRow = getNthKey(parent, row);\n        const type = +lastKey === 0 ? 'key' : 'value';\n        switch (type) {\n            case 'key': {\n                const newKey = mapper(keyToRow);\n                parent.set(newKey, parent.get(keyToRow));\n                if (newKey !== keyToRow) {\n                    parent.delete(keyToRow);\n                }\n                break;\n            }\n            case 'value': {\n                parent.set(keyToRow, mapper(parent.get(keyToRow)));\n                break;\n            }\n        }\n    }\n    return object;\n};\n//# sourceMappingURL=accessDeep.js.map","import { isArray, isEmptyObject, isMap, isPlainObject, isPrimitive, isSet, } from './is.js';\nimport { escapeKey, stringifyPath } from './pathstringifier.js';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue, } from './transformer.js';\nimport { includes, forEach } from './util.js';\nimport { parsePath } from './pathstringifier.js';\nimport { getDeep, setDeep } from './accessDeep.js';\nfunction traverse(tree, walker, origin = []) {\n    if (!tree) {\n        return;\n    }\n    if (!isArray(tree)) {\n        forEach(tree, (subtree, key) => traverse(subtree, walker, [...origin, ...parsePath(key)]));\n        return;\n    }\n    const [nodeValue, children] = tree;\n    if (children) {\n        forEach(children, (child, key) => {\n            traverse(child, walker, [...origin, ...parsePath(key)]);\n        });\n    }\n    walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations, superJson) {\n    traverse(annotations, (type, path) => {\n        plain = setDeep(plain, path, v => untransformValue(v, type, superJson));\n    });\n    return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations) {\n    function apply(identicalPaths, path) {\n        const object = getDeep(plain, parsePath(path));\n        identicalPaths.map(parsePath).forEach(identicalObjectPath => {\n            plain = setDeep(plain, identicalObjectPath, () => object);\n        });\n    }\n    if (isArray(annotations)) {\n        const [root, other] = annotations;\n        root.forEach(identicalPath => {\n            plain = setDeep(plain, parsePath(identicalPath), () => plain);\n        });\n        if (other) {\n            forEach(other, apply);\n        }\n    }\n    else {\n        forEach(annotations, apply);\n    }\n    return plain;\n}\nconst isDeep = (object, superJson) => isPlainObject(object) ||\n    isArray(object) ||\n    isMap(object) ||\n    isSet(object) ||\n    isInstanceOfRegisteredClass(object, superJson);\nfunction addIdentity(object, path, identities) {\n    const existingSet = identities.get(object);\n    if (existingSet) {\n        existingSet.push(path);\n    }\n    else {\n        identities.set(object, [path]);\n    }\n}\nexport function generateReferentialEqualityAnnotations(identitites, dedupe) {\n    const result = {};\n    let rootEqualityPaths = undefined;\n    identitites.forEach(paths => {\n        if (paths.length <= 1) {\n            return;\n        }\n        // if we're not deduping, all of these objects continue existing.\n        // putting the shortest path first makes it easier to parse for humans\n        // if we're deduping though, only the first entry will still exist, so we can't do this optimisation.\n        if (!dedupe) {\n            paths = paths\n                .map(path => path.map(String))\n                .sort((a, b) => a.length - b.length);\n        }\n        const [representativePath, ...identicalPaths] = paths;\n        if (representativePath.length === 0) {\n            rootEqualityPaths = identicalPaths.map(stringifyPath);\n        }\n        else {\n            result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);\n        }\n    });\n    if (rootEqualityPaths) {\n        if (isEmptyObject(result)) {\n            return [rootEqualityPaths];\n        }\n        else {\n            return [rootEqualityPaths, result];\n        }\n    }\n    else {\n        return isEmptyObject(result) ? undefined : result;\n    }\n}\nexport const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = new Map()) => {\n    const primitive = isPrimitive(object);\n    if (!primitive) {\n        addIdentity(object, path, identities);\n        const seen = seenObjects.get(object);\n        if (seen) {\n            // short-circuit result if we've seen this object before\n            return dedupe\n                ? {\n                    transformedValue: null,\n                }\n                : seen;\n        }\n    }\n    if (!isDeep(object, superJson)) {\n        const transformed = transformValue(object, superJson);\n        const result = transformed\n            ? {\n                transformedValue: transformed.value,\n                annotations: [transformed.type],\n            }\n            : {\n                transformedValue: object,\n            };\n        if (!primitive) {\n            seenObjects.set(object, result);\n        }\n        return result;\n    }\n    if (includes(objectsInThisPath, object)) {\n        // prevent circular references\n        return {\n            transformedValue: null,\n        };\n    }\n    const transformationResult = transformValue(object, superJson);\n    const transformed = transformationResult?.value ?? object;\n    const transformedValue = isArray(transformed) ? [] : {};\n    const innerAnnotations = {};\n    forEach(transformed, (value, index) => {\n        if (index === '__proto__' ||\n            index === 'constructor' ||\n            index === 'prototype') {\n            throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);\n        }\n        const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);\n        transformedValue[index] = recursiveResult.transformedValue;\n        if (isArray(recursiveResult.annotations)) {\n            innerAnnotations[index] = recursiveResult.annotations;\n        }\n        else if (isPlainObject(recursiveResult.annotations)) {\n            forEach(recursiveResult.annotations, (tree, key) => {\n                innerAnnotations[escapeKey(index) + '.' + key] = tree;\n            });\n        }\n    });\n    const result = isEmptyObject(innerAnnotations)\n        ? {\n            transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type]\n                : undefined,\n        }\n        : {\n            transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type, innerAnnotations]\n                : innerAnnotations,\n        };\n    if (!primitive) {\n        seenObjects.set(object, result);\n    }\n    return result;\n};\n//# sourceMappingURL=plainer.js.map","function getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\n\nfunction isAnyObject(payload) {\n  return getType(payload) === \"Object\";\n}\n\nfunction isArray(payload) {\n  return getType(payload) === \"Array\";\n}\n\nfunction isBlob(payload) {\n  return getType(payload) === \"Blob\";\n}\n\nfunction isBoolean(payload) {\n  return getType(payload) === \"Boolean\";\n}\n\nfunction isDate(payload) {\n  return getType(payload) === \"Date\" && !isNaN(payload);\n}\n\nfunction isEmptyArray(payload) {\n  return isArray(payload) && payload.length === 0;\n}\n\nfunction isPlainObject(payload) {\n  if (getType(payload) !== \"Object\")\n    return false;\n  const prototype = Object.getPrototypeOf(payload);\n  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\n\nfunction isEmptyObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length === 0;\n}\n\nfunction isEmptyString(payload) {\n  return payload === \"\";\n}\n\nfunction isError(payload) {\n  return getType(payload) === \"Error\" || payload instanceof Error;\n}\n\nfunction isFile(payload) {\n  return getType(payload) === \"File\";\n}\n\nfunction isFullArray(payload) {\n  return isArray(payload) && payload.length > 0;\n}\n\nfunction isFullObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length > 0;\n}\n\nfunction isString(payload) {\n  return getType(payload) === \"String\";\n}\n\nfunction isFullString(payload) {\n  return isString(payload) && payload !== \"\";\n}\n\nfunction isFunction(payload) {\n  return typeof payload === \"function\";\n}\n\nfunction isType(payload, type) {\n  if (!(type instanceof Function)) {\n    throw new TypeError(\"Type must be a function\");\n  }\n  if (!Object.prototype.hasOwnProperty.call(type, \"prototype\")) {\n    throw new TypeError(\"Type is not a class\");\n  }\n  const name = type.name;\n  return getType(payload) === name || Boolean(payload && payload.constructor === type);\n}\n\nfunction isInstanceOf(value, classOrClassName) {\n  if (typeof classOrClassName === \"function\") {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (isType(p, classOrClassName)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (getType(p) === classOrClassName) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nfunction isMap(payload) {\n  return getType(payload) === \"Map\";\n}\n\nfunction isNaNValue(payload) {\n  return getType(payload) === \"Number\" && isNaN(payload);\n}\n\nfunction isNumber(payload) {\n  return getType(payload) === \"Number\" && !isNaN(payload);\n}\n\nfunction isNegativeNumber(payload) {\n  return isNumber(payload) && payload < 0;\n}\n\nfunction isNull(payload) {\n  return getType(payload) === \"Null\";\n}\n\nfunction isOneOf(a, b, c, d, e) {\n  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);\n}\n\nfunction isUndefined(payload) {\n  return getType(payload) === \"Undefined\";\n}\n\nconst isNullOrUndefined = isOneOf(isNull, isUndefined);\n\nfunction isObject(payload) {\n  return isPlainObject(payload);\n}\n\nfunction isObjectLike(payload) {\n  return isAnyObject(payload);\n}\n\nfunction isPositiveNumber(payload) {\n  return isNumber(payload) && payload > 0;\n}\n\nfunction isSymbol(payload) {\n  return getType(payload) === \"Symbol\";\n}\n\nfunction isPrimitive(payload) {\n  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);\n}\n\nfunction isPromise(payload) {\n  return getType(payload) === \"Promise\";\n}\n\nfunction isRegExp(payload) {\n  return getType(payload) === \"RegExp\";\n}\n\nfunction isSet(payload) {\n  return getType(payload) === \"Set\";\n}\n\nfunction isWeakMap(payload) {\n  return getType(payload) === \"WeakMap\";\n}\n\nfunction isWeakSet(payload) {\n  return getType(payload) === \"WeakSet\";\n}\n\nexport { getType, isAnyObject, isArray, isBlob, isBoolean, isDate, isEmptyArray, isEmptyObject, isEmptyString, isError, isFile, isFullArray, isFullObject, isFullString, isFunction, isInstanceOf, isMap, isNaNValue, isNegativeNumber, isNull, isNullOrUndefined, isNumber, isObject, isObjectLike, isOneOf, isPlainObject, isPositiveNumber, isPrimitive, isPromise, isRegExp, isSet, isString, isSymbol, isType, isUndefined, isWeakMap, isWeakSet };\n","import { isArray, isPlainObject } from 'is-what';\n\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? \"enumerable\" : \"nonenumerable\";\n  if (propType === \"enumerable\")\n    carry[key] = newVal;\n  if (includeNonenumerable && propType === \"nonenumerable\") {\n    Object.defineProperty(carry, key, {\n      value: newVal,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nfunction copy(target, options = {}) {\n  if (isArray(target)) {\n    return target.map((item) => copy(item, options));\n  }\n  if (!isPlainObject(target)) {\n    return target;\n  }\n  const props = Object.getOwnPropertyNames(target);\n  const symbols = Object.getOwnPropertySymbols(target);\n  return [...props, ...symbols].reduce((carry, key) => {\n    if (isArray(options.props) && !options.props.includes(key)) {\n      return carry;\n    }\n    const val = target[key];\n    const newVal = copy(val, options);\n    assignProp(carry, key, newVal, target, options.nonenumerable);\n    return carry;\n  }, {});\n}\n\nexport { copy };\n","import { ClassRegistry } from './class-registry.js';\nimport { Registry } from './registry.js';\nimport { CustomTransformerRegistry, } from './custom-transformer-registry.js';\nimport { applyReferentialEqualityAnnotations, applyValueAnnotations, generateReferentialEqualityAnnotations, walker, } from './plainer.js';\nimport { copy } from 'copy-anything';\nexport default class SuperJSON {\n    /**\n     * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.\n     */\n    constructor({ dedupe = false, } = {}) {\n        this.classRegistry = new ClassRegistry();\n        this.symbolRegistry = new Registry(s => s.description ?? '');\n        this.customTransformerRegistry = new CustomTransformerRegistry();\n        this.allowedErrorProps = [];\n        this.dedupe = dedupe;\n    }\n    serialize(object) {\n        const identities = new Map();\n        const output = walker(object, identities, this, this.dedupe);\n        const res = {\n            json: output.transformedValue,\n        };\n        if (output.annotations) {\n            res.meta = {\n                ...res.meta,\n                values: output.annotations,\n            };\n        }\n        const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);\n        if (equalityAnnotations) {\n            res.meta = {\n                ...res.meta,\n                referentialEqualities: equalityAnnotations,\n            };\n        }\n        return res;\n    }\n    deserialize(payload) {\n        const { json, meta } = payload;\n        let result = copy(json);\n        if (meta?.values) {\n            result = applyValueAnnotations(result, meta.values, this);\n        }\n        if (meta?.referentialEqualities) {\n            result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);\n        }\n        return result;\n    }\n    stringify(object) {\n        return JSON.stringify(this.serialize(object));\n    }\n    parse(string) {\n        return this.deserialize(JSON.parse(string));\n    }\n    registerClass(v, options) {\n        this.classRegistry.register(v, options);\n    }\n    registerSymbol(v, identifier) {\n        this.symbolRegistry.register(v, identifier);\n    }\n    registerCustom(transformer, name) {\n        this.customTransformerRegistry.register({\n            name,\n            ...transformer,\n        });\n    }\n    allowErrorProps(...props) {\n        this.allowedErrorProps.push(...props);\n    }\n}\nSuperJSON.defaultInstance = new SuperJSON();\nSuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);\nSuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);\nSuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);\nSuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);\nSuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);\nSuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);\nSuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);\nSuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);\nexport { SuperJSON };\nexport const serialize = SuperJSON.serialize;\nexport const deserialize = SuperJSON.deserialize;\nexport const stringify = SuperJSON.stringify;\nexport const parse = SuperJSON.parse;\nexport const registerClass = SuperJSON.registerClass;\nexport const registerCustom = SuperJSON.registerCustom;\nexport const registerSymbol = SuperJSON.registerSymbol;\nexport const allowErrorProps = SuperJSON.allowErrorProps;\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}