/**
 * AI SDK Message Adapter
 *
 * Context7: Comprehensive Message Format Handler for AI SDK v5 Beta
 *
 * This module implements Context7 defensive programming patterns to handle the critical
 * transition between AI SDK message validation and database persistence. Key features:
 *
 * ## Problem Solved:
 * - AI SDK v5's `validateUIMessages` requires `parts` array format
 * - Database stores simple `content` strings for backward compatibility
 * - Mismatch causes "expected array, received undefined" validation errors
 *
 * ## Context7 Solutions Implemented:
 *
 * ### 1. **Bidirectional Format Conversion**
 * - `dbMessageToAIMessage`: Database → UIMessage format with parts array
 * - `aiMessageToDBMessage`: UIMessage → Database format with content strings
 * - Maintains backward compatibility with existing stored messages
 *
 * ### 2. **Defensive Data Handling**
 * - Null/undefined guard checks prevent runtime errors
 * - Graceful fallbacks when metadata or parts are missing
 * - Type validation ensures data structure integrity
 *
 * ### 3. **Smart Metadata Storage**
 * - UIMessage parts stored in `metadata.uiMessageParts` for validation
 * - Legacy `content` field preserved for backward compatibility
 * - Enables seamless transition without data migration
 *
 * ### 4. **Enhanced Error Recovery**
 * - Invalid data structures trigger cleanup and fallback
 * - Logging provides visibility into conversion issues
 * - Prevents cascade failures in chat validation pipeline
 *
 * ## Usage Pattern:
 * ```typescript
 * // Loading from DB for AI SDK validation
 * const dbMessages = await chatRepository.getMessages(chatId);
 * const aiMessages = dbMessages.map(dbMessageToAIMessage);
 *
 * // Saving AI SDK messages to DB
 * const dbMessage = aiMessageToDBMessage(aiMessage, sessionId, userId);
 * await chatRepository.addMessage(chatId, dbMessage);
 * ```
 *
 * This ensures AI SDK v5's `validateUIMessages` always receives proper UIMessage
 * format while maintaining database compatibility and performance.
 */

import { type CoreMessage as AIMessage } from "ai";
import type { Database } from "@/types/database.types";

type DBChatMessageRow = Database["public"]["Tables"]["chat_messages"]["Row"];

/**
 * Context7: Converts database message to UIMessage format for AI SDK v5 compliance
 *
 * Handles both legacy messages (content only) and new UIMessage format (parts array).
 * This ensures backward compatibility while supporting AI SDK validateUIMessages.
 *
 * @param message The message row from the database.
 * @returns The message in AI SDK UIMessage format with parts array.
 */
export function dbMessageToAIMessage(message: DBChatMessageRow): AIMessage {
  // Context7: Check for stored UIMessage parts in metadata first
  let parts: any[] = [];

  if (
    typeof message.metadata === "object" &&
    message.metadata !== null &&
    "uiMessageParts" in message.metadata
  ) {
    // New format: use stored UIMessage parts
    parts = (message.metadata as any).uiMessageParts;
  } else if (
    typeof message.metadata === "object" &&
    message.metadata !== null &&
    "parts" in message.metadata
  ) {
    // Legacy format: convert old parts format
    parts = (message.metadata as any).parts;
  } else {
    // Fallback: convert simple content to UIMessage parts
    parts = [{ type: "text", text: message.content }];
  }

  const result: any = {
    // id: AI SDK CoreMessage doesn't have id property - will be assigned by UI
    role: message.role as "user" | "assistant" | "system",
    parts: parts.map((p: any) => ({
      type: p.type || "text",
      ...(p.text && { text: p.text }),
      ...(p.content && { text: p.content }), // Handle legacy content field
    })),
    createdAt: new Date(message.created_at),
    // Keep content for backward compatibility
    content: message.content || "",
  };

  // Add experimental_attachments if present in metadata
  if (
    message.metadata &&
    typeof message.metadata === "object" &&
    "experimental_attachments" in message.metadata
  ) {
    result.experimental_attachments = (
      message.metadata as any
    ).experimental_attachments;
  }

  return result;
}

/**
 * Convert AI SDK message to database format
 */
export function aiMessageToDbFormat(
  message: AIMessage,
  sessionId: string,
  userId: string
): Partial<DBChatMessageRow> {
  return {
    // id: Generated by database UUID default
    session_id: sessionId,
    user_id: userId,
    role: message.role,
    content: typeof message.content === "string" ? message.content : "",
    // Don't include created_at or updated_at - let the database handle them
    metadata: {} as any,
  };
}

/**
 * Strip any camelCase fields that might cause PostgREST issues
 */
export function sanitizeForPostgREST<T extends Record<string, any>>(obj: T): T {
  const sanitized: any = {};

  // List of fields that should never be sent to PostgREST
  const blacklistedFields = ["createdAt", "updatedAt", "userId", "sessionId"];

  for (const [key, value] of Object.entries(obj)) {
    // Skip blacklisted fields
    if (blacklistedFields.includes(key)) continue;

    // Only include snake_case fields
    if (!key.match(/[A-Z]/)) {
      sanitized[key] = value;
    }
  }

  return sanitized as T;
}
