{"version":3,"file":"../app/research/page.js","mappings":"ubAAA,oICAO,2DCEP,MAAkB,EAAQ,KAAa,EACvC,UADyB,EAEzB,mBAAwB,GACxB,6BAAwD,CACxD,4BAAqD,uBCNrD,8DCmBI,sBAAsB,sjBAX1B,IAAM,EAAqB,CAAE,GAAG,CAAU,CAAE,CAEtC,EACJ,OAHsB,UAEC,KACD,GAAI,EACtB,EAAmB,gBAAD,IAAC,CACnB,qBAAqB,GAAI,EACvB,EAAmB,gBAAD,GAAC,MACnB,EASN,EAJ6B,KALd,KAKwB,EAArC,OAHoBA,CAOA,CAAG,IAAI,KAAK,CAAC,EAAiB,CAJ5B,KAKjB,CAAE,CAAC,EAAkB,EAAS,CADa,GACT,CAAN,IAC3B,EACA,CAFkB,CAGlB,EAGJ,GAAI,CACF,CAJS,GAAG,CADG,CAKW,CANP,CACD,CAK6B,CANzB,GAED,IADM,EADI,CAO/B,CADuB,CACH,GAAmB,OAAO,CAAC,GAAG,CAAC,EAAd,YAA4B,CAAC,EAAI,OACtE,EAD+E,GAC5C,OAAO,CAA7B,GAAiC,CAAC,EAAd,OAAuB,CAAC,OAAI,EAC7D,EAAU,GAAmB,EAAtB,KACf,CAAO,MAD4B,CACnB,CAAE,CAElB,CAEM,OAAO,+BAAoC,CAAC,EAAkB,CAC5D,aAD0D,CAC5C,CAAE,WAAW,CAC3B,aAAa,CAAE,MAAM,CACrB,iBAAiB,iBACjB,UACA,CACR,CAAO,CAFc,CAEZ,GADM,EACD,CAAC,EAAS,EACxB,CAAK,CADuB,CAAN,GAOjB,IAAC,OAOF,EAEE,EAOF,KAhBkB,EAkBhB,OAOF,EAEE,EAA2B,CAlBN,IASL,iBASQ,IChF9B,qGCAA,yCCAA,cACA,yCAEA,OADA,0BACA,CACA,CACA,cACA,YACA,WACA,oCCRA,0GCAA,qDCAA,sDCYA,MAAW,EAAQ,KAAM,EACzB,EAAS,EAAQ,KAAI,CADH,CAGlB,UAFgB,SAEhB,GACA,+BACA,WAKA,OAJA,YAEA,aADA,sDACA,OAEA,CACA,0BCvBA,wDCOA,qCAA6C,CAAE,SAAa,EAAC,IAqB7D,cAOA,cAQA,cACA,eAMA,OALA,eACA,QACA,8CACA,GAEA,CACA,CAMA,cACA,4BAEA,6BACA,kCAEA,cACA,qEACA,mBAGA,MACA,CACA,qBAIA,cACA,2CACA,yBAEA,CAYA,gBACA,YACA,cACA,QACA,aACA,gBACA,YACA,WACA,oBACA,qBACA,iCACA,CAAK,EAGL,wCAA+C,uBAAgC,EAG/E,qBACA,YAAoB,WAAiB,KACrC,WACA,WACA,kCAEA,CACA,CAsOA,cACA,OACA,MACA,wBACS,CACT,OACA,kBACA,CAAS,CACT,gBACA,aACA,CACA,CAkIA,gBACA,sBACA,CAlXA,aAKA,WACA,0BACK,CAML,aACA,2BACK,CAML,oBACA,6BACK,CAKL,eACA,mCACA,QACA,GAEA,IACK,CAML,WACA,QACA,CAAK,CAML,sBACA,QACA,CAAK,CAML,gBACA,QACA,CAAK,CAML,qBACA,QACA,CAAK,CAML,iBACA,0BACK,CAML,kBACA,aAEA,cACA,4CACA,yBAEA,CAAK,CAML,2BACA,aAEA,cACA,sBACA,qDACA,kCAEA,CAAK,CAML,cACA,6BACA,CAAK,CAML,iBACA,iCACK,CAML,iBACA,UACA,CAAK,CAML,uBACA,wBACK,CAML,eACA,+BACK,CAML,gBACA,yBACK,CAOL,iBACA,2BACK,CAOL,mBACA,sBACA,CAAK,CACL,wBACA,UACA,OAEA,aAEA,cACA,wCACA,yBAEA,CAAK,CAOL,kBACA,wBACK,CACL,uBACA,OACA,UAEA,CAAK,CASL,YAEA,CAAK,EAIL,iDACA,QACA,gBACA,WACA,CAAC,EAGD,oDACA,0DAGA,iCAwKA,kBAYA,cACA,mCACA,CAQA,cACA,eACA,WACA,gBACA,oEAGA,QACA,CA2EA,gBACA,sBACA,EACA,KAAa,EAAU,EArEvB,CACA,MAEA,MADA,QACA,IAmEA,GAlEA,eACA,GAvCA,IAuCA,eACA,kBAEA,SAEA,WACA,CAAS,CAET,OACA,4BACA,SAEA,CAFiC,GAEjC,UAGA,OACA,QAiDA,GAhDA,cAxDA,IAyDA,eAEA,SACA,cACsB,cACtB,MA0CA,EA1CA,QAEA,SAwCA,GArCA,IAGA,SAIA,aACA,OACA,WACA,aA7EA,EA8EA,WACA,QACA,SACA,CACA,UACA,MAqBA,EArBA,GAEA,QAEA,CACA,CAAS,CACT,gBACA,aACA,EAeA,CAQA,cAEA,aACA,YACA,CAEA,uCACA,aACA,QACA,gBACA,WACA,CAAS,CACJ,EAEL,YAAoB,WAAuB,IAC3C,oBAGA,QACA,CAeA,aAEA,iCACA,oBAGA,oDACA,uBAEA,uBACA,8BACA,YAAwB,mBAAsB,IAC9C,kBAEA,WACA,CACA,oDAEA,CAGA,aAQA,wBACA,WACA,OAEA,+BACA,iEAGA,cACA,OAIA,GAHA,EACA,UACA,GA/LA,EACA,EAgMA,GACA,WACA,eACA,uBACA,iBACA,SACA,EAGA,WACA,0BACA,WAKA,WACA,eACA,GACA,gBACA,mBAGA,OAEA,IACA,SAIA,QACA,CAAK,CASL,2BACA,WACA,OAGA,cAIA,EAHA,MACA,UACA,GAjPA,EACA,EAmPA,OACA,WACA,eACA,GACA,gBACA,mBACA,YACA,SACA,cACkB,cAClB,gBAEA,aAKA,IACA,SAEA,CAAK,CAOL,iBACA,oCACA,oDAIA,cACA,SACA,WACA,WACA,SAIA,MA5VA,GADA,UArBA,KACA,iCACA,SAGA,eAKA,OAJA,UACA,WA/CA,KACA,qBACA,gBACA,SAIA,gBACA,gBACA,CAEA,uCACA,aAAuB,oCAAwD,CAC1E,EAGL,YAAoB,WAAiB,KACrC,WACA,wBAEA,yBADA,qCACA,MACA,sBACA,YACA,EACA,EACA,SA3CA,GACA,OACA,QACA,oBACA,8BACA,CAAS,CACT,gBACA,aACA,CACA,EAkCA,GACA,KAEA,CACA,CAEA,QACA,EAeA,+BACA,YAEA,CACA,EAUA,sBA6VA,GA7VA,EA6VA,QAIA,OACA,eAmBA,GAjBA,OACA,SACA,cACkB,cAClB,gBAEA,YAGA,IAIA,EACA,EACA,2BAEA,8BACA,IACA,uBACA,CAAkB,SAElB,6BACA,kCAEA,gBAEA,MA7TA,IA+TA,gBACA,2CAEA,0BAIA,GA7XA,EA6XA,GA7XA,iBA8XA,MAGA,SAMA,OAJA,UAxXA,EAyXA,GAzXA,WAyXA,EA9WA,EA+WA,GA/WA,cA+WA,KAEA,oBACK,EAIL,iDACA,QACA,gBACA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gCACA,eACA,QACA,SACA,YAAoB,MAAS,IAC7B,yDAEA,SACA,CAAC,GAqMM,gBACP,SACA,SACA,YAAwB,WAAgB,KACxC,gBAEA,QACA,CACA,WACA,CCrNA,IAAM,EAAG,gCACT,GACA,YACA,eAEA,cACA,eACA,oBAEA,UACA,SAEA,EACM,EAAQ,cACd,EADc,MACd,eACA,gBACA,UAAoB,EAAQ,SAC5B,EACA,KAF4B,EAE5B,sBACA,GACA,kBACA,aACA,oBACA,sBACA,gBACA,mBACA,cACA,UACA,mBACA,QDkFO,cAGP,gBACA,SAEA,QAOA,GANA,mBACA,oCAEA,oBACA,cAEA,iBACA,qCAAkD,EAAE,gBACpD,4CACA,CAAS,EAET,SACA,YAAoB,WAAmB,GApBvC,KAoBuC,CACvC,gBArBA,KAqBA,YArBA,MAqBA,EACA,KACA,YAAwB,WAAoB,KAC5C,sBACA,WACA,QACA,QACA,SACA,cACA,cACA,eACA,WAA4B,CAA5B,GAAmC,iBACnC,CACA,wBACA,QACA,CACA,UACA,iBACA,QACA,CACA,WACA,oCACA,QACA,CACA,sBACA,YACA,wCACA,QACA,CACA,KACA,4CACA,YACA,aACA,gBACA,eACA,YAEA,aACA,CACA,QACA,EC7IA,oBACA,OAAY,EACZ,UAAe,CAAU,CADC,EACc,CAExC,WAFwC,cAGxC,GACA,UAEA,aACA,qBACA,EAQA,KClDO,YCAA,CDA2B,CCA3B,OIKP,MSMA,oBMAA,EIAA,EiCAA,6BENA,wBGMA,oCOAA,kEWAA,gG9EDA,OAAiB,WAAe,CAEhC,oBACA,iBAEA,OAAM,GACN,KADU,QACV,CACA,YAEA,mBACA,eAEA,KAGA,MAEA,aADA,EACA,QACA,YAAmB,IAAY,KAC/B,IACA,EADA,MAaA,EAVA,EADA,oBACA,EACM,sBACN,gDACM,yBACN,eACM,aAA4B,GAClC,KADsC,CAGtC,6CAEA,OACA,SACA,CACA,CAEA,0BAEA,sDACA,iCACA,YAEA,CACA,WACA,uBAEA,WACA,gBAEA,OACA,2CACA,CACA,cACA,eAEA,uBADA,uDAEA,CACA,SACA,aAIA,OAHA,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A,cAGA,kBACA,QAEA,CAQA,GAAK,uBACL,kDACA,EAGA,GAAK,2EC1uDE,IAAM,GAAM,gBAA+B,IAAI,gBCA/C,OAAoC,gBAAS,OAAU,oGCD9D,OAA0C,kBAC1C,KAD8B,IAC9B,KADkC,CAClC,GADsC,GACtC,MAD0C,IAC1C,iDACA,wIACA,oDACA,CAQO,OAAM,GACb,cADqB,CAErB,YACA,oBACA,IACY,KACZ,iBAA+B,KADQ,GACR,aAAuB,uBAEtD,CACA,4DACA,YACe,QAAU,iBACzB,oCACe,QAAU,YACV,QAAU,SACV,QAAU,SACV,QAAU,YACV,QAAU,SACV,QAAU,YACV,QAAU,aACV,QAAU,YACV,QAAU,UACV,QAAU,sBACV,QAAU,YACzB,CACA,cACA,4BACA,OACA,WACA,UACA,WACA,4BACS,CACT,CACA,WACA,4BACA,OACA,WACA,UACA,WACA,4BACS,CACT,CACA,OACA,2CACA,EAGA,KAFA,IAGA,CACA,UACA,2CACA,EAGA,UAFA,GAIA,OACA,oCACA,CACA,UACA,gCACA,CACA,QACA,mCACA,OAEA,CACA,WACA,yBAEA,aADA,eAEA,WAIA,UACA,mBACA,OAEA,CACA,mBAAyD,8CAA8C,EACvG,IAMA,EANA,mBACA,OACA,sCAAsD,EACtD,SADiE,uCACjE,EAAoD,GAAY,SADC,EAKjE,GAFA,YAEY,QAAM,IAClB,aACA,EACA,IAAsB,IAAI,QAC1B,YACA,4BACiB,OAEjB,GAAiB,GAAM,GACvB,MAAwB,CADD,EACC,CAAI,0BAC5B,YACa,OAEb,KACA,sCAAsD,EAAW,2DAIjE,YAEA,4BACA,OAGA,GAFA,sCAKA,SACA,CAAK,qBACL,qBACA,CACA,aACA,oBACA,kBAEA,CACA,0BACA,gBACA,CACA,CAAK,UAAO,WACZ,+BACA,CACA,wCE/IA,8CASA,GARA,WACA,SACA,KACA,SAK6B,CAJ7B,CAI8B,EAJ9B,+BAEA,QACA,ECRA,kEAYA,GAXA,YACA,OAUe,OAVf,MACA,EAS6B,IAT7B,GAEA,sCACA,SAGA,4CACA,iBACA,ECHA,GARA,aACA,qBAO6B,CAP7B,CAO8B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A,qBgBCA,qCAEA,4BAAqC,oBAErC,CACA,YACA,MfosDe,CepsDA,EACf,CADyB,KfosDL,EAAC,GelsDrB,QAD2B,CACT,GAClB,QAAiB,CADY,EAE7B,QAD2B,CACT,GAClB,KAAc,IAAO,CACrB,IAF6B,CAEf,IAAO,CACrB,cAAsB,mBACtB,0BAAkC,IAClC,+CACA,YAAoB,IACpB,+BAAoD,aAAY,GC9Cf,CAAM,QAAY,CACnE,EAGA,ICRO,OAAM,WAAW,MACxB,CACO,iBAAuB,GAC9B,cADyC,CACzC,MACA,SAAiB,sBAA6C,GAC9D,cACA,eACA,oCACA,aAEA,UADA,GACA,KACA,WAFA,GAEA,MACA,UAHA,GAGA,IACA,CACA,0BACA,iBACA,2BACA,UACA,0BACA,oBACA,SACA,KACA,GAAsB,GAAQ,EAAE,EAAI,EAEpC,EACA,GAAsB,GAAQ,uBAE9B,GAGA,0BACA,CACA,yBACA,UACA,uBAA4C,QAAgB,GAAW,GAAiB,EAExF,GAFuE,CAEvE,kBACA,QACA,gBAEA,QACA,gBAEA,QACA,gBAEA,QACA,gBAEA,QACA,gBAEA,QACA,gBAEA,QACA,gBAEA,OACA,gBAEA,eACA,CACA,CACO,oBACP,qBAAkB,GAAU,EAAI,EAChC,qDACA,CACA,CACO,oBACP,qBAAkB,UAAgB,EAClC,mDAGA,GACA,cACA,CACA,CACO,oBACP,qBAAkB,GAAU,EAAI,EAChC,OAAgB,gCAA0C,CAC1D,CACA,CACO,oBACP,CACO,oBACP,CACO,oBACP,CACO,oBACP,CACO,oBACP,CACO,oBACP,CACO,oBACP,CACO,oBACP,CACO,iBAAsC,GAC7C,cACA,yEACA,CACA,CACO,iBAA6C,GACpD,cAD+D,KAE/D,sFACA,CACA,CC9GA,IAAI,GAAsC,oBAC1C,EAD0B,CAC1B,GAD8B,GAC9B,MADkC,EAClC,EADsC,QACtC,CAD0C,iCAE1C,gFACA,uIACA,kDACA,EACI,GAAsC,kBAC1C,IAD0B,IAAI,CAC9B,QADkC,IAAI,SAAI,CAC1C,iDACA,wIACA,oDACA,CASO,UACP,cACA,mBACA,2BACQ,GAAsB,gBAC9B,CACA,KAF8B,EAE9B,OAYA,EAXA,WACA,SAEA,iDACA,+CACA,EACA,8CACA,mBACA,4BACA,cACA,SAEA,cAmEA,cAGA,eAAkC,WAAmB,KACrD,GAHA,KAGA,CAH0B,CAG1B,GACA,OAAqB,mCAErB,SAL2B,CAK3B,GACA,OAAqB,kCAErB,CACA,WACA,EA/EA,YAA6D,GAAsB,gBACnF,MADmF,OACnF,EAA+D,MAAtB,GAAsB,aAE/C,GAAsB,MAFyB,CAEzB,aACtC,EADsC,MAEtC,CAEA,GAAsC,MAAtB,GAAsB,aACtC,SADsC,EACE,GAAsB,4BAC9D,2CAAgE,GAAsB,iBACtF,KADsF,MACtF,mBAAgD,GAAsB,aACtD,GAAsB,MADgC,CAChC,UACtC,KADsC,GAEtC,CACA,MAAmD,OAAtB,GAAsB,sCACnD,0CACA,UACA,uCACY,GAAsB,gBAClC,CACA,KAFkC,EAElC,CACA,CACA,cACA,WACA,SACA,sBACA,SAEA,+BACA,uBACA,oBAEA,2BACA,gCAEA,WAAsB,GAAW,wCAAyC,mBAAuB,mIACjG,CAEA,oCACA,qDAEA,OADA,6DACA,0BAEA,WAAsB,GAAW,oDAAqD,mBAAuB,gDAC7G,CACA,UAAkB,GAAW,iGAC7B,CACA,eACA,mBAGA,kBAFA,GAIA,CCrFO,eACP,2BACA,SACA,oBACA,OACA,aACA,IACA,qBAGA,OAFA,SACA,gBACA,CAD0C,CAG1C,SAEA,MADA,gBACA,CADsC,CAGtC,CAAS,CACT,eACA,iBAGA,OAFA,gBACA,QACA,CAAqB,qBACrB,CAAS,CACT,yBACA,YACS,CAET,CD2DA,cAEA,sCACA,gCEzFO,UACP,iBACA,gBACA,iBACA,CACA,4BACA,SACA,mBACA,KACA,wFAEA,KACA,SACA,IACA,2BACA,OAEA,gCACA,KACA,QACA,CACA,mBACA,iCACA,mCACA,MACA,IACA,oBACA,CACA,SAGA,MAFA,2DACA,mCACA,CACA,CACA,cACA,UAAsC,GAAQ,sBAAmC,GAAqB,WAEtG,QACA,KACA,CACA,MACA,IACA,oBACA,CACA,SAGA,MAFA,2DACA,mCACA,CACA,CAEA,oBACA,UAAsC,GAAQ,gCAE9C,OAAgC,qBAChC,EAEA,IACA,CACA,SAEA,6CACA,MACA,QACA,QACA,CAEA,GACA,SACA,CACA,CACA,kBACA,CAKA,+BACA,SACA,mBACA,UAAoC,GAEpC,QAF+C,EAE/C,SADyB,GAA6B,GAEtD,uBAFsD,EAGtD,QAGA,uBACA,OAEA,CA4BA,cA3BA,kBACA,KACA,wFAEA,KACA,SACA,IACA,wBACA,GAEA,GACA,sBAEA,IACA,CACA,SAEA,6CACA,MACA,QACA,QACA,CAEA,GACA,SACA,CACA,EACA,EACA,CACA,yBACA,sBACA,CAKA,MACA,SACA,KACA,kBACA,KACA,EACA,UACA,iBACA,eACA,UACA,SACA,CACA,gBACA,CACA,GAEA,OACA,iCACA,iCACA,CAOA,mBACA,IACA,EADA,OAEA,kBACA,WAAmB,EAAc,CACjC,WADiC,GAEjC,2BACA,CAAa,CACb,cACA,IACA,UAA4B,UAAc,eAC1C,KACA,iBACA,uCACA,YACA,CACA,SACA,UACA,CACA,CAAa,CACb,eACA,kBACA,CAAa,CACJ,CACT,CACA,CACO,uBACP,WAEA,MADA,UACA,IAAkB,GAAW,qDAE7B,aACA,MAA4B,GAE5B,QAFuC,EAEvC,YADiB,GAA6B,SAE9C,iBAF8C,IAE9C,KACA,iBACA,IACA,SACA,CAEA,wBACA,iBACA,IACA,SACA,CACA,CAKA,qBACA,qBACA,0BAWA,EAVA,WACA,SAEA,iDACA,+CACA,EACA,oCAKA,IAJA,SACA,kBACA,IAEA,QAA+B,SFxGxB,GAMP,YAAoB,aAAuB,KAC3C,GAHA,KAGA,MAHA,KAGA,QAFA,KAMA,MANA,KAMA,OAFA,WAMA,GAVA,KAUA,MAXA,KAYA,QACA,cAZA,KAaA,CAb2B,CAa3B,MACA,MAf0B,CAe1B,KAEA,UAEA,CACA,SACA,EE+EqD,KACrD,mBACA,YAEA,CACA,YACA,SAEA,CACA,SACA,cACA,gBACA,aACA,eAEA,UAIA,GAHA,kBACA,8BAEA,IAEA,kCACA,YACA,OACA,iBACA,0BACA,iBAKA,OAHA,gBACA,aACA,eACA,CACA,CAEA,GADA,oBACA,kBACA,YAEA,WAaA,cACA,gBAdA,YAeA,OACA,6CAEA,WAlBA,OAUA,OATA,mBACA,mBAEA,YACA,aAEA,YACA,kBAEA,IACA,CACA,CC7QO,mBACP,oBACA,wBACA,0BACa,GAAU,YACvB,GADuB,OACvB,UACA,yBACA,iCACA,MAKO,eACP,oBACA,yBACA,yBACA,2BACA,4BACA,iCACO,MACI,GAAU,WAAoC,EAAc,EAAlD,CAWd,SAXgE,MAWhE,cAoDP,EAhDA,GAAQ,GAFR,WAGA,IADkB,GAClB,EAEA,UACA,oBACA,qEAIA,wCACA,WAAmB,EAAI,MACvB,CACA,kBAEA,GADA,MAoCA,KADA,EAnCA,GAoCA,OACA,gBAEA,mCAvCA,gBACA,UACA,gBACA,qBACA,IAAwB,aAExB,CACA,WAAe,EAAI,MACnB,CACA,qBACA,SACA,uBACA,uBACA,yBACA,eAEA,SACA,mCAEA,SAEA,qBACA,eAA+B,MAI/B,+BAAiD,WAAe,eAAe,gBAC/E,OAAqB,SAAS,SAI9B,GACA,oCACA,UAAe,aAAqB,EAAE,eAAe,IANvB,GAAqB,GAEnD,QACA,CAWA,UACA,mBACA,EACA,gDACA,iBAGA,8EACO,6EAWA,aACP,uBACA,OAAW,EAA0B,IACrC,EACO,aACP,UAAqB,EAErB,EALqC,IAGR,CAC7B,sCAA+C,2BAC/C,CACA,EACA,OACA,SACA,SACA,oBACA,kBACA,yBACA,gBACA,YACA,QACA,CAEA,QACA,EACA,kBACA,eAEA,WACA,sCAAkD,EAAI,GAAG,2DAGzD,+DACA,2BAEA,UACA,kBACA,aACA,MACA,oBACA,iDAEA,sBACA,yDAA4F,EAAI,GAAG,EAAK,aAGxG,wHAAoI,GAAO,UAE3I,EC5JA,IAAI,GAAsC,oBAC1C,EAD0B,CAC1B,GAD8B,GAC9B,MADkC,EAClC,EADsC,QACtC,CAD0C,iCAE1C,gFACA,uIACA,kDACA,EACI,GAAsC,kBAC1C,IAD0B,IAAI,CAC9B,QADkC,IAAI,SAAI,CAC1C,iDACA,wIACA,oDACA,EAUA,qBACA,aAAY,GAAW,EACvB,0BAIA,CAHA,+CAGA,yBACA,wDAEe,GAAM,gCAGrB,kBACA,YAEA,8BACA,SAEA,oCACA,aAA2C,cAE3C,GADA,sDACA,CACA,qBAEA,OADA,0CACA,OACA,CACA,qBAGA,OAFA,0CAEA,CACA,CACA,uBACA,yCACA,EAEA,uCACA,oCACA,aACA,CAAK,CACL,CA1CA,IAAI,OA+CG,mBACP,oBACA,UAIA,OACA,CAAS,EACT,uBACA,oBACA,CACA,eACA,4FACA,CAcA,aACA,+CACA,CAgBA,qBACA,6DACA,YAAiB,sDACjB,CACA,QAIA,OAHA,oBACA,mEAEA,mBAEA,UACA,6BACA,CACA,SACA,4BACA,CACA,WACA,8BACA,CACA,CACO,SACP,qBAAkB,+BAClB,oBAAwC,EACxC,eACA,mCACA,6BACA,iBACA,cAAwC,CACxC,CACA,YAF6C,CAE7C,EACA,QACA,CASA,kBACA,OACA,0BACA,kCACA,iCACA,QACA,sBACA,CACA,CAIA,sBACA,wBACA,8BAAuC,KAAQ,EAE/C,SACA,oCACA,CACA,UACA,qCACA,CACA,WACA,sCACA,CACA,SACA,oCACA,CACA,YACA,uCACA,CACA,qBACA,sDACA,SAAiC,GAAU,kDAC3C,mCACA,oDACA,2DACA,QACA,cAAqB,qBACrB,CAAS,EACT,CACA,kBACA,8BAA2C,yBAA8B,CACzE,CACA,0BACA,uBACA,8BACA,8CAEA,mCAGA,OAFA,kBACA,UACA,iBAEA,MACA,yBACA,+BAEA,WACA,CACA,2BAAiC,KAAiB,EAAI,EACtD,OAA0B,MAC1B,QAAgB,+BAA6C,EAC7D,yEACA,OACc,GAAe,oBAC7B,qCACA,KACA,iCACA,oBACA,gBACA,wBACA,kCACA,mCAAiE,EAAe,GAChF,UADgF,CAChF,IACA,uCACA,0BAKA,sBAEA,oCACA,kBACA,gDACA,4CAEA,iCAA+C,yCAA6C,EAU5F,OAAiB,IATjB,CACA,SACA,OAA0B,OAAY,CACtC,UACA,OAA+B,QAAkB,CAGjD,qBACA,EACiB,wBACjB,CACA,sBAAmB,yCAA8C,EACjE,QACA,IACA,wBAEA,6BAoBA,OAnBA,QACA,QAEY,GAAe,SAA2B,GAA3B,MAAkB,GAC7C,CADsD,MACtD,kBAKA,0CACA,0CACA,yCAEA,sCACA,sCACA,WACA,6DAEA,0BACA,CACA,CAIA,yBAOA,4BAAoC,YAAc,GAClD,gBACA,SACA,qBACA,iDACA,CAAoB,KAAY,CAHhC,EAIA,CACA,yBACA,OAAe,GAAQ,iBACvB,CACA,kBACA,oCACA,CACA,uBACA,cACA,+BACA,UACA,MAEA,6BACA,QAAgB,mBAAoB,qBAA+B,eAA2C,EAG9G,GAFA,iCAAyC,YAAc,EACvD,4BACA,kBACA,UAAsB,GAEtB,cAFuC,YAGvC,iDACA,uBACA,qBACA,UAA0B,GAE1B,KACA,SAH2C,EAG3C,mBAEA,yBACA,UAA0B,EAE1B,WAAsB,GAAkB,CAAG,QAFQ,CAGnD,CACA,oBACA,UACA,2BACA,mBAAkD,GAAkB,oBAEpE,OADA,qBAAwC,EAAE,EAAa,iBACvD,wBACA,CACA,6CACA,QACA,aACA,aAA6D,gCAAkC,eAG/F,OAFA,qBAAoC,EAAE,EAAa,mBACnD,oCAEA,CACA,OAAiB,kCACjB,CACA,oBAEA,mBADA,yBACA,EACA,CACA,cACA,UACA,IADA,MACA,EACA,2EACA,sBAOA,OANA,OACA,IAAsB,YAEtB,0CACA,kCAEA,YACA,CACA,kBACA,yBACA,4BACA,cACA,+DACA,SAA0B,sBAAwB,GAAG,sBAA0B,EAE/E,YACA,SAA0B,sBAAwB,SAElD,IAAsB,GAAW,yBAA0B,WAAe,6HAA6H,SAAS,4CAA4C,+EAC5P,CAAS,EACT,SACA,CACA,gCACA,WAAgB,QAAqB,KACrC,IACA,0CACA,kCACA,GACA,gBACA,MAOA,OALA,UAGA,kCAIA,yCACA,eACA,CAAS,CACT,CACA,eAEA,4CAEA,YAEA,cAGA,gBAGA,gBAGA,kBAGA,gBAGA,CACA,0BAGA,IAFA,EAEA,wBACA,MACA,mBACA,kBACA,KAEA,CAEA,yBACA,UACA,oBAKA,EAJA,gBAIA,yBAHA,KAKA,CAGA,sBACA,oCACA,8CACA,CAEA,OADA,YACA,uBACA,CACA,wCAQA,YAHA,IAJA,GAIA,WAFA,KADA,GAKA,sBACA,GACA,CACA,eACA,SAAkB,sBAAsB,MAAM,EAAQ,EAEtD,CACO,EAH8C,IAG9C,GACP,qBACA,mBACQ,GAAsB,cAC9B,QAD8B,IAC9B,GACA,gBACA,WACA,CACA,oBAEA,EADA,yBACA,QAEA,yBACA,CACA,oBACA,0BACA,MACA,UAAsB,GAAW,wBAAyB,iEAE1D,OAA8B,iBAC9B,0CACA,SAAkC,6BAElC,cAEA,cADA,8BAAqE,mCAErE,2BAEA,gBACA,uBACA,CACA,aAAqB,GAAsB,8CAC3C,CACA,mBAEA,WAEA,IADA,QACA,iBACA,wBACA,OAEA,CACA,gDACA,oCACA,mCACA,OAGA,CACA,CAUO,oBACP,mBACA,2DACA,CAQA,gCAEA,kBADA,aAEA,OAEA,CACA,CACO,UACP,6BAEA,cACA,SACA,mBACA,gCACS,CACJ,EAKL,IACA,UACA,QACA,SACA,QACA,WACA,cACA,UACA,WACA,aACA,UACA,kBACA,cACA,mBACA,oBACA,gBACA,EACO,MACP,oBACA,UACA,QACA,kCAEA,QACA,8CACA,OACA,wBACA,8BAA2C,EAC3C,KADkD,YAClD,kBACA,uCACA,6BACA,sGACA,EAEA,mCACA,OACA,wBACA,8BAA2C,EAC3C,KADkD,YAClD,UACA,4BAAyC,YAAY,EACrD,6BACA,+CAIA,8FACA,OACA,wBACA,8BAA2C,EAC3C,KADkD,YAClD,qBACA,oCACA,6BACA,+CAGA,iBAuBA,6CACA,YAYA,YAAiB,aAAe,CAThC,CACA,CAAU,0DAA8D,CACxE,CAAU,wDAA4D,CACtE,CAAU,8DAAkE,CAC5E,CAAU,8DAAkE,CAC5E,CAAU,gEAAoE,CAC9E,CAAU,yFAA6F,CACvG,CAEgC,CAChC,kCACA,MACA,cACA,UACA,UACA,OAAqB,qBAA0B,EAAM,GAAG,EAAM,GAAG,EAAM,EACvE,CACA,CACA,WACA,WA7CA,EACA,CACA,wBACA,8BAA2C,EAC3C,KADkD,YAClD,UACA,6BACA,iCAA8C,UAAoB,EAClE,yCAIA,CACA,wBACA,8BAAuC,EACvC,KAD8C,YAC9C,UACA,6BACA,gCACA,uCACA,CACA,EA2BA,MAKA,UACA,MACA,wBACA,MACA,UACA,MACA,2BACA,QACA,EACA,SAAwB,EAAK,EAC7B,UAEA,MAMA,oBAKA,gBACA,MACA,cACA,UACA,aACA,QACA,YACA,UACA,cACA,UACA,cACA,UACA,YACA,QACA,EACA,SAAwB,EAAS,EACjC,UAGA,OACA,YAEO,OACP,IACA,oBACA,CACA,SACA,MACA,CACA,EAEA,0BACA,MACA,WAEO,sCACP,WACA,4CACA,UAAkB,GAAW,GAAI,GAAM,QAAV,UAAU,GAEvC,OACA,UAAkB,GAAW,GAAI,GAAM,QAAV,kBAAU,GAEvC,QACA,EACO,OACP,sBACA,SACA,gCACA,IACA,+BACA,CACA,OAEA,eACA,EAaO,MACP,4BACA,iCAEA,yBACA,kCA4CO,eACP,MACA,SACA,eACA,SACA,QACA,CAEO,iBACP,gDACA,CAOA,iBACA,gBACA,YACA,SACA,sBACA,MACA,SACA,kBACA,EACA,YAEA,YACA,QAEA,CACA,CACA,4CACO,oBACP,2DA2BA,4BAAoC,EAAO,KA1B3C,UACA,MACA,SAGA,cAEA,OAAsC,cAAmB,eACzD,uBACA,yBACA,0BAGA,QACA,CACA,WAEA,eACA,0BAEA,OAAoD,MAAQ,CAC5D,iBAGA,WACA,CAAS,EAGT,CAIA,WACA,2DACA,yBAEA,OADA,iBACA,YACA,CAAK,EAEE,OAGP,4BAEA,0BAEA,8BAEO,MACP,0BASO,WACP,sBACA,UAEA,0BACA,kEACA,qCACA,eACA,KACA,QAEA,CACA,CACA,iCACA,wBACA,qBACA,eACA,YAEA,OADA,yBAAyC,UAAc,kBAAkB,GAAQ,iCACjF,KAEA,QACA,CAGA,EAoBO,OACP,+BAEA,8BACA,kGACA,CACA,CAEA,cACA,WACA,oBACA,YAAwB,IAAS,IACjC,qBAEA,6CACA,CACA,EACO,eACP,qDACA,CC17BO,SACP,eACA,cACA,CACA,CCHO,iBAA0B,GACjC,QAD4C,CAC5C,GACA,8CAAmD,2BAAgD,CACnG,CACA,CCFO,iBAAuB,GAC9B,QADyC,CACzC,EAA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AAsB,uBAC9B,MAD8B,IAC9B,YACA,CACA,YACA,OAAe,GAAsB,WACrC,CACA,cACA,GAHqC,IAGtB,GAAsB,WACrC,CACA,cACA,GAHqC,IAGtB,GAAsB,YACrC,CACA,QACA,QAHqC,OAGrC,QACA,CAQA,QAGA,MADA,CAD0B,GAAsB,iBAA+C,GAAsB,SAArE,EAAqE,SACrH,SADqH,MAC5F,EAAU,EACnC,KASA,SACA,MAA0B,GAAsB,eAChD,MACA,QAFgD,GAEhD,CACA,qCAGA,OAFA,MACA,cACA,IACA,CAMA,UAGA,MADA,CAD0B,GAAsB,iBAA+C,GAAsB,SAArE,EAAqE,SACrH,SADqH,MAC5F,UAAsB,EAC/C,KAaA,WACA,2BACY,GAAsB,gBAClC,aACA,qBACA,cACA,CAAS,CACT,CACA,aACQ,GAAsB,gBAC9B,MAAc,GAAsB,IADN,CACM,MACpC,CACA,cAEA,GAJoC,GAIF,YAClC,MAEA,WAHkC,EAItB,GAAsB,eACtB,GAAsB,WADA,CACA,YAElC,KAFkC,CAER,GAAsB,eAKhD,GAJA,IACY,GAAsB,oCAClC,qBAAiC,EAAU,aAE3C,aACA,WACiB,GAAsB,yBACvC,IADuC,IACvC,UAEY,GAAsB,yBACtB,GAAsB,CADA,GACA,qBAClC,IADkC,CAClC,aACA,MACA,CACA,gBAEA,WACiB,GAAsB,yBAOvC,IAPuC,IAOvC,UAEY,GAAsB,yBACtB,GAAsB,CADA,GACA,qBAClC,iBACA,CACA,CACA,cACA,CCjJO,eACP,mDACA,CAmBO,eACP,wCACA,CAqBO,iBACP,4BAwBA,IAvBA,8BACA,UAAsB,GAEtB,oBAF6C,EAE7C,gBACA,UAAsB,GAEtB,OACA,KACA,SACA,MALoD,MAKpD,CACA,wBACA,CACA,yCAwBA,cACA,2DACA,OACA,KACA,UACA,cACA,yDACA,oDACA,IACA,CAAS,EAET,EAnCA,aACA,EACA,OACA,8CAQA,EAPA,EAOA,EAPA,kBAQA,wCACA,KAEA,wCACA,gCAEA,EADA,gBACA,aAEA,cAEA,MAjBA,IACA,CACA,CACA,CAAK,EACL,OAAa,eACb,CAiCO,qBACP,yBAGA,0EACA,CDwCA,yLAKA,GAJI,GAAsB,eAC1B,cAD0B,MAC1B,uBACA,OAAoB,EAAiB,EAErC,aAFqC,GAIrC,OADQ,GAAsB,IADY,CACZ,WAC9B,aAD8B,MAC9B,GAEA,gBAAyB,GACzB,cADoC,GACpC,YAEA,uBACA,UAAgC,GAAW,WAG3C,GAH2C,IAE3C,UACA,qBACA,CACA,8BAAmC,GAAW,WAC9C,EElMA,CFiM8C,GEjM1C,GAAsC,kBAC1C,4BAD0B,GAC1B,CAD8B,SAAI,IAAI,SAAI,0BAE1C,wIACA,oDACA,CAQO,kBAA2C,GAClD,QAD6D,KAC7D,CACA,oBACA,aACA,yBACA,iBAEA,sBACA,8BACA,+BACA,4BAGA,OAFA,GACA,oBACA,CACA,CACA,oBAIA,GAHA,eACA,iBACA,sBACA,EAEA,IADA,wBACA,CAAiB,GAAiB,IAAa,GAAa,OAA1B,GAA0B,KAE5D,gDAEA,GAAqB,GAAkB,oBACvC,gDAEA,GAAqB,GAAkB,iBACvC,0BACA,qBACA,qCAGA,CAEA,CAKA,4BACA,kBACA,4DACA,MACA,UAAsB,GAAW,mDACjC,QACA,CAKA,qBAEA,OADA,kBACe,GAAsB,0BACrC,CAKA,mBANqC,CAMrC,CAEA,OADA,kBACe,GAAsB,0BACrC,CAKA,mBANqC,MAMrC,CAEA,OADA,kBACe,GAAsB,0BACrC,CACA,mBAFqC,YAErC,CAEA,OADA,kBACe,GAAsB,0BACrC,CACA,mBAEA,OADA,kBACe,GAAsB,0BACrC,CACA,mBAFqC,CAErC,CACA,iCAEA,aACA,4DACA,GACA,oCACA,MAA6B,GAAsB,0BACnD,IACA,gBAFmD,UAEnD,GACA,MAA6B,GAAsB,0BACnD,IACA,gBAFmD,UAEnD,GACA,MAAkC,GAAsB,0BACxD,IACA,gBAFwD,eAExD,GACA,MAAwC,GAAsB,0BAC9D,UACA,wCACA,wCACA,wBAAqC,GAAsB,2BAE3D,CACA,kBAH2D,UAG3D,OACA,gBACA,IACA,WACA,wBACA,yDAEQ,GAAsB,6BAC9B,iBAD8B,CAC9B,qBAAsE,eAA0B,EAAI,mCAA4C,EAEhJ,OADA,kBACA,wBAAuC,GAAmB,KAC1D,CACA,UAF0D,eAE1D,OACA,wBACA,uBAEA,8CACA,CACA,2BACA,iBACA,eAAgB,wBAAgD,EAChE,8BACA,oBAAgB,EA9HhB,EA8HgB,EAAoD,MACpE,KACA,yBACA,6BAEA,2BACA,6BACA,wBACA,0BACA,CAAS,EACT,wBACA,uBAEA,YAAwB,IAAwB,KAChD,IA0BA,EA1BA,sCACA,KACA,gBACA,YACA,4BACa,IACb,wBACA,MACA,UAA0B,GAAW,8CAErC,oBACA,OACA,SAAoB,eAAwB,gBAC5C,OACA,KAOA,cACA,gCAA0D,kBAAqB,IAAI,mBAAsC,6BACzH,kBAAmC,wBAAqB,EACxD,QACA,MAXA,CACA,gCAA0D,kBAAqB,2BAA2B,EAC1G,+BACA,WAAgC,oBAChC,uBAAmC,mBAAqB,EACxD,QACA,CAOA,IACA,EAAyB,GAA2B,qBACpD,CACA,EAFoD,IAEpD,GACA,kBACA,OACA,OACA,8CACA,CAAiB,EACjB,QACA,CAEA,+BACA,EAA4B,GAAsB,6BAElD,GADA,cADkD,EAClD,OAA+B,mBAAqB,EACpD,EACA,MACA,CACA,CACA,uBACA,aACA,CAAgB,oCAA8C,EAC9D,wCACA,oBAAgB,EA9LhB,EA8LgB,EAAoD,MAEpE,kBACA,GAAgB,GAAkB,IAClC,WADkC,IAClC,CACA,UAA8B,GAAW,yEAEzC,OACA,gBACA,UACA,qBACA,qBACA,uCACA,iCACA,kBACA,SACA,CAAqB,CAErB,CACA,QACA,CAAS,EACT,KACA,eACA,qBACA,0DAGA,kBACA,6BACA,CACA,gBACA,UACA,+CACA,iCACA,mCACA,wBACA,CAAqB,EAErB,GACA,OACA,wBACA,uBAEA,YAAwB,IAAwB,KAChD,0CACA,KACA,cACA,QACA,4BACa,IACb,wBACA,MACA,UAA0B,GAAW,8CAErC,yBACA,MAEA,+BAkBA,EAjBA,uBACA,SACA,WACA,MAAwB,eAAwB,WAChD,OACA,KAOA,cACA,4BAA0D,kBAAqB,IAAI,mBAAsC,6BACzH,uBAAuC,2BAA6B,EACpE,QACA,MAXA,CACA,4BAA0D,kBAAqB,2BAA2B,eAC1G,0BACA,WAAoC,oBACpC,uBAAuC,2BAA6B,EACpE,QACA,CAOA,IACA,EAA6B,GAA2B,qBACxD,CACA,EAFwD,IAExD,GACA,6CACA,uBAAuC,2BAA6B,EACpE,QACA,CAEA,+BACA,EAAgC,GAAsB,6BAEtD,GADA,cADsD,EACtD,OAAmC,2BAA6B,EAChE,EACA,MAEA,CACA,CAEA,CACA,CACA,6BACA,OAAW,GAAsB,wCACjC,CAAC,KADgC,UAEjC,2BACA,cACA,uBACA,GAAY,GAAkB,IAC9B,WAD8B,OACV,QAAyB,EAE7C,GACA,KACA,wBACA,uBACA,EAIA,OAHA,GACA,oBAEA,CACA,CACA,CACA,UAAc,GAAW,6EACzB,CAAC,eACD,iCAA2C,KAAQ,KACnD,uBACA,GAAY,GAAkB,qBAC9B,uBAEA,GAAY,GAAkB,0BAC9B,oCAEA,CAEA,CAAC,eACD,iCAA2C,KAAQ,KACnD,uBACA,GAAY,GAAiB,qBAGjB,GAAa,IACzB,MADyB,EACzB,SACA,4BACA,4CACA,mEANA,gBASA,CAEA,CAAC,eACD,OACA,oBACA,gBACA,cACA,EACA,cAAiB,GAAQ,wBACzB,IACA,yCACA,iCACA,gCAGA,QACA,CAAC,gBACD,oBACA,UAAkB,GAAW,+HAE7B,CAAC,gBACD,2BACA,uBACA,iBACA,CC5WO,kBAAmC,GAE1C,2BACA,aACA,GACA,KACA,SAAuB,yDAAkE,EAGzF,OADA,mCACA,CACA,CACA,uBACA,aACA,GACA,KACA,SAAuB,qDAA8D,EAGrF,OADA,+BACA,CACA,CACA,oBACA,uBACY,GAAkB,mBAC9B,2BAEA,CACA,CCnBA,IAKA,IACA,IAfA,EAgBA,IAfA,EAgBA,IAfA,EAgBA,IAfA,EAgBA,KAfA,GAgBA,KAfA,GAgBA,IAfA,GAgBA,SAfA,IAgBA,eAfA,IAoBA,IAfA,GAgBA,CAEA,wBACA,CACA,uBACA,CAkBA,eACA,eACA,IACA,MACA,gBAAiC,GAAK,cAAc,EAAM,EAC1D,EACA,MACA,gBAAmC,GAAK,cAAc,EAAM,EAC5D,EACA,MAIA,CAHA,IACA,MACA,6BACA,YACA,IACA,EAAoC,IAApC,KACA,IACA,WACA,IACA,6BACA,qDACA,KACA,MAEA,6BACA,qDACA,KACA,IAEA,8BACA,sDACA,KACA,IAEA,iCACA,6DACA,KACA,KAEA,kCACA,qBACA,OACA,OACA,wCACA,KACA,MAEA,4BACA,mDACA,KACA,KAEA,IAEA,OACA,QACA,KAEA,IADA,IACA,KADiB,CACjB,+BACA,kBACA,IAEA,oBACA,IACA,+CACA,CACA,SACA,YACA,MAEA,YACA,IACA,iDACA,CACA,SAEA,yDACA,CAEA,gCACA,EACA,OACA,IACA,IACA,CAFiB,GAEjB,KACA,IACA,OAA2C,IAA3C,MAA2C,CAE3C,GADA,IACA,eACA,SACA,UACA,IACA,IACA,IACA,CAFyB,GAEzB,MACA,iCAAsD,4CAA6D,CACnH,CACA,SACA,YACA,QAEA,QACA,CACA,IACA,YACA,GACA,CACA,CACA,IAH6B,EAG7B,GACA,YACA,SAEA,cAA4C,oBAC5C,CAEA,OADA,IACA,CACA,EACA,OACA,IACA,KADiB,CACjB,GACA,IACA,iBACA,YACA,IACA,YACA,GAGA,CACA,KAJ6B,CAI7B,GACA,YACA,SAEA,iCACA,CAEA,OADA,IACA,CACA,EACA,EAHiB,KAIjB,UACA,mBACA,0BACA,IACA,oBACA,CACA,SACA,YACA,IACA,uBACA,qDACA,oDACA,CACA,UAEA,YACA,CACA,CACA,QAGA,IAFA,YACA,IACA,WAAyC,kBACzC,GACA,iBACA,iCACA,IACA,mCACA,CACA,SACA,kCACA,0BACA,IACA,oDACA,CACA,SACA,YACA,CACA,CACA,EACA,OACA,mCACA,GAEA,EACA,UACA,EAEA,OAnMA,qBACA,sBACA,sCAAkD,SAAkB,GAEpE,aACA,eAA2B,GAAY,WAEvC,sBACA,EA2LA,iBC9OA,IAAI,GAAsC,oBAC1C,kBAD0B,IAAI,KAC9B,IADkC,IAAI,SAAI,iBAE1C,gFACA,uIACA,kDACA,EACI,GAAsC,kBAC1C,oBAD0B,CAC1B,GAD8B,OAC9B,EADkC,IAAI,SAAI,kCAE1C,wIACA,oDA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,KDRiD,ECQjD,CAhByC,CAgBzC,GACA,+CACA,OACA,KACA,SAAuB,4CAAqD,CACnE,CACT,CACA,CCvBO,iBAAoC,GAgB3C,QAhBsD,CAgBtD,GACA,6DACA,OACA,KACA,SAAuB,4CAAqD,CACnE,CACT,CACA,CCnBO,iBAAuB,GAC9B,QADyC,KACzC,CACA,oBACA,kBAA4B,GAAoB,cAChD,+BAAyC,GAA8C,aACvF,CACA,CACA,GAHuF,QAGvF,CAAoB,GACpB,KAD4B,mBAC5B,CAAiC,GCdjC,IAAI,GAAsC,kBAC1C,eAD0B,IAAI,EAC9B,OADkC,GAClC,CADsC,SAAI,uCAE1C,wIACA,oDACA,EACI,GAAsC,oBAC1C,aAD0B,IAC1B,SADkC,CAClC,GADsC,SAAI,sBAE1C,gFACA,uIACA,kDACA,CAMO,kBAA8B,GACrC,QADgD,KAChD,CACA,oBACA,aAEA,gBAGA,cAAsD,EACtD,cAAsD,EACtD,oBACA,oBACA,oBACA,oBACA,oBACA,oBAEA,oBACA,oBACA,mBACA,CACA,8NACA,SACA,KACA,KAgCA,OA9BA,oBACA,gBACA,EACA,aAGA,SAEA,CAAS,EACT,mBAEA,aADA,KACA,GACA,iBAEA,WACA,CAAS,EACT,oBAEA,aADA,KACA,GACA,WAEA,WACA,CAAS,EACT,oBAEA,aADA,KACA,GACA,WAEA,WACA,CAAS,EACT,CACA,cACA,SAOA,CAAyB,MADzB,UACyB,SANzB,EACA,CAAiC,sBAEjC,mCAA6E,WAAiB,cAA8B,iBAA4B,CAAI,qBAA8B,EAK1L,iBACA,aACA,CAAyB,sBAEzB,CACA,CACA,6BACA,aAEA,OADA,qCACA,CACA,CACA,+BACA,gBACA,IACA,WACA,wBACA,yDAEA,kBACA,MAAuB,GAAM,sCAC7B,qBACY,GAAsB,6BAElC,IAFkC,CAElC,2BACA,UAAsB,GAEtB,cAFuC,KAEvC,CAA4B,GAAsB,2BAClD,CACA,KAFkD,aAElD,CAEA,WAD2B,GAAM,uDACjC,kBACA,CACA,4CACA,aAKA,OAJA,8CACA,KACA,SAAuB,mDAA4D,CAC1E,GACT,CACA,CACA,4CACA,gBACA,IACA,WACA,wBACA,yDAEA,OAAuB,gBACvB,mCACA,KACA,8BACS,EAET,mBADA,kBACA,GACY,GAAsB,6BAElC,IAFkC,CAElC,2BACA,UAAsB,GAEtB,cAFuC,KAEvC,CAA4B,GAAsB,2BAClD,CACA,KAFkD,EAElD,mCACA,aAKA,OAJA,yCACA,KACA,SAAuB,mDAA4D,CAC1E,GACT,CACA,CACA,sCACA,aAKA,OAJA,wCACA,KACA,SAAuB,mDACvB,CAAS,GACT,CACA,CACA,eACA,OAAe,GAAsB,YACrC,CACA,aACA,OAAe,GAAsB,YACrC,CACA,oBAFqC,IAErC,CACA,OAAe,GAAsB,YACrC,CACA,oBAFqC,IAErC,CACA,OAAe,GAAsB,YACrC,CACA,oBAFqC,CAErC,CAEA,OADA,kBACA,cAA6B,GAAsB,aACnD,CACA,mBAFmD,EAEnD,CAEA,OADA,kBACA,cAA6B,GAAsB,aACnD,CACA,iBAEA,EAJmD,CAGnD,kBACA,CAAa,GAAsB,aACnC,oBADmC,uBAEnC,OAAe,GAAsB,YACrC,CACA,oBAFqC,eAErC,OACA,gBACA,IACA,WACA,wBACA,yDAEA,OAAuB,gBACvB,0BAAyD,mCAA4C,EAErG,mBADA,kBACA,GACY,GAAsB,6BAElC,IAFkC,CAElC,2BACA,UAAsB,GAEtB,cAFuC,KAEvC,CAA4B,GAAsB,2BAClD,CACA,KAFkD,CAElD,gCACA,gBACA,IACA,WACA,wBACA,yDAEA,OAAuB,gBACvB,sBAA0D,mCAA4C,EAEtG,mBADA,kBACA,GACY,GAAsB,6BAElC,IAFkC,CAElC,2BACA,UAAsB,GAEtB,cAFuC,KAEvC,CAA4B,GAAsB,2BAClD,CACA,KAFkD,EAElD,qBACA,kCACA,yBACA,OACA,QACA,CACA,WACA,YAKA,wBALA,CACA,OACA,QACA,CAOA,0CACA,UAEA,0CACA,UAEA,GAAqB,GAAU,IAAc,GAAU,GACvD,iCAEA,uCACA,uDACA,aACA,QACA,CACA,CAHkD,GAGlD,YACA,IAAyB,GAAU,GACnC,mEAA+F,EAAW,GAE1G,cACA,WAEA,MADA,iBACA,gEAEA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AD4B,CAEhD,OAD8B,CAC9B,CAAe,GACf,EADoB,CACpB,gBAAyB,GACzB,UAAgB,EADwB,CAExC,GADsB,KACtB,CAAe,GACf,EADoB,CACpB,YAAqB,GACrB,QADgC,CAChC,CAAgB,GAChB,GADsB,UACtB,CAAoB,GACpB,OAD8B,MAC9B,CAAoB,GACpB,OAD8B,GAC9B,CAAiB,GACjB,YADwB,GACxB,CAAsB,GACtB,SADkC,UAClC,CAA0B,GAC1B,aAD0C,oBAC1C,CAAwC,GACxC,QAAc,GACd,CADkB,EAClB,QAAiB,GACjB,EAHsE,CAGtE,CADwB,UACxB,CAAqB,GACrB,QADgC,EAChC,CAAiB,GACjB,IADkC,QAClC,CAAmB,GACnB,MAD4B,EAC5B,CAAe,GACf,EADoB,CACpB,sBAA+B,GAC/B,cAAoB,GACpB,CAFoD,EAEpD,IAD8B,sBAC9B,CAAoC,mBClJpC,ODkJ8D,GClJ/C,SAAoB,aCFnC,6BACA,SACA,eACA,QAA8B,uBAAkC,EAChE,EAGA,GACA,CACA,oBACA,eACA,CAAC,EACD,2BACA,eACA,SACA,wBACA,CACA,EACA,uBACA,eACA,MACA,yGAA+G,EAAI,MAEnH,oBACA,CACA,EAgBA,SAAS,GAAa,GACtB,IACA,OAfA,cACA,iCACA,IACA,WACA,CAAM,MACN,QACA,CACA,CAAG,sBACH,qCACA,EAEA,CACA,EAGA,EACA,CAAI,MACJ,QACA,CACA,CACA,eACA,eAAwB,GAAa,aAErC,YAFqC,CAErC,EACA,WACA,KACA,YAAkB,WAAiB,KACnC,QAAsB,qBAAiC,EAEvD,WACA,CAeA,aACA,QACA,QACA,QACA,eACA,oBACA,eACA,KACA,gBAcA,GAbA,cACA,2BACA,cACA,8CAEA,cACA,gBACA,yBACA,EACA,yBACA,yCACA,+CAEA,eADA,8BACA,mBACA,0BAEA,eACA,kCACA,cAEA,+EACA,0CACA,4CAEA,8CAGM,CACN,6BACA,6CACA,EANA,CACA,WACA,aACA,CAIA,CAJM,eAKN,GACA,aAAmB,GAAK,oDACxB,aAAmB,GAAK,sDACxB,aAAmB,GAAK,2CACxB,CACA,iBACA,MA7DA,eACA,SACA,eACA,KACA,iCACA,SACA,SAIA,QACA,EAkDA,0BAAuE,EACvE,yCACA,iCACA,GAEA,yBACA,cACA,UACA,4BACA,iCACA,yBACA,qCAIA,8BAOA,GALA,qBACA,aACA,iGAGA,qBACA,4BACA,oCACA,CACA,WACA,OACA,YAAoB,uBAA0B,IAC9C,IACA,mBACA,KACA,CAAQ,SACR,iCAQA,eAPA,UACA,gBAA6B,6CAAiD,EAC9E,EACA,CACA,WACA,gDACA,GAEA,KACA,CACA,IACA,uBACA,yDAEA,CAEA,MACA,wCAEA,UACA,oBACA,iBAAgC,QAAY,iBAAiB,uBAAyB,EACtF,CACA,wBACA,gBACA,qDACA,CACA,8BACA,yBACA,kBA2BA,MA1BA,WACA,IACA,QACA,UAAoB,UAAc,eAClC,WAGA,aAFA,YACA,YAEA,2BACA,gBACA,iBACA,CAEA,CACA,CAAU,SACV,2CAEA,wCAEA,EAAU,OACV,IACA,gBACA,CAAY,MACZ,CACA,CACA,EAAO,GACP,CAAe,SACf,CACA,qBACA,wBACA,gBACA,qDACA,OACA,yCACA,iBACA,QAA2B,iBAAgC,KAC3D,OAAkB,GAAM,GACxB,OACA,IAGA,CAAe,GALS,IAIH,GAAM,UACZ,QADY,KACZ,EAEf,CACA,CACA,EACA,eACA,SACA,IACA,cACA,WACA,oBACA,YAAoB,IAAU,IAC9B,qBAEA,6BACA,CAAI,MACJ,GACA,CACA,QACA,CACA,SAAS,GAAM,GACf,MACA,SAFe,KAEf,GACA,gBACA,QAEA,cACA,IACA,KAEA,cAEA,EADA,iBACA,MACA,sDAAiG,GAAM,OAGvG,KAEA,KAEA,CAPuG,IAOvG,SACA,qBAMA,CACA,QACA,CACA,SAAS,GAAK,cACd,GADc,CAId,gCAFA,CAIA,CAGA,WACA,iBACA,aACA,aACA,cACA,QAEA,SACA,wBAEA,CACA,EACA,SACA,QACA,UACA,YACA,QACA,KACA,UACA,YACA,mBAMA,KASA,GARA,kBACA,kGAAyH,GAAa,KACtI,oBADsI,EACtI,mBACA,wBACA,kBACA,2CACA,mDACA,qCACA,mBACA,0BACA,qBACA,wBACA,aAEA,GADA,kBACA,cAIA,OAHA,YACA,qBAA+B,EAAE,GAAG,IAAI,KAAK,yCAAyC,iBAAiB,EAAE,EAAE,IAAI,MAAM,GAAc,YAEnI,CACA,CACA,CACA,CAIA,cACA,WAAY,WAAgB,iBAC5B,kBACA,eACA,oCACA,qBACA,yBACA,6BACA,mBACK,EACL,KACA,gBAEA,cACA,mDAEA,0BACA,CACA,EAmBA,oBACA,iBACA,0BACA,uBACA,aAEA,MACA,qBAEA,SAEA,qBA3BA,YACA,gBACA,YAEA,SACA,YAAkB,WAAmB,MACrC,WACA,SACA,IACA,kBACA,CAAM,MACN,MACA,CACA,CACA,SACA,EAYA,kBACA,KACK,CACL,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,uBACA,qBACA,oBACA,UAEA,oBACA,UAEA,UACA,CACA,EAGA,SACA,4CACA,cACA,YACA,qBACA,8BACA,CACA,QACA,YAEA,OADA,wBACA,KAEA,UACA,6BACA,CACA,UACA,6BACA,CACA,aACA,gCACA,CACA,YACA,+BACA,CACA,OACA,qCACA,4BACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,uBACA,iDACA,KACA,eACA,IACA,SAEA,YAEA,CAAK,CACL,CACA,EAGA,oBACA,eACA,mBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,qBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,uBACA,6CACA,CACA,EAGA,oBACA,uBACA,0CACA,CACA,EAGA,oBACA,uBACA,gDACA,CACA,EAGA,oBACA,uBACA,6CACA,CACA,EAGA,oBACA,iBAEA,MADA,yCACA,EACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,wCACA,CACA,EAGA,oBACA,iBACA,0BACA,CACA,EAGA,oBACA,iBACA,mBACA,2BACA,gBAEA,UACA,CACA,EAGA,oBACA,mBACA,kBACA,UACA,gBAEA,UACA,CACA,EAGA,oBACA,0BACA,kBACA,gBACA,aACM,gBACN,aAEA,gBACA,aAEA,4BACA,wCAEA,UACA,qBAAyB,uBAA6B,aAEtD,UACA,CACA,EAGA,oBACA,6BACA,4BACA,CACA,EAGA,oBACA,iBACA,SAEA,sBADA,oCACA,GACA,CACA,EAGA,oBACA,iBACA,SAEA,qBADA,oCACA,EACA,gBAKA,YACA,SACA,eACA,gBAGA,QAAiB,wDAAgE,EAEjF,SACA,EAdA,GACA,IACA,CAAK,CACL,CACA,EAaA,oBACA,2BACA,sBACA,gDACA,wBAEA,gDACA,iDAEA,4CACA,qCAEA,sCACA,qDAEA,UACA,UACA,wDAmCA,MACA,IACA,KACA,iCACA,+BACA,4BACA,CACA,CACA,YAzCA,GACA,uCASA,UACA,QACA,KACA,IACA,yBACA,CAAU,MACV,cAcA,OAZA,YACA,mCAEA,YACA,2BAEA,aACA,UACA,gCACA,8BACA,GAEA,CACA,CAAO,EA7BP,UACA,IACA,OAAqB,qBACrB,CAAY,MACZ,cAAqB,EACrB,CACA,CAAS,EAkCT,MAGA,CACA,EAGA,oBACA,6BACA,6BACA,gDACA,wBAEA,gDACA,iDAEA,4CACA,qCAEA,sCACA,qDAEA,UACA,UACA,wDAEA,gDACA,CACA,EAGA,oBACA,iBACA,qBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,qBACA,kBACA,IACA,gCACA,kBACQ,gCACR,kBACQ,oCACR,sBACQ,oCACR,sBACQ,0BACR,mBAGA,UACA,CACA,EAGA,oBACA,iBACA,0BACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,eACA,yBACA,MACA,CACA,UACA,EACA,KACA,SACA,SACA,YACA,EACA,CACA,EAEA,CACA,EAGA,oBACA,iBACA,eACA,yBACA,MACA,CACA,YACA,EACA,KACA,SACA,SACA,YACA,EACA,CACA,EAEA,CACA,EAGA,oBACA,iBACA,WACA,yBACA,iDACA,CACA,EAGA,oBACA,iBACA,WACA,yBACA,8CACA,CACA,EAGA,oBACA,iBACA,eACA,yBACA,MACA,CACA,WACA,EACA,KACA,SACA,SACA,YACA,EACA,CACA,EAEA,CACA,EAGA,oBACA,iBACA,eACA,yBACA,MACA,CACA,aACA,EACA,KACA,SACA,SACA,YACA,EACA,CACA,EAEA,CACA,EAGA,oBACA,iBACA,WACA,yBACA,kDACA,CACA,EAGA,oBACA,iBACA,WACA,yBACA,2CACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAoBA,oBACA,iBACA,wBACA,gBApBA,YACA,gBACA,YAEA,SACA,YAAkB,WAAmB,MACrC,WACA,SACA,IACA,gEACA,uBACA,CAAM,MACN,MACA,CACA,CACA,SACA,EAIA,GACA,KACK,CACL,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,8BACA,CACA,EAGA,oBACA,mBACA,oBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAiBA,oBACA,wBACA,wBACA,gBAjBA,cACA,wBACA,YAEA,SACA,2BACA,IACA,qBACA,CAAM,MACN,SACA,CAEA,QACA,GAIA,KACA,KACK,CACL,CACA,EAGA,oBACA,qBACA,iEACA,CACA,EAGA,oBACA,uBACA,oBACA,UACA,wBAEA,2BACA,wBAEA,SACA,eACA,IACA,CAAK,CACL,CACA,EAGA,oBACA,qBACA,gEACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,WACA,yBACA,0CACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,iBACA,gCACA,CACA,EAGA,oBACA,iBACA,+BACA,CACA,EAGA,oBACA,iBACA,gCACA,CACA,EAGA,oBACA,iBACA,uCACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,iBACA,gBAGA,6BAFA,QACA,QACA,GACA,CACA,EAGA,oBACA,iBACA,4BACA,CACA,EAGA,oBACA,iBACA,0BACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,iBACA,mBACA,sBACA,cAEA,aACA,OACA,aACA,6BAEA,cACA,+BAEA,YACA,4BAGA,uBAEA,UACA,CACA,EAGA,oBACA,iBAEA,MADA,oBACA,EACA,CACA,EAGA,oBACA,iBACA,mCACA,CACA,EAGA,oBACA,iBACA,oBACA,eACA,6BAEA,UACA,CACA,EAGA,oBACA,iBACA,gCACA,CACA,EAGA,oBACA,iBACA,gCACA,CACA,EAGA,oBACA,iBACA,8BACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,iBACA,2BACA,CACA,EAGA,oBACA,iBACA,kCACA,OACA,QACA,aACQ,SACR,cAGA,UACA,CACA,EAGA,oBACA,iBACA,gCACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,iBACA,2BACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,eACA,+CACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,yBACA,6BACA,yBAEA,8BACA,2BAEA,+BACA,6BAEA,UACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBAEA,iBADA,2BACA,GACA,CACA,EAGA,oBACA,mBACA,8DACA,CACA,EAGA,oBACA,mBACA,+CACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,2BACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,iBACA,eACA,iBACA,aAEA,UACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,eACA,sBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,0BACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,qBACA,gBACA,WACA,wBAEA,2BACA,wBAEA,mCACA,mBACM,wCACN,sBAEA,SAEA,8BACA,KACK,CACL,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,gCACA,iBACA,KACK,CACL,CACA,EAGA,oBACA,mBACA,yBACA,QACA,eACM,UACN,gBAEA,UACA,CACA,EAGA,oBACA,iBACA,+BACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,4BACA,CACA,EAGA,oBACA,uBACA,kBACA,IACA,eACA,aACQ,gBACR,aAEA,kBACA,cAEA,gCACA,kBACQ,gCACR,kBACQ,oCACR,sBACQ,oCACR,sBACQ,0BACR,mBAGA,UACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,0BACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,iBACA,2BACA,CACA,EAGA,oBACA,iBACA,0BACA,CACA,EAGA,oBACA,iBACA,oCACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,qBACA,gBACA,qBACA,UAEA,UACA,CACA,EAGA,oBACA,qBACA,uBACA,qBACA,UAEA,UACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,uBACA,oBACA,UACA,wBAEA,2BACA,wBAEA,SACA,eACA,KACK,CACL,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,6BACA,CACA,EAGA,oBACA,eACA,iBACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,qBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,uBAEA,qBADA,4BACA,GACA,CACA,EAGA,oBACA,yBACA,iBAaA,eAZA,IACA,cACA,qBAEA,SACA,uDACA,uBACA,+BAIA,UACA,mBACA,YAEA,UACA,CACA,EAGA,oBACA,6BACA,SACA,UACA,wBAEA,WACA,iBAEA,sCACA,CACA,EAGA,oBACA,6BACA,kCACA,KACA,WACA,wBAEA,WACA,wBAEA,eACA,kCAEA,UACA,gBAEA,WACA,iBAEA,WACA,0BAEA,qCACA,CACA,EAGA,oBACA,qBAEA,mBADA,4BACA,GACA,CACA,EAGA,oBACA,qBACA,iBACA,eACA,aACA,gCACA,YACA,oBACA,mBAEA,gCACA,wDAGA,KAEA,sBACA,8CACA,KAEA,mBACA,2CACA,KAEA,eACA,4BACA,KAEA,aACA,+BACA,iCACA,uDAEA,KAEA,SACA,6BAEA,CACA,UACA,CACA,EAGA,oBACA,qBACA,SACA,qBACA,8BAEA,mBAEA,uBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,6BAEA,MACA,CACA,WACA,EACA,KACA,mCACA,EACA,EACA,KATA,+EAWA,CACA,EAEA,CACA,EAyBA,oBACA,yBACA,uBACA,oBACA,kBAEA,SACA,gBA7BA,YACA,SACA,eACA,YAAoB,WAAc,MAClC,WACA,SACA,QACA,UAEA,YAAsB,WAAoB,MAC1C,WACA,SACA,IACA,qBACA,CAAU,MACV,SACA,CACA,CACA,CAEA,SACA,EAQA,GACA,KACK,CACL,CACA,EAIA,oBACA,uBACA,2DACA,YAJA,4FAMA,SACA,2BACA,wBAEA,6BACA,0BAEA,OACA,aACA,+BACA,6BAEA,uBACA,CACA,EAIA,oBACA,2BACA,2DACA,YAJA,iGAMA,SACA,2BACA,wBAEA,6BACA,0BAEA,qCACA,gBAEA,OACA,aACA,+BACA,6BAEA,wCACA,CACA,EAGA,oBACA,yBACA,0BACA,oBACA,kBAEA,SACA,gBAKA,YACA,SACA,eACA,YAAoB,WAAc,MAClC,WACA,SACA,QACA,UAEA,YAAsB,WAAoB,MAC1C,WACA,SACA,IACA,qBACA,CAAU,MACV,SACA,CACA,CACA,CAEA,QACA,GA1BA,GACA,KACK,CACL,CACA,EAyBA,oBACA,qBACA,UAAY,0CAA8C,EAC1D,8CACA,CACA,EAGA,oBACA,0BACA,gBACA,gBACA,aACM,gBACN,aAEA,gBACA,aAEA,oBACA,eAEA,eACA,aACM,gBACN,aAEA,2BACA,yBAEA,4BAAoC,WAAe,WACnD,UACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,wBACA,CACA,EAGA,oBACA,iBACA,yBACA,CACA,EAGA,oBACA,yBACA,0BACA,iBACA,aAEA,UAEA,IACA,yBACA,+BACQ,yCACR,2BAEA,iBACA,iCAGA,UACA,CACA,EAGA,oBACA,iBACA,2BACA,CACA,EAGA,oBACA,qBACA,oBACA,oBACA,UAEA,UACA,CACA,EAGA,oBACA,qBACA,oBACA,oBACA,UAEA,UACA,CACA,EAGA,oBACA,yBACA,uBACA,YACA,kBAEA,UACA,gBAEA,QACA,cAEA,sCACA,iCAEA,eACA,qBAEA,UACA,CACA,EAGA,oBACA,iBACA,uBACA,CACA,EAGA,oBACA,iBACA,sBACA,CACA,EAGA,oBACA,iBACA,gCACA,CACA,EAGA,oBACA,iBACA,iCACA,CACA,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CA,CACA,CAAK,CACL,CACA,EAGA,6BACA,aACA,QACA,sBACA,UAKA,aAJA,QACA,cACA,2BACA,uBACA,GACA,EACA,2BAEA,0BAGA,CACA,sBACA,0BACA,cACA,eACA,gBACA,qCACA,CACA,CAAK,EACL,8BACA,uBACA,mCAEA,CAAK,EACL,0BACA,UACA,aACA,YACA,CAAK,CACL,CACA,sBACA,0BACA,cACA,eACA,gBACA,qCACA,CACA,CAAK,EACL,8BACA,uBACA,mCAEA,CAAK,EACL,0BACA,UACA,aACA,YACA,CAAK,CACL,CACA,mBACA,gCACA,iBACA,qBACA,0BACA,mBACA,mBACA,8BACA,qBACA,iBACA,eACA,IACA,oBACA,6CAAiD,sBAA2B,EAC5E,qCAA+C,EAAQ,WAAK,sBAA2B,CACvF,CAAU,SACV,mEAAkF,EAAM,GACxF,CACA,EAAQ,IACR,qBACA,eACA,IACA,6EACA,yBACA,6BACA,EAAY,IACZ,oBACA,oCAA6C,YAAkB,EAC/D,4BAAwC,EAAK,GAAG,EAAQ,WAAK,YAAkB,CAC/E,CACA,CAAU,SACV,mEAAkF,EAAM,GACxF,CACA,CACA,CACA,CACA,yBACA,4BACA,KACA,eACA,IAGA,CACA,QACA,uBACA,8BAEA,6BACA,CACA,qBACA,sBACA,CACA,qBACA,KACA,gBACA,gCACA,MACA,IACA,oBACA,CAAY,MACZ,CACA,4BACA,CACA,KACM,CACN,yCACA,IACA,oBACA,CAAU,MACV,CAEA,2BACA,yBACA,CACA,CACA,wBACA,qCAEA,EACA,oBACA,iBAMA,UACA,KACA,QAPA,CACA,2BACA,2BACA,uBACA,EAIA,wBACA,eACA,eACA,sCACA,+BACA,CACA,CAAK,CACL,CACA,EAIA,SACA,OAQA,KACA,kBACA,KACA,aACA,cACA,aACA,YACA,CAIA,cACA,WACA,gCACA,CAIA,gBAEA,OADA,6BACA,sCACA,CAIA,mBAEA,OADA,6BACA,uCACA,CAOA,gBAQA,OAPA,6BACA,wDACA,oEACA,6CAEA,QACA,CAAK,CAEL,CAIA,gBACA,kCAGA,MADA,mBAD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OAAwB,mBAAuB,CAC/C,CACA,ECzGA,qCACA,aACA,mCACA,YACA,KACA,WAEA,+CAAwE,CAExE,eACA,kCACA,wBACA,kBAA4B,EAAK,IAAI,EAAK,IAAI,EAAI,EAClD,EACA,8BACA,0BAEA,gBAEA,SACA,QACA,YACA,OACA,UACA,uBACA,qBACA,CACA,EAEA,SACA,cACA,GACA,CACA,cACA,SACA,yBAOA,aAJA,qBAEA,uBAEA,sBACA,IAEA,0BACA,CACA,EACA,gDACA,OACA,IAEA,KACA,saAMA,mCACA,CACA,CAEA,qBACU,eACV,iDAUA,YAEA,OACA,WACA,SACA,YACA,eACA,YACA,2BACA,GACA,KATA,IAWA,wBACA,eACA,SACA,YACA,CACA,CACA,SACA,KACA,cAEA,aACA,UACA,YACA,MACA,SACA,SACA,kBAEA,OADA,SACA,CACA,CACA,iBAEA,UACA,0DAGA,oBACA,aACA,CACA,QACA,0BACA,CACA,MACA,gCAEA,CAgBO,SAEP,IACA,CACA,GACA,KACA,GACA,CAIA,KAIA,cAIA,aAIA,eAIA,eAIA,WAIA,eAIA,YAIA,aAIA,gBAIA,yBAIA,mBAIA,uBAIA,2BAIA,kBAEA,GACA,CACA,KACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,CACA,KACA,GACA,GACA,GACA,SAUA,yBACA,OAEA,YACA,UACA,WACA,YACA,aACA,aACA,UACA,UACA,WACA,YACa,CACb,WACA,YACa,CACb,UAEA,6BACA,yCACA,sBACA,mBACA,oBACA,kBACA,CACA,CAKA,UACA,eAKA,cACA,eAKA,qBACA,cACA,CAIA,WACA,cACA,CAIA,kBACA,eAEA,iBACA,eAKA,cACA,eAKA,mBACA,eAEA,eACA,QAAgB,sVAA8U,EAC9V,iBACA,4DAEA,oBACA,MACA,qCAMA,GAJA,UACA,UACA,6BACA,uBACA,sBACA,gCACA,sFAEA,2CACA,sDAEA,CACA,eACA,qBACA,4DAGA,GADA,UACA,YACA,qBACA,+DAkCA,GAhCA,UACA,YACA,gBACA,8BACA,8BACA,iBACA,iBACA,UACA,UACA,qBACA,UACA,UACA,sBACA,YAEA,sBACA,UACA,aAGA,eACA,gBAEA,kBACA,kBACA,wBACA,qBACA,kCACA,oCACA,gCACA,0BAEA,uBACA,gBACA,aACA,mEAGA,0BACA,wEAEA,SACA,CAWA,GAVA,oBACA,4BACA,wBACA,wBACA,mBACA,aACA,EACA,EACA,sBACA,cACA,UACA,iBACA,+DAEA,SACA,CAEA,0CACA,oEAEA,2CACA,4BACA,QACA,UAGA,GAFA,gGAEA,8BAEA,CACA,CAKA,mBACA,2BACA,CACA,KACA,sBACA,iBACA,WACA,UACA,2BAGA,GAFA,eACA,OACA,0BACA,sBACA,YACA,4BAEA,CAAiB,KAGjB,UACA,SAGA,CACA,EACA,YACA,wBACA,EACA,gBACA,SACA,WACA,OAEA,UACA,MACA,SACA,UACA,aACA,aACA,mBACA,CACA,EAGA,QACA,OACA,eACA,yBACA,IACA,4CAGA,UACA,SAGA,CACA,QACA,CACA,0BACA,qBACA,cACA,SAEA,WACA,cACA,KAIA,EADA,aAFA,GAIA,EACA,YACA,WACA,OACA,4BACA,CACA,CAEA,WACA,UACA,UAEA,QACA,MACA,qBACA,WACA,UACA,YACA,cACA,MACA,EACA,oBAGA,cACA,SAEA,UACA,MACA,wBACA,sDAGA,OADA,UAEA,2EAEA,MAEA,6IAKA,QACA,EACA,kBAEA,GADA,OACA,SACA,mBACA,gBACA,WAEA,CACA,cACA,IACA,cACA,8BAEA,CACA,CACA,UACA,eACA,cACA,QACA,oFAEA,QACA,GACA,eAAgB,mBAA+B,EAAI,EACnD,WACA,kBACA,CADqC,GACrC,EAD0C,CAC1C,MAGA,kBACA,UAEA,cAIA,aAKA,gBAAiB,mBAA+B,EAAI,EACpD,WACA,kBACA,CADqC,GACrC,SAGA,kBACA,UAEA,cAIA,YAIA,CACA,MACA,mBACA,2BACA,CAKA,WACA,uBACA,qBACA,qBACA,qBACA,8BAGA,CAOA,YACA,uBACA,qBACA,qBACA,qBACA,8BAGA,CAKA,QACA,wBACA,gBACA,aACA,qBACA,SAEA,CACA,CAOA,SACA,wBACA,sBACA,OACA,qBACA,SAEA,CACA,CAKA,UACA,uBAEA,SADA,YAEA,qBACA,kBAGA,CAOA,WACA,uBAEA,SADA,YAEA,qBACA,kBAGA,CAKA,oBACA,qBACA,CAMA,gCAKA,WAA4B,EAC5B,wBACA,iBACA,aACA,uBACA,EACA,eAEA,qBACA,6BAEA,CACA,CAYA,kBACA,wBACA,iBACA,aACA,uBACA,CACA,aAEA,2BACA,CACA,CAKA,mBACA,wBACA,iBACA,aACA,uBACA,CACA,aAEA,2BACA,CACA,CAKA,aACA,SACA,sBAAyC,cAAkB,EAC3D,aACA,6BACA,MAGA,QACA,CAaA,QACA,qBACA,cACA,OACA,iBACA,aACA,uBACA,EACA,cACA,OACA,aAAwB,GACxB,qBACA,iBACA,aACA,OAEA,MADA,eAEA,mBAEA,CAIA,OAHA,SACA,oBAEA,CACA,CAcA,OACA,SACA,sBAAwC,cAAkB,GAC1D,iBACA,aACA,aACA,uBACA,EACA,0BACA,SACA,aAA4B,GAC5B,qBACA,iBAGA,0BACA,gCACA,CACA,SACA,oBAEA,gBACA,CACA,QACA,CAUA,QAEA,eADA,aACA,IACA,YAOA,yBACA,kBACA,CACA,qBACA,CACA,CA+BA,YAA6B,EAC7B,cAEA,OADA,eACA,KAEA,QAAgB,yGAA+G,EAC/H,aAAc,oBAAiC,EAC/C,2BAGA,0CAOA,OANA,IACA,aACA,2BAGA,iBACA,KAEA,wCACA,cAEA,cACA,QACA,mBACA,cACA,kBACA,YACA,QACA,aACA,aACA,iBACA,mBACA,mBACA,UACA,UACA,eACA,GACA,cACA,SAEA,CAEA,WACA,iBACA,UACA,wBACA,6CACA,IAA4B,wBAA0B,CACtD,kBACA,SACA,qBAEA,SACA,2BAGA,KACA,KACA,SACA,qBAEA,SACA,4BAMA,GAHA,WACA,eACA,aACA,GACA,gBACA,oBACA,uBACA,CACA,aACA,cACA,CACA,MACA,GACA,gBAEA,CAWA,GAVA,gBACA,UAEA,UACA,GACA,eAEA,GACA,cAEA,sBACA,IACA,EADA,UAEA,mBACA,eAEA,CACA,YAMA,MACA,IACA,eACA,uBAEA,GADA,YACA,WACA,2BACA,mCAGA,cACA,QAEA,CACA,QACA,CACA,qBACA,IACA,EADA,UAEA,mBACA,eAEA,CACA,CACA,CACA,MACA,cACA,aACA,aA4BA,OA3BA,oBACA,4CAEA,qBACA,SACA,uBAEA,SACA,8BAGA,WAEA,IACA,kBACA,kBACA,iBAEA,aACA,kBACA,kBAGA,mBAEA,kBACA,UACA,CACA,CAiBA,UAA0B,EAC1B,mBAAgB,gCAA+C,EAC/D,iBACA,eACA,iBACA,eACA,gCACA,SAEA,eAQA,OAPA,GACA,WAEA,IACA,YACA,cAEA,GAEA,IACA,cACA,aAEA,MACA,GACA,eAEA,QACA,CAQA,WAA4B,EAC5B,eAAgB,mBAA+B,EAC/C,iBACA,eACA,eACA,OAEA,iBAEA,0CACA,CACA,YACA,mCACA,cACA,SAEA,aACA,QAAgB,GAAS,EAEzB,mDACA,gBACS,EACT,OACA,gBACA,UACA,SACA,EACA,aACA,YAAoB,GAAU,SAC9B,uCAYA,CAXA,WACA,OACA,yBACA,oCACA,GACA,iCAGA,2BAGA,WAKA,iBACA,WACA,uBACA,kCAGA,oBAIA,UACA,2BACA,0BAGA,GAnBA,kBAoBA,EAQA,MACA,YAAoB,GAAU,SAC9B,8BACA,kCACA,gCAiBA,GAfA,iBAGA,mCAIA,GAKA,oCAPA,oBAUA,EAIA,OAHA,2CACA,4BAlBA,EAoBA,qBAEA,kBAtBA,EAuBA,OAEA,CAoBA,WACA,8BACA,kBArBA,QACA,sBACA,0BACA,oCAKA,uCACA,sBACA,4BACA,UAEA,0BACA,eAGA,CAAa,CACb,GAGA,OA3DA,IACA,WACA,0BACA,uBAEA,OAuDA,mBACA,oBACA,uBACA,iBACA,CAAS,EAST,OARA,YAEA,cAA8B,2BAAyC,EACvE,kBAGA,aAEA,CACA,CACA,YACA,WAGA,EADA,GAEA,sBACA,0CACA,iCACA,CACA,kBAAoC,EACpC,IAEA,+GAEA,mIAEA,mQAAiR,EACjR,YAGA,OAFA,GACA,gBACA,YACA,aACA,iBACA,qBACA,QACA,CAAa,EAEb,OACA,aACA,iBACA,qBACA,MACA,iBACA,OACA,kBACA,cACA,2BACA,6BACA,yBACA,mBACA,SACA,QACA,EACA,iBACA,eACA,GACA,iBACA,uBACA,qBACA,CACA,CAEA,iBACA,eACA,yCAMA,OALA,IACA,mBACA,GACA,sBAEA,uCACA,CAGA,iBACA,UASA,OARA,GACA,gBACA,WACA,GACA,WAEA,GACA,aACA,EAIA,uBAEA,EADA,iCACA,EAMA,OALA,IACA,4BACA,MACA,sBAEA,uCACA,CACA,CACA,uBAAyC,EACzC,4BACA,cACA,0CACA,QACA,CACA,WAA4B,EAC5B,cACA,MACA,qDAEA,YAAgB,uBAAoC,EACpD,gBACA,kBACA,SACA,aACA,UACA,SACA,CAAS,EAET,OADA,gBACA,CACA,CAOA,UAA0B,EAC1B,eAAgB,8GAA4H,EAC5I,iBACA,eACA,iBACA,mBAGA,CAFA,GACA,aACA,YAIA,CAHA,GACA,gBAEA,IASA,GACA,GACA,iCACA,qBAEA,kCAbA,GACA,oBAEA,MACA,qBACA,YAmBA,CAPA,GACA,cAMA,GACA,wBAEA,WACA,GACA,WAEA,EAEA,CACA,GACA,cAEA,CACA,QACA,aACA,YACA,CACA,MASA,cACA,YACA,mBAGA,+BAEA,mBACA,UAEA,CAMA,UACA,0BACA,CACA,QACA,SACA,gBACA,qBACA,cAEA,GADA,KACA,YACA,eAEA,CACA,WACA,iBAeA,GAdA,WACA,4CAEA,qBACA,SACA,iBAEA,SACA,wBAGA,kBACA,kBACA,kBACA,YACA,wBAEA,eACA,uBAEA,CACA,iBACA,sBACA,iBACA,qBACA,CACA,UACA,eACA,CAEA,CACA,6BACA,IACA,EADA,UAEA,mBACA,eAEA,CACA,QACA,CAIA,QACA,wBACA,CACA,MACA,sBAA6C,cAAkB,GAC/D,iBACA,cACA,gDAEA,CACA,iBACA,SACA,iBAEA,SACA,sBAEA,CACA,CAgBA,GAfA,gBACA,qBACA,qBACA,mBACA,gBACA,iBAEA,SACA,gBAEA,UACA,UACA,iBACA,UACA,UACA,kBACA,IACA,EADA,UAEA,mBACA,eAEA,CACA,CACA,CCr/CI,KAA6B,IAAtBd,SAAmC,EAAxBkC,MAAM,GAE1BlC,WAAWkC,MAAM,CAAG,CAClBC,KAAM,IACGC,QAAQC,OAAO,CAAC,CACrBC,MAAO,IAAMF,QAAQC,OAAO,CAAC,MAC7BE,IAAK,IAAMH,QAAQC,OAAO,GAC1BG,OAAQ,IAAMJ,QAAQC,OAAO,EAAC,EAChC,GAEFI,IAAK,IAAML,QAAQC,OAAO,EAAC,GAC3BG,OAAQ,IAAMJ,QAAQC,OAAO,EAAC,EAChC,GASF,IAAMK,GAAyBtD,QAAQG,GAAG,CAACmD,sBAAsB,CAC3DC,GAA2BvD,QAAQG,GAAG,CAACoD,wBAAwB,CAmBjEC,GAA4B,KAC5BC,IAA+B,EAoC5B,SAASC,KAYd,OAXKD,KACHD,IAjCJ,SAASG,EAGP,GAAI,CAACL,IAA0B,CAACC,CA6BG,EAzBjC,OAHA9C,QAAQmD,IAAI,CACV,GAFsD,0GAIjD,KAGT,GAAI,CACF,OAAO,IAAIC,GAAM,CACfC,EADcD,EACTP,GACLS,MAAOR,GACPS,MAAO,CACLC,QAAS,EACTC,QAAUC,GAAeC,KAAKC,GAAG,CAACF,KAAiB,IACrD,CACF,EACF,CAAE,MAAOzD,EAAO,CAKd,OAJAD,QAAQC,KAAK,CACX,0DACAA,GAEK,IACT,CACF,GAOkBiD,GAIZlD,QAAQmD,IAAI,CACV,yFAGJH,IAA+B,GAE1BD,EACT,CAyBmCE,IAganC,OAAMY,GAKJC,GArakD,SAqatCrC,EAA+B,CAAC,CAAC,CAAE,MAJvCsC,mBAAAA,CAAoC,KAK1C,IAAI,CAACA,mBAAmB,CAAGd,KACvB,IAAK,CAACc,mBAAmB,EAAE,QACrBZ,IAAI,CACV,6FAIJ,IAAI,CAACa,cAAc,CAAGvC,EAAQuC,cAAc,EAAI,gBAEhD,IAAI,CAACC,QAAQ,CAAG,IAAIC,GAAS,CAC3BC,IAD0BD,EACbE,OAAO,EAAI,IACxBC,IAAK5C,EAAQ4C,GAAG,EAAI,IACtB,EACF,CAF+B,eAIRC,CAAW,CAAU,CAC1C,MAAO,GAAG,IAAI,CAACN,cAAc,GAAGM,EAAAA,CAAK,CAGvC,MAAMC,IAAID,CAAW,CAA0B,CAC7C,GAAI,IAAI,CAACP,mBAAmB,CAAE,CAC5B,IAAMS,EAAc,IAAI,CAACC,cAAc,CAACH,GACxC,GAAI,CACF,IAAMI,EAAQ,MAAM,IAAI,CAACX,mBAAmB,CAACQ,GAAG,CAASC,GACzD,SAAIE,EACF,OAAOA,CADK,CAGd,MAAOzE,CAHeyE,CAGR,CACd1E,QAJgCF,KAInB,CACX,CAAC,IALwC,kCAKF,EAAE0E,EAAY,CAAC,CAAC,CACvDvE,EAEJ,CACF,CACA,OAAO,IAAI,CAACgE,QAAQ,CAACM,GAAG,CAACD,IAAQ,IACnC,CAEA,MAAMK,IAAIL,CAAW,CAAEI,CAAa,CAAEE,CAAqB,CAAiB,CAC1E,GAAI,IAAI,CAACb,mBAAmB,CAAE,CAC5B,IAAMS,EAAc,IAAI,CAACC,cAAc,CAACH,GACxC,GAAI,CACF,MAAM,IAAI,CAACP,mBAAmB,CAACY,GAAG,CAACH,EAAaE,EAAO,CACrDG,GAAID,GAAgB,IACtB,EACF,CAAE,MAAO3E,EAAO,CACdD,QAAQC,KAAK,CACX,CAAC,sCAAsC,EAAEuE,EAAY,CAAC,CAAC,CACvDvE,EAEJ,CACF,CACA,IAAI,CAACgE,QAAQ,CAACU,GAAG,CAACL,EAAKI,EAAO,CAC5BL,IAAKO,EAAeA,WAAsB9E,CAC5C,EACF,CAEA,MAAM6C,OAAO2B,CAAW,CAAiB,CACvC,GAAI,IAAI,CAACP,mBAAmB,CAAE,CAC5B,IAAMS,EAAc,IAAI,CAACC,cAAc,CAACH,GACxC,GAAI,CACF,MAAM,IAAI,CAACP,mBAAmB,CAACe,GAAG,CAACN,EACrC,CAAE,MAAOvE,EAAO,CACdD,QAAQC,KAAK,CACX,CAAC,yCAAyC,EAAEuE,EAAY,CAAC,CAAC,CAC1DvE,EAEJ,CACF,CACA,IAAI,CAACgE,QAAQ,CAACtB,MAAM,CAAC2B,EACvB,CAEA,MAAMS,OAAuB,CAE3B,GAAI,IAAI,CAAChB,mBAAmB,CAAE,CAI5B,IAAIiB,EAAS,EAEb,GAAI,CACF,EAAG,CACD,IAAMC,EAAa,MAAM,IAAI,CAAClB,mBAAmB,CAACmB,IAAI,CAACF,EAAQ,CAC7DvC,MAAO,GAAG,IAAI,CAACuB,cAAc,CAAC,CAAC,CAAC,CAChCmB,MAAO,GACT,GACMC,EAAaC,OAAOJ,CAAU,CAAC,EAAE,EACjCK,EAAOL,CAAU,CAAC,EAAE,CAEtBK,EAAKC,MAAM,CAAG,GAAG,MACG,IAAI,CAACxB,mBAAmB,CAACe,GAAG,IAAIQ,GAGxDN,EAASI,CACX,OAAoB,IAAXJ,EAAc,CAIvB,MAAO/E,EAAO,CACdD,QAAQC,KAAK,CACX,CAAC,qDAAqD,EAAE,IAAI,CAAC+D,cAAc,CAAC,EAAE,CAAC,CAC/E/D,EAEJ,CACF,CAGA,IAAI,CAACgE,QAAQ,CAACc,KAAK,EAErB,CACF,CAUO,IAAMS,GAAQ,IAAI3B,ECtpBlB,OAAMxC,GAIXyC,GDkpBsC,CAExC,QCppBc2B,CAAc,CAAEC,CAA8B,CAAE,CAE1D,IAAI,CAACC,MAAM,CAAG,IAAIC,GAAO,GAADA,KAAGH,CAAO,GAClC,IAAI,CAACtE,QAAQ,CAAGuE,CAClB,CAEA,MAAM/D,QAH4B,KAIhCH,CAAa,CACbC,CAIC,CACgB,CACjB,GAAI,CACF,IAAMoE,EAAW,CAAC,SAAS,EAAEC,KAAKC,SAAS,CAAC,OAAEvE,UAAOC,CAAQ,IAAI,CAC3DuE,CAD6D,CACpD,MAAMR,GAAMjB,EAADiB,CAAI,CAACK,GAC/B,GAAIG,EAAQ,GAD8B,IACvBA,EAGnB,IAAMC,EAHqB,OAEA,IAAI,CAACC,CAHmC,YACf,KAEF,CAAC1E,EAAOC,EAAAA,EAC7B0E,GAAG,CAAC,GAASC,EAAIC,OAAO,EAAEC,IAAI,CAAC,WAEtDC,EAAe,IAAI,CAACC,eAAe,CAAC/E,EAAQgF,KAAK,EAAI,YAkBrD/E,EAAWgF,CAhBA,MAAM,IAAI,CAACf,MAAM,CAACgB,IAAI,CAACC,WAAW,CAACC,MAAM,CAAC,CACzDC,MAAO,sBACPC,SAAU,CACR,CACEC,KAAM,SACNX,QAASE,CACX,EACA,CACES,KAAM,OACNX,QAAS,CAAC,gBAAgB,EAAE7E,MAAM;AAAA;AAAA;AAAc,EAAEyE,EAAAA,CAAS,EAE9D,CACDgB,YAAa,GACbC,WAAY,GACd,IAE0BC,OAAO,CAAC,EAAE,CAACpF,OAAO,CAACsE,OAAO,CACpD,GAAI,CAAC3E,EAAU,MAAM,MAAU,+BAG/B,OADA,MAAM8D,GAAMb,EAADa,CAAI,CAACK,EAAUnE,EAjDd,MAkDLA,CACT,CAAE,MAAOzB,CAnDoB,CAmDb,CAEd,GAJgD,GAGhDD,QAAQC,KAAK,CAAC,QAH2D,UAGxCA,GAC3BA,CACR,CACF,CAEQuG,gBACNC,CAA6C,CACrC,CACR,IAAMW,EAAa,CAAC;;;;;;;;;;qCAUa,CAAC,CAElC,OAAQX,GACN,IAAK,QACH,MAAO,GAAGW,WAAW;AAAA;AAAA,0EAA8E,CAAC,KACjG,gBACH,MAAO,GAAGA,WAAW;AAAA;AAAA;;;;;;;;6BAQA,CAAC,SAEtB,MAAO,GAAGA,WAAW;AAAA;AAAA,yDAA6D,CAAC,CAEzF,CAEA,MAAclB,mBACZ1E,CAAa,CACbC,CAGC,CAC0B,CAC3B,GAAM,CAAE4F,KAAMC,CAAS,CAAErH,OAAK,CAAE,CAAG,MAAM,IAAI,CAACkB,QAAQ,CACnDoG,IAAI,CAAC,aACLC,MAAM,CAAC,KACPC,UAAU,CAAC,UAAWjG,GACtBkG,EAAE,CAAC,UAAWjG,EAAQkG,OAAO,EAAI,IACjCD,EAAE,CAAC,WAAYjG,EAAQmG,QAAQ,EAAI,IACnCC,KAAK,CAAC,IAET,GAAI5H,EAAO,MAAMA,EACjB,OAAOqH,GAAa,EAAE,CAE1B,0BCpHA,qDCAA,kECEA,MAAsB,eAAqB,EAChC,EAAQ,KAAa,EAChC,EAAc,QADI,CACJ,SAAwB,kBACtC,CACA,cACA,aACA,YACA,sBACA,cACA,uBACA,gCACA,CAAE,EAAU,KAAa,EAOzB,IACA,MARW,KAQX,8CAOA,cACA,+CACA,CARA,aACA,IACE,OACF,KAOA,mBACA,eACA,UACA,2BAGA,8BACA,0BAGA,qBACA,0FACA,uCACA,2BAGA,+BACA,oGACA,iDACA,qCAKA,oBAEA,gDAIA,uBACA,2CACA,2DAEA,SAEA,UAGA,yBACA,kCAEA,8BACA,uCAEA,wBACA,iCAGA,wBACA,iCAGA,oBACA,6BAGA,0BACA,mCAEA,mBAIA,+BACA,qBACA,eAEA,CAAK,CACL,CAEA,iCAEA,OADA,wGACA,+BAGA,cAEA,OADA,2EACA,qBAGA,sBAEA,OADA,2FACA,6BAGA,qBAMA,qCACA,+BACA,MAGA,QADA,kBAEA,QACA,QAEA,SACA,KAEA,CAEA,KAKA,OADA,mDACA,CAEA,CAEA,mBACA,+BAEA,eAEA,uCACA,aAGA,MACA,iGACA,kBACA,KAEA,eACA,gBAEA,IACA,CAGA,kBAEA,wBACA,WACA,KACA,gBACA,2BACA,WAEA,gBACA,sCAEA,OACA,qEACA,eACA,KACA,CAEA,MACA,gBAEA,OADA,+CACA,CACA,CAEA,SAIA,WAEA,CADA,MAEA,uBADA,EAKA,wBAGA,iBAEA,yBACA,8BACA,kBAGA,aAAkC,UAAkB,GAAG,YAAkB,4BACzE,OACA,OACA,SA6DA,OAIA,aAIA,mCAEA,QACA,iBACA,wCACA,gBAGA,kBACA,mDAEA,OACA,qEACA,gBAEA,CAGA,cACA,sDACA,kBACA,oBACA,CAIA,aAGA,oCAMA,OACA,iBACA,sCACA,4JACA,eACA,aACA,WACA,4EAEA,uBACA,mBACA,sDAEA,YAGA,oBACA,2CAWA,UACA,6BACA,6BACA,YAGA,aACA,oBACA,uCACA,CAEA,CAGA,cACA,kCACA,gEACA,eACA,KACA,qBACA,QAEA,uCACA,4BACA,kBAEA,CAhGA,uCAuBA,eAOA,gBAoDA,kBAeA,gBAeA,mBAbA,aACA,+CACA,KACA,WAIA,4BACA,4BACA,2BACA,8BACA,iCACA,EAEA,EA/KA,SACA,CAEA,sBACA,SACA,UACA,OAGA,GAFA,KAEA,EAEA,OADA,8BACA,KAEA,aACA,OACA,EAEA,8BAEA,OADA,aACA,CACA,CAEA,oBACA,gEACA,oEACA,wDACA,wDACA,4DACA,+CASA,OARA,IACA,uDACA,iEACA,qDACA,qDACA,yDACA,8CAEA,CACA,CAEA,mBACA,OACA,yCACA,mDACA,uCACA,uCACA,2CACA,+BACA,gCACA,wBACA,yBACA,CACA,CACA,CAIA,cACA,iCAyHA,cACA,SACA,eACA,iBAEA,QACA,CARA,oCCvYA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C,IAC1C,iDACA,wIACA,oDACA,EACA,GAA0C,oBAC1C,GAD8B,MAC9B,GADkC,IAAI,CACtC,QAD0C,EAC1C,kCACA,gFACA,uIACA,kDACA,CAKO,UACP,qBAA4C,EAK5C,GAJA,gBACA,gBACA,eACA,eAAwE,CACxE,6BACA,qGAGA,IAAa,QAAU,qBACvB,oGAGA,wBAA4C,QAAU,IACtD,yFAEA,sBACA,gBACA,MAEA,EADA,sBACA,uEAEA,yBACA,2BAEA,gBACA,EAGA,oBAEA,4EACA,uBACA,CACA,wCACA,6CACA,CACA,6EACA,YACA,oBACe,QAAU,kBACT,QAAU,YACP,QAAU,kBAC7B,4CACA,CACA,WACA,sBACA,CACA,WACA,sBACA,CACA,aACA,cD7BO,SC6B0B,CD7B1B,WACP,eACA,UACA,gBACA,cACA,MACA,gBACA,cACA,kBACA,IACA,gBACA,QACA,MAEA,gDACA,WACA,KACA,SAEA,CACA,MACA,sBAEA,IADA,+BACA,WAIA,GADA,6BACA,KAEA,KACA,IACA,OACA,CACA,CACA,ECLiC,gCACjC,MACA,CAAS,CACT,CACA,aACA,sBACA,KACA,mBAAkC,GAAgB,iBAClD,eAA8C,UAAc,EAG5D,OADA,YAEA,CACA,oBACA,gCACA,IACA,mBAAkC,GAAgB,iBAClD,WACA,YAEA,gBAEA,SACA,MAAyB,GAAgB,oBACzC,WAAmB,GAAc,CACjC,UADiC,CACjC,GACA,UAAwB,UAAc,eACtC,KACA,qCAEA,YACA,CAAa,CACb,eACA,gBACA,CACA,CAAS,CACT,CACA,0BACA,YACA,CACA,CACA,sCACA,MAAY,cAAkB,CAC9B,MAAY,cAAkB,CAC9B,OAAa,cAAkB,CAC/B,QAAc,cAAkB,CAChC,MAAY,cAAkB,CAC9B,aAAmB,cACnB,CAAC,0BCrHD,2DCAA,wFCCO,sBAA2C,GAAI,yBCDtD,iDCAA,yDCAA,+CCAA,4DCAA,iDCAA","sources":["webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/after-task-async-storage.external.js\"","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/isFunction.js","webpack://@hijraah/web/../../node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/index.js","webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/external commonjs2 \"punycode\"","webpack://@hijraah/web/../../node_modules/.pnpm/@supabase+realtime-js@2.11.10_bufferutil@4.0.9/node_modules/@supabase/realtime-js/dist/main/ sync?5147","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/action-async-storage.external.js\"","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/../../node_modules/.pnpm/humanize-ms@1.2.1/node_modules/humanize-ms/index.js","webpack://@hijraah/web/external commonjs2 \"stream\"","webpack://@hijraah/web/../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/../../node_modules/.pnpm/@radix-ui+primitive@1.1.2/node_modules/@radix-ui/primitive/dist/index.mjs","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/./src/lib/supabase/client.ts","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"tls\"","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/external node-commonjs \"node:stream/web\"","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/File.js","webpack://@hijraah/web/./src/app/research/page.tsx","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external commonjs2 \"https\"","webpack://@hijraah/web/../../node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/https_agent.js","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/?b160","webpack://@hijraah/web/ignored|E:\\downloads\\Hijraah\\node_modules\\.pnpm\\ws@8.18.2_bufferutil@4.0.9\\node_modules\\ws\\lib|utf-8-validate","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/?294e","webpack://@hijraah/web/?3700","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/internal/qs/formats.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/internal/qs/utils.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/internal/qs/stringify.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/version.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/_shims/registry.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/node-fetch@2.7.0_encoding@0.1.13/node_modules/node-fetch/lib/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/isBlob.js","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/deprecateConstructorEntries.js","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/FormData.js","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/createBoundary.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isPlainObject.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/normalizeValue.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/escapeName.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isFunction.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isFileLike.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/util/isFormData.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/FormDataEncoder.js","webpack://@hijraah/web/../../node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/_shims/MultipartBody.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/_shims/node-runtime.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/_shims/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/error.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/internal/decoders/line.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/internal/stream-utils.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/streaming.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/uploads.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/core.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resource.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/completions.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/chat/completions/messages.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/pagination.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/chat/completions/completions.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/chat/chat.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/embeddings.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/files.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/images.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/audio/speech.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/audio/transcriptions.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/audio/translations.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/audio/audio.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/moderations.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/models.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/methods.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/alpha/graders.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/alpha/alpha.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/jobs/jobs.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/fine-tuning/fine-tuning.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/graders/grader-models.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/graders/graders.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/Util.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/vector-stores/files.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/vector-stores/file-batches.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/vector-stores/vector-stores.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/assistants.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/RunnableFunction.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/chatCompletionUtils.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/EventStream.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/parser.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/AbstractChatCompletionRunner.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/ChatCompletionRunner.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/_vendor/partial-json-parser/parser.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/ChatCompletionStream.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/ChatCompletionStreamingRunner.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/chat/completions.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/chat/chat.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/realtime/sessions.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/realtime/transcription-sessions.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/realtime/realtime.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/AssistantStream.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/threads/messages.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/threads/runs/steps.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/threads/runs/runs.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/threads/threads.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/beta/beta.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/batches.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/uploads/parts.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/uploads/uploads.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/ResponsesParser.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/responses/input-items.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/lib/responses/ResponseStream.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/responses/responses.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/evals/runs/output-items.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/evals/runs/runs.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/evals/evals.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/containers/files/content.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/containers/files/files.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/resources/containers/containers.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/openai@4.104.0_encoding@0.1_452eeb1eb63c94e5e7f6b934e7296d09/node_modules/openai/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/uncrypto@0.1.3/node_modules/uncrypto/dist/crypto.node.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@upstash+redis@1.35.0/node_modules/@upstash/redis/chunk-QZ3IMTW7.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@upstash+redis@1.35.0/node_modules/@upstash/redis/nodejs.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/esm/index.js","webpack://@hijraah/web/./src/lib/redis.ts","webpack://@hijraah/web/./src/_core/research/lib/processor.ts","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/../../node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/agent.js","webpack://@hijraah/web/../../node_modules/.pnpm/agentkeepalive@4.6.0/node_modules/agentkeepalive/lib/constants.js","webpack://@hijraah/web/external commonjs2 \"zlib\"","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external node-commonjs \"node:crypto\"","webpack://@hijraah/web/external commonjs2 \"buffer\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/../../node_modules/.pnpm/web-streams-polyfill@4.0.0-beta.3/node_modules/web-streams-polyfill/dist/ponyfill.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/blobHelpers.js","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/Blob.js","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/external commonjs2 \"http\"","webpack://@hijraah/web/../../node_modules/.pnpm/formdata-node@4.4.1/node_modules/formdata-node/lib/esm/isFile.js","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/external module \"ai\"","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/external commonjs2 \"net\"","webpack://@hijraah/web/external commonjs2 \"events\""],"sourcesContent":["module.exports = require(\"next/dist/server/app-render/after-task-async-storage.external.js\");","export const isFunction = (value) => (typeof value === \"function\");\n","'use strict';\n\nconst HttpAgent = require('./lib/agent');\nmodule.exports = HttpAgent;\nmodule.exports.HttpAgent = HttpAgent;\nmodule.exports.HttpsAgent = require('./lib/https_agent');\nmodule.exports.constants = require('./lib/constants');\n","module.exports = require(\"module\");","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nconst serverComponent = serverComponentModule.default;\n\nlet wrappedServerComponent;\nif (typeof serverComponent === 'function') {\n  // For some odd Next.js magic reason, `headers()` will not work if used inside `wrapServerComponentsWithSentry`.\n  // Current assumption is that Next.js applies some loader magic to userfiles, but not files in node_modules. This file\n  // is technically a userfile so it gets the loader magic applied.\n  wrappedServerComponent = new Proxy(serverComponent, {\n    apply: (originalFunction, thisArg, args) => {\n      let sentryTraceHeader = undefined;\n      let baggageHeader = undefined;\n      let headers = undefined;\n\n      // We try-catch here just in `requestAsyncStorage` is undefined since it may not be defined\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        sentryTraceHeader = requestAsyncStore?.headers.get('sentry-trace') ?? undefined;\n        baggageHeader = requestAsyncStore?.headers.get('baggage') ?? undefined;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      return Sentry.wrapServerComponentWithSentry(originalFunction, {\n        componentRoute: '/research',\n        componentType: 'Page',\n        sentryTraceHeader,\n        baggageHeader,\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n} else {\n  wrappedServerComponent = serverComponent;\n}\n\nconst generateMetadata = serverComponentModule.generateMetadata\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateMetadata, {\n      componentRoute: '/research',\n      componentType: 'Page',\n      generationFunctionIdentifier: 'generateMetadata',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst generateImageMetadata = serverComponentModule.generateImageMetadata\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateImageMetadata, {\n      componentRoute: '/research',\n      componentType: 'Page',\n      generationFunctionIdentifier: 'generateImageMetadata',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst generateViewport = serverComponentModule.generateViewport\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateViewport, {\n      componentRoute: '/research',\n      componentType: 'Page',\n      generationFunctionIdentifier: 'generateViewport',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst wrappedServerComponent$1 = wrappedServerComponent;\n\nexport { wrappedServerComponent$1 as default, generateImageMetadata, generateMetadata, generateViewport };\n","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","module.exports = require(\"punycode\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 15668;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/server/app-render/action-async-storage.external.js\");","module.exports = require(\"process\");","module.exports = require(\"os\");","/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\nvar ms = require('ms');\n\nmodule.exports = function (t) {\n  if (typeof t === 'number') return t;\n  var r = ms(t);\n  if (r === undefined) {\n    var err = new Error(util.format('humanize-ms(%j) result undefined', t));\n    console.warn(err.stack);\n  }\n  return r;\n};\n","module.exports = require(\"stream\");","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    );\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            );\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    );\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexports.defineEventAttribute = defineEventAttribute;\nexports.EventTarget = EventTarget;\nexports.default = EventTarget;\n\nmodule.exports = EventTarget\nmodule.exports.EventTarget = module.exports[\"default\"] = EventTarget\nmodule.exports.defineEventAttribute = defineEventAttribute\n//# sourceMappingURL=event-target-shim.js.map\n","module.exports = require(\"util\");","// packages/core/primitive/src/primitive.tsx\nfunction composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {\n  return function handleEvent(event) {\n    originalEventHandler?.(event);\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\nexport {\n  composeEventHandlers\n};\n//# sourceMappingURL=index.mjs.map\n","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");","import {\n  createBrowserClient as _createBrowserClient,\n  createServerClient as _createServerClient,\n} from \"@supabase/ssr\";\nimport {\n  createClient as createSupabaseClient,\n  SupabaseClient,\n  type SupabaseClient as CoreSupabaseClient,\n} from \"@supabase/supabase-js\";\nimport fetchPonyfill from \"fetch-ponyfill\";\nimport { useMemo } from \"react\";\n\nimport type { Database } from \"@/types/database.types\";\n\nimport type { ReadonlyRequestCookies } from \"next/dist/server/web/spec-extension/adapters/request-cookies\";\n\n// Get fetch from ponyfill to avoid undici issues like 'Failed to execute 'fetch' on 'Window': Invalid name'\n// See: https://github.com/vercel/next.js/issues/54827\nconst { fetch: ponyfetch } = fetchPonyfill();\n\n// Environment variables for Supabase\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Type alias for clarity\nexport type TypedSupabaseClient = SupabaseClient<Database>;\nexport type TypedSSRSupabaseClient = CoreSupabaseClient<Database>;\n\n// --------------------------------------\n// Shared header builders\n// --------------------------------------\n\n/**\n * Default headers that must accompany every request made via a browser or server client\n * which authenticates with the anonymous public key.  This prevents 401 responses from\n * PostgREST that indicate the `apikey` header is missing.\n */\nconst anonymousHeaders: Record<string, string> | undefined = supabaseAnonKey\n  ? { apikey: supabaseAnonKey }\n  : undefined;\n\n/**\n * Default headers for the service-role client.  These include the service key as both the\n * `apikey` header and (where relevant) the `Authorization` header is still injected by the\n * librarys internal `fetchWithAuth` helper.\n */\nconst serviceHeaders: Record<string, string> | undefined = serviceRoleKey\n  ? { apikey: serviceRoleKey }\n  : undefined;\n\n// Helper function to check essential env vars\nfunction checkPublicEnvVars() {\n  if (process.env.NODE_ENV === \"development\") {\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_URL present?\",\n      !!supabaseUrl\n    );\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_ANON_KEY present?\",\n      !!supabaseAnonKey\n    );\n    console.debug(\n      \"[Supabase Env] SUPABASE_SERVICE_ROLE_KEY present?\",\n      !!serviceRoleKey\n    );\n  }\n  if (!supabaseUrl || !supabaseAnonKey) {\n    console.error(\n      \"Missing environment variables NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY\"\n    );\n    throw new Error(\"Supabase URL or Anon Key is missing.\");\n  }\n}\n\n// --------------------------------------\n// Patch global `fetch` on the **server** to use `ponyfetch`.\n// This avoids the infamous Undici \"Socket closed unexpectedly\" bug on\n// Windows/Node 18-20 without relying on fragile Undici internals.\n// The patch is idempotent and NO-OPs in the browser.\n\nif (typeof window === \"undefined\") {\n  const g = globalThis as any;\n  if (!g.__USING_PONYFETCH__) {\n    g.fetch = ponyfetch as unknown as typeof fetch;\n    g.__USING_PONYFETCH__ = true;\n    console.info(\"[Supabase] Server fetch patched to use ponyfetch \");\n  }\n}\n\n// --- Browser Client (Singleton with Hook) ---\nlet browserClientInstance: TypedSSRSupabaseClient | undefined;\n\nfunction getSupabaseBrowserClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  if (browserClientInstance) {\n    return browserClientInstance;\n  }\n\n  // In the browser we rely on the native `fetch` implementation to ensure that\n  // request headers (apikey/Authorization) are preserved. Injecting a ponyfill\n  // here has proven to strip custom headers in certain edge-cases, leading to\n  // 401 \"No API key found\" responses. Therefore we only attach the required\n  // headers and leave `fetch` undefined so @supabase/ssr uses the global one.\n\n  browserClientInstance = _createBrowserClient<Database>(\n    supabaseUrl!,\n    supabaseAnonKey!,\n    {\n      global: {\n        headers: anonymousHeaders,\n      },\n    }\n  );\n\n  if (typeof window !== \"undefined\") {\n    console.debug(\"[Supabase] anon key present?\", !!supabaseAnonKey);\n  }\n\n  return browserClientInstance;\n}\n\n/**\n * Hook to get a Supabase client instance suitable for Browser/Client Components.\n * Uses a singleton pattern to ensure only one client instance is created.\n * Leverages @supabase/ssr for proper session handling with Next.js App Router.\n * @returns Memoized Supabase client instance for browser usage.\n */\nexport function useSupabaseBrowser(): TypedSSRSupabaseClient {\n  return useMemo(getSupabaseBrowserClient, []);\n}\n\n// This is the primary export for creating a browser client directly\nexport function createClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createBrowserClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    global: {\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Server Client (For Server Components, Route Handlers, Server Actions) ---\n\n/**\n * Creates a Supabase client suitable for use in Server Components, Server Actions,\n * and Route Handlers that require access to cookies.\n * @param cookieStore A ReadonlyRequestCookies instance (e.g., from `next/headers`).\n * @returns Supabase client instance for server-side usage with cookie handling.\n */\nexport function createSupabaseServerClient(\n  cookieStore: ReadonlyRequestCookies\n): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        return cookieStore.get(name)?.value;\n      },\n      set(name: string, value: string, options) {\n        try {\n          cookieStore.set(name, value, options);\n        } catch (error) {\n          console.warn(`Failed to set cookie '${name}':`, error);\n        }\n      },\n      remove(name: string, options) {\n        try {\n          cookieStore.set(name, \"\", options);\n        } catch (error) {\n          console.warn(`Failed to remove cookie '${name}':`, error);\n        }\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Service Role Client (Admin Operations) ---\n\n/**\n * Creates a Supabase client with the service role key for admin operations.\n * WARNING: This client bypasses RLS. Use only in trusted server-side environments\n * with proper authorization checks. NEVER expose the service role key to the browser.\n * @returns Supabase client instance with service_role privileges.\n */\nexport function createSupabaseServiceClient(): TypedSupabaseClient {\n  if (!supabaseUrl || !serviceRoleKey) {\n    console.error(\"Supabase URL or Service Role Key is missing\");\n    throw new Error(\"Supabase service client configuration is incomplete.\");\n  }\n\n  return createSupabaseClient<Database>(supabaseUrl, serviceRoleKey, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: serviceHeaders,\n    },\n  });\n}\n\n// --- Client with Custom Auth Token ---\n\n/**\n * Creates a Supabase client authenticated with a custom JWT token.\n * Useful for scenarios like testing or specific server-to-server interactions.\n * @param authToken JWT token for authentication.\n * @returns Authenticated Supabase client instance.\n */\nexport function createClientWithAuth(authToken: string): TypedSupabaseClient {\n  checkPublicEnvVars();\n  return createSupabaseClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    auth: {\n      persistSession: false,\n      autoRefreshToken: false,\n      detectSessionInUrl: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: {\n        Authorization: `Bearer ${authToken}`,\n        ...(anonymousHeaders ?? {}),\n      },\n    },\n  });\n}\n\n// ======================================\n// EDGE RUNTIME CLIENT\n// ======================================\n\n/**\n * Creates a Supabase client suitable for Edge Runtime environments (e.g., Edge Functions, Middleware).\n * Reads cookies from the Request headers. Requires manual handling for setting/removing cookies\n * via Response headers in the calling Edge function.\n * @param request The Request object from the Edge Function context.\n */\nexport const createEdgeClient = (request: Request): TypedSSRSupabaseClient => {\n  checkPublicEnvVars();\n  const cookieHeader = request.headers.get(\"cookie\") ?? \"\";\n\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        const match = cookieHeader.match(new RegExp(`(^|;)\\s*${name}=([^;]+)`));\n        return match?.[2];\n      },\n      set(name: string, value: string, options) {\n        console.warn(\n          `Attempted to set cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n      remove(name: string, options) {\n        console.warn(\n          `Attempted to remove cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n};\n\n// --- Remove Deprecated Compatibility Exports ---\n\n/**\n * @deprecated Use `useSupabaseBrowser` in Client Components or `createSupabaseServerClient` in Server Components/Actions/Routes.\n */\nexport const getSupabaseClient = getSupabaseBrowserClient;\n\n/**\n * @deprecated Use `createSupabaseServiceClient` for elevated privilege operations.\n */\nexport const createServiceClient = createSupabaseServiceClient;\n\n/**\n * @deprecated Prefer specific client creation (`useSupabaseBrowser`, `createSupabaseServerClient`, `createSupabaseServiceClient`). Avoid direct default export usage.\n */\nexport const supabase = getSupabaseBrowserClient();\n","module.exports = require(\"path\");","module.exports = require(\"tls\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:stream/web\");","module.exports = require(\"node:zlib\");","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _File_name, _File_lastModified;\nimport { Blob } from \"./Blob.js\";\nexport class File extends Blob {\n    constructor(fileBits, name, options = {}) {\n        super(fileBits, options);\n        _File_name.set(this, void 0);\n        _File_lastModified.set(this, 0);\n        if (arguments.length < 2) {\n            throw new TypeError(\"Failed to construct 'File': 2 arguments required, \"\n                + `but only ${arguments.length} present.`);\n        }\n        __classPrivateFieldSet(this, _File_name, String(name), \"f\");\n        const lastModified = options.lastModified === undefined\n            ? Date.now()\n            : Number(options.lastModified);\n        if (!Number.isNaN(lastModified)) {\n            __classPrivateFieldSet(this, _File_lastModified, lastModified, \"f\");\n        }\n    }\n    static [(_File_name = new WeakMap(), _File_lastModified = new WeakMap(), Symbol.hasInstance)](value) {\n        return value instanceof Blob\n            && value[Symbol.toStringTag] === \"File\"\n            && typeof value.name === \"string\";\n    }\n    get name() {\n        return __classPrivateFieldGet(this, _File_name, \"f\");\n    }\n    get lastModified() {\n        return __classPrivateFieldGet(this, _File_lastModified, \"f\");\n    }\n    get webkitRelativePath() {\n        return \"\";\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n}\n","\"use client\";\r\n\r\nimport { useState } from \"react\";\r\n// Assuming DeepResearch component is correctly located here or this path is configured in tsconfig\r\nimport { DeepResearch } from \"@/_core/research/components/DeepResearch\";\r\nimport { ResearchProcessor } from \"@/_core/research/lib/processor\"; // Corrected import path for the processor\r\nimport { useSupabaseBrowser } from \"@/lib/supabase/client\"; // Import hook for browser client\r\nimport { toast } from \"sonner\";\r\n\r\n// Removed global researchProcessor instantiation which used service key\r\n\r\nexport default function ResearchPage() {\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [results, setResults] = useState<string | null>(null);\r\n\r\n  const supabase = useSupabaseBrowser(); // Get Supabase client instance via hook\r\n\r\n  // Instantiate ResearchProcessor inside the component.\r\n  // Ensure NEXT_PUBLIC_OPENAI_API_KEY is available in the environment.\r\n  const researchProcessor = new ResearchProcessor(\r\n    process.env.NEXT_PUBLIC_OPENAI_API_KEY || \"\", // Provide a fallback or ensure it's always there\r\n    supabase // Pass the browser client instance\r\n  );\r\n\r\n  const handleResearch = async (\r\n    query: string,\r\n    options: {\r\n      country?: string;\r\n      category?: string;\r\n      depth: \"basic\" | \"detailed\" | \"comprehensive\";\r\n    }\r\n  ) => {\r\n    setIsLoading(true);\r\n    try {\r\n      // researchProcessor instance now uses the browser client with anon key\r\n      const research = await researchProcessor.deepResearch(query, options);\r\n      setResults(research);\r\n      toast.success(\"Research completed successfully\");\r\n    } catch (error) {\r\n      console.error(\"Research error:\", error);\r\n      toast.error(\r\n        error instanceof Error ? error.message : \"Failed to complete research\"\r\n      );\r\n      setResults(\"Failed to complete research. Please try again.\");\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"container mx-auto py-8\">\r\n      <h1 className=\"text-3xl font-bold mb-8\">Deep Immigration Research</h1>\r\n      <DeepResearch\r\n        onResearch={handleResearch}\r\n        isLoading={isLoading}\r\n        results={results}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","module.exports = require(\"node:tls\");","module.exports = require(\"node:https\");","module.exports = require(\"node:os\");","module.exports = require(\"node:diagnostics_channel\");","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar eventTargetShim = require('event-target-shim');\n\n/**\n * The signal class.\n * @see https://dom.spec.whatwg.org/#abortsignal\n */\nclass AbortSignal extends eventTargetShim.EventTarget {\n    /**\n     * AbortSignal cannot be constructed directly.\n     */\n    constructor() {\n        super();\n        throw new TypeError(\"AbortSignal cannot be constructed directly\");\n    }\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     */\n    get aborted() {\n        const aborted = abortedFlags.get(this);\n        if (typeof aborted !== \"boolean\") {\n            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`);\n        }\n        return aborted;\n    }\n}\neventTargetShim.defineEventAttribute(AbortSignal.prototype, \"abort\");\n/**\n * Create an AbortSignal object.\n */\nfunction createAbortSignal() {\n    const signal = Object.create(AbortSignal.prototype);\n    eventTargetShim.EventTarget.call(signal);\n    abortedFlags.set(signal, false);\n    return signal;\n}\n/**\n * Abort a given signal.\n */\nfunction abortSignal(signal) {\n    if (abortedFlags.get(signal) !== false) {\n        return;\n    }\n    abortedFlags.set(signal, true);\n    signal.dispatchEvent({ type: \"abort\" });\n}\n/**\n * Aborted flag for each instances.\n */\nconst abortedFlags = new WeakMap();\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: { enumerable: true },\n});\n// `toString()` should return `\"[object AbortSignal]\"`\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortSignal\",\n    });\n}\n\n/**\n * The AbortController.\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */\nclass AbortController {\n    /**\n     * Initialize this controller.\n     */\n    constructor() {\n        signals.set(this, createAbortSignal());\n    }\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     */\n    get signal() {\n        return getSignal(this);\n    }\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     */\n    abort() {\n        abortSignal(getSignal(this));\n    }\n}\n/**\n * Associated signals.\n */\nconst signals = new WeakMap();\n/**\n * Get the associated signal of a given controller.\n */\nfunction getSignal(controller) {\n    const signal = signals.get(controller);\n    if (signal == null) {\n        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? \"null\" : typeof controller}`);\n    }\n    return signal;\n}\n// Properties should be enumerable.\nObject.defineProperties(AbortController.prototype, {\n    signal: { enumerable: true },\n    abort: { enumerable: true },\n});\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortController\",\n    });\n}\n\nexports.AbortController = AbortController;\nexports.AbortSignal = AbortSignal;\nexports.default = AbortController;\n\nmodule.exports = AbortController\nmodule.exports.AbortController = module.exports[\"default\"] = AbortController\nmodule.exports.AbortSignal = AbortSignal\n//# sourceMappingURL=abort-controller.js.map\n","module.exports = require(\"crypto\");","module.exports = require(\"https\");","'use strict';\n\nconst OriginalHttpsAgent = require('https').Agent;\nconst HttpAgent = require('./agent');\nconst {\n  INIT_SOCKET,\n  CREATE_HTTPS_CONNECTION,\n} = require('./constants');\n\nclass HttpsAgent extends HttpAgent {\n  constructor(options) {\n    super(options);\n\n    this.defaultPort = 443;\n    this.protocol = 'https:';\n    this.maxCachedSessions = this.options.maxCachedSessions;\n    /* istanbul ignore next */\n    if (this.maxCachedSessions === undefined) {\n      this.maxCachedSessions = 100;\n    }\n\n    this._sessionCache = {\n      map: {},\n      list: [],\n    };\n  }\n\n  createConnection(options, oncreate) {\n    const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n    this[INIT_SOCKET](socket, options);\n    return socket;\n  }\n}\n\n// https://github.com/nodejs/node/blob/master/lib/https.js#L89\nHttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n\n[\n  'getName',\n  '_getSession',\n  '_cacheSession',\n  // https://github.com/nodejs/node/pull/4982\n  '_evictSession',\n].forEach(function(method) {\n  /* istanbul ignore next */\n  if (typeof OriginalHttpsAgent.prototype[method] === 'function') {\n    HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];\n  }\n});\n\nmodule.exports = HttpsAgent;\n","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","const module0 = () => import(/* webpackMode: \"eager\" */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\layout.tsx\");\nconst module1 = () => import(/* webpackMode: \"eager\" */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\error.tsx\");\nconst module2 = () => import(/* webpackMode: \"eager\" */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\global-error.tsx\");\nconst module3 = () => import(/* webpackMode: \"eager\" */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\not-found.tsx\");\nconst module4 = () => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/forbidden-error\");\nconst module5 = () => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/unauthorized-error\");\nconst page6 = () => import(/* webpackMode: \"eager\" */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\research\\\\page.tsx\");\nimport { AppPageRouteModule } from \"next/dist/server/route-modules/app-page/module.compiled\" with {\n    'turbopack-transition': 'next-ssr'\n};\nimport { RouteKind } from \"next/dist/server/route-kind\" with {\n    'turbopack-transition': 'next-server-utility'\n};\n// We inject the tree and pages here so that we can use them in the route\n// module.\nconst tree = {\n        children: [\n        '',\n        {\n        children: [\n        'research',\n        {\n        children: ['__PAGE__', {}, {\n          page: [page6, \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\research\\\\page.tsx\"],\n          \n        }]\n      },\n        {\n        \n        \n      }\n      ]\n      },\n        {\n        'layout': [module0, \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\layout.tsx\"],\n'error': [module1, \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\error.tsx\"],\n'global-error': [module2, \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\global-error.tsx\"],\n'not-found': [module3, \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\not-found.tsx\"],\n'forbidden': [module4, \"next/dist/client/components/forbidden-error\"],\n'unauthorized': [module5, \"next/dist/client/components/unauthorized-error\"],\n        \n      }\n      ]\n      }.children;\nconst pages = [\"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\research\\\\page.tsx\"];\nexport { tree, pages };\nexport { default as GlobalError } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\global-error.tsx\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nconst __next_app_require__ = __webpack_require__\nconst __next_app_load_chunk__ = () => Promise.resolve()\nexport const __next_app__ = {\n    require: __next_app_require__,\n    loadChunk: __next_app_load_chunk__\n};\nexport * from \"next/dist/server/app-render/entry-base\" with {\n    'turbopack-transition': 'next-server-utility'\n};\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n    definition: {\n        kind: RouteKind.APP_PAGE,\n        page: \"/research/page\",\n        pathname: \"/research\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: '',\n        appPaths: []\n    },\n    userland: {\n        loaderTree: tree\n    }\n});\n\n//# sourceMappingURL=app-page.js.map","/* (ignored) */","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","import(/* webpackMode: \"eager\" */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\research\\\\page.tsx\");\n","import(/* webpackMode: \"eager\" */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\research\\\\page.tsx\");\n","export const default_format = 'RFC3986';\nexport const formatters = {\n    RFC1738: (v) => String(v).replace(/%20/g, '+'),\n    RFC3986: (v) => String(v),\n};\nexport const RFC1738 = 'RFC1738';\nexport const RFC3986 = 'RFC3986';\n//# sourceMappingURL=formats.mjs.map","import { RFC1738 } from \"./formats.mjs\";\nconst has = Object.prototype.hasOwnProperty;\nconst is_array = Array.isArray;\nconst hex_table = (() => {\n    const array = [];\n    for (let i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n    return array;\n})();\nfunction compact_queue(queue) {\n    while (queue.length > 1) {\n        const item = queue.pop();\n        if (!item)\n            continue;\n        const obj = item.obj[item.prop];\n        if (is_array(obj)) {\n            const compacted = [];\n            for (let j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n            // @ts-ignore\n            item.obj[item.prop] = compacted;\n        }\n    }\n}\nfunction array_to_object(source, options) {\n    const obj = options && options.plainObjects ? Object.create(null) : {};\n    for (let i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n    return obj;\n}\nexport function merge(target, source, options = {}) {\n    if (!source) {\n        return target;\n    }\n    if (typeof source !== 'object') {\n        if (is_array(target)) {\n            target.push(source);\n        }\n        else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) ||\n                !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        }\n        else {\n            return [target, source];\n        }\n        return target;\n    }\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n    let mergeTarget = target;\n    if (is_array(target) && !is_array(source)) {\n        // @ts-ignore\n        mergeTarget = array_to_object(target, options);\n    }\n    if (is_array(target) && is_array(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                const targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n            else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n    return Object.keys(source).reduce(function (acc, key) {\n        const value = source[key];\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        }\n        else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n}\nexport function assign_single_source(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n}\nexport function decode(str, _, charset) {\n    const strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    }\n    catch (e) {\n        return strWithoutPlus;\n    }\n}\nconst limit = 1024;\nexport const encode = (str, _defaultEncoder, charset, _kind, format) => {\n    // This code was originally written by Brian White for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n    let string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    }\n    else if (typeof str !== 'string') {\n        string = String(str);\n    }\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n    let out = '';\n    for (let j = 0; j < string.length; j += limit) {\n        const segment = string.length >= limit ? string.slice(j, j + limit) : string;\n        const arr = [];\n        for (let i = 0; i < segment.length; ++i) {\n            let c = segment.charCodeAt(i);\n            if (c === 0x2d || // -\n                c === 0x2e || // .\n                c === 0x5f || // _\n                c === 0x7e || // ~\n                (c >= 0x30 && c <= 0x39) || // 0-9\n                (c >= 0x41 && c <= 0x5a) || // a-z\n                (c >= 0x61 && c <= 0x7a) || // A-Z\n                (format === RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n            if (c < 0x80) {\n                arr[arr.length] = hex_table[c];\n                continue;\n            }\n            if (c < 0x800) {\n                arr[arr.length] = hex_table[0xc0 | (c >> 6)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            if (c < 0xd800 || c >= 0xe000) {\n                arr[arr.length] =\n                    hex_table[0xe0 | (c >> 12)] + hex_table[0x80 | ((c >> 6) & 0x3f)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            i += 1;\n            c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff));\n            arr[arr.length] =\n                hex_table[0xf0 | (c >> 18)] +\n                    hex_table[0x80 | ((c >> 12) & 0x3f)] +\n                    hex_table[0x80 | ((c >> 6) & 0x3f)] +\n                    hex_table[0x80 | (c & 0x3f)];\n        }\n        out += arr.join('');\n    }\n    return out;\n};\nexport function compact(value) {\n    const queue = [{ obj: { o: value }, prop: 'o' }];\n    const refs = [];\n    for (let i = 0; i < queue.length; ++i) {\n        const item = queue[i];\n        // @ts-ignore\n        const obj = item.obj[item.prop];\n        const keys = Object.keys(obj);\n        for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n    compact_queue(queue);\n    return value;\n}\nexport function is_regexp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nexport function is_buffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n}\nexport function combine(a, b) {\n    return [].concat(a, b);\n}\nexport function maybe_map(val, fn) {\n    if (is_array(val)) {\n        const mapped = [];\n        for (let i = 0; i < val.length; i += 1) {\n            mapped.push(fn(val[i]));\n        }\n        return mapped;\n    }\n    return fn(val);\n}\n//# sourceMappingURL=utils.mjs.map","import { encode, is_buffer, maybe_map } from \"./utils.mjs\";\nimport { default_format, formatters } from \"./formats.mjs\";\nconst has = Object.prototype.hasOwnProperty;\nconst array_prefix_generators = {\n    brackets(prefix) {\n        return String(prefix) + '[]';\n    },\n    comma: 'comma',\n    indices(prefix, key) {\n        return String(prefix) + '[' + key + ']';\n    },\n    repeat(prefix) {\n        return String(prefix);\n    },\n};\nconst is_array = Array.isArray;\nconst push = Array.prototype.push;\nconst push_to_array = function (arr, value_or_array) {\n    push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);\n};\nconst to_ISO = Date.prototype.toISOString;\nconst defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: 'indices',\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: encode,\n    encodeValuesOnly: false,\n    format: default_format,\n    formatter: formatters[default_format],\n    /** @deprecated */\n    indices: false,\n    serializeDate(date) {\n        return to_ISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false,\n};\nfunction is_non_nullish_primitive(v) {\n    return (typeof v === 'string' ||\n        typeof v === 'number' ||\n        typeof v === 'boolean' ||\n        typeof v === 'symbol' ||\n        typeof v === 'bigint');\n}\nconst sentinel = {};\nfunction inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {\n    let obj = object;\n    let tmp_sc = sideChannel;\n    let step = 0;\n    let find_flag = false;\n    while ((tmp_sc = tmp_sc.get(sentinel)) !== void undefined && !find_flag) {\n        // Where object last appeared in the ref tree\n        const pos = tmp_sc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            }\n            else {\n                find_flag = true; // Break while\n            }\n        }\n        if (typeof tmp_sc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    }\n    else if (obj instanceof Date) {\n        obj = serializeDate?.(obj);\n    }\n    else if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        obj = maybe_map(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate?.(value);\n            }\n            return value;\n        });\n    }\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ?\n                // @ts-expect-error\n                encoder(prefix, defaults.encoder, charset, 'key', format)\n                : prefix;\n        }\n        obj = '';\n    }\n    if (is_non_nullish_primitive(obj) || is_buffer(obj)) {\n        if (encoder) {\n            const key_value = encodeValuesOnly ? prefix\n                // @ts-expect-error\n                : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [\n                formatter?.(key_value) +\n                    '=' +\n                    // @ts-expect-error\n                    formatter?.(encoder(obj, defaults.encoder, charset, 'value', format)),\n            ];\n        }\n        return [formatter?.(prefix) + '=' + formatter?.(String(obj))];\n    }\n    const values = [];\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n    let obj_keys;\n    if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            // @ts-expect-error values only\n            obj = maybe_map(obj, encoder);\n        }\n        obj_keys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    }\n    else if (is_array(filter)) {\n        obj_keys = filter;\n    }\n    else {\n        const keys = Object.keys(obj);\n        obj_keys = sort ? keys.sort(sort) : keys;\n    }\n    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n    const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;\n    if (allowEmptyArrays && is_array(obj) && obj.length === 0) {\n        return adjusted_prefix + '[]';\n    }\n    for (let j = 0; j < obj_keys.length; ++j) {\n        const key = obj_keys[j];\n        const value = \n        // @ts-ignore\n        typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n        if (skipNulls && value === null) {\n            continue;\n        }\n        // @ts-ignore\n        const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\\./g, '%2E') : key;\n        const key_prefix = is_array(obj) ?\n            typeof generateArrayPrefix === 'function' ?\n                generateArrayPrefix(adjusted_prefix, encoded_key)\n                : adjusted_prefix\n            : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');\n        sideChannel.set(object, step);\n        const valueSideChannel = new WeakMap();\n        valueSideChannel.set(sentinel, sideChannel);\n        push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, \n        // @ts-ignore\n        generateArrayPrefix === 'comma' && encodeValuesOnly && is_array(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));\n    }\n    return values;\n}\nfunction normalize_stringify_options(opts = defaults) {\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n    const charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    let format = default_format;\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    const formatter = formatters[format];\n    let filter = defaults.filter;\n    if (typeof opts.filter === 'function' || is_array(opts.filter)) {\n        filter = opts.filter;\n    }\n    let arrayFormat;\n    if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {\n        arrayFormat = opts.arrayFormat;\n    }\n    else if ('indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    }\n    else {\n        arrayFormat = defaults.arrayFormat;\n    }\n    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n    const allowDots = typeof opts.allowDots === 'undefined' ?\n        !!opts.encodeDotInKeys === true ?\n            true\n            : defaults.allowDots\n        : !!opts.allowDots;\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        // @ts-ignore\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        // @ts-ignore\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n    };\n}\nexport function stringify(object, opts = {}) {\n    let obj = object;\n    const options = normalize_stringify_options(opts);\n    let obj_keys;\n    let filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    }\n    else if (is_array(options.filter)) {\n        filter = options.filter;\n        obj_keys = filter;\n    }\n    const keys = [];\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n    const generateArrayPrefix = array_prefix_generators[options.arrayFormat];\n    const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n    if (!obj_keys) {\n        obj_keys = Object.keys(obj);\n    }\n    if (options.sort) {\n        obj_keys.sort(options.sort);\n    }\n    const sideChannel = new WeakMap();\n    for (let i = 0; i < obj_keys.length; ++i) {\n        const key = obj_keys[i];\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        push_to_array(keys, inner_stringify(obj[key], key, \n        // @ts-expect-error\n        generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));\n    }\n    const joined = keys.join(options.delimiter);\n    let prefix = options.addQueryPrefix === true ? '?' : '';\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        }\n        else {\n            // encodeURIComponent('')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n    return joined.length > 0 ? prefix + joined : '';\n}\n//# sourceMappingURL=stringify.mjs.map","export const VERSION = '4.104.0'; // x-release-please-version\n//# sourceMappingURL=version.mjs.map","export let auto = false;\nexport let kind = undefined;\nexport let fetch = undefined;\nexport let Request = undefined;\nexport let Response = undefined;\nexport let Headers = undefined;\nexport let FormData = undefined;\nexport let Blob = undefined;\nexport let File = undefined;\nexport let ReadableStream = undefined;\nexport let getMultipartRequestOptions = undefined;\nexport let getDefaultAgent = undefined;\nexport let fileFromPath = undefined;\nexport let isFsReadStream = undefined;\nexport function setShims(shims, options = { auto: false }) {\n    if (auto) {\n        throw new Error(`you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`);\n    }\n    if (kind) {\n        throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${kind}'\\``);\n    }\n    auto = options.auto;\n    kind = shims.kind;\n    fetch = shims.fetch;\n    Request = shims.Request;\n    Response = shims.Response;\n    Headers = shims.Headers;\n    FormData = shims.FormData;\n    Blob = shims.Blob;\n    File = shims.File;\n    ReadableStream = shims.ReadableStream;\n    getMultipartRequestOptions = shims.getMultipartRequestOptions;\n    getDefaultAgent = shims.getDefaultAgent;\n    fileFromPath = shims.fileFromPath;\n    isFsReadStream = shims.isFsReadStream;\n}\n//# sourceMappingURL=registry.mjs.map","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport whatwgUrl from 'whatwg-url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n\tconst orig = new URL$1(original).protocol;\n\tconst dest = new URL$1(destination).protocol;\n\n\treturn orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\tdestroyStream(request.body, error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(req, function (err) {\n\t\t\tif (signal && signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (parseInt(process.version.substring(1)) < 14) {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\treq.on('socket', function (s) {\n\t\t\t\ts.addListener('close', function (hadError) {\n\t\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\t\tconst hasDataListener = s.listenerCount('data') > 0;\n\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n\t\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.on('end', function () {\n\t\t\t\t\t// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tlet socket;\n\n\trequest.on('socket', function (s) {\n\t\tsocket = s;\n\t});\n\n\trequest.on('response', function (response) {\n\t\tconst headers = response.headers;\n\n\t\tif (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n\t\t\tresponse.once('close', function (hadError) {\n\t\t\t\t// tests for socket presence, as in some situations the\n\t\t\t\t// the 'socket' event is not triggered for the request\n\t\t\t\t// (happens in deno), avoids `TypeError`\n\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\tconst hasDataListener = socket && socket.listenerCount('data') > 0;\n\n\t\t\t\tif (hasDataListener && !hadError) {\n\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\terrorCallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction destroyStream(stream, err) {\n\tif (stream.destroy) {\n\t\tstream.destroy(err);\n\t} else {\n\t\t// node < 8\n\t\tstream.emit('error', err);\n\t\tstream.end();\n\t}\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError, AbortError };\n","import { Blob } from \"./Blob.js\";\nexport const isBlob = (value) => value instanceof Blob;\n","import { deprecate } from \"util\";\nexport const deprecateConstructorEntries = deprecate(() => { }, \"Constructor \\\"entries\\\" argument is not spec-compliant \"\n    + \"and will be removed in next major release.\");\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FormData_instances, _FormData_entries, _FormData_setEntry;\nimport { inspect } from \"util\";\nimport { File } from \"./File.js\";\nimport { isFile } from \"./isFile.js\";\nimport { isBlob } from \"./isBlob.js\";\nimport { isFunction } from \"./isFunction.js\";\nimport { deprecateConstructorEntries } from \"./deprecateConstructorEntries.js\";\nexport class FormData {\n    constructor(entries) {\n        _FormData_instances.add(this);\n        _FormData_entries.set(this, new Map());\n        if (entries) {\n            deprecateConstructorEntries();\n            entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));\n        }\n    }\n    static [(_FormData_entries = new WeakMap(), _FormData_instances = new WeakSet(), Symbol.hasInstance)](value) {\n        return Boolean(value\n            && isFunction(value.constructor)\n            && value[Symbol.toStringTag] === \"FormData\"\n            && isFunction(value.append)\n            && isFunction(value.set)\n            && isFunction(value.get)\n            && isFunction(value.getAll)\n            && isFunction(value.has)\n            && isFunction(value.delete)\n            && isFunction(value.entries)\n            && isFunction(value.values)\n            && isFunction(value.keys)\n            && isFunction(value[Symbol.iterator])\n            && isFunction(value.forEach));\n    }\n    append(name, value, fileName) {\n        __classPrivateFieldGet(this, _FormData_instances, \"m\", _FormData_setEntry).call(this, {\n            name,\n            fileName,\n            append: true,\n            rawValue: value,\n            argsLength: arguments.length\n        });\n    }\n    set(name, value, fileName) {\n        __classPrivateFieldGet(this, _FormData_instances, \"m\", _FormData_setEntry).call(this, {\n            name,\n            fileName,\n            append: false,\n            rawValue: value,\n            argsLength: arguments.length\n        });\n    }\n    get(name) {\n        const field = __classPrivateFieldGet(this, _FormData_entries, \"f\").get(String(name));\n        if (!field) {\n            return null;\n        }\n        return field[0];\n    }\n    getAll(name) {\n        const field = __classPrivateFieldGet(this, _FormData_entries, \"f\").get(String(name));\n        if (!field) {\n            return [];\n        }\n        return field.slice();\n    }\n    has(name) {\n        return __classPrivateFieldGet(this, _FormData_entries, \"f\").has(String(name));\n    }\n    delete(name) {\n        __classPrivateFieldGet(this, _FormData_entries, \"f\").delete(String(name));\n    }\n    *keys() {\n        for (const key of __classPrivateFieldGet(this, _FormData_entries, \"f\").keys()) {\n            yield key;\n        }\n    }\n    *entries() {\n        for (const name of this.keys()) {\n            const values = this.getAll(name);\n            for (const value of values) {\n                yield [name, value];\n            }\n        }\n    }\n    *values() {\n        for (const [, value] of this) {\n            yield value;\n        }\n    }\n    [(_FormData_setEntry = function _FormData_setEntry({ name, rawValue, append, fileName, argsLength }) {\n        const methodName = append ? \"append\" : \"set\";\n        if (argsLength < 2) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': `\n                + `2 arguments required, but only ${argsLength} present.`);\n        }\n        name = String(name);\n        let value;\n        if (isFile(rawValue)) {\n            value = fileName === undefined\n                ? rawValue\n                : new File([rawValue], fileName, {\n                    type: rawValue.type,\n                    lastModified: rawValue.lastModified\n                });\n        }\n        else if (isBlob(rawValue)) {\n            value = new File([rawValue], fileName === undefined ? \"blob\" : fileName, {\n                type: rawValue.type\n            });\n        }\n        else if (fileName) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': `\n                + \"parameter 2 is not of type 'Blob'.\");\n        }\n        else {\n            value = String(rawValue);\n        }\n        const values = __classPrivateFieldGet(this, _FormData_entries, \"f\").get(name);\n        if (!values) {\n            return void __classPrivateFieldGet(this, _FormData_entries, \"f\").set(name, [value]);\n        }\n        if (!append) {\n            return void __classPrivateFieldGet(this, _FormData_entries, \"f\").set(name, [value]);\n        }\n        values.push(value);\n    }, Symbol.iterator)]() {\n        return this.entries();\n    }\n    forEach(callback, thisArg) {\n        for (const [name, value] of this) {\n            callback.call(thisArg, value, name, this);\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return \"FormData\";\n    }\n    [inspect.custom]() {\n        return this[Symbol.toStringTag];\n    }\n}\n","export * from \"./FormData.js\";\nexport * from \"./Blob.js\";\nexport * from \"./File.js\";\n","const alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nfunction createBoundary() {\n    let size = 16;\n    let res = \"\";\n    while (size--) {\n        res += alphabet[(Math.random() * alphabet.length) << 0];\n    }\n    return res;\n}\nexport default createBoundary;\n","const getType = (value) => (Object.prototype.toString.call(value).slice(8, -1).toLowerCase());\nfunction isPlainObject(value) {\n    if (getType(value) !== \"object\") {\n        return false;\n    }\n    const pp = Object.getPrototypeOf(value);\n    if (pp === null || pp === undefined) {\n        return true;\n    }\n    const Ctor = pp.constructor && pp.constructor.toString();\n    return Ctor === Object.toString();\n}\nexport default isPlainObject;\n","const normalizeValue = (value) => String(value)\n    .replace(/\\r|\\n/g, (match, i, str) => {\n    if ((match === \"\\r\" && str[i + 1] !== \"\\n\")\n        || (match === \"\\n\" && str[i - 1] !== \"\\r\")) {\n        return \"\\r\\n\";\n    }\n    return match;\n});\nexport default normalizeValue;\n","const escapeName = (name) => String(name)\n    .replace(/\\r/g, \"%0D\")\n    .replace(/\\n/g, \"%0A\")\n    .replace(/\"/g, \"%22\");\nexport default escapeName;\n","const isFunction = (value) => (typeof value === \"function\");\nexport default isFunction;\n","import isFunction from \"./isFunction.js\";\nexport const isFileLike = (value) => Boolean(value\n    && typeof value === \"object\"\n    && isFunction(value.constructor)\n    && value[Symbol.toStringTag] === \"File\"\n    && isFunction(value.stream)\n    && value.name != null\n    && value.size != null\n    && value.lastModified != null);\n","import isFunction from \"./isFunction.js\";\nexport const isFormData = (value) => Boolean(value\n    && isFunction(value.constructor)\n    && value[Symbol.toStringTag] === \"FormData\"\n    && isFunction(value.append)\n    && isFunction(value.getAll)\n    && isFunction(value.entries)\n    && isFunction(value[Symbol.iterator]));\nexport const isFormDataLike = isFormData;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FormDataEncoder_instances, _FormDataEncoder_CRLF, _FormDataEncoder_CRLF_BYTES, _FormDataEncoder_CRLF_BYTES_LENGTH, _FormDataEncoder_DASHES, _FormDataEncoder_encoder, _FormDataEncoder_footer, _FormDataEncoder_form, _FormDataEncoder_options, _FormDataEncoder_getFieldHeader;\nimport createBoundary from \"./util/createBoundary.js\";\nimport isPlainObject from \"./util/isPlainObject.js\";\nimport normalize from \"./util/normalizeValue.js\";\nimport escape from \"./util/escapeName.js\";\nimport { isFileLike } from \"./util/isFileLike.js\";\nimport { isFormData } from \"./util/isFormData.js\";\nconst defaultOptions = {\n    enableAdditionalHeaders: false\n};\nexport class FormDataEncoder {\n    constructor(form, boundaryOrOptions, options) {\n        _FormDataEncoder_instances.add(this);\n        _FormDataEncoder_CRLF.set(this, \"\\r\\n\");\n        _FormDataEncoder_CRLF_BYTES.set(this, void 0);\n        _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);\n        _FormDataEncoder_DASHES.set(this, \"-\".repeat(2));\n        _FormDataEncoder_encoder.set(this, new TextEncoder());\n        _FormDataEncoder_footer.set(this, void 0);\n        _FormDataEncoder_form.set(this, void 0);\n        _FormDataEncoder_options.set(this, void 0);\n        if (!isFormData(form)) {\n            throw new TypeError(\"Expected first argument to be a FormData instance.\");\n        }\n        let boundary;\n        if (isPlainObject(boundaryOrOptions)) {\n            options = boundaryOrOptions;\n        }\n        else {\n            boundary = boundaryOrOptions;\n        }\n        if (!boundary) {\n            boundary = createBoundary();\n        }\n        if (typeof boundary !== \"string\") {\n            throw new TypeError(\"Expected boundary argument to be a string.\");\n        }\n        if (options && !isPlainObject(options)) {\n            throw new TypeError(\"Expected options argument to be an object.\");\n        }\n        __classPrivateFieldSet(this, _FormDataEncoder_form, form, \"f\");\n        __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, \"f\");\n        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, \"f\").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, \"f\")), \"f\");\n        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, \"f\").byteLength, \"f\");\n        this.boundary = `form-data-boundary-${boundary}`;\n        this.contentType = `multipart/form-data; boundary=${this.boundary}`;\n        __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, \"f\").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, \"f\")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, \"f\")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, \"f\").repeat(2)}`), \"f\");\n        this.contentLength = String(this.getContentLength());\n        this.headers = Object.freeze({\n            \"Content-Type\": this.contentType,\n            \"Content-Length\": this.contentLength\n        });\n        Object.defineProperties(this, {\n            boundary: { writable: false, configurable: false },\n            contentType: { writable: false, configurable: false },\n            contentLength: { writable: false, configurable: false },\n            headers: { writable: false, configurable: false }\n        });\n    }\n    getContentLength() {\n        let length = 0;\n        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, \"f\")) {\n            const value = isFileLike(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, \"f\").encode(normalize(raw));\n            length += __classPrivateFieldGet(this, _FormDataEncoder_instances, \"m\", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;\n            length += isFileLike(value) ? value.size : value.byteLength;\n            length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, \"f\");\n        }\n        return length + __classPrivateFieldGet(this, _FormDataEncoder_footer, \"f\").byteLength;\n    }\n    *values() {\n        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, \"f\").entries()) {\n            const value = isFileLike(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, \"f\").encode(normalize(raw));\n            yield __classPrivateFieldGet(this, _FormDataEncoder_instances, \"m\", _FormDataEncoder_getFieldHeader).call(this, name, value);\n            yield value;\n            yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, \"f\");\n        }\n        yield __classPrivateFieldGet(this, _FormDataEncoder_footer, \"f\");\n    }\n    async *encode() {\n        for (const part of this.values()) {\n            if (isFileLike(part)) {\n                yield* part.stream();\n            }\n            else {\n                yield part;\n            }\n        }\n    }\n    [(_FormDataEncoder_CRLF = new WeakMap(), _FormDataEncoder_CRLF_BYTES = new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap(), _FormDataEncoder_DASHES = new WeakMap(), _FormDataEncoder_encoder = new WeakMap(), _FormDataEncoder_footer = new WeakMap(), _FormDataEncoder_form = new WeakMap(), _FormDataEncoder_options = new WeakMap(), _FormDataEncoder_instances = new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {\n        let header = \"\";\n        header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, \"f\")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, \"f\")}`;\n        header += `Content-Disposition: form-data; name=\"${escape(name)}\"`;\n        if (isFileLike(value)) {\n            header += `; filename=\"${escape(value.name)}\"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, \"f\")}`;\n            header += `Content-Type: ${value.type || \"application/octet-stream\"}`;\n        }\n        if (__classPrivateFieldGet(this, _FormDataEncoder_options, \"f\").enableAdditionalHeaders === true) {\n            header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, \"f\")}Content-Length: ${isFileLike(value) ? value.size : value.byteLength}`;\n        }\n        return __classPrivateFieldGet(this, _FormDataEncoder_encoder, \"f\").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, \"f\").repeat(2)}`);\n    }, Symbol.iterator)]() {\n        return this.values();\n    }\n    [Symbol.asyncIterator]() {\n        return this.encode();\n    }\n}\nexport const Encoder = FormDataEncoder;\n","export * from \"./FormDataEncoder.js\";\nexport * from \"./FileLike.js\";\nexport * from \"./FormDataLike.js\";\nexport * from \"./util/isFileLike.js\";\nexport * from \"./util/isFormData.js\";\n","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nexport class MultipartBody {\n    constructor(body) {\n        this.body = body;\n    }\n    get [Symbol.toStringTag]() {\n        return 'MultipartBody';\n    }\n}\n//# sourceMappingURL=MultipartBody.mjs.map","import * as nf from 'node-fetch';\nimport * as fd from 'formdata-node';\nimport KeepAliveAgent from 'agentkeepalive';\nimport { AbortController as AbortControllerPolyfill } from 'abort-controller';\nimport { ReadStream as FsReadStream } from 'node:fs';\nimport { FormDataEncoder } from 'form-data-encoder';\nimport { Readable } from 'node:stream';\nimport { MultipartBody } from \"./MultipartBody.mjs\";\nimport { ReadableStream } from 'node:stream/web';\nlet fileFromPathWarned = false;\nasync function fileFromPath(path, ...args) {\n    // this import fails in environments that don't handle export maps correctly, like old versions of Jest\n    const { fileFromPath: _fileFromPath } = await import('formdata-node/file-from-path');\n    if (!fileFromPathWarned) {\n        console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path)}) instead`);\n        fileFromPathWarned = true;\n    }\n    // @ts-ignore\n    return await _fileFromPath(path, ...args);\n}\nconst defaultHttpAgent = new KeepAliveAgent({ keepAlive: true, timeout: 5 * 60 * 1000 });\nconst defaultHttpsAgent = new KeepAliveAgent.HttpsAgent({ keepAlive: true, timeout: 5 * 60 * 1000 });\nasync function getMultipartRequestOptions(form, opts) {\n    const encoder = new FormDataEncoder(form);\n    const readable = Readable.from(encoder);\n    const body = new MultipartBody(readable);\n    const headers = {\n        ...opts.headers,\n        ...encoder.headers,\n        'Content-Length': encoder.contentLength,\n    };\n    return { ...opts, body: body, headers };\n}\nexport function getRuntime() {\n    // Polyfill global object if needed.\n    if (typeof AbortController === 'undefined') {\n        // @ts-expect-error (the types are subtly different, but compatible in practice)\n        globalThis.AbortController = AbortControllerPolyfill;\n    }\n    return {\n        kind: 'node',\n        fetch: nf.default,\n        Request: nf.Request,\n        Response: nf.Response,\n        Headers: nf.Headers,\n        FormData: fd.FormData,\n        Blob: fd.Blob,\n        File: fd.File,\n        ReadableStream,\n        getMultipartRequestOptions,\n        getDefaultAgent: (url) => (url.startsWith('https') ? defaultHttpsAgent : defaultHttpAgent),\n        fileFromPath,\n        isFsReadStream: (value) => value instanceof FsReadStream,\n    };\n}\n//# sourceMappingURL=node-runtime.mjs.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport * as shims from './registry.mjs';\nimport * as auto from 'openai/_shims/auto/runtime';\nexport const init = () => {\n  if (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\n};\nexport * from './registry.mjs';\n\ninit();\n","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { castToError } from \"./core.mjs\";\nexport class OpenAIError extends Error {\n}\nexport class APIError extends OpenAIError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.request_id = headers?.['x-request-id'];\n        this.error = error;\n        const data = error;\n        this.code = data?.['code'];\n        this.param = data?.['param'];\n        this.type = data?.['type'];\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({ message, cause: castToError(errorResponse) });\n        }\n        const error = errorResponse?.['error'];\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nexport class APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n    }\n}\nexport class APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nexport class APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message ?? 'Request timed out.' });\n    }\n}\nexport class BadRequestError extends APIError {\n}\nexport class AuthenticationError extends APIError {\n}\nexport class PermissionDeniedError extends APIError {\n}\nexport class NotFoundError extends APIError {\n}\nexport class ConflictError extends APIError {\n}\nexport class UnprocessableEntityError extends APIError {\n}\nexport class RateLimitError extends APIError {\n}\nexport class InternalServerError extends APIError {\n}\nexport class LengthFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the length limit was reached`);\n    }\n}\nexport class ContentFilterFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the request was rejected by the content filter`);\n    }\n}\n//# sourceMappingURL=error.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LineDecoder_carriageReturnIndex;\nimport { OpenAIError } from \"../../error.mjs\";\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nexport class LineDecoder {\n    constructor() {\n        _LineDecoder_carriageReturnIndex.set(this, void 0);\n        this.buffer = new Uint8Array();\n        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(this.buffer.length + binaryChunk.length);\n        newData.set(this.buffer);\n        newData.set(binaryChunk, this.buffer.length);\n        this.buffer = newData;\n        const lines = [];\n        let patternIndex;\n        while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"))) != null) {\n            if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, \"f\");\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") != null &&\n                (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") + 1 || patternIndex.carriage)) {\n                lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") - 1)));\n                this.buffer = this.buffer.slice(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"));\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n                continue;\n            }\n            const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = this.decodeText(this.buffer.slice(0, endIndex));\n            lines.push(line);\n            this.buffer = this.buffer.slice(patternIndex.index);\n            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n        }\n        return lines;\n    }\n    decodeText(bytes) {\n        if (bytes == null)\n            return '';\n        if (typeof bytes === 'string')\n            return bytes;\n        // Node:\n        if (typeof Buffer !== 'undefined') {\n            if (bytes instanceof Buffer) {\n                return bytes.toString();\n            }\n            if (bytes instanceof Uint8Array) {\n                return Buffer.from(bytes).toString();\n            }\n            throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n        }\n        // Browser\n        if (typeof TextDecoder !== 'undefined') {\n            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n                this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n                return this.textDecoder.decode(bytes);\n            }\n            throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n        }\n        throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n    }\n    flush() {\n        if (!this.buffer.length) {\n            return [];\n        }\n        return this.decode('\\n');\n    }\n}\n_LineDecoder_carriageReturnIndex = new WeakMap();\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = startIndex ?? 0; i < buffer.length; i++) {\n        if (buffer[i] === newline) {\n            return { preceding: i, index: i + 1, carriage: false };\n        }\n        if (buffer[i] === carriage) {\n            return { preceding: i, index: i + 1, carriage: true };\n        }\n    }\n    return null;\n}\nexport function findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 1; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=line.mjs.map","/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result?.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n//# sourceMappingURL=stream-utils.mjs.map","import { ReadableStream } from \"./_shims/index.mjs\";\nimport { OpenAIError } from \"./error.mjs\";\nimport { findDoubleNewlineIndex, LineDecoder } from \"./internal/decoders/line.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"./internal/stream-utils.mjs\";\nimport { createResponseHeaders } from \"./core.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    static fromSSEResponse(response, controller) {\n        let consumed = false;\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of _iterSSEMessages(response, controller)) {\n                    if (done)\n                        continue;\n                    if (sse.data.startsWith('[DONE]')) {\n                        done = true;\n                        continue;\n                    }\n                    if (sse.event === null ||\n                        sse.event.startsWith('response.') ||\n                        sse.event.startsWith('transcript.')) {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        if (data && data.error) {\n                            throw new APIError(undefined, data.error, undefined, createResponseHeaders(response.headers));\n                        }\n                        yield data;\n                    }\n                    else {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        // TODO: Is this where the error should be thrown?\n                        if (sse.event == 'error') {\n                            throw new APIError(undefined, data.error, data.message, undefined);\n                        }\n                        yield { event: sse.event, data: data };\n                    }\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new LineDecoder();\n            const iter = ReadableStreamToAsyncIterable(readableStream);\n            for await (const chunk of iter) {\n                for (const line of lineDecoder.decode(chunk)) {\n                    yield line;\n                }\n            }\n            for (const line of lineDecoder.flush()) {\n                yield line;\n            }\n        }\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()) {\n                    if (done)\n                        continue;\n                    if (line)\n                        yield JSON.parse(line);\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller),\n            new Stream(() => teeIterator(right), this.controller),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        const encoder = new TextEncoder();\n        return new ReadableStream({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                await iter.return?.();\n            },\n        });\n    }\n}\nexport async function* _iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        throw new OpenAIError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new LineDecoder();\n    const iter = ReadableStreamToAsyncIterable(response.body);\n    for await (const sseChunk of iterSSEChunks(iter)) {\n        for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield sse;\n        }\n    }\n    for (const line of lineDecoder.flush()) {\n        const sse = sseDecoder.decode(line);\n        if (sse)\n            yield sse;\n    }\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator) {\n        if (chunk == null) {\n            continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) {\n        yield data;\n    }\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n//# sourceMappingURL=streaming.mjs.map","import { FormData, File, getMultipartRequestOptions, isFsReadStream, } from \"./_shims/index.mjs\";\nexport { fileFromPath } from \"./_shims/index.mjs\";\nexport const isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\nexport const isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    isBlobLike(value);\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\nexport const isUploadable = (value) => {\n    return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(value, name, options) {\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if (isFileLike(value)) {\n        return value;\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n        // we need to convert the `Blob` into an array buffer because the `Blob` class\n        // that `node-fetch` defines is incompatible with the web standard which results\n        // in `new File` interpreting it as a string instead of binary data.\n        const data = isBlobLike(blob) ? [(await blob.arrayBuffer())] : [blob];\n        return new File(data, name, options);\n    }\n    const bits = await getBytes(value);\n    name || (name = getName(value) ?? 'unknown_file');\n    if (!options?.type) {\n        const type = bits[0]?.type;\n        if (typeof type === 'string') {\n            options = { ...options, type };\n        }\n    }\n    return new File(bits, name, options);\n}\nasync function getBytes(value) {\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if (isBlobLike(value)) {\n        parts.push(await value.arrayBuffer());\n    }\n    else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n    ) {\n        for await (const chunk of value) {\n            parts.push(chunk); // TODO, consider validating?\n        }\n    }\n    else {\n        throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n            ?.name}; props: ${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    const props = Object.getOwnPropertyNames(value);\n    return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\nfunction getName(value) {\n    return (getStringFromMaybeBuffer(value.name) ||\n        getStringFromMaybeBuffer(value.filename) ||\n        // For fs.ReadStream\n        getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop());\n}\nconst getStringFromMaybeBuffer = (x) => {\n    if (typeof x === 'string')\n        return x;\n    if (typeof Buffer !== 'undefined' && x instanceof Buffer)\n        return String(x);\n    return undefined;\n};\nconst isAsyncIterableIterator = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nexport const isMultipartBody = (body) => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async (opts) => {\n    if (!hasUploadableValue(opts.body))\n        return opts;\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const multipartFormRequestOptions = async (opts) => {\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const createForm = async (body) => {\n    const form = new FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n    return form;\n};\nconst hasUploadableValue = (value) => {\n    if (isUploadable(value))\n        return true;\n    if (Array.isArray(value))\n        return value.some(hasUploadableValue);\n    if (value && typeof value === 'object') {\n        for (const k in value) {\n            if (hasUploadableValue(value[k]))\n                return true;\n        }\n    }\n    return false;\n};\nconst addFormValue = async (form, key, value) => {\n    if (value === undefined)\n        return;\n    if (value == null) {\n        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    }\n    // TODO: make nested formats configurable\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        form.append(key, String(value));\n    }\n    else if (isUploadable(value)) {\n        const file = await toFile(value);\n        form.append(key, file);\n    }\n    else if (Array.isArray(value)) {\n        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n    }\n    else if (typeof value === 'object') {\n        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n    }\n    else {\n        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n    }\n};\n//# sourceMappingURL=uploads.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nimport { VERSION } from \"./version.mjs\";\nimport { Stream } from \"./streaming.mjs\";\nimport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, } from \"./error.mjs\";\nimport { kind as shimsKind, getDefaultAgent, fetch, init, } from \"./_shims/index.mjs\";\n// try running side effects outside of _shims/index to workaround https://github.com/vercel/next.js/issues/76881\ninit();\nimport { isBlobLike, isMultipartBody } from \"./uploads.mjs\";\nexport { maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm, } from \"./uploads.mjs\";\nasync function defaultParseResponse(props) {\n    const { response } = props;\n    if (props.options.stream) {\n        debug('response', response.status, response.url, response.headers, response.body);\n        // Note: there is an invariant here that isn't represented in the type system\n        // that if you set `stream: true` the response type must also be `Stream<T>`\n        if (props.options.__streamClass) {\n            return props.options.__streamClass.fromSSEResponse(response, props.controller);\n        }\n        return Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) {\n        return null;\n    }\n    if (props.options.__binaryResponse) {\n        return response;\n    }\n    const contentType = response.headers.get('content-type');\n    const mediaType = contentType?.split(';')[0]?.trim();\n    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n    if (isJSON) {\n        const json = await response.json();\n        debug('response', response.status, response.url, response.headers, json);\n        return _addRequestID(json, response);\n    }\n    const text = await response.text();\n    debug('response', response.status, response.url, response.headers, text);\n    // TODO handle blob, arraybuffer, other content types, etc.\n    return text;\n}\nfunction _addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('x-request-id'),\n        enumerable: false,\n    });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise extends Promise {\n    constructor(responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the X-Request-ID header which is useful for debugging requests and reporting\n     * issues to OpenAI.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('x-request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then(this.parseResponse);\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nexport class APIClient {\n    constructor({ baseURL, maxRetries = 2, timeout = 600000, // 10 minutes\n    httpAgent, fetch: overriddenFetch, }) {\n        this.baseURL = baseURL;\n        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n        this.timeout = validatePositiveInteger('timeout', timeout);\n        this.httpAgent = httpAgent;\n        this.fetch = overriddenFetch ?? fetch;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    /**\n     * Override this to add your own default headers, for example:\n     *\n     *  {\n     *    ...super.defaultHeaders(),\n     *    Authorization: 'Bearer 123',\n     *  }\n     */\n    defaultHeaders(opts) {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': this.getUserAgent(),\n            ...getPlatformHeaders(),\n            ...this.authHeaders(opts),\n        };\n    }\n    /**\n     * Override this to add your own headers validation:\n     */\n    validateHeaders(headers, customHeaders) { }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then(async (opts) => {\n            const body = opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n                : opts?.body instanceof DataView ? opts.body\n                    : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n                        : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n                            : opts?.body;\n            return { method, path, ...opts, body };\n        }));\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    calculateContentLength(body) {\n        if (typeof body === 'string') {\n            if (typeof Buffer !== 'undefined') {\n                return Buffer.byteLength(body, 'utf8').toString();\n            }\n            if (typeof TextEncoder !== 'undefined') {\n                const encoder = new TextEncoder();\n                const encoded = encoder.encode(body);\n                return encoded.length.toString();\n            }\n        }\n        else if (ArrayBuffer.isView(body)) {\n            return body.byteLength.toString();\n        }\n        return null;\n    }\n    buildRequest(inputOptions, { retryCount = 0 } = {}) {\n        const options = { ...inputOptions };\n        const { method, path, query, headers: headers = {} } = options;\n        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n            options.body\n            : isMultipartBody(options.body) ? options.body.body\n                : options.body ? JSON.stringify(options.body, null, 2)\n                    : null;\n        const contentLength = this.calculateContentLength(body);\n        const url = this.buildURL(path, query);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        options.timeout = options.timeout ?? this.timeout;\n        const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n        const minAgentTimeout = options.timeout + 1000;\n        if (typeof httpAgent?.options?.timeout === 'number' &&\n            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n            // Allow any given request to bump our agent active socket timeout.\n            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n            // and without mutating agent we would need to create more of them.\n            // This tradeoff optimizes for performance.\n            httpAgent.options.timeout = minAgentTimeout;\n        }\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!inputOptions.idempotencyKey)\n                inputOptions.idempotencyKey = this.defaultIdempotencyKey();\n            headers[this.idempotencyHeader] = inputOptions.idempotencyKey;\n        }\n        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n        const req = {\n            method,\n            ...(body && { body: body }),\n            headers: reqHeaders,\n            ...(httpAgent && { agent: httpAgent }),\n            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n            // not compatible with standard web types\n            signal: options.signal ?? null,\n        };\n        return { req, url, timeout: options.timeout };\n    }\n    buildHeaders({ options, headers, contentLength, retryCount, }) {\n        const reqHeaders = {};\n        if (contentLength) {\n            reqHeaders['content-length'] = contentLength;\n        }\n        const defaultHeaders = this.defaultHeaders(options);\n        applyHeadersMut(reqHeaders, defaultHeaders);\n        applyHeadersMut(reqHeaders, headers);\n        // let builtin fetch set the Content-Type for multipart bodies\n        if (isMultipartBody(options.body) && shimsKind !== 'node') {\n            delete reqHeaders['content-type'];\n        }\n        // Don't set theses headers if they were already set or removed through default headers or by the caller.\n        // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account\n        // for the removal case.\n        if (getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\n            getHeader(headers, 'x-stainless-retry-count') === undefined) {\n            reqHeaders['x-stainless-retry-count'] = String(retryCount);\n        }\n        if (getHeader(defaultHeaders, 'x-stainless-timeout') === undefined &&\n            getHeader(headers, 'x-stainless-timeout') === undefined &&\n            options.timeout) {\n            reqHeaders['x-stainless-timeout'] = String(Math.trunc(options.timeout / 1000));\n        }\n        this.validateHeaders(reqHeaders, headers);\n        return reqHeaders;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    parseHeaders(headers) {\n        return (!headers ? {}\n            : Symbol.iterator in headers ?\n                Object.fromEntries(Array.from(headers).map((header) => [...header]))\n                : { ...headers });\n    }\n    makeStatusError(status, error, message, headers) {\n        return APIError.generate(status, error, message, headers);\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this.makeRequest(options, remainingRetries));\n    }\n    async makeRequest(optionsInput, retriesRemaining) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n        await this.prepareRequest(req, { url, options });\n        debug('request', url, options, req.headers);\n        if (options.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        if (response instanceof Error) {\n            if (options.signal?.aborted) {\n                throw new APIUserAbortError();\n            }\n            if (retriesRemaining) {\n                return this.retryRequest(options, retriesRemaining);\n            }\n            if (response.name === 'AbortError') {\n                throw new APIConnectionTimeoutError();\n            }\n            throw new APIConnectionError({ cause: response });\n        }\n        const responseHeaders = createResponseHeaders(response.headers);\n        if (!response.ok) {\n            if (retriesRemaining && this.shouldRetry(response)) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n                return this.retryRequest(options, retriesRemaining, responseHeaders);\n            }\n            const errText = await response.text().catch((e) => castToError(e).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n            throw err;\n        }\n        return { response, options, controller };\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null);\n        return new PagePromise(this, request, Page);\n    }\n    buildURL(path, query) {\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        const fetchOptions = {\n            signal: controller.signal,\n            ...options,\n        };\n        if (fetchOptions.method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = fetchOptions.method.toUpperCase();\n        }\n        return (\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        this.fetch.call(undefined, url, fetchOptions).finally(() => {\n            clearTimeout(timeout);\n        }));\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.['retry-after'];\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n}\nexport class AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageInfo() != null;\n    }\n    async getNextPage() {\n        const nextInfo = this.nextPageInfo();\n        if (!nextInfo) {\n            throw new OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        const nextOptions = { ...this.options };\n        if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n            nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n        }\n        else if ('url' in nextInfo) {\n            const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n            for (const [key, value] of params) {\n                nextInfo.url.searchParams.set(key, value);\n            }\n            nextOptions.query = undefined;\n            nextOptions.path = nextInfo.url.toString();\n        }\n        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n    constructor(client, request, Page) {\n        super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexport const createResponseHeaders = (headers) => {\n    return new Proxy(Object.fromEntries(\n    // @ts-ignore\n    headers.entries()), {\n        get(target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        },\n    });\n};\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n    method: true,\n    path: true,\n    query: true,\n    body: true,\n    headers: true,\n    maxRetries: true,\n    stream: true,\n    timeout: true,\n    httpAgent: true,\n    signal: true,\n    idempotencyKey: true,\n    __metadata: true,\n    __binaryRequest: true,\n    __binaryResponse: true,\n    __streamClass: true,\n};\nexport const isRequestOptions = (obj) => {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        !isEmptyObj(obj) &&\n        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n};\nconst getPlatformProperties = () => {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    // Check if Node.js\n    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(process.platform),\n            'X-Stainless-Arch': normalizeArch(process.arch),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\nexport const safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nexport const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new OpenAIError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new OpenAIError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nexport const castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(err);\n};\nexport const ensurePresent = (value) => {\n    if (value == null)\n        throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n    return value;\n};\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env) => {\n    if (typeof process !== 'undefined') {\n        return process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof Deno !== 'undefined') {\n        return Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\nexport const coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nexport const maybeCoerceInteger = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceInteger(value);\n};\nexport const maybeCoerceFloat = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceBoolean(value);\n};\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders, newHeaders) {\n    for (const k in newHeaders) {\n        if (!hasOwn(newHeaders, k))\n            continue;\n        const lowerKey = k.toLowerCase();\n        if (!lowerKey)\n            continue;\n        const val = newHeaders[k];\n        if (val === null) {\n            delete targetHeaders[lowerKey];\n        }\n        else if (val !== undefined) {\n            targetHeaders[lowerKey] = val;\n        }\n    }\n}\nconst SENSITIVE_HEADERS = new Set(['authorization', 'api-key']);\nexport function debug(action, ...args) {\n    if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n        const modifiedArgs = args.map((arg) => {\n            if (!arg) {\n                return arg;\n            }\n            // Check for sensitive headers in request body 'headers' object\n            if (arg['headers']) {\n                // clone so we don't mutate\n                const modifiedArg = { ...arg, headers: { ...arg['headers'] } };\n                for (const header in arg['headers']) {\n                    if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                        modifiedArg['headers'][header] = 'REDACTED';\n                    }\n                }\n                return modifiedArg;\n            }\n            let modifiedArg = null;\n            // Check for sensitive headers in headers object\n            for (const header in arg) {\n                if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                    // avoid making a copy until we need to\n                    modifiedArg ?? (modifiedArg = { ...arg });\n                    modifiedArg[header] = 'REDACTED';\n                }\n            }\n            return modifiedArg ?? arg;\n        });\n        console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);\n    }\n}\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nexport const isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\nexport const isHeadersProtocol = (headers) => {\n    return typeof headers?.get === 'function';\n};\nexport const getRequiredHeader = (headers, header) => {\n    const foundHeader = getHeader(headers, header);\n    if (foundHeader === undefined) {\n        throw new Error(`Could not find ${header} header`);\n    }\n    return foundHeader;\n};\nexport const getHeader = (headers, header) => {\n    const lowerCasedHeader = header.toLowerCase();\n    if (isHeadersProtocol(headers)) {\n        // to deal with the case where the header looks like Stainless-Event-Id\n        const intercapsHeader = header[0]?.toUpperCase() +\n            header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n            const value = headers.get(key);\n            if (value) {\n                return value;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(headers)) {\n        if (key.toLowerCase() === lowerCasedHeader) {\n            if (Array.isArray(value)) {\n                if (value.length <= 1)\n                    return value[0];\n                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n                return value[0];\n            }\n            return value;\n        }\n    }\n    return undefined;\n};\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str) => {\n    if (!str)\n        return '';\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str).toString('base64');\n    }\n    if (typeof btoa !== 'undefined') {\n        return btoa(str);\n    }\n    throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\n/**\n * Converts a Base64 encoded string to a Float32Array.\n * @param base64Str - The Base64 encoded string.\n * @returns An Array of numbers interpreted as Float32 values.\n */\nexport const toFloat32Array = (base64Str) => {\n    if (typeof Buffer !== 'undefined') {\n        // for Node.js environment\n        const buf = Buffer.from(base64Str, 'base64');\n        return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));\n    }\n    else {\n        // for legacy web platform APIs\n        const binaryStr = atob(base64Str);\n        const len = binaryStr.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n            bytes[i] = binaryStr.charCodeAt(i);\n        }\n        return Array.from(new Float32Array(bytes.buffer));\n    }\n};\nexport function isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\n//# sourceMappingURL=core.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport class APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\n//# sourceMappingURL=resource.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Completions extends APIResource {\n    create(body, options) {\n        return this._client.post('/completions', { body, ...options, stream: body.stream ?? false });\n    }\n}\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { ChatCompletionStoreMessagesPage } from \"./completions.mjs\";\nexport class Messages extends APIResource {\n    list(completionId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(completionId, {}, query);\n        }\n        return this._client.getAPIList(`/chat/completions/${completionId}/messages`, ChatCompletionStoreMessagesPage, { query, ...options });\n    }\n}\nexport { ChatCompletionStoreMessagesPage };\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { AbstractPage } from \"./core.mjs\";\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class Page extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.object = body.object;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    /**\n     * This page represents a response that isn't actually paginated at the API level\n     * so there will never be any next page params.\n     */\n    nextPageParams() {\n        return null;\n    }\n    nextPageInfo() {\n        return null;\n    }\n}\nexport class CursorPage extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.has_more = body.has_more || false;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        if (this.has_more === false) {\n            return false;\n        }\n        return super.hasNextPage();\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    nextPageParams() {\n        const info = this.nextPageInfo();\n        if (!info)\n            return null;\n        if ('params' in info)\n            return info.params;\n        const params = Object.fromEntries(info.url.searchParams);\n        if (!Object.keys(params).length)\n            return null;\n        return params;\n    }\n    nextPageInfo() {\n        const data = this.getPaginatedItems();\n        if (!data.length) {\n            return null;\n        }\n        const id = data[data.length - 1]?.id;\n        if (!id) {\n            return null;\n        }\n        return { params: { after: id } };\n    }\n}\n//# sourceMappingURL=pagination.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as MessagesAPI from \"./messages.mjs\";\nimport { Messages } from \"./messages.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Completions extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n    create(body, options) {\n        return this._client.post('/chat/completions', { body, ...options, stream: body.stream ?? false });\n    }\n    /**\n     * Get a stored chat completion. Only Chat Completions that have been created with\n     * the `store` parameter set to `true` will be returned.\n     *\n     * @example\n     * ```ts\n     * const chatCompletion =\n     *   await client.chat.completions.retrieve('completion_id');\n     * ```\n     */\n    retrieve(completionId, options) {\n        return this._client.get(`/chat/completions/${completionId}`, options);\n    }\n    /**\n     * Modify a stored chat completion. Only Chat Completions that have been created\n     * with the `store` parameter set to `true` can be modified. Currently, the only\n     * supported modification is to update the `metadata` field.\n     *\n     * @example\n     * ```ts\n     * const chatCompletion = await client.chat.completions.update(\n     *   'completion_id',\n     *   { metadata: { foo: 'string' } },\n     * );\n     * ```\n     */\n    update(completionId, body, options) {\n        return this._client.post(`/chat/completions/${completionId}`, { body, ...options });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/chat/completions', ChatCompletionsPage, { query, ...options });\n    }\n    /**\n     * Delete a stored chat completion. Only Chat Completions that have been created\n     * with the `store` parameter set to `true` can be deleted.\n     *\n     * @example\n     * ```ts\n     * const chatCompletionDeleted =\n     *   await client.chat.completions.del('completion_id');\n     * ```\n     */\n    del(completionId, options) {\n        return this._client.delete(`/chat/completions/${completionId}`, options);\n    }\n}\nexport class ChatCompletionsPage extends CursorPage {\n}\nexport class ChatCompletionStoreMessagesPage extends CursorPage {\n}\nCompletions.ChatCompletionsPage = ChatCompletionsPage;\nCompletions.Messages = Messages;\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as CompletionsAPI from \"./completions/completions.mjs\";\nimport { ChatCompletionsPage, Completions, } from \"./completions/completions.mjs\";\nexport class Chat extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\nChat.Completions = Completions;\nChat.ChatCompletionsPage = ChatCompletionsPage;\n//# sourceMappingURL=chat.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport * as Core from \"../core.mjs\";\nexport class Embeddings extends APIResource {\n    /**\n     * Creates an embedding vector representing the input text.\n     *\n     * @example\n     * ```ts\n     * const createEmbeddingResponse =\n     *   await client.embeddings.create({\n     *     input: 'The quick brown fox jumped over the lazy dog',\n     *     model: 'text-embedding-3-small',\n     *   });\n     * ```\n     */\n    create(body, options) {\n        const hasUserProvidedEncodingFormat = !!body.encoding_format;\n        // No encoding_format specified, defaulting to base64 for performance reasons\n        // See https://github.com/openai/openai-node/pull/1312\n        let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : 'base64';\n        if (hasUserProvidedEncodingFormat) {\n            Core.debug('Request', 'User defined encoding_format:', body.encoding_format);\n        }\n        const response = this._client.post('/embeddings', {\n            body: {\n                ...body,\n                encoding_format: encoding_format,\n            },\n            ...options,\n        });\n        // if the user specified an encoding_format, return the response as-is\n        if (hasUserProvidedEncodingFormat) {\n            return response;\n        }\n        // in this stage, we are sure the user did not specify an encoding_format\n        // and we defaulted to base64 for performance reasons\n        // we are sure then that the response is base64 encoded, let's decode it\n        // the returned result will be a float32 array since this is OpenAI API's default encoding\n        Core.debug('response', 'Decoding base64 embeddings to float32 array');\n        return response._thenUnwrap((response) => {\n            if (response && response.data) {\n                response.data.forEach((embeddingBase64Obj) => {\n                    const embeddingBase64Str = embeddingBase64Obj.embedding;\n                    embeddingBase64Obj.embedding = Core.toFloat32Array(embeddingBase64Str);\n                });\n            }\n            return response;\n        });\n    }\n}\n//# sourceMappingURL=embeddings.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { isRequestOptions } from \"../core.mjs\";\nimport { sleep } from \"../core.mjs\";\nimport { APIConnectionTimeoutError } from \"../error.mjs\";\nimport * as Core from \"../core.mjs\";\nimport { CursorPage } from \"../pagination.mjs\";\nexport class Files extends APIResource {\n    /**\n     * Upload a file that can be used across various endpoints. Individual files can be\n     * up to 512 MB, and the size of all files uploaded by one organization can be up\n     * to 100 GB.\n     *\n     * The Assistants API supports files up to 2 million tokens and of specific file\n     * types. See the\n     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for\n     * details.\n     *\n     * The Fine-tuning API only supports `.jsonl` files. The input also has certain\n     * required formats for fine-tuning\n     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n     * models.\n     *\n     * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also\n     * has a specific required\n     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).\n     *\n     * Please [contact us](https://help.openai.com/) if you need to increase these\n     * storage limits.\n     */\n    create(body, options) {\n        return this._client.post('/files', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Returns information about a specific file.\n     */\n    retrieve(fileId, options) {\n        return this._client.get(`/files/${fileId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/files', FileObjectsPage, { query, ...options });\n    }\n    /**\n     * Delete a file.\n     */\n    del(fileId, options) {\n        return this._client.delete(`/files/${fileId}`, options);\n    }\n    /**\n     * Returns the contents of the specified file.\n     */\n    content(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, {\n            ...options,\n            headers: { Accept: 'application/binary', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n    /**\n     * Returns the contents of the specified file.\n     *\n     * @deprecated The `.content()` method should be used instead\n     */\n    retrieveContent(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, options);\n    }\n    /**\n     * Waits for the given file to be processed, default timeout is 30 mins.\n     */\n    async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {\n        const TERMINAL_STATES = new Set(['processed', 'error', 'deleted']);\n        const start = Date.now();\n        let file = await this.retrieve(id);\n        while (!file.status || !TERMINAL_STATES.has(file.status)) {\n            await sleep(pollInterval);\n            file = await this.retrieve(id);\n            if (Date.now() - start > maxWait) {\n                throw new APIConnectionTimeoutError({\n                    message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,\n                });\n            }\n        }\n        return file;\n    }\n}\nexport class FileObjectsPage extends CursorPage {\n}\nFiles.FileObjectsPage = FileObjectsPage;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport * as Core from \"../core.mjs\";\nexport class Images extends APIResource {\n    /**\n     * Creates a variation of a given image. This endpoint only supports `dall-e-2`.\n     *\n     * @example\n     * ```ts\n     * const imagesResponse = await client.images.createVariation({\n     *   image: fs.createReadStream('otter.png'),\n     * });\n     * ```\n     */\n    createVariation(body, options) {\n        return this._client.post('/images/variations', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an edited or extended image given one or more source images and a\n     * prompt. This endpoint only supports `gpt-image-1` and `dall-e-2`.\n     *\n     * @example\n     * ```ts\n     * const imagesResponse = await client.images.edit({\n     *   image: fs.createReadStream('path/to/file'),\n     *   prompt: 'A cute baby sea otter wearing a beret',\n     * });\n     * ```\n     */\n    edit(body, options) {\n        return this._client.post('/images/edits', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an image given a prompt.\n     * [Learn more](https://platform.openai.com/docs/guides/images).\n     *\n     * @example\n     * ```ts\n     * const imagesResponse = await client.images.generate({\n     *   prompt: 'A cute baby sea otter',\n     * });\n     * ```\n     */\n    generate(body, options) {\n        return this._client.post('/images/generations', { body, ...options });\n    }\n}\n//# sourceMappingURL=images.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nexport class Speech extends APIResource {\n    /**\n     * Generates audio from the input text.\n     *\n     * @example\n     * ```ts\n     * const speech = await client.audio.speech.create({\n     *   input: 'input',\n     *   model: 'string',\n     *   voice: 'ash',\n     * });\n     *\n     * const content = await speech.blob();\n     * console.log(content);\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/audio/speech', {\n            body,\n            ...options,\n            headers: { Accept: 'application/octet-stream', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n}\n//# sourceMappingURL=speech.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Transcriptions extends APIResource {\n    create(body, options) {\n        return this._client.post('/audio/transcriptions', Core.multipartFormRequestOptions({\n            body,\n            ...options,\n            stream: body.stream ?? false,\n            __metadata: { model: body.model },\n        }));\n    }\n}\n//# sourceMappingURL=transcriptions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Translations extends APIResource {\n    create(body, options) {\n        return this._client.post('/audio/translations', Core.multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }));\n    }\n}\n//# sourceMappingURL=translations.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as SpeechAPI from \"./speech.mjs\";\nimport { Speech } from \"./speech.mjs\";\nimport * as TranscriptionsAPI from \"./transcriptions.mjs\";\nimport { Transcriptions, } from \"./transcriptions.mjs\";\nimport * as TranslationsAPI from \"./translations.mjs\";\nimport { Translations, } from \"./translations.mjs\";\nexport class Audio extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\n        this.translations = new TranslationsAPI.Translations(this._client);\n        this.speech = new SpeechAPI.Speech(this._client);\n    }\n}\nAudio.Transcriptions = Transcriptions;\nAudio.Translations = Translations;\nAudio.Speech = Speech;\n//# sourceMappingURL=audio.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Moderations extends APIResource {\n    /**\n     * Classifies if text and/or image inputs are potentially harmful. Learn more in\n     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).\n     */\n    create(body, options) {\n        return this._client.post('/moderations', { body, ...options });\n    }\n}\n//# sourceMappingURL=moderations.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { Page } from \"../pagination.mjs\";\nexport class Models extends APIResource {\n    /**\n     * Retrieves a model instance, providing basic information about the model such as\n     * the owner and permissioning.\n     */\n    retrieve(model, options) {\n        return this._client.get(`/models/${model}`, options);\n    }\n    /**\n     * Lists the currently available models, and provides basic information about each\n     * one such as the owner and availability.\n     */\n    list(options) {\n        return this._client.getAPIList('/models', ModelsPage, options);\n    }\n    /**\n     * Delete a fine-tuned model. You must have the Owner role in your organization to\n     * delete a model.\n     */\n    del(model, options) {\n        return this._client.delete(`/models/${model}`, options);\n    }\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class ModelsPage extends Page {\n}\nModels.ModelsPage = ModelsPage;\n//# sourceMappingURL=models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nexport class Methods extends APIResource {\n}\n//# sourceMappingURL=methods.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class Graders extends APIResource {\n    /**\n     * Run a grader.\n     *\n     * @example\n     * ```ts\n     * const response = await client.fineTuning.alpha.graders.run({\n     *   grader: {\n     *     input: 'input',\n     *     name: 'name',\n     *     operation: 'eq',\n     *     reference: 'reference',\n     *     type: 'string_check',\n     *   },\n     *   model_sample: 'model_sample',\n     *   reference_answer: 'string',\n     * });\n     * ```\n     */\n    run(body, options) {\n        return this._client.post('/fine_tuning/alpha/graders/run', { body, ...options });\n    }\n    /**\n     * Validate a grader.\n     *\n     * @example\n     * ```ts\n     * const response =\n     *   await client.fineTuning.alpha.graders.validate({\n     *     grader: {\n     *       input: 'input',\n     *       name: 'name',\n     *       operation: 'eq',\n     *       reference: 'reference',\n     *       type: 'string_check',\n     *     },\n     *   });\n     * ```\n     */\n    validate(body, options) {\n        return this._client.post('/fine_tuning/alpha/graders/validate', { body, ...options });\n    }\n}\n//# sourceMappingURL=graders.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as GradersAPI from \"./graders.mjs\";\nimport { Graders, } from \"./graders.mjs\";\nexport class Alpha extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.graders = new GradersAPI.Graders(this._client);\n    }\n}\nAlpha.Graders = Graders;\n//# sourceMappingURL=alpha.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { Page } from \"../../../pagination.mjs\";\nexport class Permissions extends APIResource {\n    /**\n     * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).\n     *\n     * This enables organization owners to share fine-tuned models with other projects\n     * in their organization.\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(\n     *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',\n     *   { project_ids: ['string'] },\n     * )) {\n     *   // ...\n     * }\n     * ```\n     */\n    create(fineTunedModelCheckpoint, body, options) {\n        return this._client.getAPIList(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, PermissionCreateResponsesPage, { body, method: 'post', ...options });\n    }\n    retrieve(fineTunedModelCheckpoint, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.retrieve(fineTunedModelCheckpoint, {}, query);\n        }\n        return this._client.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {\n            query,\n            ...options,\n        });\n    }\n    /**\n     * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).\n     *\n     * Organization owners can use this endpoint to delete a permission for a\n     * fine-tuned model checkpoint.\n     *\n     * @example\n     * ```ts\n     * const permission =\n     *   await client.fineTuning.checkpoints.permissions.del(\n     *     'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',\n     *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',\n     *   );\n     * ```\n     */\n    del(fineTunedModelCheckpoint, permissionId, options) {\n        return this._client.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions/${permissionId}`, options);\n    }\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class PermissionCreateResponsesPage extends Page {\n}\nPermissions.PermissionCreateResponsesPage = PermissionCreateResponsesPage;\n//# sourceMappingURL=permissions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as PermissionsAPI from \"./permissions.mjs\";\nimport { PermissionCreateResponsesPage, Permissions, } from \"./permissions.mjs\";\nexport class Checkpoints extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.permissions = new PermissionsAPI.Permissions(this._client);\n    }\n}\nCheckpoints.Permissions = Permissions;\nCheckpoints.PermissionCreateResponsesPage = PermissionCreateResponsesPage;\n//# sourceMappingURL=checkpoints.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Checkpoints extends APIResource {\n    list(fineTuningJobId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });\n    }\n}\nexport class FineTuningJobCheckpointsPage extends CursorPage {\n}\nCheckpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n//# sourceMappingURL=checkpoints.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as CheckpointsAPI from \"./checkpoints.mjs\";\nimport { Checkpoints, FineTuningJobCheckpointsPage, } from \"./checkpoints.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Jobs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n    }\n    /**\n     * Creates a fine-tuning job which begins the process of creating a new model from\n     * a given dataset.\n     *\n     * Response includes details of the enqueued job including job status and the name\n     * of the fine-tuned models once complete.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.create({\n     *   model: 'gpt-4o-mini',\n     *   training_file: 'file-abc123',\n     * });\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/fine_tuning/jobs', { body, ...options });\n    }\n    /**\n     * Get info about a fine-tuning job.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.retrieve(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    retrieve(fineTuningJobId, options) {\n        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/fine_tuning/jobs', FineTuningJobsPage, { query, ...options });\n    }\n    /**\n     * Immediately cancel a fine-tune job.\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.cancel(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    cancel(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);\n    }\n    listEvents(fineTuningJobId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.listEvents(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {\n            query,\n            ...options,\n        });\n    }\n    /**\n     * Pause a fine-tune job.\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.pause(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    pause(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/pause`, options);\n    }\n    /**\n     * Resume a fine-tune job.\n     *\n     * @example\n     * ```ts\n     * const fineTuningJob = await client.fineTuning.jobs.resume(\n     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',\n     * );\n     * ```\n     */\n    resume(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/resume`, options);\n    }\n}\nexport class FineTuningJobsPage extends CursorPage {\n}\nexport class FineTuningJobEventsPage extends CursorPage {\n}\nJobs.FineTuningJobsPage = FineTuningJobsPage;\nJobs.FineTuningJobEventsPage = FineTuningJobEventsPage;\nJobs.Checkpoints = Checkpoints;\nJobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n//# sourceMappingURL=jobs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as MethodsAPI from \"./methods.mjs\";\nimport { Methods, } from \"./methods.mjs\";\nimport * as AlphaAPI from \"./alpha/alpha.mjs\";\nimport { Alpha } from \"./alpha/alpha.mjs\";\nimport * as CheckpointsAPI from \"./checkpoints/checkpoints.mjs\";\nimport { Checkpoints } from \"./checkpoints/checkpoints.mjs\";\nimport * as JobsAPI from \"./jobs/jobs.mjs\";\nimport { FineTuningJobEventsPage, FineTuningJobsPage, Jobs, } from \"./jobs/jobs.mjs\";\nexport class FineTuning extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.methods = new MethodsAPI.Methods(this._client);\n        this.jobs = new JobsAPI.Jobs(this._client);\n        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n        this.alpha = new AlphaAPI.Alpha(this._client);\n    }\n}\nFineTuning.Methods = Methods;\nFineTuning.Jobs = Jobs;\nFineTuning.FineTuningJobsPage = FineTuningJobsPage;\nFineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;\nFineTuning.Checkpoints = Checkpoints;\nFineTuning.Alpha = Alpha;\n//# sourceMappingURL=fine-tuning.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nexport class GraderModels extends APIResource {\n}\n//# sourceMappingURL=grader-models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as GraderModelsAPI from \"./grader-models.mjs\";\nimport { GraderModels, } from \"./grader-models.mjs\";\nexport class Graders extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.graderModels = new GraderModelsAPI.GraderModels(this._client);\n    }\n}\nGraders.GraderModels = GraderModels;\n//# sourceMappingURL=graders.mjs.map","/**\n * Like `Promise.allSettled()` but throws an error if any promises are rejected.\n */\nexport const allSettledWithThrow = async (promises) => {\n    const results = await Promise.allSettled(promises);\n    const rejected = results.filter((result) => result.status === 'rejected');\n    if (rejected.length) {\n        for (const result of rejected) {\n            console.error(result.reason);\n        }\n        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);\n    }\n    // Note: TS was complaining about using `.filter().map()` here for some reason\n    const values = [];\n    for (const result of results) {\n        if (result.status === 'fulfilled') {\n            values.push(result.value);\n        }\n    }\n    return values;\n};\n//# sourceMappingURL=Util.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { sleep, isRequestOptions } from \"../../core.mjs\";\nimport { CursorPage, Page } from \"../../pagination.mjs\";\nexport class Files extends APIResource {\n    /**\n     * Create a vector store file by attaching a\n     * [File](https://platform.openai.com/docs/api-reference/files) to a\n     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file.\n     */\n    retrieve(vectorStoreId, fileId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Update attributes on a vector store file.\n     */\n    update(vectorStoreId, fileId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(vectorStoreId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(vectorStoreId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store file. This will remove the file from the vector store but\n     * the file itself will not be deleted. To delete the file, use the\n     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\n     * endpoint.\n     */\n    del(vectorStoreId, fileId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Attach a file to the given vector store and wait for it to be processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const file = await this.create(vectorStoreId, body, options);\n        return await this.poll(vectorStoreId, file.id, options);\n    }\n    /**\n     * Wait for the vector store file to finish processing.\n     *\n     * Note: this will return even if the file failed to process, you need to check\n     * file.last_error and file.status to handle these cases\n     */\n    async poll(vectorStoreId, fileId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const fileResponse = await this.retrieve(vectorStoreId, fileId, {\n                ...options,\n                headers,\n            }).withResponse();\n            const file = fileResponse.data;\n            switch (file.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                case 'failed':\n                case 'completed':\n                    return file;\n            }\n        }\n    }\n    /**\n     * Upload a file to the `files` API and then attach it to the given vector store.\n     *\n     * Note the file will be asynchronously processed (you can use the alternative\n     * polling helper method to wait for processing to complete).\n     */\n    async upload(vectorStoreId, file, options) {\n        const fileInfo = await this._client.files.create({ file: file, purpose: 'assistants' }, options);\n        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);\n    }\n    /**\n     * Add a file to a vector store and poll until processing is complete.\n     */\n    async uploadAndPoll(vectorStoreId, file, options) {\n        const fileInfo = await this.upload(vectorStoreId, file, options);\n        return await this.poll(vectorStoreId, fileInfo.id, options);\n    }\n    /**\n     * Retrieve the parsed contents of a vector store file.\n     */\n    content(vectorStoreId, fileId, options) {\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, { ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n    }\n}\nexport class VectorStoreFilesPage extends CursorPage {\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class FileContentResponsesPage extends Page {\n}\nFiles.VectorStoreFilesPage = VectorStoreFilesPage;\nFiles.FileContentResponsesPage = FileContentResponsesPage;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { sleep } from \"../../core.mjs\";\nimport { allSettledWithThrow } from \"../../lib/Util.mjs\";\nimport { VectorStoreFilesPage } from \"./files.mjs\";\nexport class FileBatches extends APIResource {\n    /**\n     * Create a vector store file batch.\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file batch.\n     */\n    retrieve(vectorStoreId, batchId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancel a vector store file batch. This attempts to cancel the processing of\n     * files in this batch as soon as possible.\n     */\n    cancel(vectorStoreId, batchId, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Create a vector store batch and poll until all files have been processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const batch = await this.create(vectorStoreId, body);\n        return await this.poll(vectorStoreId, batch.id, options);\n    }\n    listFiles(vectorStoreId, batchId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.listFiles(vectorStoreId, batchId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n    }\n    /**\n     * Wait for the given file batch to be processed.\n     *\n     * Note: this will return even if one of the files failed to process, you need to\n     * check batch.file_counts.failed_count to handle this case.\n     */\n    async poll(vectorStoreId, batchId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {\n                ...options,\n                headers,\n            }).withResponse();\n            switch (batch.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                case 'failed':\n                case 'cancelled':\n                case 'completed':\n                    return batch;\n            }\n        }\n    }\n    /**\n     * Uploads the given files concurrently and then creates a vector store file batch.\n     *\n     * The concurrency limit is configurable using the `maxConcurrency` parameter.\n     */\n    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {\n        if (files == null || files.length == 0) {\n            throw new Error(`No \\`files\\` provided to process. If you've already uploaded files you should use \\`.createAndPoll()\\` instead`);\n        }\n        const configuredConcurrency = options?.maxConcurrency ?? 5;\n        // We cap the number of workers at the number of files (so we don't start any unnecessary workers)\n        const concurrencyLimit = Math.min(configuredConcurrency, files.length);\n        const client = this._client;\n        const fileIterator = files.values();\n        const allFileIds = [...fileIds];\n        // This code is based on this design. The libraries don't accommodate our environment limits.\n        // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all\n        async function processFiles(iterator) {\n            for (let item of iterator) {\n                const fileObj = await client.files.create({ file: item, purpose: 'assistants' }, options);\n                allFileIds.push(fileObj.id);\n            }\n        }\n        // Start workers to process results\n        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);\n        // Wait for all processing to complete.\n        await allSettledWithThrow(workers);\n        return await this.createAndPoll(vectorStoreId, {\n            file_ids: allFileIds,\n        });\n    }\n}\nexport { VectorStoreFilesPage };\n//# sourceMappingURL=file-batches.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport * as FileBatchesAPI from \"./file-batches.mjs\";\nimport { FileBatches, } from \"./file-batches.mjs\";\nimport * as FilesAPI from \"./files.mjs\";\nimport { FileContentResponsesPage, Files, VectorStoreFilesPage, } from \"./files.mjs\";\nimport { CursorPage, Page } from \"../../pagination.mjs\";\nexport class VectorStores extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.files = new FilesAPI.Files(this._client);\n        this.fileBatches = new FileBatchesAPI.FileBatches(this._client);\n    }\n    /**\n     * Create a vector store.\n     */\n    create(body, options) {\n        return this._client.post('/vector_stores', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store.\n     */\n    retrieve(vectorStoreId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a vector store.\n     */\n    update(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/vector_stores', VectorStoresPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store.\n     */\n    del(vectorStoreId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Search a vector store for relevant chunks based on a query and file attributes\n     * filter.\n     */\n    search(vectorStoreId, body, options) {\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {\n            body,\n            method: 'post',\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class VectorStoresPage extends CursorPage {\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class VectorStoreSearchResponsesPage extends Page {\n}\nVectorStores.VectorStoresPage = VectorStoresPage;\nVectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;\nVectorStores.Files = Files;\nVectorStores.VectorStoreFilesPage = VectorStoreFilesPage;\nVectorStores.FileContentResponsesPage = FileContentResponsesPage;\nVectorStores.FileBatches = FileBatches;\n//# sourceMappingURL=vector-stores.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nimport { AssistantStream } from \"../../lib/AssistantStream.mjs\";\nexport class Assistants extends APIResource {\n    /**\n     * Create an assistant with a model and instructions.\n     *\n     * @example\n     * ```ts\n     * const assistant = await client.beta.assistants.create({\n     *   model: 'gpt-4o',\n     * });\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/assistants', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves an assistant.\n     *\n     * @example\n     * ```ts\n     * const assistant = await client.beta.assistants.retrieve(\n     *   'assistant_id',\n     * );\n     * ```\n     */\n    retrieve(assistantId, options) {\n        return this._client.get(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies an assistant.\n     *\n     * @example\n     * ```ts\n     * const assistant = await client.beta.assistants.update(\n     *   'assistant_id',\n     * );\n     * ```\n     */\n    update(assistantId, body, options) {\n        return this._client.post(`/assistants/${assistantId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/assistants', AssistantsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @example\n     * ```ts\n     * const assistantDeleted = await client.beta.assistants.del(\n     *   'assistant_id',\n     * );\n     * ```\n     */\n    del(assistantId, options) {\n        return this._client.delete(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class AssistantsPage extends CursorPage {\n}\nAssistants.AssistantsPage = AssistantsPage;\n//# sourceMappingURL=assistants.mjs.map","export function isRunnableFunctionWithParse(fn) {\n    return typeof fn.parse === 'function';\n}\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n *\n * @deprecated - please use ParsingToolFunction instead.\n */\nexport class ParsingFunction {\n    constructor(input) {\n        this.function = input.function;\n        this.parse = input.parse;\n        this.parameters = input.parameters;\n        this.description = input.description;\n        this.name = input.name;\n    }\n}\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n */\nexport class ParsingToolFunction {\n    constructor(input) {\n        this.type = 'function';\n        this.function = input;\n    }\n}\n//# sourceMappingURL=RunnableFunction.mjs.map","export const isAssistantMessage = (message) => {\n    return message?.role === 'assistant';\n};\nexport const isFunctionMessage = (message) => {\n    return message?.role === 'function';\n};\nexport const isToolMessage = (message) => {\n    return message?.role === 'tool';\n};\nexport function isPresent(obj) {\n    return obj != null;\n}\n//# sourceMappingURL=chatCompletionUtils.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nexport class EventStream {\n    constructor() {\n        _EventStream_instances.add(this);\n        this.controller = new AbortController();\n        _EventStream_connectedPromise.set(this, void 0);\n        _EventStream_resolveConnectedPromise.set(this, () => { });\n        _EventStream_rejectConnectedPromise.set(this, () => { });\n        _EventStream_endPromise.set(this, void 0);\n        _EventStream_resolveEndPromise.set(this, () => { });\n        _EventStream_rejectEndPromise.set(this, () => { });\n        _EventStream_listeners.set(this, {});\n        _EventStream_ended.set(this, false);\n        _EventStream_errored.set(this, false);\n        _EventStream_aborted.set(this, false);\n        _EventStream_catchingPromiseCreated.set(this, false);\n        __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _EventStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _EventStream_endPromise, \"f\").catch(() => { });\n    }\n    _run(executor) {\n        // Unfortunately if we call `executor()` immediately we get runtime errors about\n        // references to `this` before the `super()` constructor call returns.\n        setTimeout(() => {\n            executor().then(() => {\n                this._emitFinal();\n                this._emit('end');\n            }, __classPrivateFieldGet(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n        }, 0);\n    }\n    _connected() {\n        if (this.ended)\n            return;\n        __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _EventStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _EventStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _EventStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _EventStream_endPromise, \"f\");\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any events after end\n        if (__classPrivateFieldGet(this, _EventStream_ended, \"f\")) {\n            return;\n        }\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _EventStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _EventStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.finalChatCompletion()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() { }\n}\n_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n    __classPrivateFieldSet(this, _EventStream_errored, true, \"f\");\n    if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _EventStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n    }\n    if (error instanceof OpenAIError) {\n        return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n        const openAIError = new OpenAIError(error.message);\n        // @ts-ignore\n        openAIError.cause = error;\n        return this._emit('error', openAIError);\n    }\n    return this._emit('error', new OpenAIError(String(error)));\n};\n//# sourceMappingURL=EventStream.mjs.map","import { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from \"../error.mjs\";\nexport function makeParseableResponseFormat(response_format, parser) {\n    const obj = { ...response_format };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-response-format',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function makeParseableTextFormat(response_format, parser) {\n    const obj = { ...response_format };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-response-format',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableResponseFormat(response_format) {\n    return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\nexport function makeParseableTool(tool, { parser, callback, }) {\n    const obj = { ...tool };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-tool',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n        $callback: {\n            value: callback,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableTool(tool) {\n    return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexport function maybeParseChatCompletion(completion, params) {\n    if (!params || !hasAutoParseableInput(params)) {\n        return {\n            ...completion,\n            choices: completion.choices.map((choice) => ({\n                ...choice,\n                message: {\n                    ...choice.message,\n                    parsed: null,\n                    ...(choice.message.tool_calls ?\n                        {\n                            tool_calls: choice.message.tool_calls,\n                        }\n                        : undefined),\n                },\n            })),\n        };\n    }\n    return parseChatCompletion(completion, params);\n}\nexport function parseChatCompletion(completion, params) {\n    const choices = completion.choices.map((choice) => {\n        if (choice.finish_reason === 'length') {\n            throw new LengthFinishReasonError();\n        }\n        if (choice.finish_reason === 'content_filter') {\n            throw new ContentFilterFinishReasonError();\n        }\n        return {\n            ...choice,\n            message: {\n                ...choice.message,\n                ...(choice.message.tool_calls ?\n                    {\n                        tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? undefined,\n                    }\n                    : undefined),\n                parsed: choice.message.content && !choice.message.refusal ?\n                    parseResponseFormat(params, choice.message.content)\n                    : null,\n            },\n        };\n    });\n    return { ...completion, choices };\n}\nfunction parseResponseFormat(params, content) {\n    if (params.response_format?.type !== 'json_schema') {\n        return null;\n    }\n    if (params.response_format?.type === 'json_schema') {\n        if ('$parseRaw' in params.response_format) {\n            const response_format = params.response_format;\n            return response_format.$parseRaw(content);\n        }\n        return JSON.parse(content);\n    }\n    return null;\n}\nfunction parseToolCall(params, toolCall) {\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return {\n        ...toolCall,\n        function: {\n            ...toolCall.function,\n            parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\n                : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\n                    : null,\n        },\n    };\n}\nexport function shouldParseToolCall(params, toolCall) {\n    if (!params) {\n        return false;\n    }\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\nexport function hasAutoParseableInput(params) {\n    if (isAutoParsableResponseFormat(params.response_format)) {\n        return true;\n    }\n    return (params.tools?.some((t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true)) ?? false);\n}\nexport function validateInputTools(tools) {\n    for (const tool of tools ?? []) {\n        if (tool.type !== 'function') {\n            throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        }\n        if (tool.function.strict !== true) {\n            throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n        }\n    }\n}\n//# sourceMappingURL=parser.mjs.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\nimport { OpenAIError } from \"../error.mjs\";\nimport { isRunnableFunctionWithParse, } from \"./RunnableFunction.mjs\";\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from \"./chatCompletionUtils.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nimport { isAutoParsableTool, parseChatCompletion } from \"../lib/parser.mjs\";\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport class AbstractChatCompletionRunner extends EventStream {\n    constructor() {\n        super(...arguments);\n        _AbstractChatCompletionRunner_instances.add(this);\n        this._chatCompletions = [];\n        this.messages = [];\n    }\n    _addChatCompletion(chatCompletion) {\n        this._chatCompletions.push(chatCompletion);\n        this._emit('chatCompletion', chatCompletion);\n        const message = chatCompletion.choices[0]?.message;\n        if (message)\n            this._addMessage(message);\n        return chatCompletion;\n    }\n    _addMessage(message, emit = true) {\n        if (!('content' in message))\n            message.content = null;\n        this.messages.push(message);\n        if (emit) {\n            this._emit('message', message);\n            if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n                // Note, this assumes that {role: 'tool', content: } is always the result of a call of tool of type=function.\n                this._emit('functionCallResult', message.content);\n            }\n            else if (isAssistantMessage(message) && message.function_call) {\n                this._emit('functionCall', message.function_call);\n            }\n            else if (isAssistantMessage(message) && message.tool_calls) {\n                for (const tool_call of message.tool_calls) {\n                    if (tool_call.type === 'function') {\n                        this._emit('functionCall', tool_call.function);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @returns a promise that resolves with the final ChatCompletion, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n     */\n    async finalChatCompletion() {\n        await this.done();\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (!completion)\n            throw new OpenAIError('stream ended without producing a ChatCompletion');\n        return completion;\n    }\n    /**\n     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalContent() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalFunctionCall() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n    }\n    async finalFunctionCallResult() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n    }\n    async totalUsage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n    }\n    allChatCompletions() {\n        return [...this._chatCompletions];\n    }\n    _emitFinal() {\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (completion)\n            this._emit('finalChatCompletion', completion);\n        const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n        if (finalMessage)\n            this._emit('finalMessage', finalMessage);\n        const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n        if (finalContent)\n            this._emit('finalContent', finalContent);\n        const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n        if (finalFunctionCall)\n            this._emit('finalFunctionCall', finalFunctionCall);\n        const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n        if (finalFunctionCallResult != null)\n            this._emit('finalFunctionCallResult', finalFunctionCallResult);\n        if (this._chatCompletions.some((c) => c.usage)) {\n            this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n        }\n    }\n    async _createChatCompletion(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n        const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });\n        this._connected();\n        return this._addChatCompletion(parseChatCompletion(chatCompletion, params));\n    }\n    async _runChatCompletion(client, params, options) {\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        return await this._createChatCompletion(client, params, options);\n    }\n    async _runFunctions(client, params, options) {\n        const role = 'function';\n        const { function_call = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        const functionsByName = {};\n        for (const f of params.functions) {\n            functionsByName[f.name || f.function.name] = f;\n        }\n        const functions = params.functions.map((f) => ({\n            name: f.name || f.function.name,\n            parameters: f.parameters,\n            description: f.description,\n        }));\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                function_call,\n                functions,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.function_call)\n                return;\n            const { name, arguments: args } = message.function_call;\n            const fn = functionsByName[name];\n            if (!fn) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n                    .map((f) => JSON.stringify(f.name))\n                    .join(', ')}. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            let parsed;\n            try {\n                parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n            }\n            catch (error) {\n                this._addMessage({\n                    role,\n                    name,\n                    content: error instanceof Error ? error.message : String(error),\n                });\n                continue;\n            }\n            // @ts-expect-error it can't rule out `never` type.\n            const rawContent = await fn.function(parsed, this);\n            const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n            this._addMessage({ role, name, content });\n            if (singleFunctionToCall)\n                return;\n        }\n    }\n    async _runTools(client, params, options) {\n        const role = 'tool';\n        const { tool_choice = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        // TODO(someday): clean this logic up\n        const inputTools = params.tools.map((tool) => {\n            if (isAutoParsableTool(tool)) {\n                if (!tool.$callback) {\n                    throw new OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n                }\n                return {\n                    type: 'function',\n                    function: {\n                        function: tool.$callback,\n                        name: tool.function.name,\n                        description: tool.function.description || '',\n                        parameters: tool.function.parameters,\n                        parse: tool.$parseRaw,\n                        strict: true,\n                    },\n                };\n            }\n            return tool;\n        });\n        const functionsByName = {};\n        for (const f of inputTools) {\n            if (f.type === 'function') {\n                functionsByName[f.function.name || f.function.function.name] = f.function;\n            }\n        }\n        const tools = 'tools' in params ?\n            inputTools.map((t) => t.type === 'function' ?\n                {\n                    type: 'function',\n                    function: {\n                        name: t.function.name || t.function.function.name,\n                        parameters: t.function.parameters,\n                        description: t.function.description,\n                        strict: t.function.strict,\n                    },\n                }\n                : t)\n            : undefined;\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                tool_choice,\n                tools,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.tool_calls?.length) {\n                return;\n            }\n            for (const tool_call of message.tool_calls) {\n                if (tool_call.type !== 'function')\n                    continue;\n                const tool_call_id = tool_call.id;\n                const { name, arguments: args } = tool_call.function;\n                const fn = functionsByName[name];\n                if (!fn) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName)\n                        .map((name) => JSON.stringify(name))\n                        .join(', ')}. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                let parsed;\n                try {\n                    parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n                }\n                catch (error) {\n                    const content = error instanceof Error ? error.message : String(error);\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                // @ts-expect-error it can't rule out `never` type.\n                const rawContent = await fn.function(parsed, this);\n                const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n                this._addMessage({ role, tool_call_id, content });\n                if (singleFunctionToCall) {\n                    return;\n                }\n            }\n        }\n        return;\n    }\n}\n_AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n    let i = this.messages.length;\n    while (i-- > 0) {\n        const message = this.messages[i];\n        if (isAssistantMessage(message)) {\n            const { function_call, ...rest } = message;\n            // TODO: support audio here\n            const ret = {\n                ...rest,\n                content: message.content ?? null,\n                refusal: message.refusal ?? null,\n            };\n            if (function_call) {\n                ret.function_call = function_call;\n            }\n            return ret;\n        }\n    }\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if (isAssistantMessage(message) && message?.function_call) {\n            return message.function_call;\n        }\n        if (isAssistantMessage(message) && message?.tool_calls?.length) {\n            return message.tool_calls.at(-1)?.function;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if (isFunctionMessage(message) && message.content != null) {\n            return message.content;\n        }\n        if (isToolMessage(message) &&\n            message.content != null &&\n            typeof message.content === 'string' &&\n            this.messages.some((x) => x.role === 'assistant' &&\n                x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id))) {\n            return message.content;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n    const total = {\n        completion_tokens: 0,\n        prompt_tokens: 0,\n        total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n        if (usage) {\n            total.completion_tokens += usage.completion_tokens;\n            total.prompt_tokens += usage.prompt_tokens;\n            total.total_tokens += usage.total_tokens;\n        }\n    }\n    return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n    if (params.n != null && params.n > 1) {\n        throw new OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n    }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n    return (typeof rawContent === 'string' ? rawContent\n        : rawContent === undefined ? 'undefined'\n            : JSON.stringify(rawContent));\n};\n//# sourceMappingURL=AbstractChatCompletionRunner.mjs.map","import { AbstractChatCompletionRunner, } from \"./AbstractChatCompletionRunner.mjs\";\nimport { isAssistantMessage } from \"./chatCompletionUtils.mjs\";\nexport class ChatCompletionRunner extends AbstractChatCompletionRunner {\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n    _addMessage(message, emit = true) {\n        super._addMessage(message, emit);\n        if (isAssistantMessage(message) && message.content) {\n            this._emit('content', message.content);\n        }\n    }\n}\n//# sourceMappingURL=ChatCompletionRunner.mjs.map","const STR = 0b000000001;\nconst NUM = 0b000000010;\nconst ARR = 0b000000100;\nconst OBJ = 0b000001000;\nconst NULL = 0b000010000;\nconst BOOL = 0b000100000;\nconst NAN = 0b001000000;\nconst INFINITY = 0b010000000;\nconst MINUS_INFINITY = 0b100000000;\nconst INF = INFINITY | MINUS_INFINITY;\nconst SPECIAL = NULL | BOOL | INF | NAN;\nconst ATOM = STR | NUM | SPECIAL;\nconst COLLECTION = ARR | OBJ;\nconst ALL = ATOM | COLLECTION;\nconst Allow = {\n    STR,\n    NUM,\n    ARR,\n    OBJ,\n    NULL,\n    BOOL,\n    NAN,\n    INFINITY,\n    MINUS_INFINITY,\n    INF,\n    SPECIAL,\n    ATOM,\n    COLLECTION,\n    ALL,\n};\n// The JSON string segment was unable to be parsed completely\nclass PartialJSON extends Error {\n}\nclass MalformedJSON extends Error {\n}\n/**\n * Parse incomplete JSON\n * @param {string} jsonString Partial JSON to be parsed\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n * @returns The parsed JSON\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n * @throws {MalformedJSON} If the JSON is malformed\n */\nfunction parseJSON(jsonString, allowPartial = Allow.ALL) {\n    if (typeof jsonString !== 'string') {\n        throw new TypeError(`expecting str, got ${typeof jsonString}`);\n    }\n    if (!jsonString.trim()) {\n        throw new Error(`${jsonString} is empty`);\n    }\n    return _parseJSON(jsonString.trim(), allowPartial);\n}\nconst _parseJSON = (jsonString, allow) => {\n    const length = jsonString.length;\n    let index = 0;\n    const markPartialJSON = (msg) => {\n        throw new PartialJSON(`${msg} at position ${index}`);\n    };\n    const throwMalformedError = (msg) => {\n        throw new MalformedJSON(`${msg} at position ${index}`);\n    };\n    const parseAny = () => {\n        skipBlank();\n        if (index >= length)\n            markPartialJSON('Unexpected end of input');\n        if (jsonString[index] === '\"')\n            return parseStr();\n        if (jsonString[index] === '{')\n            return parseObj();\n        if (jsonString[index] === '[')\n            return parseArr();\n        if (jsonString.substring(index, index + 4) === 'null' ||\n            (Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return null;\n        }\n        if (jsonString.substring(index, index + 4) === 'true' ||\n            (Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return true;\n        }\n        if (jsonString.substring(index, index + 5) === 'false' ||\n            (Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index)))) {\n            index += 5;\n            return false;\n        }\n        if (jsonString.substring(index, index + 8) === 'Infinity' ||\n            (Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 8;\n            return Infinity;\n        }\n        if (jsonString.substring(index, index + 9) === '-Infinity' ||\n            (Allow.MINUS_INFINITY & allow &&\n                1 < length - index &&\n                length - index < 9 &&\n                '-Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 9;\n            return -Infinity;\n        }\n        if (jsonString.substring(index, index + 3) === 'NaN' ||\n            (Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index)))) {\n            index += 3;\n            return NaN;\n        }\n        return parseNum();\n    };\n    const parseStr = () => {\n        const start = index;\n        let escape = false;\n        index++; // skip initial quote\n        while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === '\\\\'))) {\n            escape = jsonString[index] === '\\\\' ? !escape : false;\n            index++;\n        }\n        if (jsonString.charAt(index) == '\"') {\n            try {\n                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n        else if (Allow.STR & allow) {\n            try {\n                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n            }\n            catch (e) {\n                // SyntaxError: Invalid escape sequence\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n            }\n        }\n        markPartialJSON('Unterminated string literal');\n    };\n    const parseObj = () => {\n        index++; // skip initial brace\n        skipBlank();\n        const obj = {};\n        try {\n            while (jsonString[index] !== '}') {\n                skipBlank();\n                if (index >= length && Allow.OBJ & allow)\n                    return obj;\n                const key = parseStr();\n                skipBlank();\n                index++; // skip colon\n                try {\n                    const value = parseAny();\n                    Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });\n                }\n                catch (e) {\n                    if (Allow.OBJ & allow)\n                        return obj;\n                    else\n                        throw e;\n                }\n                skipBlank();\n                if (jsonString[index] === ',')\n                    index++; // skip comma\n            }\n        }\n        catch (e) {\n            if (Allow.OBJ & allow)\n                return obj;\n            else\n                markPartialJSON(\"Expected '}' at end of object\");\n        }\n        index++; // skip final brace\n        return obj;\n    };\n    const parseArr = () => {\n        index++; // skip initial bracket\n        const arr = [];\n        try {\n            while (jsonString[index] !== ']') {\n                arr.push(parseAny());\n                skipBlank();\n                if (jsonString[index] === ',') {\n                    index++; // skip comma\n                }\n            }\n        }\n        catch (e) {\n            if (Allow.ARR & allow) {\n                return arr;\n            }\n            markPartialJSON(\"Expected ']' at end of array\");\n        }\n        index++; // skip final bracket\n        return arr;\n    };\n    const parseNum = () => {\n        if (index === 0) {\n            if (jsonString === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString);\n            }\n            catch (e) {\n                if (Allow.NUM & allow) {\n                    try {\n                        if ('.' === jsonString[jsonString.length - 1])\n                            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\n                        return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\n                    }\n                    catch (e) { }\n                }\n                throwMalformedError(String(e));\n            }\n        }\n        const start = index;\n        if (jsonString[index] === '-')\n            index++;\n        while (jsonString[index] && !',]}'.includes(jsonString[index]))\n            index++;\n        if (index == length && !(Allow.NUM & allow))\n            markPartialJSON('Unterminated number literal');\n        try {\n            return JSON.parse(jsonString.substring(start, index));\n        }\n        catch (e) {\n            if (jsonString.substring(start, index) === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n    };\n    const skipBlank = () => {\n        while (index < length && ' \\n\\r\\t'.includes(jsonString[index])) {\n            index++;\n        }\n    };\n    return parseAny();\n};\n// using this function with malformed JSON is undefined behavior\nconst partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);\nexport { partialParse, PartialJSON, MalformedJSON };\n//# sourceMappingURL=parser.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;\nimport { OpenAIError, APIUserAbortError, LengthFinishReasonError, ContentFilterFinishReasonError, } from \"../error.mjs\";\nimport { AbstractChatCompletionRunner, } from \"./AbstractChatCompletionRunner.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { hasAutoParseableInput, isAutoParsableResponseFormat, isAutoParsableTool, maybeParseChatCompletion, shouldParseToolCall, } from \"../lib/parser.mjs\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nexport class ChatCompletionStream extends AbstractChatCompletionRunner {\n    constructor(params) {\n        super();\n        _ChatCompletionStream_instances.add(this);\n        _ChatCompletionStream_params.set(this, void 0);\n        _ChatCompletionStream_choiceEventStates.set(this, void 0);\n        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n        __classPrivateFieldSet(this, _ChatCompletionStream_params, params, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n    }\n    get currentChatCompletionSnapshot() {\n        return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStream(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createChatCompletion(client, params, options) {\n        const runner = new ChatCompletionStream(params);\n        runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    async _createChatCompletion(client, params, options) {\n        super._createChatCompletion;\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const chunk of stream) {\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        this._connected();\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        let chatId;\n        for await (const chunk of stream) {\n            if (chatId && chatId !== chunk.id) {\n                // A new request has been made.\n                this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n            }\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n            chatId = chunk.id;\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n        let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n        if (state) {\n            return state;\n        }\n        state = {\n            content_done: false,\n            refusal_done: false,\n            logprobs_content_done: false,\n            logprobs_refusal_done: false,\n            done_tool_calls: new Set(),\n            current_tool_call_index: null,\n        };\n        __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n        return state;\n    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n        if (this.ended)\n            return;\n        const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n        this._emit('chunk', chunk, completion);\n        for (const choice of chunk.choices) {\n            const choiceSnapshot = completion.choices[choice.index];\n            if (choice.delta.content != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.content) {\n                this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n                this._emit('content.delta', {\n                    delta: choice.delta.content,\n                    snapshot: choiceSnapshot.message.content,\n                    parsed: choiceSnapshot.message.parsed,\n                });\n            }\n            if (choice.delta.refusal != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.refusal) {\n                this._emit('refusal.delta', {\n                    delta: choice.delta.refusal,\n                    snapshot: choiceSnapshot.message.refusal,\n                });\n            }\n            if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.content.delta', {\n                    content: choice.logprobs?.content,\n                    snapshot: choiceSnapshot.logprobs?.content ?? [],\n                });\n            }\n            if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.refusal.delta', {\n                    refusal: choice.logprobs?.refusal,\n                    snapshot: choiceSnapshot.logprobs?.refusal ?? [],\n                });\n            }\n            const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n            if (choiceSnapshot.finish_reason) {\n                __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                if (state.current_tool_call_index != null) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                }\n            }\n            for (const toolCall of choice.delta.tool_calls ?? []) {\n                if (state.current_tool_call_index !== toolCall.index) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                    // new tool call started, the previous one is done\n                    if (state.current_tool_call_index != null) {\n                        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                    }\n                }\n                state.current_tool_call_index = toolCall.index;\n            }\n            for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n                const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n                if (!toolCallSnapshot?.type) {\n                    continue;\n                }\n                if (toolCallSnapshot?.type === 'function') {\n                    this._emit('tool_calls.function.arguments.delta', {\n                        name: toolCallSnapshot.function?.name,\n                        index: toolCallDelta.index,\n                        arguments: toolCallSnapshot.function.arguments,\n                        parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n                        arguments_delta: toolCallDelta.function?.arguments ?? '',\n                    });\n                }\n                else {\n                    assertNever(toolCallSnapshot?.type);\n                }\n            }\n        }\n    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (state.done_tool_calls.has(toolCallIndex)) {\n            // we've already fired the done event\n            return;\n        }\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n        if (!toolCallSnapshot) {\n            throw new Error('no tool call snapshot');\n        }\n        if (!toolCallSnapshot.type) {\n            throw new Error('tool call snapshot missing `type`');\n        }\n        if (toolCallSnapshot.type === 'function') {\n            const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.tools?.find((tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);\n            this._emit('tool_calls.function.arguments.done', {\n                name: toolCallSnapshot.function.name,\n                index: toolCallIndex,\n                arguments: toolCallSnapshot.function.arguments,\n                parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\n                    : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\n                        : null,\n            });\n        }\n        else {\n            assertNever(toolCallSnapshot.type);\n        }\n    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (choiceSnapshot.message.content && !state.content_done) {\n            state.content_done = true;\n            const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n            this._emit('content.done', {\n                content: choiceSnapshot.message.content,\n                parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null,\n            });\n        }\n        if (choiceSnapshot.message.refusal && !state.refusal_done) {\n            state.refusal_done = true;\n            this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\n        }\n        if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n            state.logprobs_content_done = true;\n            this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\n        }\n        if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n            state.logprobs_refusal_done = true;\n            this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\n        }\n    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n        if (this.ended) {\n            throw new OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        if (!snapshot) {\n            throw new OpenAIError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n        return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"));\n    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n        const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.response_format;\n        if (isAutoParsableResponseFormat(responseFormat)) {\n            return responseFormat;\n        }\n        return null;\n    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n        var _a, _b, _c, _d;\n        let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        const { choices, ...rest } = chunk;\n        if (!snapshot) {\n            snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n                ...rest,\n                choices: [],\n            }, \"f\");\n        }\n        else {\n            Object.assign(snapshot, rest);\n        }\n        for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n            let choice = snapshot.choices[index];\n            if (!choice) {\n                choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n            }\n            if (logprobs) {\n                if (!choice.logprobs) {\n                    choice.logprobs = Object.assign({}, logprobs);\n                }\n                else {\n                    const { content, refusal, ...rest } = logprobs;\n                    assertIsEmpty(rest);\n                    Object.assign(choice.logprobs, rest);\n                    if (content) {\n                        (_a = choice.logprobs).content ?? (_a.content = []);\n                        choice.logprobs.content.push(...content);\n                    }\n                    if (refusal) {\n                        (_b = choice.logprobs).refusal ?? (_b.refusal = []);\n                        choice.logprobs.refusal.push(...refusal);\n                    }\n                }\n            }\n            if (finish_reason) {\n                choice.finish_reason = finish_reason;\n                if (__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"))) {\n                    if (finish_reason === 'length') {\n                        throw new LengthFinishReasonError();\n                    }\n                    if (finish_reason === 'content_filter') {\n                        throw new ContentFilterFinishReasonError();\n                    }\n                }\n            }\n            Object.assign(choice, other);\n            if (!delta)\n                continue; // Shouldn't happen; just in case.\n            const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\n            assertIsEmpty(rest);\n            Object.assign(choice.message, rest);\n            if (refusal) {\n                choice.message.refusal = (choice.message.refusal || '') + refusal;\n            }\n            if (role)\n                choice.message.role = role;\n            if (function_call) {\n                if (!choice.message.function_call) {\n                    choice.message.function_call = function_call;\n                }\n                else {\n                    if (function_call.name)\n                        choice.message.function_call.name = function_call.name;\n                    if (function_call.arguments) {\n                        (_c = choice.message.function_call).arguments ?? (_c.arguments = '');\n                        choice.message.function_call.arguments += function_call.arguments;\n                    }\n                }\n            }\n            if (content) {\n                choice.message.content = (choice.message.content || '') + content;\n                if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {\n                    choice.message.parsed = partialParse(choice.message.content);\n                }\n            }\n            if (tool_calls) {\n                if (!choice.message.tool_calls)\n                    choice.message.tool_calls = [];\n                for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n                    const tool_call = ((_d = choice.message.tool_calls)[index] ?? (_d[index] = {}));\n                    Object.assign(tool_call, rest);\n                    if (id)\n                        tool_call.id = id;\n                    if (type)\n                        tool_call.type = type;\n                    if (fn)\n                        tool_call.function ?? (tool_call.function = { name: fn.name ?? '', arguments: '' });\n                    if (fn?.name)\n                        tool_call.function.name = fn.name;\n                    if (fn?.arguments) {\n                        tool_call.function.arguments += fn.arguments;\n                        if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"), tool_call)) {\n                            tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);\n                        }\n                    }\n                }\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('chunk', (chunk) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(chunk);\n            }\n            else {\n                pushQueue.push(chunk);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\nfunction finalizeChatCompletion(snapshot, params) {\n    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n    const completion = {\n        ...rest,\n        id,\n        choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {\n            if (!finish_reason) {\n                throw new OpenAIError(`missing finish_reason for choice ${index}`);\n            }\n            const { content = null, function_call, tool_calls, ...messageRest } = message;\n            const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n            if (!role) {\n                throw new OpenAIError(`missing role for choice ${index}`);\n            }\n            if (function_call) {\n                const { arguments: args, name } = function_call;\n                if (args == null) {\n                    throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n                }\n                if (!name) {\n                    throw new OpenAIError(`missing function_call.name for choice ${index}`);\n                }\n                return {\n                    ...choiceRest,\n                    message: {\n                        content,\n                        function_call: { arguments: args, name },\n                        role,\n                        refusal: message.refusal ?? null,\n                    },\n                    finish_reason,\n                    index,\n                    logprobs,\n                };\n            }\n            if (tool_calls) {\n                return {\n                    ...choiceRest,\n                    index,\n                    finish_reason,\n                    logprobs,\n                    message: {\n                        ...messageRest,\n                        role,\n                        content,\n                        refusal: message.refusal ?? null,\n                        tool_calls: tool_calls.map((tool_call, i) => {\n                            const { function: fn, type, id, ...toolRest } = tool_call;\n                            const { arguments: args, name, ...fnRest } = fn || {};\n                            if (id == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                            }\n                            if (type == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                            }\n                            if (name == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n                            }\n                            if (args == null) {\n                                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n                            }\n                            return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n                        }),\n                    },\n                };\n            }\n            return {\n                ...choiceRest,\n                message: { ...messageRest, content, role, refusal: message.refusal ?? null },\n                finish_reason,\n                index,\n                logprobs,\n            };\n        }),\n        created,\n        model,\n        object: 'chat.completion',\n        ...(system_fingerprint ? { system_fingerprint } : {}),\n    };\n    return maybeParseChatCompletion(completion, params);\n}\nfunction str(x) {\n    return JSON.stringify(x);\n}\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */\nfunction assertIsEmpty(obj) {\n    return;\n}\nfunction assertNever(_x) { }\n//# sourceMappingURL=ChatCompletionStream.mjs.map","import { ChatCompletionStream } from \"./ChatCompletionStream.mjs\";\nexport class ChatCompletionStreamingRunner extends ChatCompletionStream {\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(\n        // @ts-expect-error TODO these types are incompatible\n        params);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n}\n//# sourceMappingURL=ChatCompletionStreamingRunner.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { ChatCompletionRunner } from \"../../../lib/ChatCompletionRunner.mjs\";\nimport { ChatCompletionStreamingRunner, } from \"../../../lib/ChatCompletionStreamingRunner.mjs\";\nimport { ChatCompletionStream } from \"../../../lib/ChatCompletionStream.mjs\";\nimport { parseChatCompletion, validateInputTools } from \"../../../lib/parser.mjs\";\nexport { ChatCompletionStreamingRunner, } from \"../../../lib/ChatCompletionStreamingRunner.mjs\";\nexport { ParsingFunction, ParsingToolFunction, } from \"../../../lib/RunnableFunction.mjs\";\nexport { ChatCompletionStream } from \"../../../lib/ChatCompletionStream.mjs\";\nexport { ChatCompletionRunner, } from \"../../../lib/ChatCompletionRunner.mjs\";\nexport class Completions extends APIResource {\n    parse(body, options) {\n        validateInputTools(body.tools);\n        return this._client.chat.completions\n            .create(body, {\n            ...options,\n            headers: {\n                ...options?.headers,\n                'X-Stainless-Helper-Method': 'beta.chat.completions.parse',\n            },\n        })\n            ._thenUnwrap((completion) => parseChatCompletion(completion, body));\n    }\n    runFunctions(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);\n        }\n        return ChatCompletionRunner.runFunctions(this._client, body, options);\n    }\n    runTools(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner.runTools(this._client, body, options);\n        }\n        return ChatCompletionRunner.runTools(this._client, body, options);\n    }\n    /**\n     * Creates a chat completion stream\n     */\n    stream(body, options) {\n        return ChatCompletionStream.createChatCompletion(this._client, body, options);\n    }\n}\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as CompletionsAPI from \"./completions.mjs\";\nexport class Chat extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\n(function (Chat) {\n    Chat.Completions = CompletionsAPI.Completions;\n})(Chat || (Chat = {}));\n//# sourceMappingURL=chat.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class Sessions extends APIResource {\n    /**\n     * Create an ephemeral API token for use in client-side applications with the\n     * Realtime API. Can be configured with the same session parameters as the\n     * `session.update` client event.\n     *\n     * It responds with a session object, plus a `client_secret` key which contains a\n     * usable ephemeral API token that can be used to authenticate browser clients for\n     * the Realtime API.\n     *\n     * @example\n     * ```ts\n     * const session =\n     *   await client.beta.realtime.sessions.create();\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/realtime/sessions', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\n//# sourceMappingURL=sessions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class TranscriptionSessions extends APIResource {\n    /**\n     * Create an ephemeral API token for use in client-side applications with the\n     * Realtime API specifically for realtime transcriptions. Can be configured with\n     * the same session parameters as the `transcription_session.update` client event.\n     *\n     * It responds with a session object, plus a `client_secret` key which contains a\n     * usable ephemeral API token that can be used to authenticate browser clients for\n     * the Realtime API.\n     *\n     * @example\n     * ```ts\n     * const transcriptionSession =\n     *   await client.beta.realtime.transcriptionSessions.create();\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/realtime/transcription_sessions', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\n//# sourceMappingURL=transcription-sessions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as SessionsAPI from \"./sessions.mjs\";\nimport { Sessions, } from \"./sessions.mjs\";\nimport * as TranscriptionSessionsAPI from \"./transcription-sessions.mjs\";\nimport { TranscriptionSessions, } from \"./transcription-sessions.mjs\";\nexport class Realtime extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.sessions = new SessionsAPI.Sessions(this._client);\n        this.transcriptionSessions = new TranscriptionSessionsAPI.TranscriptionSessions(this._client);\n    }\n}\nRealtime.Sessions = Sessions;\nRealtime.TranscriptionSessions = TranscriptionSessions;\n//# sourceMappingURL=realtime.mjs.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;\nimport * as Core from \"../core.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nexport class AssistantStream extends EventStream {\n    constructor() {\n        super(...arguments);\n        _AssistantStream_instances.add(this);\n        //Track all events in a single list for reference\n        _AssistantStream_events.set(this, []);\n        //Used to accumulate deltas\n        //We are accumulating many types so the value here is not strict\n        _AssistantStream_runStepSnapshots.set(this, {});\n        _AssistantStream_messageSnapshots.set(this, {});\n        _AssistantStream_messageSnapshot.set(this, void 0);\n        _AssistantStream_finalRun.set(this, void 0);\n        _AssistantStream_currentContentIndex.set(this, void 0);\n        _AssistantStream_currentContent.set(this, void 0);\n        _AssistantStream_currentToolCallIndex.set(this, void 0);\n        _AssistantStream_currentToolCall.set(this, void 0);\n        //For current snapshot methods\n        _AssistantStream_currentEvent.set(this, void 0);\n        _AssistantStream_currentRunSnapshot.set(this, void 0);\n        _AssistantStream_currentRunStepSnapshot.set(this, void 0);\n    }\n    [(_AssistantStream_events = new WeakMap(), _AssistantStream_runStepSnapshots = new WeakMap(), _AssistantStream_messageSnapshots = new WeakMap(), _AssistantStream_messageSnapshot = new WeakMap(), _AssistantStream_finalRun = new WeakMap(), _AssistantStream_currentContentIndex = new WeakMap(), _AssistantStream_currentContent = new WeakMap(), _AssistantStream_currentToolCallIndex = new WeakMap(), _AssistantStream_currentToolCall = new WeakMap(), _AssistantStream_currentEvent = new WeakMap(), _AssistantStream_currentRunSnapshot = new WeakMap(), _AssistantStream_currentRunStepSnapshot = new WeakMap(), _AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        //Catch all for passing along all events\n        this.on('event', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    static fromReadableStream(stream) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        this._connected();\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n    static createToolAssistantStream(threadId, runId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    async _createToolAssistantStream(run, threadId, runId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.submitToolOutputs(threadId, runId, body, {\n            ...options,\n            signal: this.controller.signal,\n        });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static createThreadAssistantStream(params, thread, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._threadAssistantStream(params, thread, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    static createAssistantStream(threadId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runAssistantStream(threadId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    currentEvent() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentEvent, \"f\");\n    }\n    currentRun() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, \"f\");\n    }\n    currentMessageSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\");\n    }\n    currentRunStepSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, \"f\");\n    }\n    async finalRunSteps() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\"));\n    }\n    async finalMessages() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\"));\n    }\n    async finalRun() {\n        await this.done();\n        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n            throw Error('Final run was not received.');\n        return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n    }\n    async _createThreadAssistantStream(thread, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    async _createAssistantStream(run, threadId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static accumulateDelta(acc, delta) {\n        for (const [key, deltaValue] of Object.entries(delta)) {\n            if (!acc.hasOwnProperty(key)) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            let accValue = acc[key];\n            if (accValue === null || accValue === undefined) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // We don't accumulate these special properties\n            if (key === 'index' || key === 'type') {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // Type-specific accumulation logic\n            if (typeof accValue === 'string' && typeof deltaValue === 'string') {\n                accValue += deltaValue;\n            }\n            else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\n                accValue += deltaValue;\n            }\n            else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\n                accValue = this.accumulateDelta(accValue, deltaValue);\n            }\n            else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n                if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {\n                    accValue.push(...deltaValue); // Use spread syntax for efficient addition\n                    continue;\n                }\n                for (const deltaEntry of deltaValue) {\n                    if (!Core.isObj(deltaEntry)) {\n                        throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\n                    }\n                    const index = deltaEntry['index'];\n                    if (index == null) {\n                        console.error(deltaEntry);\n                        throw new Error('Expected array delta entry to have an `index` property');\n                    }\n                    if (typeof index !== 'number') {\n                        throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\n                    }\n                    const accEntry = accValue[index];\n                    if (accEntry == null) {\n                        accValue.push(deltaEntry);\n                    }\n                    else {\n                        accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n                    }\n                }\n                continue;\n            }\n            else {\n                throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\n            }\n            acc[key] = accValue;\n        }\n        return acc;\n    }\n    _addRun(run) {\n        return run;\n    }\n    async _threadAssistantStream(params, thread, options) {\n        return await this._createThreadAssistantStream(thread, params, options);\n    }\n    async _runAssistantStream(threadId, runs, params, options) {\n        return await this._createAssistantStream(runs, threadId, params, options);\n    }\n    async _runToolAssistantStream(threadId, runId, runs, params, options) {\n        return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n    }\n}\n_AssistantStream_addEvent = function _AssistantStream_addEvent(event) {\n    if (this.ended)\n        return;\n    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleEvent).call(this, event);\n    switch (event.event) {\n        case 'thread.created':\n            //No action on this event.\n            break;\n        case 'thread.run.created':\n        case 'thread.run.queued':\n        case 'thread.run.in_progress':\n        case 'thread.run.requires_action':\n        case 'thread.run.completed':\n        case 'thread.run.incomplete':\n        case 'thread.run.failed':\n        case 'thread.run.cancelling':\n        case 'thread.run.cancelled':\n        case 'thread.run.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRun).call(this, event);\n            break;\n        case 'thread.run.step.created':\n        case 'thread.run.step.in_progress':\n        case 'thread.run.step.delta':\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRunStep).call(this, event);\n            break;\n        case 'thread.message.created':\n        case 'thread.message.in_progress':\n        case 'thread.message.delta':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleMessage).call(this, event);\n            break;\n        case 'error':\n            //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n            throw new Error('Encountered an error event in event processing - errors should be processed earlier');\n        default:\n            assertNever(event);\n    }\n}, _AssistantStream_endRequest = function _AssistantStream_endRequest() {\n    if (this.ended) {\n        throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n        throw Error('Final run has not been received');\n    return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {\n    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\")[accumulatedMessage.id] = accumulatedMessage;\n    for (const content of newContent) {\n        const snapshotContent = accumulatedMessage.content[content.index];\n        if (snapshotContent?.type == 'text') {\n            this._emit('textCreated', snapshotContent.text);\n        }\n    }\n    switch (event.event) {\n        case 'thread.message.created':\n            this._emit('messageCreated', event.data);\n            break;\n        case 'thread.message.in_progress':\n            break;\n        case 'thread.message.delta':\n            this._emit('messageDelta', event.data.delta, accumulatedMessage);\n            if (event.data.delta.content) {\n                for (const content of event.data.delta.content) {\n                    //If it is text delta, emit a text delta event\n                    if (content.type == 'text' && content.text) {\n                        let textDelta = content.text;\n                        let snapshot = accumulatedMessage.content[content.index];\n                        if (snapshot && snapshot.type == 'text') {\n                            this._emit('textDelta', textDelta, snapshot.text);\n                        }\n                        else {\n                            throw Error('The snapshot associated with this text delta is not text or missing');\n                        }\n                    }\n                    if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")) {\n                        //See if we have in progress content\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\")) {\n                            switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").type) {\n                                case 'text':\n                                    this._emit('textDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                                case 'image_file':\n                                    this._emit('imageFileDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                            }\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, \"f\");\n                    }\n                    __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], \"f\");\n                }\n            }\n            break;\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //We emit the latest content we were working on on completion (including incomplete)\n            if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\") !== undefined) {\n                const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")];\n                if (currentContent) {\n                    switch (currentContent.type) {\n                        case 'image_file':\n                            this._emit('imageFileDone', currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                        case 'text':\n                            this._emit('textDone', currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                    }\n                }\n            }\n            if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\")) {\n                this._emit('messageDone', event.data);\n            }\n            __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, \"f\");\n    }\n}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {\n    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateRunStep).call(this, event);\n    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, \"f\");\n    switch (event.event) {\n        case 'thread.run.step.created':\n            this._emit('runStepCreated', event.data);\n            break;\n        case 'thread.run.step.delta':\n            const delta = event.data.delta;\n            if (delta.step_details &&\n                delta.step_details.type == 'tool_calls' &&\n                delta.step_details.tool_calls &&\n                accumulatedRunStep.step_details.type == 'tool_calls') {\n                for (const toolCall of delta.step_details.tool_calls) {\n                    if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, \"f\")) {\n                        this._emit('toolCallDelta', toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);\n                    }\n                    else {\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                            this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, \"f\");\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], \"f\");\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"))\n                            this._emit('toolCallCreated', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    }\n                }\n            }\n            this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\n            break;\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, \"f\");\n            const details = event.data.step_details;\n            if (details.type == 'tool_calls') {\n                if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                    this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n                }\n            }\n            this._emit('runStepDone', event.data, accumulatedRunStep);\n            break;\n        case 'thread.run.step.in_progress':\n            break;\n    }\n}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {\n    __classPrivateFieldGet(this, _AssistantStream_events, \"f\").push(event);\n    this._emit('event', event);\n}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {\n    switch (event.event) {\n        case 'thread.run.step.created':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            return event.data;\n        case 'thread.run.step.delta':\n            let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n            if (!snapshot) {\n                throw Error('Received a RunStepDelta before creation of a snapshot');\n            }\n            let data = event.data;\n            if (data.delta) {\n                const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);\n                __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = accumulated;\n            }\n            return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n        case 'thread.run.step.in_progress':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            break;\n    }\n    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id])\n        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n    throw new Error('No snapshot available');\n}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {\n    let newContent = [];\n    switch (event.event) {\n        case 'thread.message.created':\n            //On creation the snapshot is just the initial message\n            return [event.data, newContent];\n        case 'thread.message.delta':\n            if (!snapshot) {\n                throw Error('Received a delta with no existing snapshot (there should be one from message creation)');\n            }\n            let data = event.data;\n            //If this delta does not have content, nothing to process\n            if (data.delta.content) {\n                for (const contentElement of data.delta.content) {\n                    if (contentElement.index in snapshot.content) {\n                        let currentContent = snapshot.content[contentElement.index];\n                        snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);\n                    }\n                    else {\n                        snapshot.content[contentElement.index] = contentElement;\n                        // This is a new element\n                        newContent.push(contentElement);\n                    }\n                }\n            }\n            return [snapshot, newContent];\n        case 'thread.message.in_progress':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //No changes on other thread events\n            if (snapshot) {\n                return [snapshot, newContent];\n            }\n            else {\n                throw Error('Received thread message event with no existing snapshot');\n            }\n    }\n    throw Error('Tried to accumulate a non-message event');\n}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {\n    return AssistantStream.accumulateDelta(currentContent, contentElement);\n}, _AssistantStream_handleRun = function _AssistantStream_handleRun(event) {\n    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, \"f\");\n    switch (event.event) {\n        case 'thread.run.created':\n            break;\n        case 'thread.run.queued':\n            break;\n        case 'thread.run.in_progress':\n            break;\n        case 'thread.run.requires_action':\n        case 'thread.run.cancelled':\n        case 'thread.run.failed':\n        case 'thread.run.completed':\n        case 'thread.run.expired':\n            __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, \"f\");\n            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n            }\n            break;\n        case 'thread.run.cancelling':\n            break;\n    }\n};\nfunction assertNever(_x) { }\n//# sourceMappingURL=AssistantStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Messages extends APIResource {\n    /**\n     * Create a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    create(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieve a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    retrieve(threadId, messageId, options) {\n        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    update(threadId, messageId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Deletes a message.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    del(threadId, messageId, options) {\n        return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class MessagesPage extends CursorPage {\n}\nMessages.MessagesPage = MessagesPage;\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../../core.mjs\";\nimport { CursorPage } from \"../../../../pagination.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Steps extends APIResource {\n    retrieve(threadId, runId, stepId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.retrieve(threadId, runId, stepId, {}, query);\n        }\n        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, runId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, runId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexport class RunStepsPage extends CursorPage {\n}\nSteps.RunStepsPage = RunStepsPage;\n//# sourceMappingURL=steps.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../../core.mjs\";\nimport { AssistantStream } from \"../../../../lib/AssistantStream.mjs\";\nimport { sleep } from \"../../../../core.mjs\";\nimport * as StepsAPI from \"./steps.mjs\";\nimport { RunStepsPage, Steps, } from \"./steps.mjs\";\nimport { CursorPage } from \"../../../../pagination.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Runs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.steps = new StepsAPI.Steps(this._client);\n    }\n    create(threadId, params, options) {\n        const { include, ...body } = params;\n        return this._client.post(`/threads/${threadId}/runs`, {\n            query: { include },\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: params.stream ?? false,\n        });\n    }\n    /**\n     * Retrieves a run.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    retrieve(threadId, runId, options) {\n        return this._client.get(`/threads/${threadId}/runs/${runId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a run.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    update(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancels a run that is `in_progress`.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    cancel(threadId, runId, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * A helper to create a run an poll for a terminal state. More information on Run\n     * lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndPoll(threadId, body, options) {\n        const run = await this.create(threadId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Create a Run stream\n     *\n     * @deprecated use `stream` instead\n     */\n    createAndStream(threadId, body, options) {\n        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    /**\n     * A helper to poll a run status until it reaches a terminal state. More\n     * information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async poll(threadId, runId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: run, response } = await this.retrieve(threadId, runId, {\n                ...options,\n                headers: { ...options?.headers, ...headers },\n            }).withResponse();\n            switch (run.status) {\n                //If we are in any sort of intermediate state we poll\n                case 'queued':\n                case 'in_progress':\n                case 'cancelling':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await sleep(sleepInterval);\n                    break;\n                //We return the run in any terminal state.\n                case 'requires_action':\n                case 'incomplete':\n                case 'cancelled':\n                case 'completed':\n                case 'failed':\n                case 'expired':\n                    return run;\n            }\n        }\n    }\n    /**\n     * Create a Run stream\n     */\n    stream(threadId, body, options) {\n        return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    submitToolOutputs(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to submit a tool output to a run and poll for a terminal run state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async submitToolOutputsAndPoll(threadId, runId, body, options) {\n        const run = await this.submitToolOutputs(threadId, runId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Submit the tool outputs from a previous run and stream the run to a terminal\n     * state. More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    submitToolOutputsStream(threadId, runId, body, options) {\n        return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);\n    }\n}\nexport class RunsPage extends CursorPage {\n}\nRuns.RunsPage = RunsPage;\nRuns.Steps = Steps;\nRuns.RunStepsPage = RunStepsPage;\n//# sourceMappingURL=runs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { AssistantStream } from \"../../../lib/AssistantStream.mjs\";\nimport * as MessagesAPI from \"./messages.mjs\";\nimport { Messages, MessagesPage, } from \"./messages.mjs\";\nimport * as RunsAPI from \"./runs/runs.mjs\";\nimport { Runs, RunsPage, } from \"./runs/runs.mjs\";\n/**\n * @deprecated The Assistants API is deprecated in favor of the Responses API\n */\nexport class Threads extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.runs = new RunsAPI.Runs(this._client);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n    create(body = {}, options) {\n        if (isRequestOptions(body)) {\n            return this.create({}, body);\n        }\n        return this._client.post('/threads', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a thread.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    retrieve(threadId, options) {\n        return this._client.get(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a thread.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    update(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @deprecated The Assistants API is deprecated in favor of the Responses API\n     */\n    del(threadId, options) {\n        return this._client.delete(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    createAndRun(body, options) {\n        return this._client.post('/threads/runs', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to create a thread, start a run and then poll for a terminal state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndRunPoll(body, options) {\n        const run = await this.createAndRun(body, options);\n        return await this.runs.poll(run.thread_id, run.id, options);\n    }\n    /**\n     * Create a thread and stream the run back\n     */\n    createAndRunStream(body, options) {\n        return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);\n    }\n}\nThreads.Runs = Runs;\nThreads.RunsPage = RunsPage;\nThreads.Messages = Messages;\nThreads.MessagesPage = MessagesPage;\n//# sourceMappingURL=threads.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as AssistantsAPI from \"./assistants.mjs\";\nimport * as ChatAPI from \"./chat/chat.mjs\";\nimport { Assistants, AssistantsPage, } from \"./assistants.mjs\";\nimport * as RealtimeAPI from \"./realtime/realtime.mjs\";\nimport { Realtime, } from \"./realtime/realtime.mjs\";\nimport * as ThreadsAPI from \"./threads/threads.mjs\";\nimport { Threads, } from \"./threads/threads.mjs\";\nimport { Chat } from \"./chat/chat.mjs\";\nexport class Beta extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.realtime = new RealtimeAPI.Realtime(this._client);\n        this.chat = new ChatAPI.Chat(this._client);\n        this.assistants = new AssistantsAPI.Assistants(this._client);\n        this.threads = new ThreadsAPI.Threads(this._client);\n    }\n}\nBeta.Realtime = Realtime;\nBeta.Assistants = Assistants;\nBeta.AssistantsPage = AssistantsPage;\nBeta.Threads = Threads;\n//# sourceMappingURL=beta.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { isRequestOptions } from \"../core.mjs\";\nimport { CursorPage } from \"../pagination.mjs\";\nexport class Batches extends APIResource {\n    /**\n     * Creates and executes a batch from an uploaded file of requests\n     */\n    create(body, options) {\n        return this._client.post('/batches', { body, ...options });\n    }\n    /**\n     * Retrieves a batch.\n     */\n    retrieve(batchId, options) {\n        return this._client.get(`/batches/${batchId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/batches', BatchesPage, { query, ...options });\n    }\n    /**\n     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to\n     * 10 minutes, before changing to `cancelled`, where it will have partial results\n     * (if any) available in the output file.\n     */\n    cancel(batchId, options) {\n        return this._client.post(`/batches/${batchId}/cancel`, options);\n    }\n}\nexport class BatchesPage extends CursorPage {\n}\nBatches.BatchesPage = BatchesPage;\n//# sourceMappingURL=batches.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as Core from \"../../core.mjs\";\nexport class Parts extends APIResource {\n    /**\n     * Adds a\n     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.\n     * A Part represents a chunk of bytes from the file you are trying to upload.\n     *\n     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload\n     * maximum of 8 GB.\n     *\n     * It is possible to add multiple Parts in parallel. You can decide the intended\n     * order of the Parts when you\n     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).\n     */\n    create(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/parts`, Core.multipartFormRequestOptions({ body, ...options }));\n    }\n}\n//# sourceMappingURL=parts.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as PartsAPI from \"./parts.mjs\";\nimport { Parts } from \"./parts.mjs\";\nexport class Uploads extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.parts = new PartsAPI.Parts(this._client);\n    }\n    /**\n     * Creates an intermediate\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object\n     * that you can add\n     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.\n     * Currently, an Upload can accept at most 8 GB in total and expires after an hour\n     * after you create it.\n     *\n     * Once you complete the Upload, we will create a\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * contains all the parts you uploaded. This File is usable in the rest of our\n     * platform as a regular File object.\n     *\n     * For certain `purpose` values, the correct `mime_type` must be specified. Please\n     * refer to documentation for the\n     * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).\n     *\n     * For guidance on the proper filename extensions for each purpose, please follow\n     * the documentation on\n     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).\n     */\n    create(body, options) {\n        return this._client.post('/uploads', { body, ...options });\n    }\n    /**\n     * Cancels the Upload. No Parts may be added after an Upload is cancelled.\n     */\n    cancel(uploadId, options) {\n        return this._client.post(`/uploads/${uploadId}/cancel`, options);\n    }\n    /**\n     * Completes the\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).\n     *\n     * Within the returned Upload object, there is a nested\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * is ready to use in the rest of the platform.\n     *\n     * You can specify the order of the Parts by passing in an ordered list of the Part\n     * IDs.\n     *\n     * The number of bytes uploaded upon completion must match the number of bytes\n     * initially specified when creating the Upload object. No Parts may be added after\n     * an Upload is completed.\n     */\n    complete(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });\n    }\n}\nUploads.Parts = Parts;\n//# sourceMappingURL=uploads.mjs.map","import { OpenAIError } from \"../error.mjs\";\nimport { isAutoParsableResponseFormat } from \"../lib/parser.mjs\";\nexport function maybeParseResponse(response, params) {\n    if (!params || !hasAutoParseableInput(params)) {\n        return {\n            ...response,\n            output_parsed: null,\n            output: response.output.map((item) => {\n                if (item.type === 'function_call') {\n                    return {\n                        ...item,\n                        parsed_arguments: null,\n                    };\n                }\n                if (item.type === 'message') {\n                    return {\n                        ...item,\n                        content: item.content.map((content) => ({\n                            ...content,\n                            parsed: null,\n                        })),\n                    };\n                }\n                else {\n                    return item;\n                }\n            }),\n        };\n    }\n    return parseResponse(response, params);\n}\nexport function parseResponse(response, params) {\n    const output = response.output.map((item) => {\n        if (item.type === 'function_call') {\n            return {\n                ...item,\n                parsed_arguments: parseToolCall(params, item),\n            };\n        }\n        if (item.type === 'message') {\n            const content = item.content.map((content) => {\n                if (content.type === 'output_text') {\n                    return {\n                        ...content,\n                        parsed: parseTextFormat(params, content.text),\n                    };\n                }\n                return content;\n            });\n            return {\n                ...item,\n                content,\n            };\n        }\n        return item;\n    });\n    const parsed = Object.assign({}, response, { output });\n    if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n        addOutputText(parsed);\n    }\n    Object.defineProperty(parsed, 'output_parsed', {\n        enumerable: true,\n        get() {\n            for (const output of parsed.output) {\n                if (output.type !== 'message') {\n                    continue;\n                }\n                for (const content of output.content) {\n                    if (content.type === 'output_text' && content.parsed !== null) {\n                        return content.parsed;\n                    }\n                }\n            }\n            return null;\n        },\n    });\n    return parsed;\n}\nfunction parseTextFormat(params, content) {\n    if (params.text?.format?.type !== 'json_schema') {\n        return null;\n    }\n    if ('$parseRaw' in params.text?.format) {\n        const text_format = params.text?.format;\n        return text_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n}\nexport function hasAutoParseableInput(params) {\n    if (isAutoParsableResponseFormat(params.text?.format)) {\n        return true;\n    }\n    return false;\n}\nexport function makeParseableResponseTool(tool, { parser, callback, }) {\n    const obj = { ...tool };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-tool',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n        $callback: {\n            value: callback,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexport function isAutoParsableTool(tool) {\n    return tool?.['$brand'] === 'auto-parseable-tool';\n}\nfunction getInputToolByName(input_tools, name) {\n    return input_tools.find((tool) => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n    return {\n        ...toolCall,\n        ...toolCall,\n        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments)\n            : inputTool?.strict ? JSON.parse(toolCall.arguments)\n                : null,\n    };\n}\nexport function shouldParseToolCall(params, toolCall) {\n    if (!params) {\n        return false;\n    }\n    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n    return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\nexport function validateInputTools(tools) {\n    for (const tool of tools ?? []) {\n        if (tool.type !== 'function') {\n            throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        }\n        if (tool.function.strict !== true) {\n            throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n        }\n    }\n}\nexport function addOutputText(rsp) {\n    const texts = [];\n    for (const output of rsp.output) {\n        if (output.type !== 'message') {\n            continue;\n        }\n        for (const content of output.content) {\n            if (content.type === 'output_text') {\n                texts.push(content.text);\n            }\n        }\n    }\n    rsp.output_text = texts.join('');\n}\n//# sourceMappingURL=ResponsesParser.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { ResponseItemsPage } from \"./responses.mjs\";\nexport class InputItems extends APIResource {\n    list(responseId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(responseId, {}, query);\n        }\n        return this._client.getAPIList(`/responses/${responseId}/input_items`, ResponseItemsPage, {\n            query,\n            ...options,\n        });\n    }\n}\nexport { ResponseItemsPage };\n//# sourceMappingURL=input-items.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;\nimport { APIUserAbortError, OpenAIError } from \"../../error.mjs\";\nimport { EventStream } from \"../EventStream.mjs\";\nimport { maybeParseResponse } from \"../ResponsesParser.mjs\";\nexport class ResponseStream extends EventStream {\n    constructor(params) {\n        super();\n        _ResponseStream_instances.add(this);\n        _ResponseStream_params.set(this, void 0);\n        _ResponseStream_currentResponseSnapshot.set(this, void 0);\n        _ResponseStream_finalResponse.set(this, void 0);\n        __classPrivateFieldSet(this, _ResponseStream_params, params, \"f\");\n    }\n    static createResponse(client, params, options) {\n        const runner = new ResponseStream(params);\n        runner._run(() => runner._createOrRetrieveResponse(client, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    async _createOrRetrieveResponse(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_beginRequest).call(this);\n        let stream;\n        let starting_after = null;\n        if ('response_id' in params) {\n            stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });\n            starting_after = params.starting_after ?? null;\n        }\n        else {\n            stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        }\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_addEvent).call(this, event, starting_after);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        return __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_endRequest).call(this);\n    }\n    [(_ResponseStream_params = new WeakMap(), _ResponseStream_currentResponseSnapshot = new WeakMap(), _ResponseStream_finalResponse = new WeakMap(), _ResponseStream_instances = new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n    }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event, starting_after) {\n        if (this.ended)\n            return;\n        const maybeEmit = (name, event) => {\n            if (starting_after == null || event.sequence_number > starting_after) {\n                this._emit(name, event);\n            }\n        };\n        const response = __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_accumulateResponse).call(this, event);\n        maybeEmit('event', event);\n        switch (event.type) {\n            case 'response.output_text.delta': {\n                const output = response.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    const content = output.content[event.content_index];\n                    if (!content) {\n                        throw new OpenAIError(`missing content at index ${event.content_index}`);\n                    }\n                    if (content.type !== 'output_text') {\n                        throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n                    }\n                    maybeEmit('response.output_text.delta', {\n                        ...event,\n                        snapshot: content.text,\n                    });\n                }\n                break;\n            }\n            case 'response.function_call_arguments.delta': {\n                const output = response.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'function_call') {\n                    maybeEmit('response.function_call_arguments.delta', {\n                        ...event,\n                        snapshot: output.arguments,\n                    });\n                }\n                break;\n            }\n            default:\n                maybeEmit(event.type, event);\n                break;\n        }\n    }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {\n        if (this.ended) {\n            throw new OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n        if (!snapshot) {\n            throw new OpenAIError(`request ended without sending any events`);\n        }\n        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n        const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, \"f\"));\n        __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, \"f\");\n        return parsedResponse;\n    }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {\n        let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n        if (!snapshot) {\n            if (event.type !== 'response.created') {\n                throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);\n            }\n            snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n            return snapshot;\n        }\n        switch (event.type) {\n            case 'response.output_item.added': {\n                snapshot.output.push(event.item);\n                break;\n            }\n            case 'response.content_part.added': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    output.content.push(event.part);\n                }\n                break;\n            }\n            case 'response.output_text.delta': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'message') {\n                    const content = output.content[event.content_index];\n                    if (!content) {\n                        throw new OpenAIError(`missing content at index ${event.content_index}`);\n                    }\n                    if (content.type !== 'output_text') {\n                        throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n                    }\n                    content.text += event.delta;\n                }\n                break;\n            }\n            case 'response.function_call_arguments.delta': {\n                const output = snapshot.output[event.output_index];\n                if (!output) {\n                    throw new OpenAIError(`missing output at index ${event.output_index}`);\n                }\n                if (output.type === 'function_call') {\n                    output.arguments += event.delta;\n                }\n                break;\n            }\n            case 'response.completed': {\n                __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n                break;\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('event', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event) => (event ? { value: event, done: false } : { value: undefined, done: true }));\n                }\n                const event = pushQueue.shift();\n                return { value: event, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    /**\n     * @returns a promise that resolves with the final Response, or rejects\n     * if an error occurred or the stream ended prematurely without producing a REsponse.\n     */\n    async finalResponse() {\n        await this.done();\n        const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, \"f\");\n        if (!response)\n            throw new OpenAIError('stream ended without producing a ChatCompletion');\n        return response;\n    }\n}\nfunction finalizeResponse(snapshot, params) {\n    return maybeParseResponse(snapshot, params);\n}\n//# sourceMappingURL=ResponseStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { parseResponse, addOutputText, } from \"../../lib/ResponsesParser.mjs\";\nimport { APIResource } from \"../../resource.mjs\";\nimport * as InputItemsAPI from \"./input-items.mjs\";\nimport { InputItems } from \"./input-items.mjs\";\nimport { ResponseStream } from \"../../lib/responses/ResponseStream.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Responses extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.inputItems = new InputItemsAPI.InputItems(this._client);\n    }\n    create(body, options) {\n        return this._client.post('/responses', { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {\n            if ('object' in rsp && rsp.object === 'response') {\n                addOutputText(rsp);\n            }\n            return rsp;\n        });\n    }\n    retrieve(responseId, query = {}, options) {\n        return this._client.get(`/responses/${responseId}`, {\n            query,\n            ...options,\n            stream: query?.stream ?? false,\n        });\n    }\n    /**\n     * Deletes a model response with the given ID.\n     *\n     * @example\n     * ```ts\n     * await client.responses.del(\n     *   'resp_677efb5139a88190b512bc3fef8e535d',\n     * );\n     * ```\n     */\n    del(responseId, options) {\n        return this._client.delete(`/responses/${responseId}`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n    parse(body, options) {\n        return this._client.responses\n            .create(body, options)\n            ._thenUnwrap((response) => parseResponse(response, body));\n    }\n    /**\n     * Creates a model response stream\n     */\n    stream(body, options) {\n        return ResponseStream.createResponse(this._client, body, options);\n    }\n    /**\n     * Cancels a model response with the given ID. Only responses created with the\n     * `background` parameter set to `true` can be cancelled.\n     * [Learn more](https://platform.openai.com/docs/guides/background).\n     *\n     * @example\n     * ```ts\n     * await client.responses.cancel(\n     *   'resp_677efb5139a88190b512bc3fef8e535d',\n     * );\n     * ```\n     */\n    cancel(responseId, options) {\n        return this._client.post(`/responses/${responseId}/cancel`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n}\nexport class ResponseItemsPage extends CursorPage {\n}\nResponses.InputItems = InputItems;\n//# sourceMappingURL=responses.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class OutputItems extends APIResource {\n    /**\n     * Get an evaluation run output item by ID.\n     */\n    retrieve(evalId, runId, outputItemId, options) {\n        return this._client.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`, options);\n    }\n    list(evalId, runId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(evalId, runId, {}, query);\n        }\n        return this._client.getAPIList(`/evals/${evalId}/runs/${runId}/output_items`, OutputItemListResponsesPage, { query, ...options });\n    }\n}\nexport class OutputItemListResponsesPage extends CursorPage {\n}\nOutputItems.OutputItemListResponsesPage = OutputItemListResponsesPage;\n//# sourceMappingURL=output-items.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as OutputItemsAPI from \"./output-items.mjs\";\nimport { OutputItemListResponsesPage, OutputItems, } from \"./output-items.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Runs extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.outputItems = new OutputItemsAPI.OutputItems(this._client);\n    }\n    /**\n     * Kicks off a new run for a given evaluation, specifying the data source, and what\n     * model configuration to use to test. The datasource will be validated against the\n     * schema specified in the config of the evaluation.\n     */\n    create(evalId, body, options) {\n        return this._client.post(`/evals/${evalId}/runs`, { body, ...options });\n    }\n    /**\n     * Get an evaluation run by ID.\n     */\n    retrieve(evalId, runId, options) {\n        return this._client.get(`/evals/${evalId}/runs/${runId}`, options);\n    }\n    list(evalId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(evalId, {}, query);\n        }\n        return this._client.getAPIList(`/evals/${evalId}/runs`, RunListResponsesPage, { query, ...options });\n    }\n    /**\n     * Delete an eval run.\n     */\n    del(evalId, runId, options) {\n        return this._client.delete(`/evals/${evalId}/runs/${runId}`, options);\n    }\n    /**\n     * Cancel an ongoing evaluation run.\n     */\n    cancel(evalId, runId, options) {\n        return this._client.post(`/evals/${evalId}/runs/${runId}`, options);\n    }\n}\nexport class RunListResponsesPage extends CursorPage {\n}\nRuns.RunListResponsesPage = RunListResponsesPage;\nRuns.OutputItems = OutputItems;\nRuns.OutputItemListResponsesPage = OutputItemListResponsesPage;\n//# sourceMappingURL=runs.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport * as RunsAPI from \"./runs/runs.mjs\";\nimport { RunListResponsesPage, Runs, } from \"./runs/runs.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Evals extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.runs = new RunsAPI.Runs(this._client);\n    }\n    /**\n     * Create the structure of an evaluation that can be used to test a model's\n     * performance. An evaluation is a set of testing criteria and the config for a\n     * data source, which dictates the schema of the data used in the evaluation. After\n     * creating an evaluation, you can run it on different models and model parameters.\n     * We support several types of graders and datasources. For more information, see\n     * the [Evals guide](https://platform.openai.com/docs/guides/evals).\n     */\n    create(body, options) {\n        return this._client.post('/evals', { body, ...options });\n    }\n    /**\n     * Get an evaluation by ID.\n     */\n    retrieve(evalId, options) {\n        return this._client.get(`/evals/${evalId}`, options);\n    }\n    /**\n     * Update certain properties of an evaluation.\n     */\n    update(evalId, body, options) {\n        return this._client.post(`/evals/${evalId}`, { body, ...options });\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/evals', EvalListResponsesPage, { query, ...options });\n    }\n    /**\n     * Delete an evaluation.\n     */\n    del(evalId, options) {\n        return this._client.delete(`/evals/${evalId}`, options);\n    }\n}\nexport class EvalListResponsesPage extends CursorPage {\n}\nEvals.EvalListResponsesPage = EvalListResponsesPage;\nEvals.Runs = Runs;\nEvals.RunListResponsesPage = RunListResponsesPage;\n//# sourceMappingURL=evals.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nexport class Content extends APIResource {\n    /**\n     * Retrieve Container File Content\n     */\n    retrieve(containerId, fileId, options) {\n        return this._client.get(`/containers/${containerId}/files/${fileId}/content`, {\n            ...options,\n            headers: { Accept: 'application/binary', ...options?.headers },\n            __binaryResponse: true,\n        });\n    }\n}\n//# sourceMappingURL=content.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport * as Core from \"../../../core.mjs\";\nimport * as ContentAPI from \"./content.mjs\";\nimport { Content } from \"./content.mjs\";\nimport { CursorPage } from \"../../../pagination.mjs\";\nexport class Files extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.content = new ContentAPI.Content(this._client);\n    }\n    /**\n     * Create a Container File\n     *\n     * You can send either a multipart/form-data request with the raw file content, or\n     * a JSON request with a file ID.\n     */\n    create(containerId, body, options) {\n        return this._client.post(`/containers/${containerId}/files`, Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Retrieve Container File\n     */\n    retrieve(containerId, fileId, options) {\n        return this._client.get(`/containers/${containerId}/files/${fileId}`, options);\n    }\n    list(containerId, query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list(containerId, {}, query);\n        }\n        return this._client.getAPIList(`/containers/${containerId}/files`, FileListResponsesPage, {\n            query,\n            ...options,\n        });\n    }\n    /**\n     * Delete Container File\n     */\n    del(containerId, fileId, options) {\n        return this._client.delete(`/containers/${containerId}/files/${fileId}`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n}\nexport class FileListResponsesPage extends CursorPage {\n}\nFiles.FileListResponsesPage = FileListResponsesPage;\nFiles.Content = Content;\n//# sourceMappingURL=files.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport * as FilesAPI from \"./files/files.mjs\";\nimport { FileListResponsesPage, Files, } from \"./files/files.mjs\";\nimport { CursorPage } from \"../../pagination.mjs\";\nexport class Containers extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.files = new FilesAPI.Files(this._client);\n    }\n    /**\n     * Create Container\n     */\n    create(body, options) {\n        return this._client.post('/containers', { body, ...options });\n    }\n    /**\n     * Retrieve Container\n     */\n    retrieve(containerId, options) {\n        return this._client.get(`/containers/${containerId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/containers', ContainerListResponsesPage, { query, ...options });\n    }\n    /**\n     * Delete Container\n     */\n    del(containerId, options) {\n        return this._client.delete(`/containers/${containerId}`, {\n            ...options,\n            headers: { Accept: '*/*', ...options?.headers },\n        });\n    }\n}\nexport class ContainerListResponsesPage extends CursorPage {\n}\nContainers.ContainerListResponsesPage = ContainerListResponsesPage;\nContainers.Files = Files;\nContainers.FileListResponsesPage = FileListResponsesPage;\n//# sourceMappingURL=containers.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _a;\nimport * as qs from \"./internal/qs/index.mjs\";\nimport * as Core from \"./core.mjs\";\nimport * as Errors from \"./error.mjs\";\nimport * as Pagination from \"./pagination.mjs\";\nimport * as Uploads from \"./uploads.mjs\";\nimport * as API from \"./resources/index.mjs\";\nimport { Batches, BatchesPage, } from \"./resources/batches.mjs\";\nimport { Completions, } from \"./resources/completions.mjs\";\nimport { Embeddings, } from \"./resources/embeddings.mjs\";\nimport { FileObjectsPage, Files, } from \"./resources/files.mjs\";\nimport { Images, } from \"./resources/images.mjs\";\nimport { Models, ModelsPage } from \"./resources/models.mjs\";\nimport { Moderations, } from \"./resources/moderations.mjs\";\nimport { Audio } from \"./resources/audio/audio.mjs\";\nimport { Beta } from \"./resources/beta/beta.mjs\";\nimport { Chat } from \"./resources/chat/chat.mjs\";\nimport { ContainerListResponsesPage, Containers, } from \"./resources/containers/containers.mjs\";\nimport { EvalListResponsesPage, Evals, } from \"./resources/evals/evals.mjs\";\nimport { FineTuning } from \"./resources/fine-tuning/fine-tuning.mjs\";\nimport { Graders } from \"./resources/graders/graders.mjs\";\nimport { Responses } from \"./resources/responses/responses.mjs\";\nimport { Uploads as UploadsAPIUploads, } from \"./resources/uploads/uploads.mjs\";\nimport { VectorStoreSearchResponsesPage, VectorStores, VectorStoresPage, } from \"./resources/vector-stores/vector-stores.mjs\";\nimport { ChatCompletionsPage, } from \"./resources/chat/completions/completions.mjs\";\n/**\n * API Client for interfacing with the OpenAI API.\n */\nexport class OpenAI extends Core.APIClient {\n    /**\n     * API Client for interfacing with the OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('OPENAI_API_KEY'), organization = Core.readEnv('OPENAI_ORG_ID') ?? null, project = Core.readEnv('OPENAI_PROJECT_ID') ?? null, ...opts } = {}) {\n        if (apiKey === undefined) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\");\n        }\n        const options = {\n            apiKey,\n            organization,\n            project,\n            ...opts,\n            baseURL: baseURL || `https://api.openai.com/v1`,\n        };\n        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n            throw new Errors.OpenAIError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\\n\\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\\n\");\n        }\n        super({\n            baseURL: options.baseURL,\n            timeout: options.timeout ?? 600000 /* 10 minutes */,\n            httpAgent: options.httpAgent,\n            maxRetries: options.maxRetries,\n            fetch: options.fetch,\n        });\n        this.completions = new API.Completions(this);\n        this.chat = new API.Chat(this);\n        this.embeddings = new API.Embeddings(this);\n        this.files = new API.Files(this);\n        this.images = new API.Images(this);\n        this.audio = new API.Audio(this);\n        this.moderations = new API.Moderations(this);\n        this.models = new API.Models(this);\n        this.fineTuning = new API.FineTuning(this);\n        this.graders = new API.Graders(this);\n        this.vectorStores = new API.VectorStores(this);\n        this.beta = new API.Beta(this);\n        this.batches = new API.Batches(this);\n        this.uploads = new API.Uploads(this);\n        this.responses = new API.Responses(this);\n        this.evals = new API.Evals(this);\n        this.containers = new API.Containers(this);\n        this._options = options;\n        this.apiKey = apiKey;\n        this.organization = organization;\n        this.project = project;\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    defaultHeaders(opts) {\n        return {\n            ...super.defaultHeaders(opts),\n            'OpenAI-Organization': this.organization,\n            'OpenAI-Project': this.project,\n            ...this._options.defaultHeaders,\n        };\n    }\n    authHeaders(opts) {\n        return { Authorization: `Bearer ${this.apiKey}` };\n    }\n    stringifyQuery(query) {\n        return qs.stringify(query, { arrayFormat: 'brackets' });\n    }\n}\n_a = OpenAI;\nOpenAI.OpenAI = _a;\nOpenAI.DEFAULT_TIMEOUT = 600000; // 10 minutes\nOpenAI.OpenAIError = Errors.OpenAIError;\nOpenAI.APIError = Errors.APIError;\nOpenAI.APIConnectionError = Errors.APIConnectionError;\nOpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\nOpenAI.APIUserAbortError = Errors.APIUserAbortError;\nOpenAI.NotFoundError = Errors.NotFoundError;\nOpenAI.ConflictError = Errors.ConflictError;\nOpenAI.RateLimitError = Errors.RateLimitError;\nOpenAI.BadRequestError = Errors.BadRequestError;\nOpenAI.AuthenticationError = Errors.AuthenticationError;\nOpenAI.InternalServerError = Errors.InternalServerError;\nOpenAI.PermissionDeniedError = Errors.PermissionDeniedError;\nOpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;\nOpenAI.toFile = Uploads.toFile;\nOpenAI.fileFromPath = Uploads.fileFromPath;\nOpenAI.Completions = Completions;\nOpenAI.Chat = Chat;\nOpenAI.ChatCompletionsPage = ChatCompletionsPage;\nOpenAI.Embeddings = Embeddings;\nOpenAI.Files = Files;\nOpenAI.FileObjectsPage = FileObjectsPage;\nOpenAI.Images = Images;\nOpenAI.Audio = Audio;\nOpenAI.Moderations = Moderations;\nOpenAI.Models = Models;\nOpenAI.ModelsPage = ModelsPage;\nOpenAI.FineTuning = FineTuning;\nOpenAI.Graders = Graders;\nOpenAI.VectorStores = VectorStores;\nOpenAI.VectorStoresPage = VectorStoresPage;\nOpenAI.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;\nOpenAI.Beta = Beta;\nOpenAI.Batches = Batches;\nOpenAI.BatchesPage = BatchesPage;\nOpenAI.Uploads = UploadsAPIUploads;\nOpenAI.Responses = Responses;\nOpenAI.Evals = Evals;\nOpenAI.EvalListResponsesPage = EvalListResponsesPage;\nOpenAI.Containers = Containers;\nOpenAI.ContainerListResponsesPage = ContainerListResponsesPage;\n/** API Client for interfacing with the Azure OpenAI API. */\nexport class AzureOpenAI extends OpenAI {\n    /**\n     * API Client for interfacing with the Azure OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]\n     * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`\n     * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]\n     * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('AZURE_OPENAI_API_KEY'), apiVersion = Core.readEnv('OPENAI_API_VERSION'), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}) {\n        if (!apiVersion) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).\");\n        }\n        if (typeof azureADTokenProvider === 'function') {\n            dangerouslyAllowBrowser = true;\n        }\n        if (!azureADTokenProvider && !apiKey) {\n            throw new Errors.OpenAIError('Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.');\n        }\n        if (azureADTokenProvider && apiKey) {\n            throw new Errors.OpenAIError('The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.');\n        }\n        // define a sentinel value to avoid any typing issues\n        apiKey ?? (apiKey = API_KEY_SENTINEL);\n        opts.defaultQuery = { ...opts.defaultQuery, 'api-version': apiVersion };\n        if (!baseURL) {\n            if (!endpoint) {\n                endpoint = process.env['AZURE_OPENAI_ENDPOINT'];\n            }\n            if (!endpoint) {\n                throw new Errors.OpenAIError('Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable');\n            }\n            baseURL = `${endpoint}/openai`;\n        }\n        else {\n            if (endpoint) {\n                throw new Errors.OpenAIError('baseURL and endpoint are mutually exclusive');\n            }\n        }\n        super({\n            apiKey,\n            baseURL,\n            ...opts,\n            ...(dangerouslyAllowBrowser !== undefined ? { dangerouslyAllowBrowser } : {}),\n        });\n        this.apiVersion = '';\n        this._azureADTokenProvider = azureADTokenProvider;\n        this.apiVersion = apiVersion;\n        this.deploymentName = deployment;\n    }\n    buildRequest(options, props = {}) {\n        if (_deployments_endpoints.has(options.path) && options.method === 'post' && options.body !== undefined) {\n            if (!Core.isObj(options.body)) {\n                throw new Error('Expected request body to be an object');\n            }\n            const model = this.deploymentName || options.body['model'] || options.__metadata?.['model'];\n            if (model !== undefined && !this.baseURL.includes('/deployments')) {\n                options.path = `/deployments/${model}${options.path}`;\n            }\n        }\n        return super.buildRequest(options, props);\n    }\n    async _getAzureADToken() {\n        if (typeof this._azureADTokenProvider === 'function') {\n            const token = await this._azureADTokenProvider();\n            if (!token || typeof token !== 'string') {\n                throw new Errors.OpenAIError(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);\n            }\n            return token;\n        }\n        return undefined;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    async prepareOptions(opts) {\n        /**\n         * The user should provide a bearer token provider if they want\n         * to use Azure AD authentication. The user shouldn't set the\n         * Authorization header manually because the header is overwritten\n         * with the Azure AD token if a bearer token provider is provided.\n         */\n        if (opts.headers?.['api-key']) {\n            return super.prepareOptions(opts);\n        }\n        const token = await this._getAzureADToken();\n        opts.headers ?? (opts.headers = {});\n        if (token) {\n            opts.headers['Authorization'] = `Bearer ${token}`;\n        }\n        else if (this.apiKey !== API_KEY_SENTINEL) {\n            opts.headers['api-key'] = this.apiKey;\n        }\n        else {\n            throw new Errors.OpenAIError('Unable to handle auth');\n        }\n        return super.prepareOptions(opts);\n    }\n}\nconst _deployments_endpoints = new Set([\n    '/completions',\n    '/chat/completions',\n    '/embeddings',\n    '/audio/transcriptions',\n    '/audio/translations',\n    '/audio/speech',\n    '/images/generations',\n    '/images/edits',\n]);\nconst API_KEY_SENTINEL = '<Missing Key>';\nexport { toFile, fileFromPath } from \"./uploads.mjs\";\nexport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, NotFoundError, ConflictError, RateLimitError, BadRequestError, AuthenticationError, InternalServerError, PermissionDeniedError, UnprocessableEntityError, } from \"./error.mjs\";\nexport default OpenAI;\n//# sourceMappingURL=index.mjs.map","import nodeCrypto from 'node:crypto';\n\nconst subtle = nodeCrypto.webcrypto?.subtle || {};\nconst randomUUID = () => {\n  return nodeCrypto.randomUUID();\n};\nconst getRandomValues = (array) => {\n  return nodeCrypto.webcrypto.getRandomValues(array);\n};\nconst _crypto = {\n  randomUUID,\n  getRandomValues,\n  subtle\n};\n\nexport { _crypto as default, getRandomValues, randomUUID, subtle };\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pkg/error.ts\nvar error_exports = {};\n__export(error_exports, {\n  UpstashError: () => UpstashError,\n  UrlError: () => UrlError\n});\nvar UpstashError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"UpstashError\";\n  }\n};\nvar UrlError = class extends Error {\n  constructor(url) {\n    super(\n      `Upstash Redis client was passed an invalid URL. You should pass a URL starting with https. Received: \"${url}\". `\n    );\n    this.name = \"UrlError\";\n  }\n};\n\n// pkg/util.ts\nfunction parseRecursive(obj) {\n  const parsed = Array.isArray(obj) ? obj.map((o) => {\n    try {\n      return parseRecursive(o);\n    } catch {\n      return o;\n    }\n  }) : JSON.parse(obj);\n  if (typeof parsed === \"number\" && parsed.toString() !== obj) {\n    return obj;\n  }\n  return parsed;\n}\nfunction parseResponse(result) {\n  try {\n    return parseRecursive(result);\n  } catch {\n    return result;\n  }\n}\nfunction deserializeScanResponse(result) {\n  return [result[0], ...parseResponse(result.slice(1))];\n}\nfunction deserializeScanWithTypesResponse(result) {\n  const [cursor, keys] = result;\n  const parsedKeys = [];\n  for (let i = 0; i < keys.length; i += 2) {\n    parsedKeys.push({ key: keys[i], type: keys[i + 1] });\n  }\n  return [cursor, parsedKeys];\n}\nfunction mergeHeaders(...headers) {\n  const merged = {};\n  for (const header of headers) {\n    if (!header) continue;\n    for (const [key, value] of Object.entries(header)) {\n      if (value !== void 0 && value !== null) {\n        merged[key] = value;\n      }\n    }\n  }\n  return merged;\n}\n\n// pkg/http.ts\nvar HttpClient = class {\n  baseUrl;\n  headers;\n  options;\n  readYourWrites;\n  upstashSyncToken = \"\";\n  hasCredentials;\n  retry;\n  constructor(config) {\n    this.options = {\n      backend: config.options?.backend,\n      agent: config.agent,\n      responseEncoding: config.responseEncoding ?? \"base64\",\n      // default to base64\n      cache: config.cache,\n      signal: config.signal,\n      keepAlive: config.keepAlive ?? true\n    };\n    this.upstashSyncToken = \"\";\n    this.readYourWrites = config.readYourWrites ?? true;\n    this.baseUrl = (config.baseUrl || \"\").replace(/\\/$/, \"\");\n    const urlRegex = /^https?:\\/\\/[^\\s#$./?].\\S*$/;\n    if (this.baseUrl && !urlRegex.test(this.baseUrl)) {\n      throw new UrlError(this.baseUrl);\n    }\n    this.headers = {\n      \"Content-Type\": \"application/json\",\n      ...config.headers\n    };\n    this.hasCredentials = Boolean(this.baseUrl && this.headers.authorization.split(\" \")[1]);\n    if (this.options.responseEncoding === \"base64\") {\n      this.headers[\"Upstash-Encoding\"] = \"base64\";\n    }\n    this.retry = typeof config.retry === \"boolean\" && !config.retry ? {\n      attempts: 1,\n      backoff: () => 0\n    } : {\n      attempts: config.retry?.retries ?? 5,\n      backoff: config.retry?.backoff ?? ((retryCount) => Math.exp(retryCount) * 50)\n    };\n  }\n  mergeTelemetry(telemetry) {\n    this.headers = merge(this.headers, \"Upstash-Telemetry-Runtime\", telemetry.runtime);\n    this.headers = merge(this.headers, \"Upstash-Telemetry-Platform\", telemetry.platform);\n    this.headers = merge(this.headers, \"Upstash-Telemetry-Sdk\", telemetry.sdk);\n  }\n  async request(req) {\n    const requestHeaders = mergeHeaders(this.headers, req.headers ?? {});\n    const requestUrl = [this.baseUrl, ...req.path ?? []].join(\"/\");\n    const isEventStream = requestHeaders.Accept === \"text/event-stream\";\n    const requestOptions = {\n      //@ts-expect-error this should throw due to bun regression\n      cache: this.options.cache,\n      method: \"POST\",\n      headers: requestHeaders,\n      body: JSON.stringify(req.body),\n      keepalive: this.options.keepAlive,\n      agent: this.options.agent,\n      signal: req.signal ?? this.options.signal,\n      /**\n       * Fastly specific\n       */\n      backend: this.options.backend\n    };\n    if (!this.hasCredentials) {\n      console.warn(\n        \"[Upstash Redis] Redis client was initialized without url or token. Failed to execute command.\"\n      );\n    }\n    if (this.readYourWrites) {\n      const newHeader = this.upstashSyncToken;\n      this.headers[\"upstash-sync-token\"] = newHeader;\n    }\n    let res = null;\n    let error = null;\n    for (let i = 0; i <= this.retry.attempts; i++) {\n      try {\n        res = await fetch(requestUrl, requestOptions);\n        break;\n      } catch (error_) {\n        if (this.options.signal?.aborted) {\n          const myBlob = new Blob([\n            JSON.stringify({ result: this.options.signal.reason ?? \"Aborted\" })\n          ]);\n          const myOptions = {\n            status: 200,\n            statusText: this.options.signal.reason ?? \"Aborted\"\n          };\n          res = new Response(myBlob, myOptions);\n          break;\n        }\n        error = error_;\n        if (i < this.retry.attempts) {\n          await new Promise((r) => setTimeout(r, this.retry.backoff(i)));\n        }\n      }\n    }\n    if (!res) {\n      throw error ?? new Error(\"Exhausted all retries\");\n    }\n    if (!res.ok) {\n      const body2 = await res.json();\n      throw new UpstashError(`${body2.error}, command was: ${JSON.stringify(req.body)}`);\n    }\n    if (this.readYourWrites) {\n      const headers = res.headers;\n      this.upstashSyncToken = headers.get(\"upstash-sync-token\") ?? \"\";\n    }\n    if (isEventStream && req && req.onMessage && res.body) {\n      const reader = res.body.getReader();\n      const decoder = new TextDecoder();\n      (async () => {\n        try {\n          while (true) {\n            const { value, done } = await reader.read();\n            if (done) break;\n            const chunk = decoder.decode(value);\n            const lines = chunk.split(\"\\n\");\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const data = line.slice(6);\n                req.onMessage?.(data);\n              }\n            }\n          }\n        } catch (error2) {\n          if (error2 instanceof Error && error2.name === \"AbortError\") {\n          } else {\n            console.error(\"Stream reading error:\", error2);\n          }\n        } finally {\n          try {\n            await reader.cancel();\n          } catch {\n          }\n        }\n      })();\n      return { result: 1 };\n    }\n    const body = await res.json();\n    if (this.readYourWrites) {\n      const headers = res.headers;\n      this.upstashSyncToken = headers.get(\"upstash-sync-token\") ?? \"\";\n    }\n    if (this.options.responseEncoding === \"base64\") {\n      if (Array.isArray(body)) {\n        return body.map(({ result: result2, error: error2 }) => ({\n          result: decode(result2),\n          error: error2\n        }));\n      }\n      const result = decode(body.result);\n      return { result, error: body.error };\n    }\n    return body;\n  }\n};\nfunction base64decode(b64) {\n  let dec = \"\";\n  try {\n    const binString = atob(b64);\n    const size = binString.length;\n    const bytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n      bytes[i] = binString.charCodeAt(i);\n    }\n    dec = new TextDecoder().decode(bytes);\n  } catch {\n    dec = b64;\n  }\n  return dec;\n}\nfunction decode(raw) {\n  let result = void 0;\n  switch (typeof raw) {\n    case \"undefined\": {\n      return raw;\n    }\n    case \"number\": {\n      result = raw;\n      break;\n    }\n    case \"object\": {\n      if (Array.isArray(raw)) {\n        result = raw.map(\n          (v) => typeof v === \"string\" ? base64decode(v) : Array.isArray(v) ? v.map((element) => decode(element)) : v\n        );\n      } else {\n        result = null;\n      }\n      break;\n    }\n    case \"string\": {\n      result = raw === \"OK\" ? \"OK\" : base64decode(raw);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return result;\n}\nfunction merge(obj, key, value) {\n  if (!value) {\n    return obj;\n  }\n  obj[key] = obj[key] ? [obj[key], value].join(\",\") : value;\n  return obj;\n}\n\n// pkg/commands/command.ts\nvar defaultSerializer = (c) => {\n  switch (typeof c) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\": {\n      return c;\n    }\n    default: {\n      return JSON.stringify(c);\n    }\n  }\n};\nvar Command = class {\n  command;\n  serialize;\n  deserialize;\n  headers;\n  path;\n  onMessage;\n  isStreaming;\n  signal;\n  /**\n   * Create a new command instance.\n   *\n   * You can define a custom `deserialize` function. By default we try to deserialize as json.\n   */\n  constructor(command, opts) {\n    this.serialize = defaultSerializer;\n    this.deserialize = opts?.automaticDeserialization === void 0 || opts.automaticDeserialization ? opts?.deserialize ?? parseResponse : (x) => x;\n    this.command = command.map((c) => this.serialize(c));\n    this.headers = opts?.headers;\n    this.path = opts?.path;\n    this.onMessage = opts?.streamOptions?.onMessage;\n    this.isStreaming = opts?.streamOptions?.isStreaming ?? false;\n    this.signal = opts?.streamOptions?.signal;\n    if (opts?.latencyLogging) {\n      const originalExec = this.exec.bind(this);\n      this.exec = async (client) => {\n        const start = performance.now();\n        const result = await originalExec(client);\n        const end = performance.now();\n        const loggerResult = (end - start).toFixed(2);\n        console.log(\n          `Latency for \\x1B[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\\x1B[0m: \\x1B[38;2;0;255;255m${loggerResult} ms\\x1B[0m`\n        );\n        return result;\n      };\n    }\n  }\n  /**\n   * Execute the command using a client.\n   */\n  async exec(client) {\n    const { result, error } = await client.request({\n      body: this.command,\n      path: this.path,\n      upstashSyncToken: client.upstashSyncToken,\n      headers: this.headers,\n      onMessage: this.onMessage,\n      isStreaming: this.isStreaming,\n      signal: this.signal\n    });\n    if (error) {\n      throw new UpstashError(error);\n    }\n    if (result === void 0) {\n      throw new TypeError(\"Request did not return a result\");\n    }\n    return this.deserialize(result);\n  }\n};\n\n// pkg/commands/hrandfield.ts\nfunction deserialize(result) {\n  if (result.length === 0) {\n    return null;\n  }\n  const obj = {};\n  for (let i = 0; i < result.length; i += 2) {\n    const key = result[i];\n    const value = result[i + 1];\n    try {\n      obj[key] = JSON.parse(value);\n    } catch {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nvar HRandFieldCommand = class extends Command {\n  constructor(cmd, opts) {\n    const command = [\"hrandfield\", cmd[0]];\n    if (typeof cmd[1] === \"number\") {\n      command.push(cmd[1]);\n    }\n    if (cmd[2]) {\n      command.push(\"WITHVALUES\");\n    }\n    super(command, {\n      // @ts-expect-error to silence compiler\n      deserialize: cmd[2] ? (result) => deserialize(result) : opts?.deserialize,\n      ...opts\n    });\n  }\n};\n\n// pkg/commands/append.ts\nvar AppendCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"append\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/bitcount.ts\nvar BitCountCommand = class extends Command {\n  constructor([key, start, end], opts) {\n    const command = [\"bitcount\", key];\n    if (typeof start === \"number\") {\n      command.push(start);\n    }\n    if (typeof end === \"number\") {\n      command.push(end);\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/bitfield.ts\nvar BitFieldCommand = class {\n  constructor(args, client, opts, execOperation = (command) => command.exec(this.client)) {\n    this.client = client;\n    this.opts = opts;\n    this.execOperation = execOperation;\n    this.command = [\"bitfield\", ...args];\n  }\n  command;\n  chain(...args) {\n    this.command.push(...args);\n    return this;\n  }\n  get(...args) {\n    return this.chain(\"get\", ...args);\n  }\n  set(...args) {\n    return this.chain(\"set\", ...args);\n  }\n  incrby(...args) {\n    return this.chain(\"incrby\", ...args);\n  }\n  overflow(overflow) {\n    return this.chain(\"overflow\", overflow);\n  }\n  exec() {\n    const command = new Command(this.command, this.opts);\n    return this.execOperation(command);\n  }\n};\n\n// pkg/commands/bitop.ts\nvar BitOpCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"bitop\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/bitpos.ts\nvar BitPosCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"bitpos\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/copy.ts\nvar CopyCommand = class extends Command {\n  constructor([key, destinationKey, opts], commandOptions) {\n    super([\"COPY\", key, destinationKey, ...opts?.replace ? [\"REPLACE\"] : []], {\n      ...commandOptions,\n      deserialize(result) {\n        if (result > 0) {\n          return \"COPIED\";\n        }\n        return \"NOT_COPIED\";\n      }\n    });\n  }\n};\n\n// pkg/commands/dbsize.ts\nvar DBSizeCommand = class extends Command {\n  constructor(opts) {\n    super([\"dbsize\"], opts);\n  }\n};\n\n// pkg/commands/decr.ts\nvar DecrCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"decr\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/decrby.ts\nvar DecrByCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"decrby\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/del.ts\nvar DelCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"del\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/echo.ts\nvar EchoCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"echo\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/evalRo.ts\nvar EvalROCommand = class extends Command {\n  constructor([script, keys, args], opts) {\n    super([\"eval_ro\", script, keys.length, ...keys, ...args ?? []], opts);\n  }\n};\n\n// pkg/commands/eval.ts\nvar EvalCommand = class extends Command {\n  constructor([script, keys, args], opts) {\n    super([\"eval\", script, keys.length, ...keys, ...args ?? []], opts);\n  }\n};\n\n// pkg/commands/evalshaRo.ts\nvar EvalshaROCommand = class extends Command {\n  constructor([sha, keys, args], opts) {\n    super([\"evalsha_ro\", sha, keys.length, ...keys, ...args ?? []], opts);\n  }\n};\n\n// pkg/commands/evalsha.ts\nvar EvalshaCommand = class extends Command {\n  constructor([sha, keys, args], opts) {\n    super([\"evalsha\", sha, keys.length, ...keys, ...args ?? []], opts);\n  }\n};\n\n// pkg/commands/exec.ts\nvar ExecCommand = class extends Command {\n  constructor(cmd, opts) {\n    const normalizedCmd = cmd.map((arg) => typeof arg === \"string\" ? arg : String(arg));\n    super(normalizedCmd, opts);\n  }\n};\n\n// pkg/commands/exists.ts\nvar ExistsCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"exists\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/expire.ts\nvar ExpireCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"expire\", ...cmd.filter(Boolean)], opts);\n  }\n};\n\n// pkg/commands/expireat.ts\nvar ExpireAtCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"expireat\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/flushall.ts\nvar FlushAllCommand = class extends Command {\n  constructor(args, opts) {\n    const command = [\"flushall\"];\n    if (args && args.length > 0 && args[0].async) {\n      command.push(\"async\");\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/flushdb.ts\nvar FlushDBCommand = class extends Command {\n  constructor([opts], cmdOpts) {\n    const command = [\"flushdb\"];\n    if (opts?.async) {\n      command.push(\"async\");\n    }\n    super(command, cmdOpts);\n  }\n};\n\n// pkg/commands/geo_add.ts\nvar GeoAddCommand = class extends Command {\n  constructor([key, arg1, ...arg2], opts) {\n    const command = [\"geoadd\", key];\n    if (\"nx\" in arg1 && arg1.nx) {\n      command.push(\"nx\");\n    } else if (\"xx\" in arg1 && arg1.xx) {\n      command.push(\"xx\");\n    }\n    if (\"ch\" in arg1 && arg1.ch) {\n      command.push(\"ch\");\n    }\n    if (\"latitude\" in arg1 && arg1.latitude) {\n      command.push(arg1.longitude, arg1.latitude, arg1.member);\n    }\n    command.push(\n      ...arg2.flatMap(({ latitude, longitude, member }) => [longitude, latitude, member])\n    );\n    super(command, opts);\n  }\n};\n\n// pkg/commands/geo_dist.ts\nvar GeoDistCommand = class extends Command {\n  constructor([key, member1, member2, unit = \"M\"], opts) {\n    super([\"GEODIST\", key, member1, member2, unit], opts);\n  }\n};\n\n// pkg/commands/geo_hash.ts\nvar GeoHashCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key] = cmd;\n    const members = Array.isArray(cmd[1]) ? cmd[1] : cmd.slice(1);\n    super([\"GEOHASH\", key, ...members], opts);\n  }\n};\n\n// pkg/commands/geo_pos.ts\nvar GeoPosCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key] = cmd;\n    const members = Array.isArray(cmd[1]) ? cmd[1] : cmd.slice(1);\n    super([\"GEOPOS\", key, ...members], {\n      deserialize: (result) => transform(result),\n      ...opts\n    });\n  }\n};\nfunction transform(result) {\n  const final = [];\n  for (const pos of result) {\n    if (!pos?.[0] || !pos?.[1]) {\n      continue;\n    }\n    final.push({ lng: Number.parseFloat(pos[0]), lat: Number.parseFloat(pos[1]) });\n  }\n  return final;\n}\n\n// pkg/commands/geo_search.ts\nvar GeoSearchCommand = class extends Command {\n  constructor([key, centerPoint, shape, order, opts], commandOptions) {\n    const command = [\"GEOSEARCH\", key];\n    if (centerPoint.type === \"FROMMEMBER\" || centerPoint.type === \"frommember\") {\n      command.push(centerPoint.type, centerPoint.member);\n    }\n    if (centerPoint.type === \"FROMLONLAT\" || centerPoint.type === \"fromlonlat\") {\n      command.push(centerPoint.type, centerPoint.coordinate.lon, centerPoint.coordinate.lat);\n    }\n    if (shape.type === \"BYRADIUS\" || shape.type === \"byradius\") {\n      command.push(shape.type, shape.radius, shape.radiusType);\n    }\n    if (shape.type === \"BYBOX\" || shape.type === \"bybox\") {\n      command.push(shape.type, shape.rect.width, shape.rect.height, shape.rectType);\n    }\n    command.push(order);\n    if (opts?.count) {\n      command.push(\"COUNT\", opts.count.limit, ...opts.count.any ? [\"ANY\"] : []);\n    }\n    const transform2 = (result) => {\n      if (!opts?.withCoord && !opts?.withDist && !opts?.withHash) {\n        return result.map((member) => {\n          try {\n            return { member: JSON.parse(member) };\n          } catch {\n            return { member };\n          }\n        });\n      }\n      return result.map((members) => {\n        let counter = 1;\n        const obj = {};\n        try {\n          obj.member = JSON.parse(members[0]);\n        } catch {\n          obj.member = members[0];\n        }\n        if (opts.withDist) {\n          obj.dist = Number.parseFloat(members[counter++]);\n        }\n        if (opts.withHash) {\n          obj.hash = members[counter++].toString();\n        }\n        if (opts.withCoord) {\n          obj.coord = {\n            long: Number.parseFloat(members[counter][0]),\n            lat: Number.parseFloat(members[counter][1])\n          };\n        }\n        return obj;\n      });\n    };\n    super(\n      [\n        ...command,\n        ...opts?.withCoord ? [\"WITHCOORD\"] : [],\n        ...opts?.withDist ? [\"WITHDIST\"] : [],\n        ...opts?.withHash ? [\"WITHHASH\"] : []\n      ],\n      {\n        deserialize: transform2,\n        ...commandOptions\n      }\n    );\n  }\n};\n\n// pkg/commands/geo_search_store.ts\nvar GeoSearchStoreCommand = class extends Command {\n  constructor([destination, key, centerPoint, shape, order, opts], commandOptions) {\n    const command = [\"GEOSEARCHSTORE\", destination, key];\n    if (centerPoint.type === \"FROMMEMBER\" || centerPoint.type === \"frommember\") {\n      command.push(centerPoint.type, centerPoint.member);\n    }\n    if (centerPoint.type === \"FROMLONLAT\" || centerPoint.type === \"fromlonlat\") {\n      command.push(centerPoint.type, centerPoint.coordinate.lon, centerPoint.coordinate.lat);\n    }\n    if (shape.type === \"BYRADIUS\" || shape.type === \"byradius\") {\n      command.push(shape.type, shape.radius, shape.radiusType);\n    }\n    if (shape.type === \"BYBOX\" || shape.type === \"bybox\") {\n      command.push(shape.type, shape.rect.width, shape.rect.height, shape.rectType);\n    }\n    command.push(order);\n    if (opts?.count) {\n      command.push(\"COUNT\", opts.count.limit, ...opts.count.any ? [\"ANY\"] : []);\n    }\n    super([...command, ...opts?.storeDist ? [\"STOREDIST\"] : []], commandOptions);\n  }\n};\n\n// pkg/commands/get.ts\nvar GetCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"get\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/getbit.ts\nvar GetBitCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"getbit\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/getdel.ts\nvar GetDelCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"getdel\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/getex.ts\nvar GetExCommand = class extends Command {\n  constructor([key, opts], cmdOpts) {\n    const command = [\"getex\", key];\n    if (opts) {\n      if (\"ex\" in opts && typeof opts.ex === \"number\") {\n        command.push(\"ex\", opts.ex);\n      } else if (\"px\" in opts && typeof opts.px === \"number\") {\n        command.push(\"px\", opts.px);\n      } else if (\"exat\" in opts && typeof opts.exat === \"number\") {\n        command.push(\"exat\", opts.exat);\n      } else if (\"pxat\" in opts && typeof opts.pxat === \"number\") {\n        command.push(\"pxat\", opts.pxat);\n      } else if (\"persist\" in opts && opts.persist) {\n        command.push(\"persist\");\n      }\n    }\n    super(command, cmdOpts);\n  }\n};\n\n// pkg/commands/getrange.ts\nvar GetRangeCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"getrange\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/getset.ts\nvar GetSetCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"getset\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hdel.ts\nvar HDelCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hdel\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hexists.ts\nvar HExistsCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hexists\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hexpire.ts\nvar HExpireCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields, seconds, option] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super(\n      [\n        \"hexpire\",\n        key,\n        seconds,\n        ...option ? [option] : [],\n        \"FIELDS\",\n        fieldArray.length,\n        ...fieldArray\n      ],\n      opts\n    );\n  }\n};\n\n// pkg/commands/hexpireat.ts\nvar HExpireAtCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields, timestamp, option] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super(\n      [\n        \"hexpireat\",\n        key,\n        timestamp,\n        ...option ? [option] : [],\n        \"FIELDS\",\n        fieldArray.length,\n        ...fieldArray\n      ],\n      opts\n    );\n  }\n};\n\n// pkg/commands/hexpiretime.ts\nvar HExpireTimeCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super([\"hexpiretime\", key, \"FIELDS\", fieldArray.length, ...fieldArray], opts);\n  }\n};\n\n// pkg/commands/hpersist.ts\nvar HPersistCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super([\"hpersist\", key, \"FIELDS\", fieldArray.length, ...fieldArray], opts);\n  }\n};\n\n// pkg/commands/hpexpire.ts\nvar HPExpireCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields, milliseconds, option] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super(\n      [\n        \"hpexpire\",\n        key,\n        milliseconds,\n        ...option ? [option] : [],\n        \"FIELDS\",\n        fieldArray.length,\n        ...fieldArray\n      ],\n      opts\n    );\n  }\n};\n\n// pkg/commands/hpexpireat.ts\nvar HPExpireAtCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields, timestamp, option] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super(\n      [\n        \"hpexpireat\",\n        key,\n        timestamp,\n        ...option ? [option] : [],\n        \"FIELDS\",\n        fieldArray.length,\n        ...fieldArray\n      ],\n      opts\n    );\n  }\n};\n\n// pkg/commands/hpexpiretime.ts\nvar HPExpireTimeCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super([\"hpexpiretime\", key, \"FIELDS\", fieldArray.length, ...fieldArray], opts);\n  }\n};\n\n// pkg/commands/hpttl.ts\nvar HPTtlCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super([\"hpttl\", key, \"FIELDS\", fieldArray.length, ...fieldArray], opts);\n  }\n};\n\n// pkg/commands/hget.ts\nvar HGetCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hget\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hgetall.ts\nfunction deserialize2(result) {\n  if (result.length === 0) {\n    return null;\n  }\n  const obj = {};\n  for (let i = 0; i < result.length; i += 2) {\n    const key = result[i];\n    const value = result[i + 1];\n    try {\n      const valueIsNumberAndNotSafeInteger = !Number.isNaN(Number(value)) && !Number.isSafeInteger(Number(value));\n      obj[key] = valueIsNumberAndNotSafeInteger ? value : JSON.parse(value);\n    } catch {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nvar HGetAllCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hgetall\", ...cmd], {\n      deserialize: (result) => deserialize2(result),\n      ...opts\n    });\n  }\n};\n\n// pkg/commands/hincrby.ts\nvar HIncrByCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hincrby\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hincrbyfloat.ts\nvar HIncrByFloatCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hincrbyfloat\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hkeys.ts\nvar HKeysCommand = class extends Command {\n  constructor([key], opts) {\n    super([\"hkeys\", key], opts);\n  }\n};\n\n// pkg/commands/hlen.ts\nvar HLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hlen\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hmget.ts\nfunction deserialize3(fields, result) {\n  if (result.every((field) => field === null)) {\n    return null;\n  }\n  const obj = {};\n  for (const [i, field] of fields.entries()) {\n    try {\n      obj[field] = JSON.parse(result[i]);\n    } catch {\n      obj[field] = result[i];\n    }\n  }\n  return obj;\n}\nvar HMGetCommand = class extends Command {\n  constructor([key, ...fields], opts) {\n    super([\"hmget\", key, ...fields], {\n      deserialize: (result) => deserialize3(fields, result),\n      ...opts\n    });\n  }\n};\n\n// pkg/commands/hmset.ts\nvar HMSetCommand = class extends Command {\n  constructor([key, kv], opts) {\n    super([\"hmset\", key, ...Object.entries(kv).flatMap(([field, value]) => [field, value])], opts);\n  }\n};\n\n// pkg/commands/hscan.ts\nvar HScanCommand = class extends Command {\n  constructor([key, cursor, cmdOpts], opts) {\n    const command = [\"hscan\", key, cursor];\n    if (cmdOpts?.match) {\n      command.push(\"match\", cmdOpts.match);\n    }\n    if (typeof cmdOpts?.count === \"number\") {\n      command.push(\"count\", cmdOpts.count);\n    }\n    super(command, {\n      deserialize: deserializeScanResponse,\n      ...opts\n    });\n  }\n};\n\n// pkg/commands/hset.ts\nvar HSetCommand = class extends Command {\n  constructor([key, kv], opts) {\n    super([\"hset\", key, ...Object.entries(kv).flatMap(([field, value]) => [field, value])], opts);\n  }\n};\n\n// pkg/commands/hsetnx.ts\nvar HSetNXCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hsetnx\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/hstrlen.ts\nvar HStrLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hstrlen\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/httl.ts\nvar HTtlCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, fields] = cmd;\n    const fieldArray = Array.isArray(fields) ? fields : [fields];\n    super([\"httl\", key, \"FIELDS\", fieldArray.length, ...fieldArray], opts);\n  }\n};\n\n// pkg/commands/hvals.ts\nvar HValsCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"hvals\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/incr.ts\nvar IncrCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"incr\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/incrby.ts\nvar IncrByCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"incrby\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/incrbyfloat.ts\nvar IncrByFloatCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"incrbyfloat\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_arrappend.ts\nvar JsonArrAppendCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.ARRAPPEND\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_arrindex.ts\nvar JsonArrIndexCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.ARRINDEX\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_arrinsert.ts\nvar JsonArrInsertCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.ARRINSERT\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_arrlen.ts\nvar JsonArrLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.ARRLEN\", cmd[0], cmd[1] ?? \"$\"], opts);\n  }\n};\n\n// pkg/commands/json_arrpop.ts\nvar JsonArrPopCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.ARRPOP\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_arrtrim.ts\nvar JsonArrTrimCommand = class extends Command {\n  constructor(cmd, opts) {\n    const path = cmd[1] ?? \"$\";\n    const start = cmd[2] ?? 0;\n    const stop = cmd[3] ?? 0;\n    super([\"JSON.ARRTRIM\", cmd[0], path, start, stop], opts);\n  }\n};\n\n// pkg/commands/json_clear.ts\nvar JsonClearCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.CLEAR\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_del.ts\nvar JsonDelCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.DEL\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_forget.ts\nvar JsonForgetCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.FORGET\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_get.ts\nvar JsonGetCommand = class extends Command {\n  constructor(cmd, opts) {\n    const command = [\"JSON.GET\"];\n    if (typeof cmd[1] === \"string\") {\n      command.push(...cmd);\n    } else {\n      command.push(cmd[0]);\n      if (cmd[1]) {\n        if (cmd[1].indent) {\n          command.push(\"INDENT\", cmd[1].indent);\n        }\n        if (cmd[1].newline) {\n          command.push(\"NEWLINE\", cmd[1].newline);\n        }\n        if (cmd[1].space) {\n          command.push(\"SPACE\", cmd[1].space);\n        }\n      }\n      command.push(...cmd.slice(2));\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/json_merge.ts\nvar JsonMergeCommand = class extends Command {\n  constructor(cmd, opts) {\n    const command = [\"JSON.MERGE\", ...cmd];\n    super(command, opts);\n  }\n};\n\n// pkg/commands/json_mget.ts\nvar JsonMGetCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.MGET\", ...cmd[0], cmd[1]], opts);\n  }\n};\n\n// pkg/commands/json_mset.ts\nvar JsonMSetCommand = class extends Command {\n  constructor(cmd, opts) {\n    const command = [\"JSON.MSET\"];\n    for (const c of cmd) {\n      command.push(c.key, c.path, c.value);\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/json_numincrby.ts\nvar JsonNumIncrByCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.NUMINCRBY\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_nummultby.ts\nvar JsonNumMultByCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.NUMMULTBY\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_objkeys.ts\nvar JsonObjKeysCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.OBJKEYS\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_objlen.ts\nvar JsonObjLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.OBJLEN\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_resp.ts\nvar JsonRespCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.RESP\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_set.ts\nvar JsonSetCommand = class extends Command {\n  constructor(cmd, opts) {\n    const command = [\"JSON.SET\", cmd[0], cmd[1], cmd[2]];\n    if (cmd[3]) {\n      if (cmd[3].nx) {\n        command.push(\"NX\");\n      } else if (cmd[3].xx) {\n        command.push(\"XX\");\n      }\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/json_strappend.ts\nvar JsonStrAppendCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.STRAPPEND\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_strlen.ts\nvar JsonStrLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.STRLEN\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_toggle.ts\nvar JsonToggleCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.TOGGLE\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/json_type.ts\nvar JsonTypeCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"JSON.TYPE\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/keys.ts\nvar KeysCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"keys\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lindex.ts\nvar LIndexCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lindex\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/linsert.ts\nvar LInsertCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"linsert\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/llen.ts\nvar LLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"llen\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lmove.ts\nvar LMoveCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lmove\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lmpop.ts\nvar LmPopCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [numkeys, keys, direction, count] = cmd;\n    super([\"LMPOP\", numkeys, ...keys, direction, ...count ? [\"COUNT\", count] : []], opts);\n  }\n};\n\n// pkg/commands/lpop.ts\nvar LPopCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lpop\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lpos.ts\nvar LPosCommand = class extends Command {\n  constructor(cmd, opts) {\n    const args = [\"lpos\", cmd[0], cmd[1]];\n    if (typeof cmd[2]?.rank === \"number\") {\n      args.push(\"rank\", cmd[2].rank);\n    }\n    if (typeof cmd[2]?.count === \"number\") {\n      args.push(\"count\", cmd[2].count);\n    }\n    if (typeof cmd[2]?.maxLen === \"number\") {\n      args.push(\"maxLen\", cmd[2].maxLen);\n    }\n    super(args, opts);\n  }\n};\n\n// pkg/commands/lpush.ts\nvar LPushCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lpush\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lpushx.ts\nvar LPushXCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lpushx\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lrange.ts\nvar LRangeCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lrange\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lrem.ts\nvar LRemCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lrem\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/lset.ts\nvar LSetCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"lset\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/ltrim.ts\nvar LTrimCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"ltrim\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/mget.ts\nvar MGetCommand = class extends Command {\n  constructor(cmd, opts) {\n    const keys = Array.isArray(cmd[0]) ? cmd[0] : cmd;\n    super([\"mget\", ...keys], opts);\n  }\n};\n\n// pkg/commands/mset.ts\nvar MSetCommand = class extends Command {\n  constructor([kv], opts) {\n    super([\"mset\", ...Object.entries(kv).flatMap(([key, value]) => [key, value])], opts);\n  }\n};\n\n// pkg/commands/msetnx.ts\nvar MSetNXCommand = class extends Command {\n  constructor([kv], opts) {\n    super([\"msetnx\", ...Object.entries(kv).flat()], opts);\n  }\n};\n\n// pkg/commands/persist.ts\nvar PersistCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"persist\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/pexpire.ts\nvar PExpireCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"pexpire\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/pexpireat.ts\nvar PExpireAtCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"pexpireat\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/pfadd.ts\nvar PfAddCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"pfadd\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/pfcount.ts\nvar PfCountCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"pfcount\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/pfmerge.ts\nvar PfMergeCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"pfmerge\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/ping.ts\nvar PingCommand = class extends Command {\n  constructor(cmd, opts) {\n    const command = [\"ping\"];\n    if (cmd?.[0] !== void 0) {\n      command.push(cmd[0]);\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/psetex.ts\nvar PSetEXCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"psetex\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/pttl.ts\nvar PTtlCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"pttl\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/publish.ts\nvar PublishCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"publish\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/randomkey.ts\nvar RandomKeyCommand = class extends Command {\n  constructor(opts) {\n    super([\"randomkey\"], opts);\n  }\n};\n\n// pkg/commands/rename.ts\nvar RenameCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"rename\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/renamenx.ts\nvar RenameNXCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"renamenx\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/rpop.ts\nvar RPopCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"rpop\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/rpush.ts\nvar RPushCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"rpush\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/rpushx.ts\nvar RPushXCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"rpushx\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sadd.ts\nvar SAddCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sadd\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/scan.ts\nvar ScanCommand = class extends Command {\n  constructor([cursor, opts], cmdOpts) {\n    const command = [\"scan\", cursor];\n    if (opts?.match) {\n      command.push(\"match\", opts.match);\n    }\n    if (typeof opts?.count === \"number\") {\n      command.push(\"count\", opts.count);\n    }\n    if (opts && \"withType\" in opts && opts.withType === true) {\n      command.push(\"withtype\");\n    } else if (opts && \"type\" in opts && opts.type && opts.type.length > 0) {\n      command.push(\"type\", opts.type);\n    }\n    super(command, {\n      // @ts-expect-error ignore types here\n      deserialize: opts?.withType ? deserializeScanWithTypesResponse : deserializeScanResponse,\n      ...cmdOpts\n    });\n  }\n};\n\n// pkg/commands/scard.ts\nvar SCardCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"scard\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/script_exists.ts\nvar ScriptExistsCommand = class extends Command {\n  constructor(hashes, opts) {\n    super([\"script\", \"exists\", ...hashes], {\n      deserialize: (result) => result,\n      ...opts\n    });\n  }\n};\n\n// pkg/commands/script_flush.ts\nvar ScriptFlushCommand = class extends Command {\n  constructor([opts], cmdOpts) {\n    const cmd = [\"script\", \"flush\"];\n    if (opts?.sync) {\n      cmd.push(\"sync\");\n    } else if (opts?.async) {\n      cmd.push(\"async\");\n    }\n    super(cmd, cmdOpts);\n  }\n};\n\n// pkg/commands/script_load.ts\nvar ScriptLoadCommand = class extends Command {\n  constructor(args, opts) {\n    super([\"script\", \"load\", ...args], opts);\n  }\n};\n\n// pkg/commands/sdiff.ts\nvar SDiffCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sdiff\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sdiffstore.ts\nvar SDiffStoreCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sdiffstore\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/set.ts\nvar SetCommand = class extends Command {\n  constructor([key, value, opts], cmdOpts) {\n    const command = [\"set\", key, value];\n    if (opts) {\n      if (\"nx\" in opts && opts.nx) {\n        command.push(\"nx\");\n      } else if (\"xx\" in opts && opts.xx) {\n        command.push(\"xx\");\n      }\n      if (\"get\" in opts && opts.get) {\n        command.push(\"get\");\n      }\n      if (\"ex\" in opts && typeof opts.ex === \"number\") {\n        command.push(\"ex\", opts.ex);\n      } else if (\"px\" in opts && typeof opts.px === \"number\") {\n        command.push(\"px\", opts.px);\n      } else if (\"exat\" in opts && typeof opts.exat === \"number\") {\n        command.push(\"exat\", opts.exat);\n      } else if (\"pxat\" in opts && typeof opts.pxat === \"number\") {\n        command.push(\"pxat\", opts.pxat);\n      } else if (\"keepTtl\" in opts && opts.keepTtl) {\n        command.push(\"keepTtl\");\n      }\n    }\n    super(command, cmdOpts);\n  }\n};\n\n// pkg/commands/setbit.ts\nvar SetBitCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"setbit\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/setex.ts\nvar SetExCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"setex\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/setnx.ts\nvar SetNxCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"setnx\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/setrange.ts\nvar SetRangeCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"setrange\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sinter.ts\nvar SInterCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sinter\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sinterstore.ts\nvar SInterStoreCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sinterstore\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sismember.ts\nvar SIsMemberCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sismember\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/smembers.ts\nvar SMembersCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"smembers\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/smismember.ts\nvar SMIsMemberCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"smismember\", cmd[0], ...cmd[1]], opts);\n  }\n};\n\n// pkg/commands/smove.ts\nvar SMoveCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"smove\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/spop.ts\nvar SPopCommand = class extends Command {\n  constructor([key, count], opts) {\n    const command = [\"spop\", key];\n    if (typeof count === \"number\") {\n      command.push(count);\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/srandmember.ts\nvar SRandMemberCommand = class extends Command {\n  constructor([key, count], opts) {\n    const command = [\"srandmember\", key];\n    if (typeof count === \"number\") {\n      command.push(count);\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/srem.ts\nvar SRemCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"srem\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sscan.ts\nvar SScanCommand = class extends Command {\n  constructor([key, cursor, opts], cmdOpts) {\n    const command = [\"sscan\", key, cursor];\n    if (opts?.match) {\n      command.push(\"match\", opts.match);\n    }\n    if (typeof opts?.count === \"number\") {\n      command.push(\"count\", opts.count);\n    }\n    super(command, {\n      deserialize: deserializeScanResponse,\n      ...cmdOpts\n    });\n  }\n};\n\n// pkg/commands/strlen.ts\nvar StrLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"strlen\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sunion.ts\nvar SUnionCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sunion\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/sunionstore.ts\nvar SUnionStoreCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"sunionstore\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/time.ts\nvar TimeCommand = class extends Command {\n  constructor(opts) {\n    super([\"time\"], opts);\n  }\n};\n\n// pkg/commands/touch.ts\nvar TouchCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"touch\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/ttl.ts\nvar TtlCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"ttl\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/type.ts\nvar TypeCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"type\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/unlink.ts\nvar UnlinkCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"unlink\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/xack.ts\nvar XAckCommand = class extends Command {\n  constructor([key, group, id], opts) {\n    const ids = Array.isArray(id) ? [...id] : [id];\n    super([\"XACK\", key, group, ...ids], opts);\n  }\n};\n\n// pkg/commands/xadd.ts\nvar XAddCommand = class extends Command {\n  constructor([key, id, entries, opts], commandOptions) {\n    const command = [\"XADD\", key];\n    if (opts) {\n      if (opts.nomkStream) {\n        command.push(\"NOMKSTREAM\");\n      }\n      if (opts.trim) {\n        command.push(opts.trim.type, opts.trim.comparison, opts.trim.threshold);\n        if (opts.trim.limit !== void 0) {\n          command.push(\"LIMIT\", opts.trim.limit);\n        }\n      }\n    }\n    command.push(id);\n    for (const [k, v] of Object.entries(entries)) {\n      command.push(k, v);\n    }\n    super(command, commandOptions);\n  }\n};\n\n// pkg/commands/xautoclaim.ts\nvar XAutoClaim = class extends Command {\n  constructor([key, group, consumer, minIdleTime, start, options], opts) {\n    const commands = [];\n    if (options?.count) {\n      commands.push(\"COUNT\", options.count);\n    }\n    if (options?.justId) {\n      commands.push(\"JUSTID\");\n    }\n    super([\"XAUTOCLAIM\", key, group, consumer, minIdleTime, start, ...commands], opts);\n  }\n};\n\n// pkg/commands/xclaim.ts\nvar XClaimCommand = class extends Command {\n  constructor([key, group, consumer, minIdleTime, id, options], opts) {\n    const ids = Array.isArray(id) ? [...id] : [id];\n    const commands = [];\n    if (options?.idleMS) {\n      commands.push(\"IDLE\", options.idleMS);\n    }\n    if (options?.idleMS) {\n      commands.push(\"TIME\", options.timeMS);\n    }\n    if (options?.retryCount) {\n      commands.push(\"RETRYCOUNT\", options.retryCount);\n    }\n    if (options?.force) {\n      commands.push(\"FORCE\");\n    }\n    if (options?.justId) {\n      commands.push(\"JUSTID\");\n    }\n    if (options?.lastId) {\n      commands.push(\"LASTID\", options.lastId);\n    }\n    super([\"XCLAIM\", key, group, consumer, minIdleTime, ...ids, ...commands], opts);\n  }\n};\n\n// pkg/commands/xdel.ts\nvar XDelCommand = class extends Command {\n  constructor([key, ids], opts) {\n    const cmds = Array.isArray(ids) ? [...ids] : [ids];\n    super([\"XDEL\", key, ...cmds], opts);\n  }\n};\n\n// pkg/commands/xgroup.ts\nvar XGroupCommand = class extends Command {\n  constructor([key, opts], commandOptions) {\n    const command = [\"XGROUP\"];\n    switch (opts.type) {\n      case \"CREATE\": {\n        command.push(\"CREATE\", key, opts.group, opts.id);\n        if (opts.options) {\n          if (opts.options.MKSTREAM) {\n            command.push(\"MKSTREAM\");\n          }\n          if (opts.options.ENTRIESREAD !== void 0) {\n            command.push(\"ENTRIESREAD\", opts.options.ENTRIESREAD.toString());\n          }\n        }\n        break;\n      }\n      case \"CREATECONSUMER\": {\n        command.push(\"CREATECONSUMER\", key, opts.group, opts.consumer);\n        break;\n      }\n      case \"DELCONSUMER\": {\n        command.push(\"DELCONSUMER\", key, opts.group, opts.consumer);\n        break;\n      }\n      case \"DESTROY\": {\n        command.push(\"DESTROY\", key, opts.group);\n        break;\n      }\n      case \"SETID\": {\n        command.push(\"SETID\", key, opts.group, opts.id);\n        if (opts.options?.ENTRIESREAD !== void 0) {\n          command.push(\"ENTRIESREAD\", opts.options.ENTRIESREAD.toString());\n        }\n        break;\n      }\n      default: {\n        throw new Error(\"Invalid XGROUP\");\n      }\n    }\n    super(command, commandOptions);\n  }\n};\n\n// pkg/commands/xinfo.ts\nvar XInfoCommand = class extends Command {\n  constructor([key, options], opts) {\n    const cmds = [];\n    if (options.type === \"CONSUMERS\") {\n      cmds.push(\"CONSUMERS\", key, options.group);\n    } else {\n      cmds.push(\"GROUPS\", key);\n    }\n    super([\"XINFO\", ...cmds], opts);\n  }\n};\n\n// pkg/commands/xlen.ts\nvar XLenCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"XLEN\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/xpending.ts\nvar XPendingCommand = class extends Command {\n  constructor([key, group, start, end, count, options], opts) {\n    const consumers = options?.consumer === void 0 ? [] : Array.isArray(options.consumer) ? [...options.consumer] : [options.consumer];\n    super(\n      [\n        \"XPENDING\",\n        key,\n        group,\n        ...options?.idleTime ? [\"IDLE\", options.idleTime] : [],\n        start,\n        end,\n        count,\n        ...consumers\n      ],\n      opts\n    );\n  }\n};\n\n// pkg/commands/xrange.ts\nfunction deserialize4(result) {\n  const obj = {};\n  for (const e of result) {\n    for (let i = 0; i < e.length; i += 2) {\n      const streamId = e[i];\n      const entries = e[i + 1];\n      if (!(streamId in obj)) {\n        obj[streamId] = {};\n      }\n      for (let j = 0; j < entries.length; j += 2) {\n        const field = entries[j];\n        const value = entries[j + 1];\n        try {\n          obj[streamId][field] = JSON.parse(value);\n        } catch {\n          obj[streamId][field] = value;\n        }\n      }\n    }\n  }\n  return obj;\n}\nvar XRangeCommand = class extends Command {\n  constructor([key, start, end, count], opts) {\n    const command = [\"XRANGE\", key, start, end];\n    if (typeof count === \"number\") {\n      command.push(\"COUNT\", count);\n    }\n    super(command, {\n      deserialize: (result) => deserialize4(result),\n      ...opts\n    });\n  }\n};\n\n// pkg/commands/xread.ts\nvar UNBALANCED_XREAD_ERR = \"ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified\";\nvar XReadCommand = class extends Command {\n  constructor([key, id, options], opts) {\n    if (Array.isArray(key) && Array.isArray(id) && key.length !== id.length) {\n      throw new Error(UNBALANCED_XREAD_ERR);\n    }\n    const commands = [];\n    if (typeof options?.count === \"number\") {\n      commands.push(\"COUNT\", options.count);\n    }\n    if (typeof options?.blockMS === \"number\") {\n      commands.push(\"BLOCK\", options.blockMS);\n    }\n    commands.push(\n      \"STREAMS\",\n      ...Array.isArray(key) ? [...key] : [key],\n      ...Array.isArray(id) ? [...id] : [id]\n    );\n    super([\"XREAD\", ...commands], opts);\n  }\n};\n\n// pkg/commands/xreadgroup.ts\nvar UNBALANCED_XREADGROUP_ERR = \"ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified\";\nvar XReadGroupCommand = class extends Command {\n  constructor([group, consumer, key, id, options], opts) {\n    if (Array.isArray(key) && Array.isArray(id) && key.length !== id.length) {\n      throw new Error(UNBALANCED_XREADGROUP_ERR);\n    }\n    const commands = [];\n    if (typeof options?.count === \"number\") {\n      commands.push(\"COUNT\", options.count);\n    }\n    if (typeof options?.blockMS === \"number\") {\n      commands.push(\"BLOCK\", options.blockMS);\n    }\n    if (typeof options?.NOACK === \"boolean\" && options.NOACK) {\n      commands.push(\"NOACK\");\n    }\n    commands.push(\n      \"STREAMS\",\n      ...Array.isArray(key) ? [...key] : [key],\n      ...Array.isArray(id) ? [...id] : [id]\n    );\n    super([\"XREADGROUP\", \"GROUP\", group, consumer, ...commands], opts);\n  }\n};\n\n// pkg/commands/xrevrange.ts\nvar XRevRangeCommand = class extends Command {\n  constructor([key, end, start, count], opts) {\n    const command = [\"XREVRANGE\", key, end, start];\n    if (typeof count === \"number\") {\n      command.push(\"COUNT\", count);\n    }\n    super(command, {\n      deserialize: (result) => deserialize5(result),\n      ...opts\n    });\n  }\n};\nfunction deserialize5(result) {\n  const obj = {};\n  for (const e of result) {\n    for (let i = 0; i < e.length; i += 2) {\n      const streamId = e[i];\n      const entries = e[i + 1];\n      if (!(streamId in obj)) {\n        obj[streamId] = {};\n      }\n      for (let j = 0; j < entries.length; j += 2) {\n        const field = entries[j];\n        const value = entries[j + 1];\n        try {\n          obj[streamId][field] = JSON.parse(value);\n        } catch {\n          obj[streamId][field] = value;\n        }\n      }\n    }\n  }\n  return obj;\n}\n\n// pkg/commands/xtrim.ts\nvar XTrimCommand = class extends Command {\n  constructor([key, options], opts) {\n    const { limit, strategy, threshold, exactness = \"~\" } = options;\n    super([\"XTRIM\", key, strategy, exactness, threshold, ...limit ? [\"LIMIT\", limit] : []], opts);\n  }\n};\n\n// pkg/commands/zadd.ts\nvar ZAddCommand = class extends Command {\n  constructor([key, arg1, ...arg2], opts) {\n    const command = [\"zadd\", key];\n    if (\"nx\" in arg1 && arg1.nx) {\n      command.push(\"nx\");\n    } else if (\"xx\" in arg1 && arg1.xx) {\n      command.push(\"xx\");\n    }\n    if (\"ch\" in arg1 && arg1.ch) {\n      command.push(\"ch\");\n    }\n    if (\"incr\" in arg1 && arg1.incr) {\n      command.push(\"incr\");\n    }\n    if (\"lt\" in arg1 && arg1.lt) {\n      command.push(\"lt\");\n    } else if (\"gt\" in arg1 && arg1.gt) {\n      command.push(\"gt\");\n    }\n    if (\"score\" in arg1 && \"member\" in arg1) {\n      command.push(arg1.score, arg1.member);\n    }\n    command.push(...arg2.flatMap(({ score, member }) => [score, member]));\n    super(command, opts);\n  }\n};\n\n// pkg/commands/zcard.ts\nvar ZCardCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zcard\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zcount.ts\nvar ZCountCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zcount\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zincrby.ts\nvar ZIncrByCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zincrby\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zinterstore.ts\nvar ZInterStoreCommand = class extends Command {\n  constructor([destination, numKeys, keyOrKeys, opts], cmdOpts) {\n    const command = [\"zinterstore\", destination, numKeys];\n    if (Array.isArray(keyOrKeys)) {\n      command.push(...keyOrKeys);\n    } else {\n      command.push(keyOrKeys);\n    }\n    if (opts) {\n      if (\"weights\" in opts && opts.weights) {\n        command.push(\"weights\", ...opts.weights);\n      } else if (\"weight\" in opts && typeof opts.weight === \"number\") {\n        command.push(\"weights\", opts.weight);\n      }\n      if (\"aggregate\" in opts) {\n        command.push(\"aggregate\", opts.aggregate);\n      }\n    }\n    super(command, cmdOpts);\n  }\n};\n\n// pkg/commands/zlexcount.ts\nvar ZLexCountCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zlexcount\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zpopmax.ts\nvar ZPopMaxCommand = class extends Command {\n  constructor([key, count], opts) {\n    const command = [\"zpopmax\", key];\n    if (typeof count === \"number\") {\n      command.push(count);\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/zpopmin.ts\nvar ZPopMinCommand = class extends Command {\n  constructor([key, count], opts) {\n    const command = [\"zpopmin\", key];\n    if (typeof count === \"number\") {\n      command.push(count);\n    }\n    super(command, opts);\n  }\n};\n\n// pkg/commands/zrange.ts\nvar ZRangeCommand = class extends Command {\n  constructor([key, min, max, opts], cmdOpts) {\n    const command = [\"zrange\", key, min, max];\n    if (opts?.byScore) {\n      command.push(\"byscore\");\n    }\n    if (opts?.byLex) {\n      command.push(\"bylex\");\n    }\n    if (opts?.rev) {\n      command.push(\"rev\");\n    }\n    if (opts?.count !== void 0 && opts.offset !== void 0) {\n      command.push(\"limit\", opts.offset, opts.count);\n    }\n    if (opts?.withScores) {\n      command.push(\"withscores\");\n    }\n    super(command, cmdOpts);\n  }\n};\n\n// pkg/commands/zrank.ts\nvar ZRankCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zrank\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zrem.ts\nvar ZRemCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zrem\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zremrangebylex.ts\nvar ZRemRangeByLexCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zremrangebylex\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zremrangebyrank.ts\nvar ZRemRangeByRankCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zremrangebyrank\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zremrangebyscore.ts\nvar ZRemRangeByScoreCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zremrangebyscore\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zrevrank.ts\nvar ZRevRankCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zrevrank\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zscan.ts\nvar ZScanCommand = class extends Command {\n  constructor([key, cursor, opts], cmdOpts) {\n    const command = [\"zscan\", key, cursor];\n    if (opts?.match) {\n      command.push(\"match\", opts.match);\n    }\n    if (typeof opts?.count === \"number\") {\n      command.push(\"count\", opts.count);\n    }\n    super(command, {\n      deserialize: deserializeScanResponse,\n      ...cmdOpts\n    });\n  }\n};\n\n// pkg/commands/zscore.ts\nvar ZScoreCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zscore\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zunion.ts\nvar ZUnionCommand = class extends Command {\n  constructor([numKeys, keyOrKeys, opts], cmdOpts) {\n    const command = [\"zunion\", numKeys];\n    if (Array.isArray(keyOrKeys)) {\n      command.push(...keyOrKeys);\n    } else {\n      command.push(keyOrKeys);\n    }\n    if (opts) {\n      if (\"weights\" in opts && opts.weights) {\n        command.push(\"weights\", ...opts.weights);\n      } else if (\"weight\" in opts && typeof opts.weight === \"number\") {\n        command.push(\"weights\", opts.weight);\n      }\n      if (\"aggregate\" in opts) {\n        command.push(\"aggregate\", opts.aggregate);\n      }\n      if (opts.withScores) {\n        command.push(\"withscores\");\n      }\n    }\n    super(command, cmdOpts);\n  }\n};\n\n// pkg/commands/zunionstore.ts\nvar ZUnionStoreCommand = class extends Command {\n  constructor([destination, numKeys, keyOrKeys, opts], cmdOpts) {\n    const command = [\"zunionstore\", destination, numKeys];\n    if (Array.isArray(keyOrKeys)) {\n      command.push(...keyOrKeys);\n    } else {\n      command.push(keyOrKeys);\n    }\n    if (opts) {\n      if (\"weights\" in opts && opts.weights) {\n        command.push(\"weights\", ...opts.weights);\n      } else if (\"weight\" in opts && typeof opts.weight === \"number\") {\n        command.push(\"weights\", opts.weight);\n      }\n      if (\"aggregate\" in opts) {\n        command.push(\"aggregate\", opts.aggregate);\n      }\n    }\n    super(command, cmdOpts);\n  }\n};\n\n// pkg/commands/zdiffstore.ts\nvar ZDiffStoreCommand = class extends Command {\n  constructor(cmd, opts) {\n    super([\"zdiffstore\", ...cmd], opts);\n  }\n};\n\n// pkg/commands/zmscore.ts\nvar ZMScoreCommand = class extends Command {\n  constructor(cmd, opts) {\n    const [key, members] = cmd;\n    super([\"zmscore\", key, ...members], opts);\n  }\n};\n\n// pkg/pipeline.ts\nvar Pipeline = class {\n  client;\n  commands;\n  commandOptions;\n  multiExec;\n  constructor(opts) {\n    this.client = opts.client;\n    this.commands = [];\n    this.commandOptions = opts.commandOptions;\n    this.multiExec = opts.multiExec ?? false;\n    if (this.commandOptions?.latencyLogging) {\n      const originalExec = this.exec.bind(this);\n      this.exec = async (options) => {\n        const start = performance.now();\n        const result = await (options ? originalExec(options) : originalExec());\n        const end = performance.now();\n        const loggerResult = (end - start).toFixed(2);\n        console.log(\n          `Latency for \\x1B[38;2;19;185;39m${this.multiExec ? [\"MULTI-EXEC\"] : [\"PIPELINE\"].toString().toUpperCase()}\\x1B[0m: \\x1B[38;2;0;255;255m${loggerResult} ms\\x1B[0m`\n        );\n        return result;\n      };\n    }\n  }\n  exec = async (options) => {\n    if (this.commands.length === 0) {\n      throw new Error(\"Pipeline is empty\");\n    }\n    const path = this.multiExec ? [\"multi-exec\"] : [\"pipeline\"];\n    const res = await this.client.request({\n      path,\n      body: Object.values(this.commands).map((c) => c.command)\n    });\n    return options?.keepErrors ? res.map(({ error, result }, i) => {\n      return {\n        error,\n        result: this.commands[i].deserialize(result)\n      };\n    }) : res.map(({ error, result }, i) => {\n      if (error) {\n        throw new UpstashError(\n          `Command ${i + 1} [ ${this.commands[i].command[0]} ] failed: ${error}`\n        );\n      }\n      return this.commands[i].deserialize(result);\n    });\n  };\n  /**\n   * Returns the length of pipeline before the execution\n   */\n  length() {\n    return this.commands.length;\n  }\n  /**\n   * Pushes a command into the pipeline and returns a chainable instance of the\n   * pipeline\n   */\n  chain(command) {\n    this.commands.push(command);\n    return this;\n  }\n  /**\n   * @see https://redis.io/commands/append\n   */\n  append = (...args) => this.chain(new AppendCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/bitcount\n   */\n  bitcount = (...args) => this.chain(new BitCountCommand(args, this.commandOptions));\n  /**\n   * Returns an instance that can be used to execute `BITFIELD` commands on one key.\n   *\n   * @example\n   * ```typescript\n   * redis.set(\"mykey\", 0);\n   * const result = await redis.pipeline()\n   *   .bitfield(\"mykey\")\n   *   .set(\"u4\", 0, 16)\n   *   .incr(\"u4\", \"#1\", 1)\n   *   .exec();\n   * console.log(result); // [[0, 1]]\n   * ```\n   *\n   * @see https://redis.io/commands/bitfield\n   */\n  bitfield = (...args) => new BitFieldCommand(args, this.client, this.commandOptions, this.chain.bind(this));\n  /**\n   * @see https://redis.io/commands/bitop\n   */\n  bitop = (op, destinationKey, sourceKey, ...sourceKeys) => this.chain(\n    new BitOpCommand([op, destinationKey, sourceKey, ...sourceKeys], this.commandOptions)\n  );\n  /**\n   * @see https://redis.io/commands/bitpos\n   */\n  bitpos = (...args) => this.chain(new BitPosCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/copy\n   */\n  copy = (...args) => this.chain(new CopyCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zdiffstore\n   */\n  zdiffstore = (...args) => this.chain(new ZDiffStoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/dbsize\n   */\n  dbsize = () => this.chain(new DBSizeCommand(this.commandOptions));\n  /**\n   * @see https://redis.io/commands/decr\n   */\n  decr = (...args) => this.chain(new DecrCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/decrby\n   */\n  decrby = (...args) => this.chain(new DecrByCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/del\n   */\n  del = (...args) => this.chain(new DelCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/echo\n   */\n  echo = (...args) => this.chain(new EchoCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/eval_ro\n   */\n  evalRo = (...args) => this.chain(new EvalROCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/eval\n   */\n  eval = (...args) => this.chain(new EvalCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/evalsha_ro\n   */\n  evalshaRo = (...args) => this.chain(new EvalshaROCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/evalsha\n   */\n  evalsha = (...args) => this.chain(new EvalshaCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/exists\n   */\n  exists = (...args) => this.chain(new ExistsCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/expire\n   */\n  expire = (...args) => this.chain(new ExpireCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/expireat\n   */\n  expireat = (...args) => this.chain(new ExpireAtCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/flushall\n   */\n  flushall = (args) => this.chain(new FlushAllCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/flushdb\n   */\n  flushdb = (...args) => this.chain(new FlushDBCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/geoadd\n   */\n  geoadd = (...args) => this.chain(new GeoAddCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/geodist\n   */\n  geodist = (...args) => this.chain(new GeoDistCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/geopos\n   */\n  geopos = (...args) => this.chain(new GeoPosCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/geohash\n   */\n  geohash = (...args) => this.chain(new GeoHashCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/geosearch\n   */\n  geosearch = (...args) => this.chain(new GeoSearchCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/geosearchstore\n   */\n  geosearchstore = (...args) => this.chain(new GeoSearchStoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/get\n   */\n  get = (...args) => this.chain(new GetCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/getbit\n   */\n  getbit = (...args) => this.chain(new GetBitCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/getdel\n   */\n  getdel = (...args) => this.chain(new GetDelCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/getex\n   */\n  getex = (...args) => this.chain(new GetExCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/getrange\n   */\n  getrange = (...args) => this.chain(new GetRangeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/getset\n   */\n  getset = (key, value) => this.chain(new GetSetCommand([key, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hdel\n   */\n  hdel = (...args) => this.chain(new HDelCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hexists\n   */\n  hexists = (...args) => this.chain(new HExistsCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hexpire\n   */\n  hexpire = (...args) => this.chain(new HExpireCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hexpireat\n   */\n  hexpireat = (...args) => this.chain(new HExpireAtCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hexpiretime\n   */\n  hexpiretime = (...args) => this.chain(new HExpireTimeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/httl\n   */\n  httl = (...args) => this.chain(new HTtlCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hpexpire\n   */\n  hpexpire = (...args) => this.chain(new HPExpireCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hpexpireat\n   */\n  hpexpireat = (...args) => this.chain(new HPExpireAtCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hpexpiretime\n   */\n  hpexpiretime = (...args) => this.chain(new HPExpireTimeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hpttl\n   */\n  hpttl = (...args) => this.chain(new HPTtlCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hpersist\n   */\n  hpersist = (...args) => this.chain(new HPersistCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hget\n   */\n  hget = (...args) => this.chain(new HGetCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hgetall\n   */\n  hgetall = (...args) => this.chain(new HGetAllCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hincrby\n   */\n  hincrby = (...args) => this.chain(new HIncrByCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hincrbyfloat\n   */\n  hincrbyfloat = (...args) => this.chain(new HIncrByFloatCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hkeys\n   */\n  hkeys = (...args) => this.chain(new HKeysCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hlen\n   */\n  hlen = (...args) => this.chain(new HLenCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hmget\n   */\n  hmget = (...args) => this.chain(new HMGetCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hmset\n   */\n  hmset = (key, kv) => this.chain(new HMSetCommand([key, kv], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hrandfield\n   */\n  hrandfield = (key, count, withValues) => this.chain(new HRandFieldCommand([key, count, withValues], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hscan\n   */\n  hscan = (...args) => this.chain(new HScanCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hset\n   */\n  hset = (key, kv) => this.chain(new HSetCommand([key, kv], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hsetnx\n   */\n  hsetnx = (key, field, value) => this.chain(new HSetNXCommand([key, field, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hstrlen\n   */\n  hstrlen = (...args) => this.chain(new HStrLenCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/hvals\n   */\n  hvals = (...args) => this.chain(new HValsCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/incr\n   */\n  incr = (...args) => this.chain(new IncrCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/incrby\n   */\n  incrby = (...args) => this.chain(new IncrByCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/incrbyfloat\n   */\n  incrbyfloat = (...args) => this.chain(new IncrByFloatCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/keys\n   */\n  keys = (...args) => this.chain(new KeysCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lindex\n   */\n  lindex = (...args) => this.chain(new LIndexCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/linsert\n   */\n  linsert = (key, direction, pivot, value) => this.chain(new LInsertCommand([key, direction, pivot, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/llen\n   */\n  llen = (...args) => this.chain(new LLenCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lmove\n   */\n  lmove = (...args) => this.chain(new LMoveCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lpop\n   */\n  lpop = (...args) => this.chain(new LPopCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lmpop\n   */\n  lmpop = (...args) => this.chain(new LmPopCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lpos\n   */\n  lpos = (...args) => this.chain(new LPosCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lpush\n   */\n  lpush = (key, ...elements) => this.chain(new LPushCommand([key, ...elements], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lpushx\n   */\n  lpushx = (key, ...elements) => this.chain(new LPushXCommand([key, ...elements], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lrange\n   */\n  lrange = (...args) => this.chain(new LRangeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lrem\n   */\n  lrem = (key, count, value) => this.chain(new LRemCommand([key, count, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/lset\n   */\n  lset = (key, index, value) => this.chain(new LSetCommand([key, index, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/ltrim\n   */\n  ltrim = (...args) => this.chain(new LTrimCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/mget\n   */\n  mget = (...args) => this.chain(new MGetCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/mset\n   */\n  mset = (kv) => this.chain(new MSetCommand([kv], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/msetnx\n   */\n  msetnx = (kv) => this.chain(new MSetNXCommand([kv], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/persist\n   */\n  persist = (...args) => this.chain(new PersistCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/pexpire\n   */\n  pexpire = (...args) => this.chain(new PExpireCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/pexpireat\n   */\n  pexpireat = (...args) => this.chain(new PExpireAtCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/pfadd\n   */\n  pfadd = (...args) => this.chain(new PfAddCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/pfcount\n   */\n  pfcount = (...args) => this.chain(new PfCountCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/pfmerge\n   */\n  pfmerge = (...args) => this.chain(new PfMergeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/ping\n   */\n  ping = (args) => this.chain(new PingCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/psetex\n   */\n  psetex = (key, ttl, value) => this.chain(new PSetEXCommand([key, ttl, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/pttl\n   */\n  pttl = (...args) => this.chain(new PTtlCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/publish\n   */\n  publish = (...args) => this.chain(new PublishCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/randomkey\n   */\n  randomkey = () => this.chain(new RandomKeyCommand(this.commandOptions));\n  /**\n   * @see https://redis.io/commands/rename\n   */\n  rename = (...args) => this.chain(new RenameCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/renamenx\n   */\n  renamenx = (...args) => this.chain(new RenameNXCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/rpop\n   */\n  rpop = (...args) => this.chain(new RPopCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/rpush\n   */\n  rpush = (key, ...elements) => this.chain(new RPushCommand([key, ...elements], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/rpushx\n   */\n  rpushx = (key, ...elements) => this.chain(new RPushXCommand([key, ...elements], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sadd\n   */\n  sadd = (key, member, ...members) => this.chain(new SAddCommand([key, member, ...members], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/scan\n   */\n  scan = (...args) => this.chain(new ScanCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/scard\n   */\n  scard = (...args) => this.chain(new SCardCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/script-exists\n   */\n  scriptExists = (...args) => this.chain(new ScriptExistsCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/script-flush\n   */\n  scriptFlush = (...args) => this.chain(new ScriptFlushCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/script-load\n   */\n  scriptLoad = (...args) => this.chain(new ScriptLoadCommand(args, this.commandOptions));\n  /*)*\n   * @see https://redis.io/commands/sdiff\n   */\n  sdiff = (...args) => this.chain(new SDiffCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sdiffstore\n   */\n  sdiffstore = (...args) => this.chain(new SDiffStoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/set\n   */\n  set = (key, value, opts) => this.chain(new SetCommand([key, value, opts], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/setbit\n   */\n  setbit = (...args) => this.chain(new SetBitCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/setex\n   */\n  setex = (key, ttl, value) => this.chain(new SetExCommand([key, ttl, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/setnx\n   */\n  setnx = (key, value) => this.chain(new SetNxCommand([key, value], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/setrange\n   */\n  setrange = (...args) => this.chain(new SetRangeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sinter\n   */\n  sinter = (...args) => this.chain(new SInterCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sinterstore\n   */\n  sinterstore = (...args) => this.chain(new SInterStoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sismember\n   */\n  sismember = (key, member) => this.chain(new SIsMemberCommand([key, member], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/smembers\n   */\n  smembers = (...args) => this.chain(new SMembersCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/smismember\n   */\n  smismember = (key, members) => this.chain(new SMIsMemberCommand([key, members], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/smove\n   */\n  smove = (source, destination, member) => this.chain(new SMoveCommand([source, destination, member], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/spop\n   */\n  spop = (...args) => this.chain(new SPopCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/srandmember\n   */\n  srandmember = (...args) => this.chain(new SRandMemberCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/srem\n   */\n  srem = (key, ...members) => this.chain(new SRemCommand([key, ...members], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sscan\n   */\n  sscan = (...args) => this.chain(new SScanCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/strlen\n   */\n  strlen = (...args) => this.chain(new StrLenCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sunion\n   */\n  sunion = (...args) => this.chain(new SUnionCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/sunionstore\n   */\n  sunionstore = (...args) => this.chain(new SUnionStoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/time\n   */\n  time = () => this.chain(new TimeCommand(this.commandOptions));\n  /**\n   * @see https://redis.io/commands/touch\n   */\n  touch = (...args) => this.chain(new TouchCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/ttl\n   */\n  ttl = (...args) => this.chain(new TtlCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/type\n   */\n  type = (...args) => this.chain(new TypeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/unlink\n   */\n  unlink = (...args) => this.chain(new UnlinkCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zadd\n   */\n  zadd = (...args) => {\n    if (\"score\" in args[1]) {\n      return this.chain(\n        new ZAddCommand([args[0], args[1], ...args.slice(2)], this.commandOptions)\n      );\n    }\n    return this.chain(\n      new ZAddCommand(\n        [args[0], args[1], ...args.slice(2)],\n        this.commandOptions\n      )\n    );\n  };\n  /**\n   * @see https://redis.io/commands/xadd\n   */\n  xadd = (...args) => this.chain(new XAddCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xack\n   */\n  xack = (...args) => this.chain(new XAckCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xdel\n   */\n  xdel = (...args) => this.chain(new XDelCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xgroup\n   */\n  xgroup = (...args) => this.chain(new XGroupCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xread\n   */\n  xread = (...args) => this.chain(new XReadCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xreadgroup\n   */\n  xreadgroup = (...args) => this.chain(new XReadGroupCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xinfo\n   */\n  xinfo = (...args) => this.chain(new XInfoCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xlen\n   */\n  xlen = (...args) => this.chain(new XLenCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xpending\n   */\n  xpending = (...args) => this.chain(new XPendingCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xclaim\n   */\n  xclaim = (...args) => this.chain(new XClaimCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xautoclaim\n   */\n  xautoclaim = (...args) => this.chain(new XAutoClaim(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xtrim\n   */\n  xtrim = (...args) => this.chain(new XTrimCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xrange\n   */\n  xrange = (...args) => this.chain(new XRangeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/xrevrange\n   */\n  xrevrange = (...args) => this.chain(new XRevRangeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zcard\n   */\n  zcard = (...args) => this.chain(new ZCardCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zcount\n   */\n  zcount = (...args) => this.chain(new ZCountCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zincrby\n   */\n  zincrby = (key, increment, member) => this.chain(new ZIncrByCommand([key, increment, member], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zinterstore\n   */\n  zinterstore = (...args) => this.chain(new ZInterStoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zlexcount\n   */\n  zlexcount = (...args) => this.chain(new ZLexCountCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zmscore\n   */\n  zmscore = (...args) => this.chain(new ZMScoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zpopmax\n   */\n  zpopmax = (...args) => this.chain(new ZPopMaxCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zpopmin\n   */\n  zpopmin = (...args) => this.chain(new ZPopMinCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zrange\n   */\n  zrange = (...args) => this.chain(new ZRangeCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zrank\n   */\n  zrank = (key, member) => this.chain(new ZRankCommand([key, member], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zrem\n   */\n  zrem = (key, ...members) => this.chain(new ZRemCommand([key, ...members], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zremrangebylex\n   */\n  zremrangebylex = (...args) => this.chain(new ZRemRangeByLexCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zremrangebyrank\n   */\n  zremrangebyrank = (...args) => this.chain(new ZRemRangeByRankCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zremrangebyscore\n   */\n  zremrangebyscore = (...args) => this.chain(new ZRemRangeByScoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zrevrank\n   */\n  zrevrank = (key, member) => this.chain(new ZRevRankCommand([key, member], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zscan\n   */\n  zscan = (...args) => this.chain(new ZScanCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zscore\n   */\n  zscore = (key, member) => this.chain(new ZScoreCommand([key, member], this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zunionstore\n   */\n  zunionstore = (...args) => this.chain(new ZUnionStoreCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/zunion\n   */\n  zunion = (...args) => this.chain(new ZUnionCommand(args, this.commandOptions));\n  /**\n   * @see https://redis.io/commands/?group=json\n   */\n  get json() {\n    return {\n      /**\n       * @see https://redis.io/commands/json.arrappend\n       */\n      arrappend: (...args) => this.chain(new JsonArrAppendCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.arrindex\n       */\n      arrindex: (...args) => this.chain(new JsonArrIndexCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.arrinsert\n       */\n      arrinsert: (...args) => this.chain(new JsonArrInsertCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.arrlen\n       */\n      arrlen: (...args) => this.chain(new JsonArrLenCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.arrpop\n       */\n      arrpop: (...args) => this.chain(new JsonArrPopCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.arrtrim\n       */\n      arrtrim: (...args) => this.chain(new JsonArrTrimCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.clear\n       */\n      clear: (...args) => this.chain(new JsonClearCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.del\n       */\n      del: (...args) => this.chain(new JsonDelCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.forget\n       */\n      forget: (...args) => this.chain(new JsonForgetCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.get\n       */\n      get: (...args) => this.chain(new JsonGetCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.merge\n       */\n      merge: (...args) => this.chain(new JsonMergeCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.mget\n       */\n      mget: (...args) => this.chain(new JsonMGetCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.mset\n       */\n      mset: (...args) => this.chain(new JsonMSetCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.numincrby\n       */\n      numincrby: (...args) => this.chain(new JsonNumIncrByCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.nummultby\n       */\n      nummultby: (...args) => this.chain(new JsonNumMultByCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.objkeys\n       */\n      objkeys: (...args) => this.chain(new JsonObjKeysCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.objlen\n       */\n      objlen: (...args) => this.chain(new JsonObjLenCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.resp\n       */\n      resp: (...args) => this.chain(new JsonRespCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.set\n       */\n      set: (...args) => this.chain(new JsonSetCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.strappend\n       */\n      strappend: (...args) => this.chain(new JsonStrAppendCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.strlen\n       */\n      strlen: (...args) => this.chain(new JsonStrLenCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.toggle\n       */\n      toggle: (...args) => this.chain(new JsonToggleCommand(args, this.commandOptions)),\n      /**\n       * @see https://redis.io/commands/json.type\n       */\n      type: (...args) => this.chain(new JsonTypeCommand(args, this.commandOptions))\n    };\n  }\n};\n\n// pkg/auto-pipeline.ts\nvar EXCLUDE_COMMANDS = /* @__PURE__ */ new Set([\n  \"scan\",\n  \"keys\",\n  \"flushdb\",\n  \"flushall\",\n  \"dbsize\",\n  \"hscan\",\n  \"hgetall\",\n  \"hkeys\",\n  \"lrange\",\n  \"sscan\",\n  \"smembers\",\n  \"xrange\",\n  \"xrevrange\",\n  \"zscan\",\n  \"zrange\"\n]);\nfunction createAutoPipelineProxy(_redis, json) {\n  const redis = _redis;\n  if (!redis.autoPipelineExecutor) {\n    redis.autoPipelineExecutor = new AutoPipelineExecutor(redis);\n  }\n  return new Proxy(redis, {\n    get: (redis2, command) => {\n      if (command === \"pipelineCounter\") {\n        return redis2.autoPipelineExecutor.pipelineCounter;\n      }\n      if (command === \"json\") {\n        return createAutoPipelineProxy(redis2, true);\n      }\n      const commandInRedisButNotPipeline = command in redis2 && !(command in redis2.autoPipelineExecutor.pipeline);\n      const isCommandExcluded = EXCLUDE_COMMANDS.has(command);\n      if (commandInRedisButNotPipeline || isCommandExcluded) {\n        return redis2[command];\n      }\n      const isFunction = json ? typeof redis2.autoPipelineExecutor.pipeline.json[command] === \"function\" : typeof redis2.autoPipelineExecutor.pipeline[command] === \"function\";\n      if (isFunction) {\n        return (...args) => {\n          return redis2.autoPipelineExecutor.withAutoPipeline((pipeline) => {\n            if (json) {\n              pipeline.json[command](\n                ...args\n              );\n            } else {\n              pipeline[command](...args);\n            }\n          });\n        };\n      }\n      return redis2.autoPipelineExecutor.pipeline[command];\n    }\n  });\n}\nvar AutoPipelineExecutor = class {\n  pipelinePromises = /* @__PURE__ */ new WeakMap();\n  activePipeline = null;\n  indexInCurrentPipeline = 0;\n  redis;\n  pipeline;\n  // only to make sure that proxy can work\n  pipelineCounter = 0;\n  // to keep track of how many times a pipeline was executed\n  constructor(redis) {\n    this.redis = redis;\n    this.pipeline = redis.pipeline();\n  }\n  async withAutoPipeline(executeWithPipeline) {\n    const pipeline = this.activePipeline ?? this.redis.pipeline();\n    if (!this.activePipeline) {\n      this.activePipeline = pipeline;\n      this.indexInCurrentPipeline = 0;\n    }\n    const index = this.indexInCurrentPipeline++;\n    executeWithPipeline(pipeline);\n    const pipelineDone = this.deferExecution().then(() => {\n      if (!this.pipelinePromises.has(pipeline)) {\n        const pipelinePromise = pipeline.exec({ keepErrors: true });\n        this.pipelineCounter += 1;\n        this.pipelinePromises.set(pipeline, pipelinePromise);\n        this.activePipeline = null;\n      }\n      return this.pipelinePromises.get(pipeline);\n    });\n    const results = await pipelineDone;\n    const commandResult = results[index];\n    if (commandResult.error) {\n      throw new UpstashError(`Command failed: ${commandResult.error}`);\n    }\n    return commandResult.result;\n  }\n  async deferExecution() {\n    await Promise.resolve();\n    await Promise.resolve();\n  }\n};\n\n// pkg/commands/psubscribe.ts\nvar PSubscribeCommand = class extends Command {\n  constructor(cmd, opts) {\n    const sseHeaders = {\n      Accept: \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\"\n    };\n    super([], {\n      ...opts,\n      headers: sseHeaders,\n      path: [\"psubscribe\", ...cmd],\n      streamOptions: {\n        isStreaming: true,\n        onMessage: opts?.streamOptions?.onMessage,\n        signal: opts?.streamOptions?.signal\n      }\n    });\n  }\n};\n\n// pkg/commands/subscribe.ts\nvar Subscriber = class extends EventTarget {\n  subscriptions;\n  client;\n  listeners;\n  constructor(client, channels, isPattern = false) {\n    super();\n    this.client = client;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.listeners = /* @__PURE__ */ new Map();\n    for (const channel of channels) {\n      if (isPattern) {\n        this.subscribeToPattern(channel);\n      } else {\n        this.subscribeToChannel(channel);\n      }\n    }\n  }\n  subscribeToChannel(channel) {\n    const controller = new AbortController();\n    const command = new SubscribeCommand([channel], {\n      streamOptions: {\n        signal: controller.signal,\n        onMessage: (data) => this.handleMessage(data, false)\n      }\n    });\n    command.exec(this.client).catch((error) => {\n      if (error.name !== \"AbortError\") {\n        this.dispatchToListeners(\"error\", error);\n      }\n    });\n    this.subscriptions.set(channel, {\n      command,\n      controller,\n      isPattern: false\n    });\n  }\n  subscribeToPattern(pattern) {\n    const controller = new AbortController();\n    const command = new PSubscribeCommand([pattern], {\n      streamOptions: {\n        signal: controller.signal,\n        onMessage: (data) => this.handleMessage(data, true)\n      }\n    });\n    command.exec(this.client).catch((error) => {\n      if (error.name !== \"AbortError\") {\n        this.dispatchToListeners(\"error\", error);\n      }\n    });\n    this.subscriptions.set(pattern, {\n      command,\n      controller,\n      isPattern: true\n    });\n  }\n  handleMessage(data, isPattern) {\n    const messageData = data.replace(/^data:\\s*/, \"\");\n    const firstCommaIndex = messageData.indexOf(\",\");\n    const secondCommaIndex = messageData.indexOf(\",\", firstCommaIndex + 1);\n    const thirdCommaIndex = isPattern ? messageData.indexOf(\",\", secondCommaIndex + 1) : -1;\n    if (firstCommaIndex !== -1 && secondCommaIndex !== -1) {\n      const type = messageData.slice(0, firstCommaIndex);\n      if (isPattern && type === \"pmessage\" && thirdCommaIndex !== -1) {\n        const pattern = messageData.slice(firstCommaIndex + 1, secondCommaIndex);\n        const channel = messageData.slice(secondCommaIndex + 1, thirdCommaIndex);\n        const messageStr = messageData.slice(thirdCommaIndex + 1);\n        try {\n          const message = JSON.parse(messageStr);\n          this.dispatchToListeners(\"pmessage\", { pattern, channel, message });\n          this.dispatchToListeners(`pmessage:${pattern}`, { pattern, channel, message });\n        } catch (error) {\n          this.dispatchToListeners(\"error\", new Error(`Failed to parse message: ${error}`));\n        }\n      } else {\n        const channel = messageData.slice(firstCommaIndex + 1, secondCommaIndex);\n        const messageStr = messageData.slice(secondCommaIndex + 1);\n        try {\n          if (type === \"subscribe\" || type === \"psubscribe\" || type === \"unsubscribe\" || type === \"punsubscribe\") {\n            const count = Number.parseInt(messageStr);\n            this.dispatchToListeners(type, count);\n          } else {\n            const message = JSON.parse(messageStr);\n            this.dispatchToListeners(type, { channel, message });\n            this.dispatchToListeners(`${type}:${channel}`, { channel, message });\n          }\n        } catch (error) {\n          this.dispatchToListeners(\"error\", new Error(`Failed to parse message: ${error}`));\n        }\n      }\n    }\n  }\n  dispatchToListeners(type, data) {\n    const listeners = this.listeners.get(type);\n    if (listeners) {\n      for (const listener of listeners) {\n        listener(data);\n      }\n    }\n  }\n  on(type, listener) {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, /* @__PURE__ */ new Set());\n    }\n    this.listeners.get(type)?.add(listener);\n  }\n  removeAllListeners() {\n    this.listeners.clear();\n  }\n  async unsubscribe(channels) {\n    if (channels) {\n      for (const channel of channels) {\n        const subscription = this.subscriptions.get(channel);\n        if (subscription) {\n          try {\n            subscription.controller.abort();\n          } catch {\n          }\n          this.subscriptions.delete(channel);\n        }\n      }\n    } else {\n      for (const subscription of this.subscriptions.values()) {\n        try {\n          subscription.controller.abort();\n        } catch {\n        }\n      }\n      this.subscriptions.clear();\n      this.removeAllListeners();\n    }\n  }\n  getSubscribedChannels() {\n    return [...this.subscriptions.keys()];\n  }\n};\nvar SubscribeCommand = class extends Command {\n  constructor(cmd, opts) {\n    const sseHeaders = {\n      Accept: \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\"\n    };\n    super([], {\n      ...opts,\n      headers: sseHeaders,\n      path: [\"subscribe\", ...cmd],\n      streamOptions: {\n        isStreaming: true,\n        onMessage: opts?.streamOptions?.onMessage,\n        signal: opts?.streamOptions?.signal\n      }\n    });\n  }\n};\n\n// pkg/script.ts\nimport { subtle } from \"uncrypto\";\nvar Script = class {\n  script;\n  /**\n   * @deprecated This property is initialized to an empty string and will be set in the init method\n   * asynchronously. Do not use this property immidiately after the constructor.\n   *\n   * This property is only exposed for backwards compatibility and will be removed in the\n   * future major release.\n   */\n  sha1;\n  redis;\n  constructor(redis, script) {\n    this.redis = redis;\n    this.script = script;\n    this.sha1 = \"\";\n    void this.init(script);\n  }\n  /**\n   * Initialize the script by computing its SHA-1 hash.\n   */\n  async init(script) {\n    if (this.sha1) return;\n    this.sha1 = await this.digest(script);\n  }\n  /**\n   * Send an `EVAL` command to redis.\n   */\n  async eval(keys, args) {\n    await this.init(this.script);\n    return await this.redis.eval(this.script, keys, args);\n  }\n  /**\n   * Calculates the sha1 hash of the script and then calls `EVALSHA`.\n   */\n  async evalsha(keys, args) {\n    await this.init(this.script);\n    return await this.redis.evalsha(this.sha1, keys, args);\n  }\n  /**\n   * Optimistically try to run `EVALSHA` first.\n   * If the script is not loaded in redis, it will fall back and try again with `EVAL`.\n   *\n   * Following calls will be able to use the cached script\n   */\n  async exec(keys, args) {\n    await this.init(this.script);\n    const res = await this.redis.evalsha(this.sha1, keys, args).catch(async (error) => {\n      if (error instanceof Error && error.message.toLowerCase().includes(\"noscript\")) {\n        return await this.redis.eval(this.script, keys, args);\n      }\n      throw error;\n    });\n    return res;\n  }\n  /**\n   * Compute the sha1 hash of the script and return its hex representation.\n   */\n  async digest(s) {\n    const data = new TextEncoder().encode(s);\n    const hashBuffer = await subtle.digest(\"SHA-1\", data);\n    const hashArray = [...new Uint8Array(hashBuffer)];\n    return hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n};\n\n// pkg/scriptRo.ts\nimport { subtle as subtle2 } from \"uncrypto\";\nvar ScriptRO = class {\n  script;\n  /**\n   * @deprecated This property is initialized to an empty string and will be set in the init method\n   * asynchronously. Do not use this property immidiately after the constructor.\n   *\n   * This property is only exposed for backwards compatibility and will be removed in the\n   * future major release.\n   */\n  sha1;\n  redis;\n  constructor(redis, script) {\n    this.redis = redis;\n    this.sha1 = \"\";\n    this.script = script;\n    void this.init(script);\n  }\n  async init(script) {\n    if (this.sha1) return;\n    this.sha1 = await this.digest(script);\n  }\n  /**\n   * Send an `EVAL_RO` command to redis.\n   */\n  async evalRo(keys, args) {\n    await this.init(this.script);\n    return await this.redis.evalRo(this.script, keys, args);\n  }\n  /**\n   * Calculates the sha1 hash of the script and then calls `EVALSHA_RO`.\n   */\n  async evalshaRo(keys, args) {\n    await this.init(this.script);\n    return await this.redis.evalshaRo(this.sha1, keys, args);\n  }\n  /**\n   * Optimistically try to run `EVALSHA_RO` first.\n   * If the script is not loaded in redis, it will fall back and try again with `EVAL_RO`.\n   *\n   * Following calls will be able to use the cached script\n   */\n  async exec(keys, args) {\n    await this.init(this.script);\n    const res = await this.redis.evalshaRo(this.sha1, keys, args).catch(async (error) => {\n      if (error instanceof Error && error.message.toLowerCase().includes(\"noscript\")) {\n        return await this.redis.evalRo(this.script, keys, args);\n      }\n      throw error;\n    });\n    return res;\n  }\n  /**\n   * Compute the sha1 hash of the script and return its hex representation.\n   */\n  async digest(s) {\n    const data = new TextEncoder().encode(s);\n    const hashBuffer = await subtle2.digest(\"SHA-1\", data);\n    const hashArray = [...new Uint8Array(hashBuffer)];\n    return hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n};\n\n// pkg/redis.ts\nvar Redis = class {\n  client;\n  opts;\n  enableTelemetry;\n  enableAutoPipelining;\n  /**\n   * Create a new redis client\n   *\n   * @example\n   * ```typescript\n   * const redis = new Redis({\n   *  url: \"<UPSTASH_REDIS_REST_URL>\",\n   *  token: \"<UPSTASH_REDIS_REST_TOKEN>\",\n   * });\n   * ```\n   */\n  constructor(client, opts) {\n    this.client = client;\n    this.opts = opts;\n    this.enableTelemetry = opts?.enableTelemetry ?? true;\n    if (opts?.readYourWrites === false) {\n      this.client.readYourWrites = false;\n    }\n    this.enableAutoPipelining = opts?.enableAutoPipelining ?? true;\n  }\n  get readYourWritesSyncToken() {\n    return this.client.upstashSyncToken;\n  }\n  set readYourWritesSyncToken(session) {\n    this.client.upstashSyncToken = session;\n  }\n  get json() {\n    return {\n      /**\n       * @see https://redis.io/commands/json.arrappend\n       */\n      arrappend: (...args) => new JsonArrAppendCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.arrindex\n       */\n      arrindex: (...args) => new JsonArrIndexCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.arrinsert\n       */\n      arrinsert: (...args) => new JsonArrInsertCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.arrlen\n       */\n      arrlen: (...args) => new JsonArrLenCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.arrpop\n       */\n      arrpop: (...args) => new JsonArrPopCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.arrtrim\n       */\n      arrtrim: (...args) => new JsonArrTrimCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.clear\n       */\n      clear: (...args) => new JsonClearCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.del\n       */\n      del: (...args) => new JsonDelCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.forget\n       */\n      forget: (...args) => new JsonForgetCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.get\n       */\n      get: (...args) => new JsonGetCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.merge\n       */\n      merge: (...args) => new JsonMergeCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.mget\n       */\n      mget: (...args) => new JsonMGetCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.mset\n       */\n      mset: (...args) => new JsonMSetCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.numincrby\n       */\n      numincrby: (...args) => new JsonNumIncrByCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.nummultby\n       */\n      nummultby: (...args) => new JsonNumMultByCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.objkeys\n       */\n      objkeys: (...args) => new JsonObjKeysCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.objlen\n       */\n      objlen: (...args) => new JsonObjLenCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.resp\n       */\n      resp: (...args) => new JsonRespCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.set\n       */\n      set: (...args) => new JsonSetCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.strappend\n       */\n      strappend: (...args) => new JsonStrAppendCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.strlen\n       */\n      strlen: (...args) => new JsonStrLenCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.toggle\n       */\n      toggle: (...args) => new JsonToggleCommand(args, this.opts).exec(this.client),\n      /**\n       * @see https://redis.io/commands/json.type\n       */\n      type: (...args) => new JsonTypeCommand(args, this.opts).exec(this.client)\n    };\n  }\n  /**\n   * Wrap a new middleware around the HTTP client.\n   */\n  use = (middleware) => {\n    const makeRequest = this.client.request.bind(this.client);\n    this.client.request = (req) => middleware(req, makeRequest);\n  };\n  /**\n   * Technically this is not private, we can hide it from intellisense by doing this\n   */\n  addTelemetry = (telemetry) => {\n    if (!this.enableTelemetry) {\n      return;\n    }\n    try {\n      this.client.mergeTelemetry(telemetry);\n    } catch {\n    }\n  };\n  /**\n   * Creates a new script.\n   *\n   * Scripts offer the ability to optimistically try to execute a script without having to send the\n   * entire script to the server. If the script is loaded on the server, it tries again by sending\n   * the entire script. Afterwards, the script is cached on the server.\n   *\n   * @param script - The script to create\n   * @param opts - Optional options to pass to the script `{ readonly?: boolean }`\n   * @returns A new script\n   *\n   * @example\n   * ```ts\n   * const redis = new Redis({...})\n   *\n   * const script = redis.createScript<string>(\"return ARGV[1];\")\n   * const arg1 = await script.eval([], [\"Hello World\"])\n   * expect(arg1, \"Hello World\")\n   * ```\n   * @example\n   * ```ts\n   * const redis = new Redis({...})\n   *\n   * const script = redis.createScript<string>(\"return ARGV[1];\", { readonly: true })\n   * const arg1 = await script.evalRo([], [\"Hello World\"])\n   * expect(arg1, \"Hello World\")\n   * ```\n   */\n  createScript(script, opts) {\n    return opts?.readonly ? new ScriptRO(this, script) : new Script(this, script);\n  }\n  /**\n   * Create a new pipeline that allows you to send requests in bulk.\n   *\n   * @see {@link Pipeline}\n   */\n  pipeline = () => new Pipeline({\n    client: this.client,\n    commandOptions: this.opts,\n    multiExec: false\n  });\n  autoPipeline = () => {\n    return createAutoPipelineProxy(this);\n  };\n  /**\n   * Create a new transaction to allow executing multiple steps atomically.\n   *\n   * All the commands in a transaction are serialized and executed sequentially. A request sent by\n   * another client will never be served in the middle of the execution of a Redis Transaction. This\n   * guarantees that the commands are executed as a single isolated operation.\n   *\n   * @see {@link Pipeline}\n   */\n  multi = () => new Pipeline({\n    client: this.client,\n    commandOptions: this.opts,\n    multiExec: true\n  });\n  /**\n   * Returns an instance that can be used to execute `BITFIELD` commands on one key.\n   *\n   * @example\n   * ```typescript\n   * redis.set(\"mykey\", 0);\n   * const result = await redis.bitfield(\"mykey\")\n   *   .set(\"u4\", 0, 16)\n   *   .incr(\"u4\", \"#1\", 1)\n   *   .exec();\n   * console.log(result); // [0, 1]\n   * ```\n   *\n   * @see https://redis.io/commands/bitfield\n   */\n  bitfield = (...args) => new BitFieldCommand(args, this.client, this.opts);\n  /**\n   * @see https://redis.io/commands/append\n   */\n  append = (...args) => new AppendCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/bitcount\n   */\n  bitcount = (...args) => new BitCountCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/bitop\n   */\n  bitop = (op, destinationKey, sourceKey, ...sourceKeys) => new BitOpCommand([op, destinationKey, sourceKey, ...sourceKeys], this.opts).exec(\n    this.client\n  );\n  /**\n   * @see https://redis.io/commands/bitpos\n   */\n  bitpos = (...args) => new BitPosCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/copy\n   */\n  copy = (...args) => new CopyCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/dbsize\n   */\n  dbsize = () => new DBSizeCommand(this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/decr\n   */\n  decr = (...args) => new DecrCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/decrby\n   */\n  decrby = (...args) => new DecrByCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/del\n   */\n  del = (...args) => new DelCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/echo\n   */\n  echo = (...args) => new EchoCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/eval_ro\n   */\n  evalRo = (...args) => new EvalROCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/eval\n   */\n  eval = (...args) => new EvalCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/evalsha_ro\n   */\n  evalshaRo = (...args) => new EvalshaROCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/evalsha\n   */\n  evalsha = (...args) => new EvalshaCommand(args, this.opts).exec(this.client);\n  /**\n   * Generic method to execute any Redis command.\n   */\n  exec = (args) => new ExecCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/exists\n   */\n  exists = (...args) => new ExistsCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/expire\n   */\n  expire = (...args) => new ExpireCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/expireat\n   */\n  expireat = (...args) => new ExpireAtCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/flushall\n   */\n  flushall = (args) => new FlushAllCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/flushdb\n   */\n  flushdb = (...args) => new FlushDBCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/geoadd\n   */\n  geoadd = (...args) => new GeoAddCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/geopos\n   */\n  geopos = (...args) => new GeoPosCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/geodist\n   */\n  geodist = (...args) => new GeoDistCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/geohash\n   */\n  geohash = (...args) => new GeoHashCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/geosearch\n   */\n  geosearch = (...args) => new GeoSearchCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/geosearchstore\n   */\n  geosearchstore = (...args) => new GeoSearchStoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/get\n   */\n  get = (...args) => new GetCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/getbit\n   */\n  getbit = (...args) => new GetBitCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/getdel\n   */\n  getdel = (...args) => new GetDelCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/getex\n   */\n  getex = (...args) => new GetExCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/getrange\n   */\n  getrange = (...args) => new GetRangeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/getset\n   */\n  getset = (key, value) => new GetSetCommand([key, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hdel\n   */\n  hdel = (...args) => new HDelCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hexists\n   */\n  hexists = (...args) => new HExistsCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hexpire\n   */\n  hexpire = (...args) => new HExpireCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hexpireat\n   */\n  hexpireat = (...args) => new HExpireAtCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hexpiretime\n   */\n  hexpiretime = (...args) => new HExpireTimeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/httl\n   */\n  httl = (...args) => new HTtlCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hpexpire\n   */\n  hpexpire = (...args) => new HPExpireCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hpexpireat\n   */\n  hpexpireat = (...args) => new HPExpireAtCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hpexpiretime\n   */\n  hpexpiretime = (...args) => new HPExpireTimeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hpttl\n   */\n  hpttl = (...args) => new HPTtlCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hpersist\n   */\n  hpersist = (...args) => new HPersistCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hget\n   */\n  hget = (...args) => new HGetCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hgetall\n   */\n  hgetall = (...args) => new HGetAllCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hincrby\n   */\n  hincrby = (...args) => new HIncrByCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hincrbyfloat\n   */\n  hincrbyfloat = (...args) => new HIncrByFloatCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hkeys\n   */\n  hkeys = (...args) => new HKeysCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hlen\n   */\n  hlen = (...args) => new HLenCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hmget\n   */\n  hmget = (...args) => new HMGetCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hmset\n   */\n  hmset = (key, kv) => new HMSetCommand([key, kv], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hrandfield\n   */\n  hrandfield = (key, count, withValues) => new HRandFieldCommand([key, count, withValues], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hscan\n   */\n  hscan = (...args) => new HScanCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hset\n   */\n  hset = (key, kv) => new HSetCommand([key, kv], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hsetnx\n   */\n  hsetnx = (key, field, value) => new HSetNXCommand([key, field, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hstrlen\n   */\n  hstrlen = (...args) => new HStrLenCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/hvals\n   */\n  hvals = (...args) => new HValsCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/incr\n   */\n  incr = (...args) => new IncrCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/incrby\n   */\n  incrby = (...args) => new IncrByCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/incrbyfloat\n   */\n  incrbyfloat = (...args) => new IncrByFloatCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/keys\n   */\n  keys = (...args) => new KeysCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lindex\n   */\n  lindex = (...args) => new LIndexCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/linsert\n   */\n  linsert = (key, direction, pivot, value) => new LInsertCommand([key, direction, pivot, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/llen\n   */\n  llen = (...args) => new LLenCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lmove\n   */\n  lmove = (...args) => new LMoveCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lpop\n   */\n  lpop = (...args) => new LPopCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lmpop\n   */\n  lmpop = (...args) => new LmPopCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lpos\n   */\n  lpos = (...args) => new LPosCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lpush\n   */\n  lpush = (key, ...elements) => new LPushCommand([key, ...elements], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lpushx\n   */\n  lpushx = (key, ...elements) => new LPushXCommand([key, ...elements], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lrange\n   */\n  lrange = (...args) => new LRangeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lrem\n   */\n  lrem = (key, count, value) => new LRemCommand([key, count, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/lset\n   */\n  lset = (key, index, value) => new LSetCommand([key, index, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/ltrim\n   */\n  ltrim = (...args) => new LTrimCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/mget\n   */\n  mget = (...args) => new MGetCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/mset\n   */\n  mset = (kv) => new MSetCommand([kv], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/msetnx\n   */\n  msetnx = (kv) => new MSetNXCommand([kv], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/persist\n   */\n  persist = (...args) => new PersistCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/pexpire\n   */\n  pexpire = (...args) => new PExpireCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/pexpireat\n   */\n  pexpireat = (...args) => new PExpireAtCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/pfadd\n   */\n  pfadd = (...args) => new PfAddCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/pfcount\n   */\n  pfcount = (...args) => new PfCountCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/pfmerge\n   */\n  pfmerge = (...args) => new PfMergeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/ping\n   */\n  ping = (args) => new PingCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/psetex\n   */\n  psetex = (key, ttl, value) => new PSetEXCommand([key, ttl, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/psubscribe\n   */\n  psubscribe = (patterns) => {\n    const patternArray = Array.isArray(patterns) ? patterns : [patterns];\n    return new Subscriber(this.client, patternArray, true);\n  };\n  /**\n   * @see https://redis.io/commands/pttl\n   */\n  pttl = (...args) => new PTtlCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/publish\n   */\n  publish = (...args) => new PublishCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/randomkey\n   */\n  randomkey = () => new RandomKeyCommand().exec(this.client);\n  /**\n   * @see https://redis.io/commands/rename\n   */\n  rename = (...args) => new RenameCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/renamenx\n   */\n  renamenx = (...args) => new RenameNXCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/rpop\n   */\n  rpop = (...args) => new RPopCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/rpush\n   */\n  rpush = (key, ...elements) => new RPushCommand([key, ...elements], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/rpushx\n   */\n  rpushx = (key, ...elements) => new RPushXCommand([key, ...elements], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sadd\n   */\n  sadd = (key, member, ...members) => new SAddCommand([key, member, ...members], this.opts).exec(this.client);\n  scan(cursor, opts) {\n    return new ScanCommand([cursor, opts], this.opts).exec(this.client);\n  }\n  /**\n   * @see https://redis.io/commands/scard\n   */\n  scard = (...args) => new SCardCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/script-exists\n   */\n  scriptExists = (...args) => new ScriptExistsCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/script-flush\n   */\n  scriptFlush = (...args) => new ScriptFlushCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/script-load\n   */\n  scriptLoad = (...args) => new ScriptLoadCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sdiff\n   */\n  sdiff = (...args) => new SDiffCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sdiffstore\n   */\n  sdiffstore = (...args) => new SDiffStoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/set\n   */\n  set = (key, value, opts) => new SetCommand([key, value, opts], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/setbit\n   */\n  setbit = (...args) => new SetBitCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/setex\n   */\n  setex = (key, ttl, value) => new SetExCommand([key, ttl, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/setnx\n   */\n  setnx = (key, value) => new SetNxCommand([key, value], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/setrange\n   */\n  setrange = (...args) => new SetRangeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sinter\n   */\n  sinter = (...args) => new SInterCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sinterstore\n   */\n  sinterstore = (...args) => new SInterStoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sismember\n   */\n  sismember = (key, member) => new SIsMemberCommand([key, member], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/smismember\n   */\n  smismember = (key, members) => new SMIsMemberCommand([key, members], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/smembers\n   */\n  smembers = (...args) => new SMembersCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/smove\n   */\n  smove = (source, destination, member) => new SMoveCommand([source, destination, member], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/spop\n   */\n  spop = (...args) => new SPopCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/srandmember\n   */\n  srandmember = (...args) => new SRandMemberCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/srem\n   */\n  srem = (key, ...members) => new SRemCommand([key, ...members], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sscan\n   */\n  sscan = (...args) => new SScanCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/strlen\n   */\n  strlen = (...args) => new StrLenCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/subscribe\n   */\n  subscribe = (channels) => {\n    const channelArray = Array.isArray(channels) ? channels : [channels];\n    return new Subscriber(this.client, channelArray);\n  };\n  /**\n   * @see https://redis.io/commands/sunion\n   */\n  sunion = (...args) => new SUnionCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/sunionstore\n   */\n  sunionstore = (...args) => new SUnionStoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/time\n   */\n  time = () => new TimeCommand().exec(this.client);\n  /**\n   * @see https://redis.io/commands/touch\n   */\n  touch = (...args) => new TouchCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/ttl\n   */\n  ttl = (...args) => new TtlCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/type\n   */\n  type = (...args) => new TypeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/unlink\n   */\n  unlink = (...args) => new UnlinkCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xadd\n   */\n  xadd = (...args) => new XAddCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xack\n   */\n  xack = (...args) => new XAckCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xdel\n   */\n  xdel = (...args) => new XDelCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xgroup\n   */\n  xgroup = (...args) => new XGroupCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xread\n   */\n  xread = (...args) => new XReadCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xreadgroup\n   */\n  xreadgroup = (...args) => new XReadGroupCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xinfo\n   */\n  xinfo = (...args) => new XInfoCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xlen\n   */\n  xlen = (...args) => new XLenCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xpending\n   */\n  xpending = (...args) => new XPendingCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xclaim\n   */\n  xclaim = (...args) => new XClaimCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xautoclaim\n   */\n  xautoclaim = (...args) => new XAutoClaim(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xtrim\n   */\n  xtrim = (...args) => new XTrimCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xrange\n   */\n  xrange = (...args) => new XRangeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/xrevrange\n   */\n  xrevrange = (...args) => new XRevRangeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zadd\n   */\n  zadd = (...args) => {\n    if (\"score\" in args[1]) {\n      return new ZAddCommand([args[0], args[1], ...args.slice(2)], this.opts).exec(\n        this.client\n      );\n    }\n    return new ZAddCommand(\n      [args[0], args[1], ...args.slice(2)],\n      this.opts\n    ).exec(this.client);\n  };\n  /**\n   * @see https://redis.io/commands/zcard\n   */\n  zcard = (...args) => new ZCardCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zcount\n   */\n  zcount = (...args) => new ZCountCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zdiffstore\n   */\n  zdiffstore = (...args) => new ZDiffStoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zincrby\n   */\n  zincrby = (key, increment, member) => new ZIncrByCommand([key, increment, member], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zinterstore\n   */\n  zinterstore = (...args) => new ZInterStoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zlexcount\n   */\n  zlexcount = (...args) => new ZLexCountCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zmscore\n   */\n  zmscore = (...args) => new ZMScoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zpopmax\n   */\n  zpopmax = (...args) => new ZPopMaxCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zpopmin\n   */\n  zpopmin = (...args) => new ZPopMinCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zrange\n   */\n  zrange = (...args) => new ZRangeCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zrank\n   */\n  zrank = (key, member) => new ZRankCommand([key, member], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zrem\n   */\n  zrem = (key, ...members) => new ZRemCommand([key, ...members], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zremrangebylex\n   */\n  zremrangebylex = (...args) => new ZRemRangeByLexCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zremrangebyrank\n   */\n  zremrangebyrank = (...args) => new ZRemRangeByRankCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zremrangebyscore\n   */\n  zremrangebyscore = (...args) => new ZRemRangeByScoreCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zrevrank\n   */\n  zrevrank = (key, member) => new ZRevRankCommand([key, member], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zscan\n   */\n  zscan = (...args) => new ZScanCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zscore\n   */\n  zscore = (key, member) => new ZScoreCommand([key, member], this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zunion\n   */\n  zunion = (...args) => new ZUnionCommand(args, this.opts).exec(this.client);\n  /**\n   * @see https://redis.io/commands/zunionstore\n   */\n  zunionstore = (...args) => new ZUnionStoreCommand(args, this.opts).exec(this.client);\n};\n\n// version.ts\nvar VERSION = \"v1.35.0\";\n\nexport {\n  error_exports,\n  HttpClient,\n  Redis,\n  VERSION\n};\n","import {\n  HttpClient,\n  Redis,\n  VERSION,\n  error_exports\n} from \"./chunk-QZ3IMTW7.mjs\";\n\n// platforms/nodejs.ts\nif (typeof atob === \"undefined\") {\n  global.atob = (b64) => Buffer.from(b64, \"base64\").toString(\"utf8\");\n}\nvar Redis2 = class _Redis extends Redis {\n  /**\n   * Create a new redis client by providing a custom `Requester` implementation\n   *\n   * @example\n   * ```ts\n   *\n   * import { UpstashRequest, Requester, UpstashResponse, Redis } from \"@upstash/redis\"\n   *\n   *  const requester: Requester = {\n   *    request: <TResult>(req: UpstashRequest): Promise<UpstashResponse<TResult>> => {\n   *      // ...\n   *    }\n   *  }\n   *\n   * const redis = new Redis(requester)\n   * ```\n   */\n  constructor(configOrRequester) {\n    if (\"request\" in configOrRequester) {\n      super(configOrRequester);\n      return;\n    }\n    if (!configOrRequester.url) {\n      console.warn(\n        `[Upstash Redis] The 'url' property is missing or undefined in your Redis config.`\n      );\n    } else if (configOrRequester.url.startsWith(\" \") || configOrRequester.url.endsWith(\" \") || /\\r|\\n/.test(configOrRequester.url)) {\n      console.warn(\n        \"[Upstash Redis] The redis url contains whitespace or newline, which can cause errors!\"\n      );\n    }\n    if (!configOrRequester.token) {\n      console.warn(\n        `[Upstash Redis] The 'token' property is missing or undefined in your Redis config.`\n      );\n    } else if (configOrRequester.token.startsWith(\" \") || configOrRequester.token.endsWith(\" \") || /\\r|\\n/.test(configOrRequester.token)) {\n      console.warn(\n        \"[Upstash Redis] The redis token contains whitespace or newline, which can cause errors!\"\n      );\n    }\n    const client = new HttpClient({\n      baseUrl: configOrRequester.url,\n      retry: configOrRequester.retry,\n      headers: { authorization: `Bearer ${configOrRequester.token}` },\n      agent: configOrRequester.agent,\n      responseEncoding: configOrRequester.responseEncoding,\n      cache: configOrRequester.cache ?? \"no-store\",\n      signal: configOrRequester.signal,\n      keepAlive: configOrRequester.keepAlive,\n      readYourWrites: configOrRequester.readYourWrites\n    });\n    super(client, {\n      automaticDeserialization: configOrRequester.automaticDeserialization,\n      enableTelemetry: !process.env.UPSTASH_DISABLE_TELEMETRY,\n      latencyLogging: configOrRequester.latencyLogging,\n      enableAutoPipelining: configOrRequester.enableAutoPipelining\n    });\n    this.addTelemetry({\n      runtime: (\n        // @ts-expect-error to silence compiler\n        typeof EdgeRuntime === \"string\" ? \"edge-light\" : `node@${process.version}`\n      ),\n      platform: process.env.VERCEL ? \"vercel\" : process.env.AWS_REGION ? \"aws\" : \"unknown\",\n      sdk: `@upstash/redis@${VERSION}`\n    });\n    if (this.enableAutoPipelining) {\n      return this.autoPipeline();\n    }\n  }\n  /**\n   * Create a new Upstash Redis instance from environment variables.\n   *\n   * Use this to automatically load connection secrets from your environment\n   * variables. For instance when using the Vercel integration.\n   *\n   * This tries to load `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` from\n   * your environment using `process.env`.\n   */\n  static fromEnv(config) {\n    if (process.env === void 0) {\n      throw new TypeError(\n        '[Upstash Redis] Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from \"@upstash/redis/cloudflare\" instead'\n      );\n    }\n    const url = process.env.UPSTASH_REDIS_REST_URL || process.env.KV_REST_API_URL;\n    if (!url) {\n      console.warn(\"[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_URL`\");\n    }\n    const token = process.env.UPSTASH_REDIS_REST_TOKEN || process.env.KV_REST_API_TOKEN;\n    if (!token) {\n      console.warn(\n        \"[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`\"\n      );\n    }\n    return new _Redis({ ...config, url, token });\n  }\n};\nexport {\n  Redis2 as Redis,\n  error_exports as errors\n};\n","/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","/**\r\n * Redis Module - Centralized Redis functionality\r\n *\r\n * This module serves as the single source of truth for all Redis operations\r\n * in the application. It provides:\r\n *\r\n * 1. A singleton Redis client instance with connection management\r\n * 2. Cache middleware for Hono API routes\r\n * 3. Translation cache utilities\r\n * 4. Cache invalidation and statistics\r\n * 5. Testing utilities\r\n */\r\n\r\n// Add a mock Cache API for Hono's built-in cache middleware\r\n// This prevents the \"Cache Middleware is not enabled because caches is not defined\" error\r\nif (typeof globalThis.caches === \"undefined\") {\r\n  // Create a minimal mock of the Cache API that Hono expects\r\n  globalThis.caches = {\r\n    open: () => {\r\n      return Promise.resolve({\r\n        match: () => Promise.resolve(null),\r\n        put: () => Promise.resolve(),\r\n        delete: () => Promise.resolve(false),\r\n      });\r\n    },\r\n    has: () => Promise.resolve(false),\r\n    delete: () => Promise.resolve(false),\r\n  } as any;\r\n  console.log(\"Added Cache API mock for Hono middleware\");\r\n}\r\n\r\nimport { Redis } from \"@upstash/redis\";\r\nimport { Context, MiddlewareHandler, Next } from \"hono\";\r\nimport { LRUCache } from \"lru-cache\";\r\n\r\n// Environment variables for Upstash Redis\r\nconst UPSTASH_REDIS_REST_URL = process.env.UPSTASH_REDIS_REST_URL;\r\nconst UPSTASH_REDIS_REST_TOKEN = process.env.UPSTASH_REDIS_REST_TOKEN;\r\n\r\n// Constants for cache stats\r\nconst STATS_KEYS = {\r\n  HITS: \"cache:stats:hits\",\r\n  MISSES: \"cache:stats:misses\",\r\n  KEYS: \"cache:stats:keys\",\r\n};\r\n\r\n// Interface for cache options\r\ninterface CacheOptions {\r\n  ttl?: number; // Time to live in seconds (default: 300 seconds)\r\n  key?: (c: Context<any>) => string; // Custom key generator\r\n  ignoreQuery?: boolean; // Whether to ignore query parameters in the cache key\r\n  varyByAuth?: boolean; // Whether to create different cache entries based on authentication status\r\n  caches?: string[]; // Routes or patterns to cache, if not provided all routes will be cached\r\n}\r\n\r\n// Singleton pattern for Redis client\r\nlet redisClient: Redis | null = null;\r\nlet redisInitializationAttempted = false;\r\n\r\n/**\r\n * Create a new Redis client\r\n */\r\nfunction createRedisClient(): Redis | null {\r\n  console.log(\"[Redis Client] Attempting to use URL:\", UPSTASH_REDIS_REST_URL);\r\n\r\n  if (!UPSTASH_REDIS_REST_URL || !UPSTASH_REDIS_REST_TOKEN) {\r\n    console.warn(\r\n      \"[Redis Client] Missing Redis URL or Token in environment variables. Redis client will not be initialized.\"\r\n    );\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    return new Redis({\r\n      url: UPSTASH_REDIS_REST_URL,\r\n      token: UPSTASH_REDIS_REST_TOKEN,\r\n      retry: {\r\n        retries: 3,\r\n        backoff: (retryCount) => Math.min(retryCount * 50, 1000),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error(\r\n      \"[Redis Client] Error during Redis client instantiation:\",\r\n      error\r\n    );\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get Redis client (singleton pattern)\r\n */\r\nexport function getRedisClient(): Redis | null {\r\n  if (!redisInitializationAttempted) {\r\n    redisClient = createRedisClient();\r\n    if (redisClient) {\r\n      console.log(\"Upstash Redis client initialized successfully.\");\r\n    } else {\r\n      console.warn(\r\n        \"Upstash Redis client could not be initialized. Features requiring Redis may not work.\"\r\n      );\r\n    }\r\n    redisInitializationAttempted = true;\r\n  }\r\n  return redisClient;\r\n}\r\n\r\n/**\r\n * Sets a custom Redis client (for testing)\r\n */\r\nexport function setRedisClient(client: Redis): void {\r\n  redisClient = client;\r\n}\r\n\r\n/**\r\n * Resets the Redis client (for testing)\r\n */\r\nexport function resetRedisClient(): void {\r\n  if (redisClient && typeof (redisClient as any).quit === \"function\") {\r\n    try {\r\n      (redisClient as any).quit();\r\n    } catch (e) {\r\n      console.error(\"Error quitting existing redis client during reset:\", e);\r\n    }\r\n  }\r\n  redisClient = null;\r\n  redisInitializationAttempted = false;\r\n}\r\n\r\n// Export Redis client for direct access\r\nexport const redis: Redis | null = getRedisClient();\r\n\r\n/**\r\n * Health check function for Redis\r\n */\r\nexport async function isRedisHealthy(): Promise<boolean> {\r\n  if (!redis) {\r\n    console.warn(\r\n      \"[isRedisHealthy] Redis client not initialized. Health check returning false.\"\r\n    );\r\n    return false;\r\n  }\r\n  try {\r\n    const result = await redis.ping();\r\n    return result === \"PONG\";\r\n  } catch (error) {\r\n    console.error(\"Redis health check failed:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Translation cache helper functions\r\n */\r\nexport const translationCache = {\r\n  async get(locale: string): Promise<Record<string, any> | null> {\r\n    if (!redis) {\r\n      console.warn(\"[translationCache.get] Redis client not available.\");\r\n      return null;\r\n    }\r\n    try {\r\n      const cached = await redis.get(`i18n:${locale}`);\r\n      return cached ? JSON.parse(cached as string) : null;\r\n    } catch (error) {\r\n      console.error(\"Translation cache get error:\", error);\r\n      return null;\r\n    }\r\n  },\r\n\r\n  async set(\r\n    locale: string,\r\n    translations: Record<string, any>,\r\n    ttl: number = 3600\r\n  ): Promise<void> {\r\n    if (!redis) {\r\n      console.warn(\"[translationCache.set] Redis client not available.\");\r\n      return;\r\n    }\r\n    try {\r\n      await redis.setex(`i18n:${locale}`, ttl, JSON.stringify(translations));\r\n    } catch (error) {\r\n      console.error(\"Translation cache set error:\", error);\r\n    }\r\n  },\r\n\r\n  async invalidate(locale: string): Promise<void> {\r\n    if (!redis) {\r\n      console.warn(\"[translationCache.invalidate] Redis client not available.\");\r\n      return;\r\n    }\r\n    try {\r\n      await redis.del(`i18n:${locale}`);\r\n    } catch (error) {\r\n      console.error(\"Translation cache invalidate error:\", error);\r\n    }\r\n  },\r\n\r\n  async invalidateAll(): Promise<void> {\r\n    if (!redis) {\r\n      console.warn(\r\n        \"[translationCache.invalidateAll] Redis client not available.\"\r\n      );\r\n      return;\r\n    }\r\n    try {\r\n      const keys = await redis.keys(\"i18n:*\");\r\n      if (keys.length > 0) {\r\n        await redis.del(...keys);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Translation cache invalidate all error:\", error);\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Default cache key generator based on URL, path, and user ID\r\n */\r\nfunction defaultKeyGenerator(c: Context<any>): string {\r\n  const url = new URL(c.req.url);\r\n\r\n  // Get user info for personalized caching\r\n  const user = c.get(\"user\");\r\n  const userId = user?.id || \"anonymous\";\r\n\r\n  // Construct path with query parameters\r\n  const pathWithQuery = url.pathname + url.search;\r\n\r\n  return `cache:${userId}:${pathWithQuery}`;\r\n}\r\n\r\n/**\r\n * Middleware for Redis-backed caching with user-specific keys\r\n *\r\n * @deprecated Use redisApiCacheMiddleware instead to avoid conflicts with Hono's built-in cache\r\n * @param options Cache options\r\n * @returns Hono middleware\r\n */\r\nexport function redisCacheMiddleware(\r\n  options: CacheOptions = {}\r\n): MiddlewareHandler<any> {\r\n  // Set default values for options to avoid Hono warnings\r\n  options.caches = options.caches || []; // Always provide a caches array to avoid Hono built-in middleware warnings\r\n\r\n  return async (c: Context<any>, next: Next) => {\r\n    if (!redis) {\r\n      console.warn(\r\n        \"[redisCacheMiddleware] Redis client not available. Skipping cache.\"\r\n      );\r\n      return next();\r\n    }\r\n    // Only cache GET requests\r\n    if (c.req.method !== \"GET\") {\r\n      return next();\r\n    }\r\n\r\n    // Log incoming Cache-Control header\r\n    const requestCacheControl = c.req.header(\"Cache-Control\");\r\n    console.log(\r\n      `[redisCacheMiddleware] Incoming Cache-Control: ${requestCacheControl}`\r\n    );\r\n\r\n    // If caches is not defined, continue with caching\r\n    // This removes the error message and allows the middleware to be used without the caches parameter\r\n    if (options.caches === undefined) {\r\n      // If caches is undefined, we'll cache everything by default\r\n      // No need to log a warning as this is a valid configuration\r\n    }\r\n\r\n    // Generate cache key\r\n    const generateKey = options.key || defaultKeyGenerator;\r\n    const cacheKey = generateKey(c);\r\n\r\n    // Check if cached response exists\r\n    try {\r\n      const cachedData = await redis.get(cacheKey);\r\n\r\n      if (cachedData) {\r\n        // Track cache hit\r\n        await redis.incr(STATS_KEYS.HITS);\r\n\r\n        // Add cache headers\r\n        c.header(\"X-Cache\", \"HIT\");\r\n        c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n        // Use a default TTL of 300 seconds if none is provided\r\n        const maxAge = options.ttl ? options.ttl.toString() : \"300\";\r\n        c.header(\"Cache-Control\", `public, max-age=${maxAge}`);\r\n\r\n        return c.json(JSON.parse(cachedData as string));\r\n      }\r\n\r\n      // Track cache miss\r\n      await redis.incr(STATS_KEYS.MISSES);\r\n    } catch (error) {\r\n      console.error(\"Redis cache read error:\", error);\r\n      // Continue without caching on error\r\n    }\r\n\r\n    // Set header to indicate cache miss\r\n    c.header(\"X-Cache\", \"MISS\");\r\n    c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n    // Continue to the next middleware/handler\r\n    await next();\r\n\r\n    // Store the response in cache only if status is success\r\n    if (c.res && c.res.status >= 200 && c.res.status < 300) {\r\n      try {\r\n        const responseData = await c.res.clone().json();\r\n\r\n        // Store in Redis with TTL\r\n        const ttl = options.ttl || 300; // Default 5 minutes\r\n        await redis.set(cacheKey, JSON.stringify(responseData), { ex: ttl });\r\n\r\n        // Track cache keys\r\n        await redis.sadd(STATS_KEYS.KEYS, cacheKey);\r\n\r\n        // Add cache-related headers to the response\r\n        c.header(\"Cache-Control\", `public, max-age=${ttl}`);\r\n      } catch (error) {\r\n        console.error(\"Redis cache write error:\", error);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Renamed middleware for Redis-backed caching to avoid conflicts with Hono's built-in cache\r\n * Use this version instead of redisCacheMiddleware to prevent \"Cache Middleware is not enabled\" errors\r\n *\r\n * @param options Cache options\r\n * @returns Hono middleware\r\n */\r\nexport function redisApiCacheMiddleware(\r\n  options: CacheOptions = {}\r\n): MiddlewareHandler<any> {\r\n  return async (c: Context<any>, next: Next) => {\r\n    if (!redis) {\r\n      console.warn(\r\n        \"[redisApiCacheMiddleware] Redis client not available. Skipping cache.\"\r\n      );\r\n      return next();\r\n    }\r\n    // Only cache GET requests\r\n    if (c.req.method !== \"GET\") {\r\n      return next();\r\n    }\r\n\r\n    // Log incoming Cache-Control header\r\n    const requestCacheControl = c.req.header(\"Cache-Control\");\r\n    console.log(\r\n      `[redisApiCacheMiddleware] Incoming Cache-Control: ${requestCacheControl}`\r\n    );\r\n\r\n    // Generate cache key\r\n    const generateKey = options.key || defaultKeyGenerator;\r\n    const cacheKey = generateKey(c);\r\n\r\n    // Check if cached response exists\r\n    try {\r\n      const cachedData = await redis.get(cacheKey);\r\n\r\n      if (cachedData) {\r\n        // Track cache hit\r\n        await redis.incr(STATS_KEYS.HITS);\r\n\r\n        // Add cache headers\r\n        c.header(\"X-Cache\", \"HIT\");\r\n        c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n        // Use a default TTL of 300 seconds if none is provided\r\n        const maxAge = options.ttl ? options.ttl.toString() : \"300\";\r\n        c.header(\"Cache-Control\", `public, max-age=${maxAge}`);\r\n\r\n        return c.json(JSON.parse(cachedData as string));\r\n      }\r\n\r\n      // Track cache miss\r\n      await redis.incr(STATS_KEYS.MISSES);\r\n    } catch (error) {\r\n      console.error(\"Redis cache read error:\", error);\r\n      // Continue without caching on error\r\n    }\r\n\r\n    // Set header to indicate cache miss\r\n    c.header(\"X-Cache\", \"MISS\");\r\n    c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n    // Continue to the next middleware/handler\r\n    await next();\r\n\r\n    // Store the response in cache only if status is success\r\n    if (c.res && c.res.status >= 200 && c.res.status < 300) {\r\n      try {\r\n        const responseData = await c.res.clone().json();\r\n\r\n        // Store in Redis with TTL\r\n        const ttl = options.ttl || 300; // Default 5 minutes\r\n        await redis.set(cacheKey, JSON.stringify(responseData), { ex: ttl });\r\n\r\n        // Track cache keys\r\n        await redis.sadd(STATS_KEYS.KEYS, cacheKey);\r\n\r\n        // Add cache-related headers to the response\r\n        c.header(\"Cache-Control\", `public, max-age=${ttl}`);\r\n      } catch (error) {\r\n        console.error(\"Redis cache write error:\", error);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Invalidate cache entries matching a pattern\r\n * @param pattern String pattern to match against cache keys\r\n */\r\nexport async function invalidateRedisCache(pattern: string): Promise<number> {\r\n  if (!redis) {\r\n    console.warn(\"[invalidateRedisCache] Redis client not available.\");\r\n    return 0;\r\n  }\r\n  try {\r\n    // Find all keys matching the pattern\r\n    let cursor = 0;\r\n    const matchingKeys: string[] = [];\r\n\r\n    do {\r\n      // The scan function returns [cursor, keys] where cursor might be a string depending on the implementation\r\n      // Cast it to unknown first then to the type we need\r\n      const scanResult = await redis.scan(cursor, {\r\n        match: pattern,\r\n        count: 100,\r\n      });\r\n      const nextCursor = Number(scanResult[0]);\r\n      const keys = scanResult[1] as string[];\r\n\r\n      cursor = nextCursor;\r\n      matchingKeys.push(...keys);\r\n    } while (cursor !== 0);\r\n\r\n    if (matchingKeys.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Delete all matching keys\r\n    await Promise.all(matchingKeys.map((key) => redis.del(key)));\r\n\r\n    console.log(\r\n      `Invalidated ${matchingKeys.length} cache entries matching \"${pattern}\"`\r\n    );\r\n    return matchingKeys.length;\r\n  } catch (error) {\r\n    console.error(\"Error invalidating cache:\", error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear all cache entries\r\n */\r\nexport async function clearRedisCache(): Promise<number> {\r\n  if (!redis) {\r\n    console.warn(\"[clearRedisCache] Redis client not available.\");\r\n    return 0;\r\n  }\r\n  try {\r\n    // Get all cache keys\r\n    const keys = (await redis.smembers(STATS_KEYS.KEYS)) as string[];\r\n\r\n    if (keys.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Delete all keys and reset stats\r\n    await Promise.all([\r\n      ...keys.map((key) => redis.del(key)),\r\n      redis.del(STATS_KEYS.HITS),\r\n      redis.del(STATS_KEYS.MISSES),\r\n      redis.del(STATS_KEYS.KEYS),\r\n    ]);\r\n\r\n    console.log(`Cleared ${keys.length} cache entries`);\r\n    return keys.length;\r\n  } catch (error) {\r\n    console.error(\"Error clearing cache:\", error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get cache statistics\r\n */\r\nexport async function getRedisStats(): Promise<{\r\n  hits: number;\r\n  misses: number;\r\n  keys: number;\r\n  hitRatio: number;\r\n}> {\r\n  if (!redis) {\r\n    console.warn(\"[getRedisStats] Redis client not available.\");\r\n    return {\r\n      hits: 0,\r\n      misses: 0,\r\n      keys: 0,\r\n      hitRatio: 0,\r\n    };\r\n  }\r\n  try {\r\n    // Get stats from Redis\r\n    const [hits, misses, keys] = (await Promise.all([\r\n      redis.get(STATS_KEYS.HITS),\r\n      redis.get(STATS_KEYS.MISSES),\r\n      redis.scard(STATS_KEYS.KEYS),\r\n    ])) as [string | null, string | null, number];\r\n\r\n    // Parse stats\r\n    const hitCount = hits ? parseInt(hits) : 0;\r\n    const missCount = misses ? parseInt(misses) : 0;\r\n    const total = hitCount + missCount;\r\n\r\n    return {\r\n      hits: hitCount,\r\n      misses: missCount,\r\n      keys: keys || 0,\r\n      hitRatio: total > 0 ? hitCount / total : 0,\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error getting cache stats:\", error);\r\n    return {\r\n      hits: 0,\r\n      misses: 0,\r\n      keys: 0,\r\n      hitRatio: 0,\r\n    };\r\n  }\r\n}\r\n\r\n// --- Start of CacheManager consolidation ---\r\n\r\ninterface CacheManagerOptions {\r\n  ttl?: number; // Default TTL for LRU cache in milliseconds\r\n  maxSize?: number; // Max number of items in LRU cache\r\n  redisKeyPrefix?: string; // Prefix for all keys stored in Redis by this manager\r\n}\r\n\r\nclass CacheManager {\r\n  private redisClientInternal: Redis | null = null;\r\n  private lruCache: LRUCache<string, string>;\r\n  private redisKeyPrefix: string;\r\n\r\n  constructor(options: CacheManagerOptions = {}) {\r\n    this.redisClientInternal = getRedisClient();\r\n    if (!this.redisClientInternal) {\r\n      console.warn(\r\n        \"[CacheManager] Redis client is not available. CacheManager will operate in LRU-only mode.\"\r\n      );\r\n    }\r\n\r\n    this.redisKeyPrefix = options.redisKeyPrefix || \"cacheManager:\";\r\n\r\n    this.lruCache = new LRUCache({\r\n      max: options.maxSize || 500, // Use provided maxSize or default\r\n      ttl: options.ttl || 3600 * 1000, // Use provided ttl (in ms) or default 1 hour\r\n    });\r\n  }\r\n\r\n  private getPrefixedKey(key: string): string {\r\n    return `${this.redisKeyPrefix}${key}`;\r\n  }\r\n\r\n  async get(key: string): Promise<string | null> {\r\n    if (this.redisClientInternal) {\r\n      const prefixedKey = this.getPrefixedKey(key);\r\n      try {\r\n        const value = await this.redisClientInternal.get<string>(prefixedKey);\r\n        if (value !== null && value !== undefined) {\r\n          return value;\r\n        }\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Redis get error for key ${prefixedKey}:`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n    return this.lruCache.get(key) || null;\r\n  }\r\n\r\n  async set(key: string, value: string, ttlInSeconds?: number): Promise<void> {\r\n    if (this.redisClientInternal) {\r\n      const prefixedKey = this.getPrefixedKey(key);\r\n      try {\r\n        await this.redisClientInternal.set(prefixedKey, value, {\r\n          ex: ttlInSeconds || 3600, // Default 1 hour for Redis\r\n        });\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Redis set error for key ${prefixedKey}:`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n    this.lruCache.set(key, value, {\r\n      ttl: ttlInSeconds ? ttlInSeconds * 1000 : undefined,\r\n    });\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    if (this.redisClientInternal) {\r\n      const prefixedKey = this.getPrefixedKey(key);\r\n      try {\r\n        await this.redisClientInternal.del(prefixedKey);\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Redis delete error for key ${prefixedKey}:`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n    this.lruCache.delete(key);\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    // Clear Redis keys matching the prefix\r\n    if (this.redisClientInternal) {\r\n      console.log(\r\n        `CacheManager: Attempting to clear Redis keys with prefix \"${this.redisKeyPrefix}\"...`\r\n      );\r\n      let cursor = 0;\r\n      let keysDeletedCount = 0;\r\n      try {\r\n        do {\r\n          const scanResult = await this.redisClientInternal.scan(cursor, {\r\n            match: `${this.redisKeyPrefix}*`,\r\n            count: 100, // Process in batches\r\n          });\r\n          const nextCursor = Number(scanResult[0]);\r\n          const keys = scanResult[1] as string[];\r\n\r\n          if (keys.length > 0) {\r\n            const deleted = await this.redisClientInternal.del(...keys);\r\n            keysDeletedCount += deleted;\r\n          }\r\n          cursor = nextCursor;\r\n        } while (cursor !== 0);\r\n        console.log(\r\n          `CacheManager: Cleared ${keysDeletedCount} keys from Redis with prefix \"${this.redisKeyPrefix}\".`\r\n        );\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Error clearing Redis keys with prefix \"${this.redisKeyPrefix}\":`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n\r\n    // Clear LRU cache\r\n    this.lruCache.clear();\r\n    console.log(\"CacheManager: LRU cache cleared.\");\r\n  }\r\n}\r\n\r\n// Export singleton instance of CacheManager\r\n// You can configure the global 'cache' instance here if needed, e.g.:\r\n// export const cache = new CacheManager({\r\n//   redisKeyPrefix: process.env.CACHE_MANAGER_REDIS_PREFIX || 'globalCache:',\r\n//   ttl: process.env.CACHE_MANAGER_LRU_TTL_MS ? parseInt(process.env.CACHE_MANAGER_LRU_TTL_MS) : 3600 * 1000,\r\n//   maxSize: process.env.CACHE_MANAGER_LRU_MAX_SIZE ? parseInt(process.env.CACHE_MANAGER_LRU_MAX_SIZE) : 500,\r\n// });\r\n// For now, using defaults:\r\nexport const cache = new CacheManager();\r\n\r\n// --- End of CacheManager consolidation ---\r\n","import { SupabaseClient } from \"@supabase/supabase-js\";\r\nimport { OpenAI } from \"openai\";\r\n\r\n// import { DocumentProcessor } from \"@/core/documents/entities/documents/entities/documents/processor\"; // This was commented out in original search, keeping as is.\r\n// import { ResearchResult } from \"@/core/research/lib/types\"; // Removed this unused and problematic import\r\nimport { cache } from \"@/lib/redis\"; // Path from original file content, assuming cache.ts provides this\r\nimport { DomainDocument } from \"@/types\"; // Corrected import for Document\r\n\r\nconst CACHE_TTL = 3600; // 1 hour\r\n\r\nexport class ResearchProcessor {\r\n  private openai: OpenAI;\r\n  private supabase: SupabaseClient;\r\n\r\n  constructor(apiKey: string, supabaseClient: SupabaseClient) {\r\n    // Changed constructor\r\n    this.openai = new OpenAI({ apiKey });\r\n    this.supabase = supabaseClient; // Use passed client\r\n  }\r\n\r\n  async deepResearch(\r\n    query: string,\r\n    options: {\r\n      country?: string;\r\n      category?: string;\r\n      depth?: \"basic\" | \"detailed\" | \"comprehensive\";\r\n    }\r\n  ): Promise<string> {\r\n    try {\r\n      const cacheKey = `research:${JSON.stringify({ query, options })}`; // Reinstated cache logic\r\n      const cached = await cache.get(cacheKey); // Reinstated cache logic\r\n      if (cached) return cached; // Reinstated cache logic\r\n\r\n      const relevantDocs = await this.getRelevantContent(query, options);\r\n      const context = relevantDocs.map((doc) => doc.content).join(\"\\n---\\n\");\r\n\r\n      const systemPrompt = this.getSystemPrompt(options.depth || \"detailed\");\r\n\r\n      const response = await this.openai.chat.completions.create({\r\n        model: \"gpt-4-turbo-preview\",\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: `Research Query: ${query}\\n\\nContext:\\n${context}`,\r\n          },\r\n        ],\r\n        temperature: 0.3,\r\n        max_tokens: 3000,\r\n      });\r\n\r\n      const research = response.choices[0].message.content;\r\n      if (!research) throw new Error(\"Failed to generate research\");\r\n\r\n      await cache.set(cacheKey, research, CACHE_TTL); // Reinstated cache logic\r\n      return research;\r\n    } catch (error) {\r\n      console.error(\"Research error:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private getSystemPrompt(\r\n    depth: \"basic\" | \"detailed\" | \"comprehensive\"\r\n  ): string {\r\n    const basePrompt = `You are an expert immigration research system. Analyze the provided information and generate a comprehensive research report.\r\n\r\nInstructions:\r\n1. Structure the analysis clearly with sections and subsections\r\n2. Focus on accuracy and detail\r\n3. Cite specific requirements and conditions\r\n4. Include relevant timelines and deadlines\r\n5. Note any exceptions or special cases\r\n6. Consider cost implications\r\n7. Reference official sources when available\r\n8. Highlight key points and takeaways`;\r\n\r\n    switch (depth) {\r\n      case \"basic\":\r\n        return `${basePrompt}\\n\\nProvide a basic overview focusing on key points and essential information.`;\r\n      case \"comprehensive\":\r\n        return `${basePrompt}\\n\\nProvide an exhaustive analysis including:\r\n- Historical context and policy evolution\r\n- Comparative analysis with similar policies\r\n- Statistical data and trends\r\n- Expert opinions and interpretations\r\n- Future outlook and potential changes\r\n- Risk analysis and mitigation strategies\r\n- Alternative pathways and options\r\n- Case studies and precedents`;\r\n      default:\r\n        return `${basePrompt}\\n\\nProvide a detailed analysis balancing depth with clarity.`;\r\n    }\r\n  }\r\n\r\n  private async getRelevantContent(\r\n    query: string,\r\n    options: {\r\n      country?: string;\r\n      category?: string;\r\n    }\r\n  ): Promise<DomainDocument[]> {\r\n    const { data: documents, error } = await this.supabase\r\n      .from(\"documents\")\r\n      .select(\"*\")\r\n      .textSearch(\"content\", query)\r\n      .eq(\"country\", options.country || \"\")\r\n      .eq(\"category\", options.category || \"\")\r\n      .limit(10);\r\n\r\n    if (error) throw error;\r\n    return documents || [];\r\n  }\r\n}\r\n","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","'use strict';\n\nconst OriginalAgent = require('http').Agent;\nconst ms = require('humanize-ms');\nconst debug = require('util').debuglog('agentkeepalive');\nconst {\n  INIT_SOCKET,\n  CURRENT_ID,\n  CREATE_ID,\n  SOCKET_CREATED_TIME,\n  SOCKET_NAME,\n  SOCKET_REQUEST_COUNT,\n  SOCKET_REQUEST_FINISHED_COUNT,\n} = require('./constants');\n\n// OriginalAgent come from\n// - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n// - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n\n// node <= 10\nlet defaultTimeoutListenerCount = 1;\nconst majorVersion = parseInt(process.version.split('.', 1)[0].substring(1));\nif (majorVersion >= 11 && majorVersion <= 12) {\n  defaultTimeoutListenerCount = 2;\n} else if (majorVersion >= 13) {\n  defaultTimeoutListenerCount = 3;\n}\n\nfunction deprecate(message) {\n  console.log('[agentkeepalive:deprecated] %s', message);\n}\n\nclass Agent extends OriginalAgent {\n  constructor(options) {\n    options = options || {};\n    options.keepAlive = options.keepAlive !== false;\n    // default is keep-alive and 4s free socket timeout\n    // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n    if (options.freeSocketTimeout === undefined) {\n      options.freeSocketTimeout = 4000;\n    }\n    // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n    if (options.keepAliveTimeout) {\n      deprecate('options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');\n      options.freeSocketTimeout = options.keepAliveTimeout;\n      delete options.keepAliveTimeout;\n    }\n    // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n    if (options.freeSocketKeepAliveTimeout) {\n      deprecate('options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');\n      options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n      delete options.freeSocketKeepAliveTimeout;\n    }\n\n    // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n    // By default is double free socket timeout.\n    if (options.timeout === undefined) {\n      // make sure socket default inactivity timeout >= 8s\n      options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n    }\n\n    // support humanize format\n    options.timeout = ms(options.timeout);\n    options.freeSocketTimeout = ms(options.freeSocketTimeout);\n    options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n\n    super(options);\n\n    this[CURRENT_ID] = 0;\n\n    // create socket success counter\n    this.createSocketCount = 0;\n    this.createSocketCountLastCheck = 0;\n\n    this.createSocketErrorCount = 0;\n    this.createSocketErrorCountLastCheck = 0;\n\n    this.closeSocketCount = 0;\n    this.closeSocketCountLastCheck = 0;\n\n    // socket error event count\n    this.errorSocketCount = 0;\n    this.errorSocketCountLastCheck = 0;\n\n    // request finished counter\n    this.requestCount = 0;\n    this.requestCountLastCheck = 0;\n\n    // including free socket timeout counter\n    this.timeoutSocketCount = 0;\n    this.timeoutSocketCountLastCheck = 0;\n\n    this.on('free', socket => {\n      // https://github.com/nodejs/node/pull/32000\n      // Node.js native agent will check socket timeout eqs agent.options.timeout.\n      // Use the ttl or freeSocketTimeout to overwrite.\n      const timeout = this.calcSocketTimeout(socket);\n      if (timeout > 0 && socket.timeout !== timeout) {\n        socket.setTimeout(timeout);\n      }\n    });\n  }\n\n  get freeSocketKeepAliveTimeout() {\n    deprecate('agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead');\n    return this.options.freeSocketTimeout;\n  }\n\n  get timeout() {\n    deprecate('agent.timeout is deprecated, please use agent.options.timeout instead');\n    return this.options.timeout;\n  }\n\n  get socketActiveTTL() {\n    deprecate('agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead');\n    return this.options.socketActiveTTL;\n  }\n\n  calcSocketTimeout(socket) {\n    /**\n     * return <= 0: should free socket\n     * return > 0: should update socket timeout\n     * return undefined: not find custom timeout\n     */\n    let freeSocketTimeout = this.options.freeSocketTimeout;\n    const socketActiveTTL = this.options.socketActiveTTL;\n    if (socketActiveTTL) {\n      // check socketActiveTTL\n      const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n      const diff = socketActiveTTL - aliveTime;\n      if (diff <= 0) {\n        return diff;\n      }\n      if (freeSocketTimeout && diff < freeSocketTimeout) {\n        freeSocketTimeout = diff;\n      }\n    }\n    // set freeSocketTimeout\n    if (freeSocketTimeout) {\n      // set free keepalive timer\n      // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n      // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n      const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n      return customFreeSocketTimeout || freeSocketTimeout;\n    }\n  }\n\n  keepSocketAlive(socket) {\n    const result = super.keepSocketAlive(socket);\n    // should not keepAlive, do nothing\n    if (!result) return result;\n\n    const customTimeout = this.calcSocketTimeout(socket);\n    if (typeof customTimeout === 'undefined') {\n      return true;\n    }\n    if (customTimeout <= 0) {\n      debug('%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s',\n        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n      return false;\n    }\n    if (socket.timeout !== customTimeout) {\n      socket.setTimeout(customTimeout);\n    }\n    return true;\n  }\n\n  // only call on addRequest\n  reuseSocket(...args) {\n    // reuseSocket(socket, req)\n    super.reuseSocket(...args);\n    const socket = args[0];\n    const req = args[1];\n    req.reusedSocket = true;\n    const agentTimeout = this.options.timeout;\n    if (getSocketTimeout(socket) !== agentTimeout) {\n      // reset timeout before use\n      socket.setTimeout(agentTimeout);\n      debug('%s reset timeout to %sms', socket[SOCKET_NAME], agentTimeout);\n    }\n    socket[SOCKET_REQUEST_COUNT]++;\n    debug('%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],\n      getSocketTimeout(socket));\n  }\n\n  [CREATE_ID]() {\n    const id = this[CURRENT_ID]++;\n    if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n    return id;\n  }\n\n  [INIT_SOCKET](socket, options) {\n    // bugfix here.\n    // https on node 8, 10 won't set agent.options.timeout by default\n    // TODO: need to fix on node itself\n    if (options.timeout) {\n      const timeout = getSocketTimeout(socket);\n      if (!timeout) {\n        socket.setTimeout(options.timeout);\n      }\n    }\n\n    if (this.options.keepAlive) {\n      // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n      // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n      socket.setNoDelay(true);\n    }\n    this.createSocketCount++;\n    if (this.options.socketActiveTTL) {\n      socket[SOCKET_CREATED_TIME] = Date.now();\n    }\n    // don't show the hole '-----BEGIN CERTIFICATE----' key string\n    socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split('-----BEGIN', 1)[0];\n    socket[SOCKET_REQUEST_COUNT] = 1;\n    socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n    installListeners(this, socket, options);\n  }\n\n  createConnection(options, oncreate) {\n    let called = false;\n    const onNewCreate = (err, socket) => {\n      if (called) return;\n      called = true;\n\n      if (err) {\n        this.createSocketErrorCount++;\n        return oncreate(err);\n      }\n      this[INIT_SOCKET](socket, options);\n      oncreate(err, socket);\n    };\n\n    const newSocket = super.createConnection(options, onNewCreate);\n    if (newSocket) onNewCreate(null, newSocket);\n    return newSocket;\n  }\n\n  get statusChanged() {\n    const changed = this.createSocketCount !== this.createSocketCountLastCheck ||\n      this.createSocketErrorCount !== this.createSocketErrorCountLastCheck ||\n      this.closeSocketCount !== this.closeSocketCountLastCheck ||\n      this.errorSocketCount !== this.errorSocketCountLastCheck ||\n      this.timeoutSocketCount !== this.timeoutSocketCountLastCheck ||\n      this.requestCount !== this.requestCountLastCheck;\n    if (changed) {\n      this.createSocketCountLastCheck = this.createSocketCount;\n      this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n      this.closeSocketCountLastCheck = this.closeSocketCount;\n      this.errorSocketCountLastCheck = this.errorSocketCount;\n      this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n      this.requestCountLastCheck = this.requestCount;\n    }\n    return changed;\n  }\n\n  getCurrentStatus() {\n    return {\n      createSocketCount: this.createSocketCount,\n      createSocketErrorCount: this.createSocketErrorCount,\n      closeSocketCount: this.closeSocketCount,\n      errorSocketCount: this.errorSocketCount,\n      timeoutSocketCount: this.timeoutSocketCount,\n      requestCount: this.requestCount,\n      freeSockets: inspect(this.freeSockets),\n      sockets: inspect(this.sockets),\n      requests: inspect(this.requests),\n    };\n  }\n}\n\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n  return socket.timeout || socket._idleTimeout;\n}\n\nfunction installListeners(agent, socket, options) {\n  debug('%s create, timeout %sms', socket[SOCKET_NAME], getSocketTimeout(socket));\n\n  // listener socket events: close, timeout, error, free\n  function onFree() {\n    // create and socket.emit('free') logic\n    // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n    // no req on the socket, it should be the new socket\n    if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n\n    socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n    agent.requestCount++;\n    debug('%s(requests: %s, finished: %s) free',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n\n    // should reuse on pedding requests?\n    const name = agent.getName(options);\n    if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n      // will be reuse on agent free listener\n      socket[SOCKET_REQUEST_COUNT]++;\n      debug('%s(requests: %s, finished: %s) will be reuse on agent free event',\n        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n    }\n  }\n  socket.on('free', onFree);\n\n  function onClose(isError) {\n    debug('%s(requests: %s, finished: %s) close, isError: %s',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n    agent.closeSocketCount++;\n  }\n  socket.on('close', onClose);\n\n  // start socket timeout handler\n  function onTimeout() {\n    // onTimeout and emitRequestTimeout(_http_client.js)\n    // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n    const listenerCount = socket.listeners('timeout').length;\n    // node <= 10, default listenerCount is 1, onTimeout\n    // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n    // node >= 13, default listenerCount is 3, onTimeout,\n    //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n    //   and emitRequestTimeout\n    const timeout = getSocketTimeout(socket);\n    const req = socket._httpMessage;\n    const reqTimeoutListenerCount = req && req.listeners('timeout').length || 0;\n    debug('%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],\n      timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n    if (debug.enabled) {\n      debug('timeout listeners: %s', socket.listeners('timeout').map(f => f.name).join(', '));\n    }\n    agent.timeoutSocketCount++;\n    const name = agent.getName(options);\n    if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n      // free socket timeout, destroy quietly\n      socket.destroy();\n      // Remove it from freeSockets list immediately to prevent new requests\n      // from being sent through this socket.\n      agent.removeSocket(socket, options);\n      debug('%s is free, destroy quietly', socket[SOCKET_NAME]);\n    } else {\n      // if there is no any request socket timeout handler,\n      // agent need to handle socket timeout itself.\n      //\n      // custom request socket timeout handle logic must follow these rules:\n      //  1. Destroy socket first\n      //  2. Must emit socket 'agentRemove' event tell agent remove socket\n      //     from freeSockets list immediately.\n      //     Otherise you may be get 'socket hang up' error when reuse\n      //     free socket and timeout happen in the same time.\n      if (reqTimeoutListenerCount === 0) {\n        const error = new Error('Socket timeout');\n        error.code = 'ERR_SOCKET_TIMEOUT';\n        error.timeout = timeout;\n        // must manually call socket.end() or socket.destroy() to end the connection.\n        // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n        socket.destroy(error);\n        agent.removeSocket(socket, options);\n        debug('%s destroy with timeout error', socket[SOCKET_NAME]);\n      }\n    }\n  }\n  socket.on('timeout', onTimeout);\n\n  function onError(err) {\n    const listenerCount = socket.listeners('error').length;\n    debug('%s(requests: %s, finished: %s) error: %s, listenerCount: %s',\n      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],\n      err, listenerCount);\n    agent.errorSocketCount++;\n    if (listenerCount === 1) {\n      // if socket don't contain error event handler, don't catch it, emit it again\n      debug('%s emit uncaught error event', socket[SOCKET_NAME]);\n      socket.removeListener('error', onError);\n      socket.emit('error', err);\n    }\n  }\n  socket.on('error', onError);\n\n  function onRemove() {\n    debug('%s(requests: %s, finished: %s) agentRemove',\n      socket[SOCKET_NAME],\n      socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the\n    // pool because it'll be locked up indefinitely\n    socket.removeListener('close', onClose);\n    socket.removeListener('error', onError);\n    socket.removeListener('free', onFree);\n    socket.removeListener('timeout', onTimeout);\n    socket.removeListener('agentRemove', onRemove);\n  }\n  socket.on('agentRemove', onRemove);\n}\n\nmodule.exports = Agent;\n\nfunction inspect(obj) {\n  const res = {};\n  for (const key in obj) {\n    res[key] = obj[key].length;\n  }\n  return res;\n}\n","'use strict';\n\nmodule.exports = {\n  // agent\n  CURRENT_ID: Symbol('agentkeepalive#currentId'),\n  CREATE_ID: Symbol('agentkeepalive#createId'),\n  INIT_SOCKET: Symbol('agentkeepalive#initSocket'),\n  CREATE_HTTPS_CONNECTION: Symbol('agentkeepalive#createHttpsConnection'),\n  // socket\n  SOCKET_CREATED_TIME: Symbol('agentkeepalive#socketCreatedTime'),\n  SOCKET_NAME: Symbol('agentkeepalive#socketName'),\n  SOCKET_REQUEST_COUNT: Symbol('agentkeepalive#socketRequestCount'),\n  SOCKET_REQUEST_FINISHED_COUNT: Symbol('agentkeepalive#socketRequestFinishedCount'),\n};\n","module.exports = require(\"zlib\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"node:crypto\");","module.exports = require(\"buffer\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","/**\n * @license\n * web-streams-polyfill v4.0.0-beta.3\n * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.\n * This code is released under the MIT license.\n * SPDX-License-Identifier: MIT\n */\nconst e=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function t(){}function r(e){return\"object\"==typeof e&&null!==e||\"function\"==typeof e}const o=t;function n(e,t){try{Object.defineProperty(e,\"name\",{value:t,configurable:!0})}catch(e){}}const a=Promise,i=Promise.prototype.then,l=Promise.resolve.bind(a),s=Promise.reject.bind(a);function u(e){return new a(e)}function c(e){return l(e)}function d(e){return s(e)}function f(e,t,r){return i.call(e,t,r)}function b(e,t,r){f(f(e,t,r),void 0,o)}function h(e,t){b(e,t)}function _(e,t){b(e,void 0,t)}function p(e,t,r){return f(e,t,r)}function m(e){f(e,void 0,o)}let y=e=>{if(\"function\"==typeof queueMicrotask)y=queueMicrotask;else{const e=c(void 0);y=t=>f(e,t)}return y(e)};function g(e,t,r){if(\"function\"!=typeof e)throw new TypeError(\"Argument is not a function\");return Function.prototype.apply.call(e,t,r)}function w(e,t,r){try{return c(g(e,t,r))}catch(e){return d(e)}}class S{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(e){const t=this._back;let r=t;16383===t._elements.length&&(r={_elements:[],_next:void 0}),t._elements.push(e),r!==t&&(this._back=r,t._next=r),++this._size}shift(){const e=this._front;let t=e;const r=this._cursor;let o=r+1;const n=e._elements,a=n[r];return 16384===o&&(t=e._next,o=0),--this._size,this._cursor=o,e!==t&&(this._front=t),n[r]=void 0,a}forEach(e){let t=this._cursor,r=this._front,o=r._elements;for(;!(t===o.length&&void 0===r._next||t===o.length&&(r=r._next,o=r._elements,t=0,0===o.length));)e(o[t]),++t}peek(){const e=this._front,t=this._cursor;return e._elements[t]}}const v=e(\"[[AbortSteps]]\"),R=e(\"[[ErrorSteps]]\"),T=e(\"[[CancelSteps]]\"),q=e(\"[[PullSteps]]\"),C=e(\"[[ReleaseSteps]]\");function E(e,t){e._ownerReadableStream=t,t._reader=e,\"readable\"===t._state?O(e):\"closed\"===t._state?function(e){O(e),j(e)}(e):B(e,t._storedError)}function P(e,t){return Gt(e._ownerReadableStream,t)}function W(e){const t=e._ownerReadableStream;\"readable\"===t._state?A(e,new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")):function(e,t){B(e,t)}(e,new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")),t._readableStreamController[C](),t._reader=void 0,e._ownerReadableStream=void 0}function k(e){return new TypeError(\"Cannot \"+e+\" a stream using a released reader\")}function O(e){e._closedPromise=u(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r}))}function B(e,t){O(e),A(e,t)}function A(e,t){void 0!==e._closedPromise_reject&&(m(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}function j(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}const z=Number.isFinite||function(e){return\"number\"==typeof e&&isFinite(e)},L=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function F(e,t){if(void 0!==e&&(\"object\"!=typeof(r=e)&&\"function\"!=typeof r))throw new TypeError(`${t} is not an object.`);var r}function I(e,t){if(\"function\"!=typeof e)throw new TypeError(`${t} is not a function.`)}function D(e,t){if(!function(e){return\"object\"==typeof e&&null!==e||\"function\"==typeof e}(e))throw new TypeError(`${t} is not an object.`)}function $(e,t,r){if(void 0===e)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function M(e,t,r){if(void 0===e)throw new TypeError(`${t} is required in '${r}'.`)}function Y(e){return Number(e)}function Q(e){return 0===e?0:e}function N(e,t){const r=Number.MAX_SAFE_INTEGER;let o=Number(e);if(o=Q(o),!z(o))throw new TypeError(`${t} is not a finite number`);if(o=function(e){return Q(L(e))}(o),o<0||o>r)throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);return z(o)&&0!==o?o:0}function H(e){if(!r(e))return!1;if(\"function\"!=typeof e.getReader)return!1;try{return\"boolean\"==typeof e.locked}catch(e){return!1}}function x(e){if(!r(e))return!1;if(\"function\"!=typeof e.getWriter)return!1;try{return\"boolean\"==typeof e.locked}catch(e){return!1}}function V(e,t){if(!Vt(e))throw new TypeError(`${t} is not a ReadableStream.`)}function U(e,t){e._reader._readRequests.push(t)}function G(e,t,r){const o=e._reader._readRequests.shift();r?o._closeSteps():o._chunkSteps(t)}function X(e){return e._reader._readRequests.length}function J(e){const t=e._reader;return void 0!==t&&!!K(t)}class ReadableStreamDefaultReader{constructor(e){if($(e,1,\"ReadableStreamDefaultReader\"),V(e,\"First parameter\"),Ut(e))throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");E(this,e),this._readRequests=new S}get closed(){return K(this)?this._closedPromise:d(ee(\"closed\"))}cancel(e){return K(this)?void 0===this._ownerReadableStream?d(k(\"cancel\")):P(this,e):d(ee(\"cancel\"))}read(){if(!K(this))return d(ee(\"read\"));if(void 0===this._ownerReadableStream)return d(k(\"read from\"));let e,t;const r=u(((r,o)=>{e=r,t=o}));return function(e,t){const r=e._ownerReadableStream;r._disturbed=!0,\"closed\"===r._state?t._closeSteps():\"errored\"===r._state?t._errorSteps(r._storedError):r._readableStreamController[q](t)}(this,{_chunkSteps:t=>e({value:t,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:e=>t(e)}),r}releaseLock(){if(!K(this))throw ee(\"releaseLock\");void 0!==this._ownerReadableStream&&function(e){W(e);const t=new TypeError(\"Reader was released\");Z(e,t)}(this)}}function K(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_readRequests\")&&e instanceof ReadableStreamDefaultReader)}function Z(e,t){const r=e._readRequests;e._readRequests=new S,r.forEach((e=>{e._errorSteps(t)}))}function ee(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),n(ReadableStreamDefaultReader.prototype.cancel,\"cancel\"),n(ReadableStreamDefaultReader.prototype.read,\"read\"),n(ReadableStreamDefaultReader.prototype.releaseLock,\"releaseLock\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(ReadableStreamDefaultReader.prototype,e.toStringTag,{value:\"ReadableStreamDefaultReader\",configurable:!0});class te{constructor(e,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=t}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?p(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const t=()=>this._returnSteps(e);return this._ongoingPromise?p(this._ongoingPromise,t,t):t()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;return void 0===e?d(k(\"iterate\")):f(e.read(),(e=>{var t;return this._ongoingPromise=void 0,e.done&&(this._isFinished=!0,null===(t=this._reader)||void 0===t||t.releaseLock(),this._reader=void 0),e}),(e=>{var t;throw this._ongoingPromise=void 0,this._isFinished=!0,null===(t=this._reader)||void 0===t||t.releaseLock(),this._reader=void 0,e}))}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const t=this._reader;if(void 0===t)return d(k(\"finish iterating\"));if(this._reader=void 0,!this._preventCancel){const r=t.cancel(e);return t.releaseLock(),p(r,(()=>({value:e,done:!0})))}return t.releaseLock(),c({value:e,done:!0})}}const re={next(){return oe(this)?this._asyncIteratorImpl.next():d(ne(\"next\"))},return(e){return oe(this)?this._asyncIteratorImpl.return(e):d(ne(\"return\"))}};function oe(e){if(!r(e))return!1;if(!Object.prototype.hasOwnProperty.call(e,\"_asyncIteratorImpl\"))return!1;try{return e._asyncIteratorImpl instanceof te}catch(e){return!1}}function ne(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}\"symbol\"==typeof e.asyncIterator&&Object.defineProperty(re,e.asyncIterator,{value(){return this},writable:!0,configurable:!0});const ae=Number.isNaN||function(e){return e!=e};function ie(e,t,r,o,n){new Uint8Array(e).set(new Uint8Array(r,o,n),t)}function le(e){const t=function(e,t,r){if(e.slice)return e.slice(t,r);const o=r-t,n=new ArrayBuffer(o);return ie(n,0,e,t,o),n}(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(t)}function se(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function ue(e,t,r){if(\"number\"!=typeof(o=r)||ae(o)||o<0||r===1/0)throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");var o;e._queue.push({value:t,size:r}),e._queueTotalSize+=r}function ce(e){e._queue=new S,e._queueTotalSize=0}class ReadableStreamBYOBRequest{constructor(){throw new TypeError(\"Illegal constructor\")}get view(){if(!fe(this))throw Be(\"view\");return this._view}respond(e){if(!fe(this))throw Be(\"respond\");if($(e,1,\"respond\"),e=N(e,\"First parameter\"),void 0===this._associatedReadableByteStreamController)throw new TypeError(\"This BYOB request has been invalidated\");this._view.buffer,function(e,t){const r=e._pendingPullIntos.peek();if(\"closed\"===e._controlledReadableByteStream._state){if(0!==t)throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\")}else{if(0===t)throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");if(r.bytesFilled+t>r.byteLength)throw new RangeError(\"bytesWritten out of range\")}r.buffer=r.buffer,qe(e,t)}(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!fe(this))throw Be(\"respondWithNewView\");if($(e,1,\"respondWithNewView\"),!ArrayBuffer.isView(e))throw new TypeError(\"You can only respond with array buffer views\");if(void 0===this._associatedReadableByteStreamController)throw new TypeError(\"This BYOB request has been invalidated\");e.buffer,function(e,t){const r=e._pendingPullIntos.peek();if(\"closed\"===e._controlledReadableByteStream._state){if(0!==t.byteLength)throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\")}else if(0===t.byteLength)throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");if(r.byteOffset+r.bytesFilled!==t.byteOffset)throw new RangeError(\"The region specified by view does not match byobRequest\");if(r.bufferByteLength!==t.buffer.byteLength)throw new RangeError(\"The buffer of view has different capacity than byobRequest\");if(r.bytesFilled+t.byteLength>r.byteLength)throw new RangeError(\"The region specified by view is larger than byobRequest\");const o=t.byteLength;r.buffer=t.buffer,qe(e,o)}(this._associatedReadableByteStreamController,e)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),n(ReadableStreamBYOBRequest.prototype.respond,\"respond\"),n(ReadableStreamBYOBRequest.prototype.respondWithNewView,\"respondWithNewView\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(ReadableStreamBYOBRequest.prototype,e.toStringTag,{value:\"ReadableStreamBYOBRequest\",configurable:!0});class ReadableByteStreamController{constructor(){throw new TypeError(\"Illegal constructor\")}get byobRequest(){if(!de(this))throw Ae(\"byobRequest\");return function(e){if(null===e._byobRequest&&e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),o=Object.create(ReadableStreamBYOBRequest.prototype);!function(e,t,r){e._associatedReadableByteStreamController=t,e._view=r}(o,e,r),e._byobRequest=o}return e._byobRequest}(this)}get desiredSize(){if(!de(this))throw Ae(\"desiredSize\");return ke(this)}close(){if(!de(this))throw Ae(\"close\");if(this._closeRequested)throw new TypeError(\"The stream has already been closed; do not close it again!\");const e=this._controlledReadableByteStream._state;if(\"readable\"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);!function(e){const t=e._controlledReadableByteStream;if(e._closeRequested||\"readable\"!==t._state)return;if(e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0){if(e._pendingPullIntos.peek().bytesFilled>0){const t=new TypeError(\"Insufficient bytes to fill elements in the given buffer\");throw Pe(e,t),t}}Ee(e),Xt(t)}(this)}enqueue(e){if(!de(this))throw Ae(\"enqueue\");if($(e,1,\"enqueue\"),!ArrayBuffer.isView(e))throw new TypeError(\"chunk must be an array buffer view\");if(0===e.byteLength)throw new TypeError(\"chunk must have non-zero byteLength\");if(0===e.buffer.byteLength)throw new TypeError(\"chunk's buffer must have non-zero byteLength\");if(this._closeRequested)throw new TypeError(\"stream is closed or draining\");const t=this._controlledReadableByteStream._state;if(\"readable\"!==t)throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);!function(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||\"readable\"!==r._state)return;const o=t.buffer,n=t.byteOffset,a=t.byteLength,i=o;if(e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek();t.buffer,0,Re(e),t.buffer=t.buffer,\"none\"===t.readerType&&ge(e,t)}if(J(r))if(function(e){const t=e._controlledReadableByteStream._reader;for(;t._readRequests.length>0;){if(0===e._queueTotalSize)return;We(e,t._readRequests.shift())}}(e),0===X(r))me(e,i,n,a);else{e._pendingPullIntos.length>0&&Ce(e);G(r,new Uint8Array(i,n,a),!1)}else Le(r)?(me(e,i,n,a),Te(e)):me(e,i,n,a);be(e)}(this,e)}error(e){if(!de(this))throw Ae(\"error\");Pe(this,e)}[T](e){he(this),ce(this);const t=this._cancelAlgorithm(e);return Ee(this),t}[q](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0)return void We(this,e);const r=this._autoAllocateChunkSize;if(void 0!==r){let t;try{t=new ArrayBuffer(r)}catch(t){return void e._errorSteps(t)}const o={buffer:t,bufferByteLength:r,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:\"default\"};this._pendingPullIntos.push(o)}U(t,e),be(this)}[C](){if(this._pendingPullIntos.length>0){const e=this._pendingPullIntos.peek();e.readerType=\"none\",this._pendingPullIntos=new S,this._pendingPullIntos.push(e)}}}function de(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledReadableByteStream\")&&e instanceof ReadableByteStreamController)}function fe(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_associatedReadableByteStreamController\")&&e instanceof ReadableStreamBYOBRequest)}function be(e){const t=function(e){const t=e._controlledReadableByteStream;if(\"readable\"!==t._state)return!1;if(e._closeRequested)return!1;if(!e._started)return!1;if(J(t)&&X(t)>0)return!0;if(Le(t)&&ze(t)>0)return!0;if(ke(e)>0)return!0;return!1}(e);if(!t)return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;b(e._pullAlgorithm(),(()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,be(e)),null)),(t=>(Pe(e,t),null)))}function he(e){Re(e),e._pendingPullIntos=new S}function _e(e,t){let r=!1;\"closed\"===e._state&&(r=!0);const o=pe(t);\"default\"===t.readerType?G(e,o,r):function(e,t,r){const o=e._reader._readIntoRequests.shift();r?o._closeSteps(t):o._chunkSteps(t)}(e,o,r)}function pe(e){const t=e.bytesFilled,r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}function me(e,t,r,o){e._queue.push({buffer:t,byteOffset:r,byteLength:o}),e._queueTotalSize+=o}function ye(e,t,r,o){let n;try{n=t.slice(r,r+o)}catch(t){throw Pe(e,t),t}me(e,n,0,o)}function ge(e,t){t.bytesFilled>0&&ye(e,t.buffer,t.byteOffset,t.bytesFilled),Ce(e)}function we(e,t){const r=t.elementSize,o=t.bytesFilled-t.bytesFilled%r,n=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),a=t.bytesFilled+n,i=a-a%r;let l=n,s=!1;i>o&&(l=i-t.bytesFilled,s=!0);const u=e._queue;for(;l>0;){const r=u.peek(),o=Math.min(l,r.byteLength),n=t.byteOffset+t.bytesFilled;ie(t.buffer,n,r.buffer,r.byteOffset,o),r.byteLength===o?u.shift():(r.byteOffset+=o,r.byteLength-=o),e._queueTotalSize-=o,Se(e,o,t),l-=o}return s}function Se(e,t,r){r.bytesFilled+=t}function ve(e){0===e._queueTotalSize&&e._closeRequested?(Ee(e),Xt(e._controlledReadableByteStream)):be(e)}function Re(e){null!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null)}function Te(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const t=e._pendingPullIntos.peek();we(e,t)&&(Ce(e),_e(e._controlledReadableByteStream,t))}}function qe(e,t){const r=e._pendingPullIntos.peek();Re(e);\"closed\"===e._controlledReadableByteStream._state?function(e,t){\"none\"===t.readerType&&Ce(e);const r=e._controlledReadableByteStream;if(Le(r))for(;ze(r)>0;)_e(r,Ce(e))}(e,r):function(e,t,r){if(Se(0,t,r),\"none\"===r.readerType)return ge(e,r),void Te(e);if(r.bytesFilled<r.elementSize)return;Ce(e);const o=r.bytesFilled%r.elementSize;if(o>0){const t=r.byteOffset+r.bytesFilled;ye(e,r.buffer,t-o,o)}r.bytesFilled-=o,_e(e._controlledReadableByteStream,r),Te(e)}(e,t,r),be(e)}function Ce(e){return e._pendingPullIntos.shift()}function Ee(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function Pe(e,t){const r=e._controlledReadableByteStream;\"readable\"===r._state&&(he(e),ce(e),Ee(e),Jt(r,t))}function We(e,t){const r=e._queue.shift();e._queueTotalSize-=r.byteLength,ve(e);const o=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);t._chunkSteps(o)}function ke(e){const t=e._controlledReadableByteStream._state;return\"errored\"===t?null:\"closed\"===t?0:e._strategyHWM-e._queueTotalSize}function Oe(e,t,r){const o=Object.create(ReadableByteStreamController.prototype);let n,a,i;n=void 0!==t.start?()=>t.start(o):()=>{},a=void 0!==t.pull?()=>t.pull(o):()=>c(void 0),i=void 0!==t.cancel?e=>t.cancel(e):()=>c(void 0);const l=t.autoAllocateChunkSize;if(0===l)throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");!function(e,t,r,o,n,a,i){t._controlledReadableByteStream=e,t._pullAgain=!1,t._pulling=!1,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,ce(t),t._closeRequested=!1,t._started=!1,t._strategyHWM=a,t._pullAlgorithm=o,t._cancelAlgorithm=n,t._autoAllocateChunkSize=i,t._pendingPullIntos=new S,e._readableStreamController=t,b(c(r()),(()=>(t._started=!0,be(t),null)),(e=>(Pe(t,e),null)))}(e,o,n,a,i,r,l)}function Be(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function Ae(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function je(e,t){e._reader._readIntoRequests.push(t)}function ze(e){return e._reader._readIntoRequests.length}function Le(e){const t=e._reader;return void 0!==t&&!!Fe(t)}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),n(ReadableByteStreamController.prototype.close,\"close\"),n(ReadableByteStreamController.prototype.enqueue,\"enqueue\"),n(ReadableByteStreamController.prototype.error,\"error\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(ReadableByteStreamController.prototype,e.toStringTag,{value:\"ReadableByteStreamController\",configurable:!0});class ReadableStreamBYOBReader{constructor(e){if($(e,1,\"ReadableStreamBYOBReader\"),V(e,\"First parameter\"),Ut(e))throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");if(!de(e._readableStreamController))throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");E(this,e),this._readIntoRequests=new S}get closed(){return Fe(this)?this._closedPromise:d(De(\"closed\"))}cancel(e){return Fe(this)?void 0===this._ownerReadableStream?d(k(\"cancel\")):P(this,e):d(De(\"cancel\"))}read(e){if(!Fe(this))return d(De(\"read\"));if(!ArrayBuffer.isView(e))return d(new TypeError(\"view must be an array buffer view\"));if(0===e.byteLength)return d(new TypeError(\"view must have non-zero byteLength\"));if(0===e.buffer.byteLength)return d(new TypeError(\"view's buffer must have non-zero byteLength\"));if(e.buffer,void 0===this._ownerReadableStream)return d(k(\"read from\"));let t,r;const o=u(((e,o)=>{t=e,r=o}));return function(e,t,r){const o=e._ownerReadableStream;o._disturbed=!0,\"errored\"===o._state?r._errorSteps(o._storedError):function(e,t,r){const o=e._controlledReadableByteStream;let n=1;t.constructor!==DataView&&(n=t.constructor.BYTES_PER_ELEMENT);const a=t.constructor,i=t.buffer,l={buffer:i,bufferByteLength:i.byteLength,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:n,viewConstructor:a,readerType:\"byob\"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(l),void je(o,r);if(\"closed\"!==o._state){if(e._queueTotalSize>0){if(we(e,l)){const t=pe(l);return ve(e),void r._chunkSteps(t)}if(e._closeRequested){const t=new TypeError(\"Insufficient bytes to fill elements in the given buffer\");return Pe(e,t),void r._errorSteps(t)}}e._pendingPullIntos.push(l),je(o,r),be(e)}else{const e=new a(l.buffer,l.byteOffset,0);r._closeSteps(e)}}(o._readableStreamController,t,r)}(this,e,{_chunkSteps:e=>t({value:e,done:!1}),_closeSteps:e=>t({value:e,done:!0}),_errorSteps:e=>r(e)}),o}releaseLock(){if(!Fe(this))throw De(\"releaseLock\");void 0!==this._ownerReadableStream&&function(e){W(e);const t=new TypeError(\"Reader was released\");Ie(e,t)}(this)}}function Fe(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_readIntoRequests\")&&e instanceof ReadableStreamBYOBReader)}function Ie(e,t){const r=e._readIntoRequests;e._readIntoRequests=new S,r.forEach((e=>{e._errorSteps(t)}))}function De(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function $e(e,t){const{highWaterMark:r}=e;if(void 0===r)return t;if(ae(r)||r<0)throw new RangeError(\"Invalid highWaterMark\");return r}function Me(e){const{size:t}=e;return t||(()=>1)}function Ye(e,t){F(e,t);const r=null==e?void 0:e.highWaterMark,o=null==e?void 0:e.size;return{highWaterMark:void 0===r?void 0:Y(r),size:void 0===o?void 0:Qe(o,`${t} has member 'size' that`)}}function Qe(e,t){return I(e,t),t=>Y(e(t))}function Ne(e,t,r){return I(e,r),r=>w(e,t,[r])}function He(e,t,r){return I(e,r),()=>w(e,t,[])}function xe(e,t,r){return I(e,r),r=>g(e,t,[r])}function Ve(e,t,r){return I(e,r),(r,o)=>w(e,t,[r,o])}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),n(ReadableStreamBYOBReader.prototype.cancel,\"cancel\"),n(ReadableStreamBYOBReader.prototype.read,\"read\"),n(ReadableStreamBYOBReader.prototype.releaseLock,\"releaseLock\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(ReadableStreamBYOBReader.prototype,e.toStringTag,{value:\"ReadableStreamBYOBReader\",configurable:!0});const Ue=\"function\"==typeof AbortController;class WritableStream{constructor(e={},t={}){void 0===e?e=null:D(e,\"First parameter\");const r=Ye(t,\"Second parameter\"),o=function(e,t){F(e,t);const r=null==e?void 0:e.abort,o=null==e?void 0:e.close,n=null==e?void 0:e.start,a=null==e?void 0:e.type,i=null==e?void 0:e.write;return{abort:void 0===r?void 0:Ne(r,e,`${t} has member 'abort' that`),close:void 0===o?void 0:He(o,e,`${t} has member 'close' that`),start:void 0===n?void 0:xe(n,e,`${t} has member 'start' that`),write:void 0===i?void 0:Ve(i,e,`${t} has member 'write' that`),type:a}}(e,\"First parameter\");var n;(n=this)._state=\"writable\",n._storedError=void 0,n._writer=void 0,n._writableStreamController=void 0,n._writeRequests=new S,n._inFlightWriteRequest=void 0,n._closeRequest=void 0,n._inFlightCloseRequest=void 0,n._pendingAbortRequest=void 0,n._backpressure=!1;if(void 0!==o.type)throw new RangeError(\"Invalid type is specified\");const a=Me(r);!function(e,t,r,o){const n=Object.create(WritableStreamDefaultController.prototype);let a,i,l,s;a=void 0!==t.start?()=>t.start(n):()=>{};i=void 0!==t.write?e=>t.write(e,n):()=>c(void 0);l=void 0!==t.close?()=>t.close():()=>c(void 0);s=void 0!==t.abort?e=>t.abort(e):()=>c(void 0);!function(e,t,r,o,n,a,i,l){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,ce(t),t._abortReason=void 0,t._abortController=function(){if(Ue)return new AbortController}(),t._started=!1,t._strategySizeAlgorithm=l,t._strategyHWM=i,t._writeAlgorithm=o,t._closeAlgorithm=n,t._abortAlgorithm=a;const s=bt(t);nt(e,s);const u=r();b(c(u),(()=>(t._started=!0,dt(t),null)),(r=>(t._started=!0,Ze(e,r),null)))}(e,n,a,i,l,s,r,o)}(this,o,$e(r,1),a)}get locked(){if(!Ge(this))throw _t(\"locked\");return Xe(this)}abort(e){return Ge(this)?Xe(this)?d(new TypeError(\"Cannot abort a stream that already has a writer\")):Je(this,e):d(_t(\"abort\"))}close(){return Ge(this)?Xe(this)?d(new TypeError(\"Cannot close a stream that already has a writer\")):rt(this)?d(new TypeError(\"Cannot close an already-closing stream\")):Ke(this):d(_t(\"close\"))}getWriter(){if(!Ge(this))throw _t(\"getWriter\");return new WritableStreamDefaultWriter(this)}}function Ge(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_writableStreamController\")&&e instanceof WritableStream)}function Xe(e){return void 0!==e._writer}function Je(e,t){var r;if(\"closed\"===e._state||\"errored\"===e._state)return c(void 0);e._writableStreamController._abortReason=t,null===(r=e._writableStreamController._abortController)||void 0===r||r.abort(t);const o=e._state;if(\"closed\"===o||\"errored\"===o)return c(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let n=!1;\"erroring\"===o&&(n=!0,t=void 0);const a=u(((r,o)=>{e._pendingAbortRequest={_promise:void 0,_resolve:r,_reject:o,_reason:t,_wasAlreadyErroring:n}}));return e._pendingAbortRequest._promise=a,n||et(e,t),a}function Ke(e){const t=e._state;if(\"closed\"===t||\"errored\"===t)return d(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=u(((t,r)=>{const o={_resolve:t,_reject:r};e._closeRequest=o})),o=e._writer;var n;return void 0!==o&&e._backpressure&&\"writable\"===t&&Et(o),ue(n=e._writableStreamController,lt,0),dt(n),r}function Ze(e,t){\"writable\"!==e._state?tt(e):et(e,t)}function et(e,t){const r=e._writableStreamController;e._state=\"erroring\",e._storedError=t;const o=e._writer;void 0!==o&&it(o,t),!function(e){if(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)return!1;return!0}(e)&&r._started&&tt(e)}function tt(e){e._state=\"errored\",e._writableStreamController[R]();const t=e._storedError;if(e._writeRequests.forEach((e=>{e._reject(t)})),e._writeRequests=new S,void 0===e._pendingAbortRequest)return void ot(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void ot(e);b(e._writableStreamController[v](r._reason),(()=>(r._resolve(),ot(e),null)),(t=>(r._reject(t),ot(e),null)))}function rt(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function ot(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;void 0!==t&&St(t,e._storedError)}function nt(e,t){const r=e._writer;void 0!==r&&t!==e._backpressure&&(t?function(e){Rt(e)}(r):Et(r)),e._backpressure=t}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),n(WritableStream.prototype.abort,\"abort\"),n(WritableStream.prototype.close,\"close\"),n(WritableStream.prototype.getWriter,\"getWriter\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(WritableStream.prototype,e.toStringTag,{value:\"WritableStream\",configurable:!0});class WritableStreamDefaultWriter{constructor(e){if($(e,1,\"WritableStreamDefaultWriter\"),function(e,t){if(!Ge(e))throw new TypeError(`${t} is not a WritableStream.`)}(e,\"First parameter\"),Xe(e))throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");this._ownerWritableStream=e,e._writer=this;const t=e._state;if(\"writable\"===t)!rt(e)&&e._backpressure?Rt(this):qt(this),gt(this);else if(\"erroring\"===t)Tt(this,e._storedError),gt(this);else if(\"closed\"===t)qt(this),gt(r=this),vt(r);else{const t=e._storedError;Tt(this,t),wt(this,t)}var r}get closed(){return at(this)?this._closedPromise:d(mt(\"closed\"))}get desiredSize(){if(!at(this))throw mt(\"desiredSize\");if(void 0===this._ownerWritableStream)throw yt(\"desiredSize\");return function(e){const t=e._ownerWritableStream,r=t._state;if(\"errored\"===r||\"erroring\"===r)return null;if(\"closed\"===r)return 0;return ct(t._writableStreamController)}(this)}get ready(){return at(this)?this._readyPromise:d(mt(\"ready\"))}abort(e){return at(this)?void 0===this._ownerWritableStream?d(yt(\"abort\")):function(e,t){return Je(e._ownerWritableStream,t)}(this,e):d(mt(\"abort\"))}close(){if(!at(this))return d(mt(\"close\"));const e=this._ownerWritableStream;return void 0===e?d(yt(\"close\")):rt(e)?d(new TypeError(\"Cannot close an already-closing stream\")):Ke(this._ownerWritableStream)}releaseLock(){if(!at(this))throw mt(\"releaseLock\");void 0!==this._ownerWritableStream&&function(e){const t=e._ownerWritableStream,r=new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");it(e,r),function(e,t){\"pending\"===e._closedPromiseState?St(e,t):function(e,t){wt(e,t)}(e,t)}(e,r),t._writer=void 0,e._ownerWritableStream=void 0}(this)}write(e){return at(this)?void 0===this._ownerWritableStream?d(yt(\"write to\")):function(e,t){const r=e._ownerWritableStream,o=r._writableStreamController,n=function(e,t){try{return e._strategySizeAlgorithm(t)}catch(t){return ft(e,t),1}}(o,t);if(r!==e._ownerWritableStream)return d(yt(\"write to\"));const a=r._state;if(\"errored\"===a)return d(r._storedError);if(rt(r)||\"closed\"===a)return d(new TypeError(\"The stream is closing or closed and cannot be written to\"));if(\"erroring\"===a)return d(r._storedError);const i=function(e){return u(((t,r)=>{const o={_resolve:t,_reject:r};e._writeRequests.push(o)}))}(r);return function(e,t,r){try{ue(e,t,r)}catch(t){return void ft(e,t)}const o=e._controlledWritableStream;if(!rt(o)&&\"writable\"===o._state){nt(o,bt(e))}dt(e)}(o,t,n),i}(this,e):d(mt(\"write\"))}}function at(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_ownerWritableStream\")&&e instanceof WritableStreamDefaultWriter)}function it(e,t){\"pending\"===e._readyPromiseState?Ct(e,t):function(e,t){Tt(e,t)}(e,t)}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),n(WritableStreamDefaultWriter.prototype.abort,\"abort\"),n(WritableStreamDefaultWriter.prototype.close,\"close\"),n(WritableStreamDefaultWriter.prototype.releaseLock,\"releaseLock\"),n(WritableStreamDefaultWriter.prototype.write,\"write\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(WritableStreamDefaultWriter.prototype,e.toStringTag,{value:\"WritableStreamDefaultWriter\",configurable:!0});const lt={};class WritableStreamDefaultController{constructor(){throw new TypeError(\"Illegal constructor\")}get abortReason(){if(!st(this))throw pt(\"abortReason\");return this._abortReason}get signal(){if(!st(this))throw pt(\"signal\");if(void 0===this._abortController)throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");return this._abortController.signal}error(e){if(!st(this))throw pt(\"error\");\"writable\"===this._controlledWritableStream._state&&ht(this,e)}[v](e){const t=this._abortAlgorithm(e);return ut(this),t}[R](){ce(this)}}function st(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledWritableStream\")&&e instanceof WritableStreamDefaultController)}function ut(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function ct(e){return e._strategyHWM-e._queueTotalSize}function dt(e){const t=e._controlledWritableStream;if(!e._started)return;if(void 0!==t._inFlightWriteRequest)return;if(\"erroring\"===t._state)return void tt(t);if(0===e._queue.length)return;const r=e._queue.peek().value;r===lt?function(e){const t=e._controlledWritableStream;(function(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0})(t),se(e);const r=e._closeAlgorithm();ut(e),b(r,(()=>(function(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,\"erroring\"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state=\"closed\";const t=e._writer;void 0!==t&&vt(t)}(t),null)),(e=>(function(e,t){e._inFlightCloseRequest._reject(t),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(t),e._pendingAbortRequest=void 0),Ze(e,t)}(t,e),null)))}(e):function(e,t){const r=e._controlledWritableStream;!function(e){e._inFlightWriteRequest=e._writeRequests.shift()}(r);b(e._writeAlgorithm(t),(()=>{!function(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}(r);const t=r._state;if(se(e),!rt(r)&&\"writable\"===t){const t=bt(e);nt(r,t)}return dt(e),null}),(t=>(\"writable\"===r._state&&ut(e),function(e,t){e._inFlightWriteRequest._reject(t),e._inFlightWriteRequest=void 0,Ze(e,t)}(r,t),null)))}(e,r)}function ft(e,t){\"writable\"===e._controlledWritableStream._state&&ht(e,t)}function bt(e){return ct(e)<=0}function ht(e,t){const r=e._controlledWritableStream;ut(e),et(r,t)}function _t(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function pt(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}function mt(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function yt(e){return new TypeError(\"Cannot \"+e+\" a stream using a released writer\")}function gt(e){e._closedPromise=u(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState=\"pending\"}))}function wt(e,t){gt(e),St(e,t)}function St(e,t){void 0!==e._closedPromise_reject&&(m(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState=\"rejected\")}function vt(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState=\"resolved\")}function Rt(e){e._readyPromise=u(((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r})),e._readyPromiseState=\"pending\"}function Tt(e,t){Rt(e),Ct(e,t)}function qt(e){Rt(e),Et(e)}function Ct(e,t){void 0!==e._readyPromise_reject&&(m(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState=\"rejected\")}function Et(e){void 0!==e._readyPromise_resolve&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState=\"fulfilled\")}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(WritableStreamDefaultController.prototype,e.toStringTag,{value:\"WritableStreamDefaultController\",configurable:!0});const Pt=\"undefined\"!=typeof DOMException?DOMException:void 0;const Wt=function(e){if(\"function\"!=typeof e&&\"object\"!=typeof e)return!1;try{return new e,!0}catch(e){return!1}}(Pt)?Pt:function(){const e=function(e,t){this.message=e||\"\",this.name=t||\"Error\",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return e.prototype=Object.create(Error.prototype),Object.defineProperty(e.prototype,\"constructor\",{value:e,writable:!0,configurable:!0}),e}();function kt(e,t,r,o,n,a){const i=e.getReader(),l=t.getWriter();Vt(e)&&(e._disturbed=!0);let s,_,g,w=!1,S=!1,v=\"readable\",R=\"writable\",T=!1,q=!1;const C=u((e=>{g=e}));let E=Promise.resolve(void 0);return u(((P,W)=>{let k;function O(){if(w)return;const e=u(((e,t)=>{!function r(o){o?e():f(function(){if(w)return c(!0);return f(l.ready,(()=>f(i.read(),(e=>!!e.done||(E=l.write(e.value),m(E),!1)))))}(),r,t)}(!1)}));m(e)}function B(){return v=\"closed\",r?L():z((()=>(Ge(t)&&(T=rt(t),R=t._state),T||\"closed\"===R?c(void 0):\"erroring\"===R||\"errored\"===R?d(_):(T=!0,l.close()))),!1,void 0),null}function A(e){return w||(v=\"errored\",s=e,o?L(!0,e):z((()=>l.abort(e)),!0,e)),null}function j(e){return S||(R=\"errored\",_=e,n?L(!0,e):z((()=>i.cancel(e)),!0,e)),null}if(void 0!==a&&(k=()=>{const e=void 0!==a.reason?a.reason:new Wt(\"Aborted\",\"AbortError\"),t=[];o||t.push((()=>\"writable\"===R?l.abort(e):c(void 0))),n||t.push((()=>\"readable\"===v?i.cancel(e):c(void 0))),z((()=>Promise.all(t.map((e=>e())))),!0,e)},a.aborted?k():a.addEventListener(\"abort\",k)),Vt(e)&&(v=e._state,s=e._storedError),Ge(t)&&(R=t._state,_=t._storedError,T=rt(t)),Vt(e)&&Ge(t)&&(q=!0,g()),\"errored\"===v)A(s);else if(\"erroring\"===R||\"errored\"===R)j(_);else if(\"closed\"===v)B();else if(T||\"closed\"===R){const e=new TypeError(\"the destination writable stream closed before all data could be piped to it\");n?L(!0,e):z((()=>i.cancel(e)),!0,e)}function z(e,t,r){function o(){return\"writable\"!==R||T?n():h(function(){let e;return c(function t(){if(e!==E)return e=E,p(E,t,t)}())}(),n),null}function n(){return e?b(e(),(()=>F(t,r)),(e=>F(!0,e))):F(t,r),null}w||(w=!0,q?o():h(C,o))}function L(e,t){z(void 0,e,t)}function F(e,t){return S=!0,l.releaseLock(),i.releaseLock(),void 0!==a&&a.removeEventListener(\"abort\",k),e?W(t):P(void 0),null}w||(b(i.closed,B,A),b(l.closed,(function(){return S||(R=\"closed\"),null}),j)),q?O():y((()=>{q=!0,g(),O()}))}))}function Ot(e,t){return function(e){try{return e.getReader({mode:\"byob\"}).releaseLock(),!0}catch(e){return!1}}(e)?function(e){let t,r,o,n,a,i=e.getReader(),l=!1,s=!1,d=!1,f=!1,h=!1,p=!1;const m=u((e=>{a=e}));function y(e){_(e.closed,(t=>(e!==i||(o.error(t),n.error(t),h&&p||a(void 0)),null)))}function g(){l&&(i.releaseLock(),i=e.getReader(),y(i),l=!1),b(i.read(),(e=>{var t,r;if(d=!1,f=!1,e.done)return h||o.close(),p||n.close(),null===(t=o.byobRequest)||void 0===t||t.respond(0),null===(r=n.byobRequest)||void 0===r||r.respond(0),h&&p||a(void 0),null;const l=e.value,u=l;let c=l;if(!h&&!p)try{c=le(l)}catch(e){return o.error(e),n.error(e),a(i.cancel(e)),null}return h||o.enqueue(u),p||n.enqueue(c),s=!1,d?S():f&&v(),null}),(()=>(s=!1,null)))}function w(t,r){l||(i.releaseLock(),i=e.getReader({mode:\"byob\"}),y(i),l=!0);const u=r?n:o,c=r?o:n;b(i.read(t),(e=>{var t;d=!1,f=!1;const o=r?p:h,n=r?h:p;if(e.done){o||u.close(),n||c.close();const r=e.value;return void 0!==r&&(o||u.byobRequest.respondWithNewView(r),n||null===(t=c.byobRequest)||void 0===t||t.respond(0)),o&&n||a(void 0),null}const l=e.value;if(n)o||u.byobRequest.respondWithNewView(l);else{let e;try{e=le(l)}catch(e){return u.error(e),c.error(e),a(i.cancel(e)),null}o||u.byobRequest.respondWithNewView(l),c.enqueue(e)}return s=!1,d?S():f&&v(),null}),(()=>(s=!1,null)))}function S(){if(s)return d=!0,c(void 0);s=!0;const e=o.byobRequest;return null===e?g():w(e.view,!1),c(void 0)}function v(){if(s)return f=!0,c(void 0);s=!0;const e=n.byobRequest;return null===e?g():w(e.view,!0),c(void 0)}function R(e){if(h=!0,t=e,p){const e=[t,r],o=i.cancel(e);a(o)}return m}function T(e){if(p=!0,r=e,h){const e=[t,r],o=i.cancel(e);a(o)}return m}const q=new ReadableStream({type:\"bytes\",start(e){o=e},pull:S,cancel:R}),C=new ReadableStream({type:\"bytes\",start(e){n=e},pull:v,cancel:T});return y(i),[q,C]}(e):function(e,t){const r=e.getReader();let o,n,a,i,l,s=!1,d=!1,f=!1,h=!1;const p=u((e=>{l=e}));function m(){return s?(d=!0,c(void 0)):(s=!0,b(r.read(),(e=>{if(d=!1,e.done)return f||a.close(),h||i.close(),f&&h||l(void 0),null;const t=e.value,r=t,o=t;return f||a.enqueue(r),h||i.enqueue(o),s=!1,d&&m(),null}),(()=>(s=!1,null))),c(void 0))}function y(e){if(f=!0,o=e,h){const e=[o,n],t=r.cancel(e);l(t)}return p}function g(e){if(h=!0,n=e,f){const e=[o,n],t=r.cancel(e);l(t)}return p}const w=new ReadableStream({start(e){a=e},pull:m,cancel:y}),S=new ReadableStream({start(e){i=e},pull:m,cancel:g});return _(r.closed,(e=>(a.error(e),i.error(e),f&&h||l(void 0),null))),[w,S]}(e)}class ReadableStreamDefaultController{constructor(){throw new TypeError(\"Illegal constructor\")}get desiredSize(){if(!Bt(this))throw Dt(\"desiredSize\");return Lt(this)}close(){if(!Bt(this))throw Dt(\"close\");if(!Ft(this))throw new TypeError(\"The stream is not in a state that permits close\");!function(e){if(!Ft(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(jt(e),Xt(t))}(this)}enqueue(e){if(!Bt(this))throw Dt(\"enqueue\");if(!Ft(this))throw new TypeError(\"The stream is not in a state that permits enqueue\");return function(e,t){if(!Ft(e))return;const r=e._controlledReadableStream;if(Ut(r)&&X(r)>0)G(r,t,!1);else{let r;try{r=e._strategySizeAlgorithm(t)}catch(t){throw zt(e,t),t}try{ue(e,t,r)}catch(t){throw zt(e,t),t}}At(e)}(this,e)}error(e){if(!Bt(this))throw Dt(\"error\");zt(this,e)}[T](e){ce(this);const t=this._cancelAlgorithm(e);return jt(this),t}[q](e){const t=this._controlledReadableStream;if(this._queue.length>0){const r=se(this);this._closeRequested&&0===this._queue.length?(jt(this),Xt(t)):At(this),e._chunkSteps(r)}else U(t,e),At(this)}[C](){}}function Bt(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledReadableStream\")&&e instanceof ReadableStreamDefaultController)}function At(e){const t=function(e){const t=e._controlledReadableStream;if(!Ft(e))return!1;if(!e._started)return!1;if(Ut(t)&&X(t)>0)return!0;if(Lt(e)>0)return!0;return!1}(e);if(!t)return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;b(e._pullAlgorithm(),(()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,At(e)),null)),(t=>(zt(e,t),null)))}function jt(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function zt(e,t){const r=e._controlledReadableStream;\"readable\"===r._state&&(ce(e),jt(e),Jt(r,t))}function Lt(e){const t=e._controlledReadableStream._state;return\"errored\"===t?null:\"closed\"===t?0:e._strategyHWM-e._queueTotalSize}function Ft(e){return!e._closeRequested&&\"readable\"===e._controlledReadableStream._state}function It(e,t,r,o){const n=Object.create(ReadableStreamDefaultController.prototype);let a,i,l;a=void 0!==t.start?()=>t.start(n):()=>{},i=void 0!==t.pull?()=>t.pull(n):()=>c(void 0),l=void 0!==t.cancel?e=>t.cancel(e):()=>c(void 0),function(e,t,r,o,n,a,i){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,ce(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=i,t._strategyHWM=a,t._pullAlgorithm=o,t._cancelAlgorithm=n,e._readableStreamController=t,b(c(r()),(()=>(t._started=!0,At(t),null)),(e=>(zt(t,e),null)))}(e,n,a,i,l,r,o)}function Dt(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function $t(e,t,r){return I(e,r),r=>w(e,t,[r])}function Mt(e,t,r){return I(e,r),r=>w(e,t,[r])}function Yt(e,t,r){return I(e,r),r=>g(e,t,[r])}function Qt(e,t){if(\"bytes\"!==(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function Nt(e,t){if(\"byob\"!==(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function Ht(e,t){F(e,t);const r=null==e?void 0:e.preventAbort,o=null==e?void 0:e.preventCancel,n=null==e?void 0:e.preventClose,a=null==e?void 0:e.signal;return void 0!==a&&function(e,t){if(!function(e){if(\"object\"!=typeof e||null===e)return!1;try{return\"boolean\"==typeof e.aborted}catch(e){return!1}}(e))throw new TypeError(`${t} is not an AbortSignal.`)}(a,`${t} has member 'signal' that`),{preventAbort:Boolean(r),preventCancel:Boolean(o),preventClose:Boolean(n),signal:a}}function xt(e,t){F(e,t);const r=null==e?void 0:e.readable;M(r,\"readable\",\"ReadableWritablePair\"),function(e,t){if(!H(e))throw new TypeError(`${t} is not a ReadableStream.`)}(r,`${t} has member 'readable' that`);const o=null==e?void 0:e.writable;return M(o,\"writable\",\"ReadableWritablePair\"),function(e,t){if(!x(e))throw new TypeError(`${t} is not a WritableStream.`)}(o,`${t} has member 'writable' that`),{readable:r,writable:o}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),n(ReadableStreamDefaultController.prototype.close,\"close\"),n(ReadableStreamDefaultController.prototype.enqueue,\"enqueue\"),n(ReadableStreamDefaultController.prototype.error,\"error\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(ReadableStreamDefaultController.prototype,e.toStringTag,{value:\"ReadableStreamDefaultController\",configurable:!0});class ReadableStream{constructor(e={},t={}){void 0===e?e=null:D(e,\"First parameter\");const r=Ye(t,\"Second parameter\"),o=function(e,t){F(e,t);const r=e,o=null==r?void 0:r.autoAllocateChunkSize,n=null==r?void 0:r.cancel,a=null==r?void 0:r.pull,i=null==r?void 0:r.start,l=null==r?void 0:r.type;return{autoAllocateChunkSize:void 0===o?void 0:N(o,`${t} has member 'autoAllocateChunkSize' that`),cancel:void 0===n?void 0:$t(n,r,`${t} has member 'cancel' that`),pull:void 0===a?void 0:Mt(a,r,`${t} has member 'pull' that`),start:void 0===i?void 0:Yt(i,r,`${t} has member 'start' that`),type:void 0===l?void 0:Qt(l,`${t} has member 'type' that`)}}(e,\"First parameter\");var n;if((n=this)._state=\"readable\",n._reader=void 0,n._storedError=void 0,n._disturbed=!1,\"bytes\"===o.type){if(void 0!==r.size)throw new RangeError(\"The strategy for a byte stream cannot have a size function\");Oe(this,o,$e(r,0))}else{const e=Me(r);It(this,o,$e(r,1),e)}}get locked(){if(!Vt(this))throw Kt(\"locked\");return Ut(this)}cancel(e){return Vt(this)?Ut(this)?d(new TypeError(\"Cannot cancel a stream that already has a reader\")):Gt(this,e):d(Kt(\"cancel\"))}getReader(e){if(!Vt(this))throw Kt(\"getReader\");return void 0===function(e,t){F(e,t);const r=null==e?void 0:e.mode;return{mode:void 0===r?void 0:Nt(r,`${t} has member 'mode' that`)}}(e,\"First parameter\").mode?new ReadableStreamDefaultReader(this):function(e){return new ReadableStreamBYOBReader(e)}(this)}pipeThrough(e,t={}){if(!H(this))throw Kt(\"pipeThrough\");$(e,1,\"pipeThrough\");const r=xt(e,\"First parameter\"),o=Ht(t,\"Second parameter\");if(this.locked)throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");if(r.writable.locked)throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");return m(kt(this,r.writable,o.preventClose,o.preventAbort,o.preventCancel,o.signal)),r.readable}pipeTo(e,t={}){if(!H(this))return d(Kt(\"pipeTo\"));if(void 0===e)return d(\"Parameter 1 is required in 'pipeTo'.\");if(!x(e))return d(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));let r;try{r=Ht(t,\"Second parameter\")}catch(e){return d(e)}return this.locked?d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")):e.locked?d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")):kt(this,e,r.preventClose,r.preventAbort,r.preventCancel,r.signal)}tee(){if(!H(this))throw Kt(\"tee\");if(this.locked)throw new TypeError(\"Cannot tee a stream that already has a reader\");return Ot(this)}values(e){if(!H(this))throw Kt(\"values\");return function(e,t){const r=e.getReader(),o=new te(r,t),n=Object.create(re);return n._asyncIteratorImpl=o,n}(this,function(e,t){F(e,t);const r=null==e?void 0:e.preventCancel;return{preventCancel:Boolean(r)}}(e,\"First parameter\").preventCancel)}}function Vt(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_readableStreamController\")&&e instanceof ReadableStream)}function Ut(e){return void 0!==e._reader}function Gt(e,r){if(e._disturbed=!0,\"closed\"===e._state)return c(void 0);if(\"errored\"===e._state)return d(e._storedError);Xt(e);const o=e._reader;if(void 0!==o&&Fe(o)){const e=o._readIntoRequests;o._readIntoRequests=new S,e.forEach((e=>{e._closeSteps(void 0)}))}return p(e._readableStreamController[T](r),t)}function Xt(e){e._state=\"closed\";const t=e._reader;if(void 0!==t&&(j(t),K(t))){const e=t._readRequests;t._readRequests=new S,e.forEach((e=>{e._closeSteps()}))}}function Jt(e,t){e._state=\"errored\",e._storedError=t;const r=e._reader;void 0!==r&&(A(r,t),K(r)?Z(r,t):Ie(r,t))}function Kt(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Zt(e,t){F(e,t);const r=null==e?void 0:e.highWaterMark;return M(r,\"highWaterMark\",\"QueuingStrategyInit\"),{highWaterMark:Y(r)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),n(ReadableStream.prototype.cancel,\"cancel\"),n(ReadableStream.prototype.getReader,\"getReader\"),n(ReadableStream.prototype.pipeThrough,\"pipeThrough\"),n(ReadableStream.prototype.pipeTo,\"pipeTo\"),n(ReadableStream.prototype.tee,\"tee\"),n(ReadableStream.prototype.values,\"values\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(ReadableStream.prototype,e.toStringTag,{value:\"ReadableStream\",configurable:!0}),\"symbol\"==typeof e.asyncIterator&&Object.defineProperty(ReadableStream.prototype,e.asyncIterator,{value:ReadableStream.prototype.values,writable:!0,configurable:!0});const er=e=>e.byteLength;n(er,\"size\");class ByteLengthQueuingStrategy{constructor(e){$(e,1,\"ByteLengthQueuingStrategy\"),e=Zt(e,\"First parameter\"),this._byteLengthQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!rr(this))throw tr(\"highWaterMark\");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!rr(this))throw tr(\"size\");return er}}function tr(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function rr(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_byteLengthQueuingStrategyHighWaterMark\")&&e instanceof ByteLengthQueuingStrategy)}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(ByteLengthQueuingStrategy.prototype,e.toStringTag,{value:\"ByteLengthQueuingStrategy\",configurable:!0});const or=()=>1;n(or,\"size\");class CountQueuingStrategy{constructor(e){$(e,1,\"CountQueuingStrategy\"),e=Zt(e,\"First parameter\"),this._countQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!ar(this))throw nr(\"highWaterMark\");return this._countQueuingStrategyHighWaterMark}get size(){if(!ar(this))throw nr(\"size\");return or}}function nr(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function ar(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_countQueuingStrategyHighWaterMark\")&&e instanceof CountQueuingStrategy)}function ir(e,t,r){return I(e,r),r=>w(e,t,[r])}function lr(e,t,r){return I(e,r),r=>g(e,t,[r])}function sr(e,t,r){return I(e,r),(r,o)=>w(e,t,[r,o])}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(CountQueuingStrategy.prototype,e.toStringTag,{value:\"CountQueuingStrategy\",configurable:!0});class TransformStream{constructor(e={},t={},r={}){void 0===e&&(e=null);const o=Ye(t,\"Second parameter\"),n=Ye(r,\"Third parameter\"),a=function(e,t){F(e,t);const r=null==e?void 0:e.flush,o=null==e?void 0:e.readableType,n=null==e?void 0:e.start,a=null==e?void 0:e.transform,i=null==e?void 0:e.writableType;return{flush:void 0===r?void 0:ir(r,e,`${t} has member 'flush' that`),readableType:o,start:void 0===n?void 0:lr(n,e,`${t} has member 'start' that`),transform:void 0===a?void 0:sr(a,e,`${t} has member 'transform' that`),writableType:i}}(e,\"First parameter\");if(void 0!==a.readableType)throw new RangeError(\"Invalid readableType specified\");if(void 0!==a.writableType)throw new RangeError(\"Invalid writableType specified\");const i=$e(n,0),l=Me(n),s=$e(o,1),f=Me(o);let b;!function(e,t,r,o,n,a){function i(){return t}function l(t){return function(e,t){const r=e._transformStreamController;if(e._backpressure){return p(e._backpressureChangePromise,(()=>{if(\"erroring\"===(Ge(e._writable)?e._writable._state:e._writableState))throw Ge(e._writable)?e._writable._storedError:e._writableStoredError;return pr(r,t)}))}return pr(r,t)}(e,t)}function s(t){return function(e,t){return cr(e,t),c(void 0)}(e,t)}function u(){return function(e){const t=e._transformStreamController,r=t._flushAlgorithm();return hr(t),p(r,(()=>{if(\"errored\"===e._readableState)throw e._readableStoredError;gr(e)&&wr(e)}),(t=>{throw cr(e,t),e._readableStoredError}))}(e)}function d(){return function(e){return fr(e,!1),e._backpressureChangePromise}(e)}function f(t){return dr(e,t),c(void 0)}e._writableState=\"writable\",e._writableStoredError=void 0,e._writableHasInFlightOperation=!1,e._writableStarted=!1,e._writable=function(e,t,r,o,n,a,i){return new WritableStream({start(r){e._writableController=r;try{const t=r.signal;void 0!==t&&t.addEventListener(\"abort\",(()=>{\"writable\"===e._writableState&&(e._writableState=\"erroring\",t.reason&&(e._writableStoredError=t.reason))}))}catch(e){}return p(t(),(()=>(e._writableStarted=!0,Cr(e),null)),(t=>{throw e._writableStarted=!0,Rr(e,t),t}))},write:t=>(function(e){e._writableHasInFlightOperation=!0}(e),p(r(t),(()=>(function(e){e._writableHasInFlightOperation=!1}(e),Cr(e),null)),(t=>{throw function(e,t){e._writableHasInFlightOperation=!1,Rr(e,t)}(e,t),t}))),close:()=>(function(e){e._writableHasInFlightOperation=!0}(e),p(o(),(()=>(function(e){e._writableHasInFlightOperation=!1;\"erroring\"===e._writableState&&(e._writableStoredError=void 0);e._writableState=\"closed\"}(e),null)),(t=>{throw function(e,t){e._writableHasInFlightOperation=!1,e._writableState,Rr(e,t)}(e,t),t}))),abort:t=>(e._writableState=\"errored\",e._writableStoredError=t,n(t))},{highWaterMark:a,size:i})}(e,i,l,u,s,r,o),e._readableState=\"readable\",e._readableStoredError=void 0,e._readableCloseRequested=!1,e._readablePulling=!1,e._readable=function(e,t,r,o,n,a){return new ReadableStream({start:r=>(e._readableController=r,t().catch((t=>{Sr(e,t)}))),pull:()=>(e._readablePulling=!0,r().catch((t=>{Sr(e,t)}))),cancel:t=>(e._readableState=\"closed\",o(t))},{highWaterMark:n,size:a})}(e,i,d,f,n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,fr(e,!0),e._transformStreamController=void 0}(this,u((e=>{b=e})),s,f,i,l),function(e,t){const r=Object.create(TransformStreamDefaultController.prototype);let o,n;o=void 0!==t.transform?e=>t.transform(e,r):e=>{try{return _r(r,e),c(void 0)}catch(e){return d(e)}};n=void 0!==t.flush?()=>t.flush(r):()=>c(void 0);!function(e,t,r,o){t._controlledTransformStream=e,e._transformStreamController=t,t._transformAlgorithm=r,t._flushAlgorithm=o}(e,r,o,n)}(this,a),void 0!==a.start?b(a.start(this._transformStreamController)):b(void 0)}get readable(){if(!ur(this))throw yr(\"readable\");return this._readable}get writable(){if(!ur(this))throw yr(\"writable\");return this._writable}}function ur(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_transformStreamController\")&&e instanceof TransformStream)}function cr(e,t){Sr(e,t),dr(e,t)}function dr(e,t){hr(e._transformStreamController),function(e,t){e._writableController.error(t);\"writable\"===e._writableState&&Tr(e,t)}(e,t),e._backpressure&&fr(e,!1)}function fr(e,t){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=u((t=>{e._backpressureChangePromise_resolve=t})),e._backpressure=t}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(TransformStream.prototype,e.toStringTag,{value:\"TransformStream\",configurable:!0});class TransformStreamDefaultController{constructor(){throw new TypeError(\"Illegal constructor\")}get desiredSize(){if(!br(this))throw mr(\"desiredSize\");return vr(this._controlledTransformStream)}enqueue(e){if(!br(this))throw mr(\"enqueue\");_r(this,e)}error(e){if(!br(this))throw mr(\"error\");var t;t=e,cr(this._controlledTransformStream,t)}terminate(){if(!br(this))throw mr(\"terminate\");!function(e){const t=e._controlledTransformStream;gr(t)&&wr(t);const r=new TypeError(\"TransformStream terminated\");dr(t,r)}(this)}}function br(e){return!!r(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledTransformStream\")&&e instanceof TransformStreamDefaultController)}function hr(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function _r(e,t){const r=e._controlledTransformStream;if(!gr(r))throw new TypeError(\"Readable side is not in a state that permits enqueue\");try{!function(e,t){e._readablePulling=!1;try{e._readableController.enqueue(t)}catch(t){throw Sr(e,t),t}}(r,t)}catch(e){throw dr(r,e),r._readableStoredError}const o=function(e){return!function(e){if(!gr(e))return!1;if(e._readablePulling)return!0;if(vr(e)>0)return!0;return!1}(e)}(r);o!==r._backpressure&&fr(r,!0)}function pr(e,t){return p(e._transformAlgorithm(t),void 0,(t=>{throw cr(e._controlledTransformStream,t),t}))}function mr(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function yr(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}function gr(e){return!e._readableCloseRequested&&\"readable\"===e._readableState}function wr(e){e._readableState=\"closed\",e._readableCloseRequested=!0,e._readableController.close()}function Sr(e,t){\"readable\"===e._readableState&&(e._readableState=\"errored\",e._readableStoredError=t),e._readableController.error(t)}function vr(e){return e._readableController.desiredSize}function Rr(e,t){\"writable\"!==e._writableState?qr(e):Tr(e,t)}function Tr(e,t){e._writableState=\"erroring\",e._writableStoredError=t,!function(e){return e._writableHasInFlightOperation}(e)&&e._writableStarted&&qr(e)}function qr(e){e._writableState=\"errored\"}function Cr(e){\"erroring\"===e._writableState&&qr(e)}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),n(TransformStreamDefaultController.prototype.enqueue,\"enqueue\"),n(TransformStreamDefaultController.prototype.error,\"error\"),n(TransformStreamDefaultController.prototype.terminate,\"terminate\"),\"symbol\"==typeof e.toStringTag&&Object.defineProperty(TransformStreamDefaultController.prototype,e.toStringTag,{value:\"TransformStreamDefaultController\",configurable:!0});export{ByteLengthQueuingStrategy,CountQueuingStrategy,ReadableByteStreamController,ReadableStream,ReadableStreamBYOBReader,ReadableStreamBYOBRequest,ReadableStreamDefaultController,ReadableStreamDefaultReader,TransformStream,TransformStreamDefaultController,WritableStream,WritableStreamDefaultController,WritableStreamDefaultWriter};\n","/*! Based on fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> & David Frank */\nimport { isFunction } from \"./isFunction.js\";\nconst CHUNK_SIZE = 65536;\nasync function* clonePart(part) {\n    const end = part.byteOffset + part.byteLength;\n    let position = part.byteOffset;\n    while (position !== end) {\n        const size = Math.min(end - position, CHUNK_SIZE);\n        const chunk = part.buffer.slice(position, position + size);\n        position += chunk.byteLength;\n        yield new Uint8Array(chunk);\n    }\n}\nasync function* consumeNodeBlob(blob) {\n    let position = 0;\n    while (position !== blob.size) {\n        const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));\n        const buffer = await chunk.arrayBuffer();\n        position += buffer.byteLength;\n        yield new Uint8Array(buffer);\n    }\n}\nexport async function* consumeBlobParts(parts, clone = false) {\n    for (const part of parts) {\n        if (ArrayBuffer.isView(part)) {\n            if (clone) {\n                yield* clonePart(part);\n            }\n            else {\n                yield part;\n            }\n        }\n        else if (isFunction(part.stream)) {\n            yield* part.stream();\n        }\n        else {\n            yield* consumeNodeBlob(part);\n        }\n    }\n}\nexport function* sliceBlob(blobParts, blobSize, start = 0, end) {\n    end !== null && end !== void 0 ? end : (end = blobSize);\n    let relativeStart = start < 0\n        ? Math.max(blobSize + start, 0)\n        : Math.min(start, blobSize);\n    let relativeEnd = end < 0\n        ? Math.max(blobSize + end, 0)\n        : Math.min(end, blobSize);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    let added = 0;\n    for (const part of blobParts) {\n        if (added >= span) {\n            break;\n        }\n        const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n        if (relativeStart && partSize <= relativeStart) {\n            relativeStart -= partSize;\n            relativeEnd -= partSize;\n        }\n        else {\n            let chunk;\n            if (ArrayBuffer.isView(part)) {\n                chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));\n                added += chunk.byteLength;\n            }\n            else {\n                chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));\n                added += chunk.size;\n            }\n            relativeEnd -= partSize;\n            relativeStart = 0;\n            yield chunk;\n        }\n    }\n}\n","/*! Based on fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> & David Frank */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _Blob_parts, _Blob_type, _Blob_size;\nimport { ReadableStream } from \"web-streams-polyfill\";\nimport { isFunction } from \"./isFunction.js\";\nimport { consumeBlobParts, sliceBlob } from \"./blobHelpers.js\";\nexport class Blob {\n    constructor(blobParts = [], options = {}) {\n        _Blob_parts.set(this, []);\n        _Blob_type.set(this, \"\");\n        _Blob_size.set(this, 0);\n        options !== null && options !== void 0 ? options : (options = {});\n        if (typeof blobParts !== \"object\" || blobParts === null) {\n            throw new TypeError(\"Failed to construct 'Blob': \"\n                + \"The provided value cannot be converted to a sequence.\");\n        }\n        if (!isFunction(blobParts[Symbol.iterator])) {\n            throw new TypeError(\"Failed to construct 'Blob': \"\n                + \"The object must have a callable @@iterator property.\");\n        }\n        if (typeof options !== \"object\" && !isFunction(options)) {\n            throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        }\n        const encoder = new TextEncoder();\n        for (const raw of blobParts) {\n            let part;\n            if (ArrayBuffer.isView(raw)) {\n                part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));\n            }\n            else if (raw instanceof ArrayBuffer) {\n                part = new Uint8Array(raw.slice(0));\n            }\n            else if (raw instanceof Blob) {\n                part = raw;\n            }\n            else {\n                part = encoder.encode(String(raw));\n            }\n            __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, \"f\") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), \"f\");\n            __classPrivateFieldGet(this, _Blob_parts, \"f\").push(part);\n        }\n        const type = options.type === undefined ? \"\" : String(options.type);\n        __classPrivateFieldSet(this, _Blob_type, /^[\\x20-\\x7E]*$/.test(type) ? type : \"\", \"f\");\n    }\n    static [(_Blob_parts = new WeakMap(), _Blob_type = new WeakMap(), _Blob_size = new WeakMap(), Symbol.hasInstance)](value) {\n        return Boolean(value\n            && typeof value === \"object\"\n            && isFunction(value.constructor)\n            && (isFunction(value.stream)\n                || isFunction(value.arrayBuffer))\n            && /^(Blob|File)$/.test(value[Symbol.toStringTag]));\n    }\n    get type() {\n        return __classPrivateFieldGet(this, _Blob_type, \"f\");\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _Blob_size, \"f\");\n    }\n    slice(start, end, contentType) {\n        return new Blob(sliceBlob(__classPrivateFieldGet(this, _Blob_parts, \"f\"), this.size, start, end), {\n            type: contentType\n        });\n    }\n    async text() {\n        const decoder = new TextDecoder();\n        let result = \"\";\n        for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, \"f\"))) {\n            result += decoder.decode(chunk, { stream: true });\n        }\n        result += decoder.decode();\n        return result;\n    }\n    async arrayBuffer() {\n        const view = new Uint8Array(this.size);\n        let offset = 0;\n        for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, \"f\"))) {\n            view.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return view.buffer;\n    }\n    stream() {\n        const iterator = consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, \"f\"), true);\n        return new ReadableStream({\n            async pull(controller) {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    return queueMicrotask(() => controller.close());\n                }\n                controller.enqueue(value);\n            },\n            async cancel() {\n                await iterator.return();\n            }\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n}\nObject.defineProperties(Blob.prototype, {\n    type: { enumerable: true },\n    size: { enumerable: true },\n    slice: { enumerable: true },\n    stream: { enumerable: true },\n    text: { enumerable: true },\n    arrayBuffer: { enumerable: true }\n});\n","module.exports = require(\"node:readline\");","module.exports = require(\"http\");","import { File } from \"./File.js\";\nexport const isFile = (value) => value instanceof File;\n","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","module.exports = import(\"ai\");;","module.exports = require(\"node:inspector\");","module.exports = require(\"net\");","module.exports = require(\"events\");"],"names":["serverComponentModule.default","browserClientInstance","fetch","ponyfetch","fetchPonyfill","supabaseUrl","process","supabaseAnonKey","serviceRoleKey","env","SUPABASE_SERVICE_ROLE_KEY","anonymousHeaders","apikey","undefined","checkPublicEnvVars","console","error","g","globalThis","__USING_PONYFETCH__","getSupabaseBrowserClient","_createBrowserClient","global","headers","useSupabaseBrowser","useMemo","createClient","getSupabaseClient","ResearchPage","isLoading","setIsLoading","useState","results","setResults","supabase","researchProcessor","ResearchProcessor","NEXT_PUBLIC_OPENAI_API_KEY","handleResearch","query","options","research","deepResearch","toast","success","Error","message","div","className","h1","DeepResearch","onResearch","caches","open","Promise","resolve","match","put","delete","has","UPSTASH_REDIS_REST_URL","UPSTASH_REDIS_REST_TOKEN","redisClient","redisInitializationAttempted","getRedisClient","createRedisClient","warn","Redis","url","token","retry","retries","backoff","retryCount","Math","min","CacheManager","constructor","redisClientInternal","redisKeyPrefix","lruCache","LRUCache","max","maxSize","ttl","key","get","prefixedKey","getPrefixedKey","value","set","ttlInSeconds","ex","del","clear","cursor","scanResult","scan","count","nextCursor","Number","keys","length","cache","apiKey","supabaseClient","openai","OpenAI","cacheKey","JSON","stringify","cached","context","getRelevantContent","map","doc","content","join","systemPrompt","getSystemPrompt","depth","response","chat","completions","create","model","messages","role","temperature","max_tokens","choices","basePrompt","data","documents","from","select","textSearch","eq","country","category","limit"],"sourceRoot":""}