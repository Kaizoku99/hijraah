{"version":3,"file":"../app/api/graphql/route.js","mappings":"6bACA,qCAA6C,CAAE,SAAa,EAC5D,eAAqB,CAmBrB,cACA,2BACA,IACA,IAMA,EAUA,EAhBA,EAZA,YACA,yBACA,iBAEA,0BACA,uBAEA,+BAA6C,mBAAyB,EACtE,EAIA,8BAEA,EADA,uCACA,WA6FA,GA5FA,4BACA,2CAIA,EADA,iBACA,OAEA,UACA,UAGA,SAoBA,CAfA,MADA,UACA,YAQA,MARA,CACA,gBACA,UACA,SACA,cACiB,GAUjB,gBACA,0BACA,EAEA,OADA,+BAEA,aACA,WACA,uBACA,KACA,iBACA,cACA,wBACA,KACA,qBACA,kBACA,2BACA,KACA,UACA,gCAEA,CACA,2DACA,yBACA,yCACA,KACA,WACA,MACA,CACA,0BACA,+DACA,gCACA,aACA,gBACA,KAEA,WACA,MACA,CACA,CACA,SACA,6CACA,kBACA,cACA,SACA,SACA,EAAqB,EAErB,wBACA,2CACA,GACA,OAEA,mCACA,SACA,aACA,kBACA,UACA,QACA,CAAiB,EACjB,IACA,CAAa,EACb,gBACA,0FAEA,CACA,mBACA,6BACA,OACA,wBACA,KACA,EACA,UAGA,kBAEA,CACA,CACA,SACA,IACA,CACA,CAAK,CACL,EAzIA,MAAoB,EAAQ,KAAW,EACvC,EAAqB,EAAQ,KAAY,CADd,CAE3B,EAAsB,EAAQ,KAAa,CADf,CAE5B,EAAoB,EAAQ,KAAW,CADV,CAE7B,EAA0B,EAAQ,KAA8B,CADrC,CAE3B,EAAqB,EAAQ,KAAc,CADV,CAEjC,EAAsB,EAAQ,KAAe,CADjB,CAE5B,EAAiB,EAAQ,KAAU,CADN,CAE7B,EAAmB,EAAQ,KAAY,CADf,WACE,ECN1B,4BACA,iBAGA,gBAPA,wDAcA,yBChBA,8DCCA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,uBAA+B,QAC/B,MAA4B,EAAQ,KAAqB,EACzD,EAAqB,EAAQ,KAAc,CADR,CAEnC,EAAmB,EAAQ,KAAY,CADX,CAE5B,UAD0B,GAC1B,0CACA,SACA,iBACA,WACA,iCAEA,OAIA,MAHA,2BACA,0DAEA,CACA,CACA,WAIA,OAHA,GACA,8BAEA,CACA,CACA,SACA,GACA,sBAEA,CACA,OACA,YAGA,OAFA,2BACA,kBACA,CACA,CACA,UACA,0CACA,CACA,OACA,oBACA,2BACA,MACA,IACA,GACA,CACA,SACA,8CACA,CACA,+BACA,CACA,CACA,gCAEA,GADA,yBACA,aACA,wBACA,mBACA,CACA,CACA,CACA,uCAEA,yBAA+B,sCC7D/B,kDCEA,2BACA,GACA,IACA,eACA,YACM,SAEN,GACA,uBACA,YACM,qDAEN,0CCbA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,eAAuB,QACvB,eAAqB,GACrB,MAAoB,EAAQ,KAAW,EACvC,EAA4B,EAAQ,KAAqB,CAD9B,CAE3B,UADmC,CACnC,GACA,yBACA,CACA,QACA,YACA,KACA,qCACA,mCACA,wBACA,GACA,kBACA,CAEA,QACA,sBACA,8CACA,mCAGA,aACA,8BAGA,0BACA,YAEA,oCACA,iEACA,aACA,KAEA,aACA,QAEA,2BACA,CAIA,CAHA,uBACA,+BAGA,+CACA,WACA,QAEA,gDACA,0CACA,6CACA,4DACA,CAAiB,EAEjB,wDACA,UACA,YAEA,8CACA,2BAEA,CAGA,SACA,cAEA,GADA,sBACA,uBACA,mCAEA,eADA,kBACA,mBACA,sBACA,qBACA,yBACA,QACA,CACA,kBACA,MAEA,uBACA,kBACA,iCACA,qBACA,sBACA,yBACA,MACA,CACA,kBACA,CAAqB,OAIrB,aADA,kBACA,kBACA,0BACA,YACA,sBACA,qBACA,sBACA,yBACA,QACA,CACA,kBACA,CACA,MAIA,kBAGA,iBAEA,YACA,sBACA,qBACA,sBACA,yBACA,MACA,CACA,2BACA,OAA8C,EAAc,IAAI,EAAM,IACtE,sBACA,CACA,OACA,0BACA,QACA,KAEA,YACA,CACA,aAEA,eADA,gBAEA,2BAEA,cACA,CACA,IAFkC,CAElC,IACA,sBACA,qBACA,qBACA,MACA,CACA,sCACA,2CAUA,yBACA,8BAIA,4BAfA,CACA,wDACA,EACA,OAGA,6BAEA,MACA,CAUA,sBACA,CACA,UACA,sBACA,qBACA,oBACA,MACA,CACA,uBACA,CACA,WAIA,GAHA,8BACA,sBACA,CAAS,EACT,YACA,qBACA,+CACA,mCACA,WACA,CAAqB,EAGrB,mCACA,4BAGA,mDACA,SACA,WAEA,CAAiB,CACjB,CACA,MACA,CACA,8BACA,WACA,CAAS,CACT,CACA,SAIA,GAHA,0BACA,oBAEA,YACA,wBACA,oCACA,0DAGA,wBACA,oCAGA,wDAIA,2BACA,CACA,OACA,mEACA,CACA,WAIA,GAHA,0BACA,yBAEA,YACA,wBACA,oCACA,2DAGA,wBACA,sCAGA,0DAIA,6BACA,CACA,SACA,qEACA,CACA,YAIA,GAHA,0BACA,kDAEA,YACA,wBACA,oCACA,yBAGA,wBACA,uCAGA,wCAIA,8BACA,CACA,UACA,sEACA,CACA,eAIA,OAHA,kBACA,cAEA,iBAEA,oBACA,qBACA,CACA,6CACA,SASA,OARA,qBACA,iBACA,qCAGA,qDAEA,CAAS,EACT,WAA0B,iBAAiC,EAE3D,CACA,iBAAuB,aCtSvB,cACA,yCAEA,OADA,0BACA,CACA,CACA,cACA,YACA,UACA,yCCPA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,yBAAiC,CAAG,2BAAiC,QACrE,MAAgC,EAAQ,KAAyB,EACjE,EAA6B,EAAQ,KAAsB,CADpB,OAEvC,IADoC,MACpC,0BACA,wBACA,KACA,OACA,sDAAkG,UAAc,EAChH,CAAS,EACT,+CACA,CACA,eACA,iCAEA,YACA,6BACA,CACA,gBACA,kCAEA,CACA,2BAAiC,EACjC,2CACA,wBACA,GACA,OACA,sDACA,CAAS,EACT,6CACA,CACA,eACA,iCAEA,UACA,iCACA,CACA,CACA,2BAAiC,iCCVjC,iBAAQ,GAAe,EAAU,KAAa,EAC9C,UADgC,CACxB,EAAa,EAAQ,KAAW,EAExC,UAF4B,CAE5B,GAKA,GAJA,oBACA,mBAGA,oBACA,8DAGA,eACA,MAEA,SACA,4DAGA,SACA,+DAGA,qBACA,eAEA,8BACA,QACA,wBACA,eACA,eAEA,iCAIA,YAAkB,IAAyB,IAC3C,GADkD,CAClD,eAEA,CACA,OAEA,6BACA,wBACA,eACA,cACA,EAEA,mCAMA,C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AIxE,CAHA,GACA,WAEA,GACA,aAGA,MAIA,MAhBA,KACA,6BAAyE,EAAS;AAAA,KAiBlF,WACA,eACA,cACA,CAAS,CACJ,CACL,EAtIA,MAAsB,EAAQ,IAAa,EAC3C,EAA4B,EAAQ,KAAqB,EACzD,EAA4B,EAAQ,KAAqB,CACzD,SACA,EAFmC,EAEnC,QACA,cACA,sBACA,IACA,KACA,mBAEA,WACA,SACA,EACA,SACA,CACA,UACA,kBACA,CACA,OACA,sBACA,kBACA,CACA,UACA,2BAEA,OACA,sBACA,CACA,WACA,WACA,SACA,EACA,mBACA,CACA,oBACA,sBACA,CACA,YACA,wBACA,eACA,WAIA,UACA,uEACA,CACA,QACA,sBACA,CACA,OACA,oEACA,CACA,WACA,+BACA,eACA,OAGA,CACA,SACA,sEACA,CACA,WACA,oBACA,WAEA,CACA,CAkEA,kBAMA,OALA,gCACA,gBACA,cACA,kBACA,CAAK,EACL,CACA,CACA,cACA,2BACA,CA3EA,kBAAwB,+BCzExB,qCAA6C,CAAE,SAAa,EAAC,EAC7D,uBAA+B,QAC/B,yBAA+B,oDCH/B,qDCAA,oDCCA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,uBAA+B,OAC/B,uBACA,MACA,uBAEA,OACA,SACA,aACA,kBACA,4BACA,8CACA,CACA,CACA,yBAA+B,iCCd/B,qCAA6C,CAAE,SAAa,EAAC,EAC7D,YAAoB,QACpB,MAAkB,EAAQ,KAAW,CACrC,WADyB,MACzB,eACA,IACA,aACA,oBACA,WACA,YACA,6CACA,CACA,sBAEA,cAAoB,2BCdpB,oDCAA,wDCEA,MAAgB,EAAQ,KAAkB,EAC1C,EAAmB,EAAQ,KAAqB,CADzB,CAEvB,EAAiB,EAAQ,IAAmB,EADlB,EAG1B,SAFwB,IAKxB,gBACA,IAQA,EARA,WACA,kBACA,WAEA,6CACA,iDACA,mCAGA,uBAA8C,IAAS,IACvD,GAD8D,MAC9D,eACA,iBACA,wBACA,KACA,CAGA,aAA+B,wBAE/B,mBACA,eACA,eACA,kBACA,uBACA,iBACA,iBACA,aACA,aACA,kBACA,kBACA,iBACA,CAjCA,gDAmCA,oCASA,EAAa,EAAY,EARzB,CAQa,EARb,CAQyB,GARzB,4BAKA,OAJA,0BACA,2BACA,8BAEA,IAGgC,QAAW,WAE3C,UACA,wBAEA,IADA,WACA,IAAkB,IAAS,KAE3B,GADA,sBAAoC,IACpC,WACA,IACA,KACA,CAAU,cACV,IACA,KACA,CACA,kEACA,kBACA,KACA,CAAU,qBAAgC,iBAG1C,cAEA,MAAyB,yDACzB,kBAEA,kBACA,uBACA,aACA,iBACA,kBACA,qBAEA,WACQ,mBAGR,CADA,gBACiB,qBAkBjB,GAjB0B,EAA1B,IAA0B,wDAAqF,QAAP,CAAO,CAE/G,KAF+G,SAE/G,IACA,uBACA,aACA,iBACA,kBACA,qBAEA,UACA,iDACA,GACA,EACA,IAGA,MACA,gCAAiD,UACjD,EAAQ,oBAER,MAAqB,yDACrB,IACA,8DAEA,uBACA,qBAGA,KAAuB,wDACvB,IAEA,EAAM,IAEN,IADA,SACA,IAAkB,IAAS,KAE3B,GADA,sBAAoC,IACpC,WACA,IACA,KACA,CACA,8DACA,kBACA,KACA,CAAU,qBAAgC,iBAG1C,cAiBA,IAhBA,eACA,MAA0B,yDAC1B,yDACA,mCACA,eACA,gBACA,kBAEA,kBACA,uBACA,aACA,iBACA,kBACA,qBAEA,MACA,gCAAiD,gBACzC,gBAER,MAAqB,yDACrB,IACA,0CACA,2DAEA,uBACA,qBAGA,MAAuB,uDACvB,IAEA,CAEA,GACA,EAEA,2BACA,iBAEA,CAFwB,OAExB,gCACA,yDACA,GACA,eACA,IACI,qBACJ,yDACA,mCACA,eACA,gBAEA,kBACA,wBACA,EAEA,mCC7LA,iDCAA,8GCCA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,SAAiB,CAMjB,YACA,IAcA,EAqCA,EAUA,EA7DA,MAAY,gDAAiD,mBAC7D,QA0BA,GAzBA,0BACA,sBACA,gDACA,8BAEA,gCACA,mDAGA,sDAEA,2BAGA,EADA,iBACA,OAEA,UACA,UAGA,SAEA,uCACA,kDACA,CAAK,EACL,sBACA,sCAEA,CACA,mBACA,6BACA,OACA,wBACA,KACA,IACA,sBACA,qBAEA,CACA,mBACA,uBAEA,iCACA,sCACA,iDACA,yBACA,+BACA,mCAGA,MAFA,kDAEA,cACA,WACA,CAAK,CACL,UACA,yBAEA,yBACA,4BACA,oCAEA,aACA,YACA,IACA,eACA,CACA,SACA,WACA,CAEA,CAiEA,OAhEA,+BAAiD,QAAY,EAC7D,wBACA,IACA,SACA,CACA,SACA,WACA,CACA,iCACA,CAAK,EACL,2BACA,2BAIA,gEACA,yCAEA,aANA,aAQA,IACA,SACA,CACA,SACA,WACA,CACA,CAAK,EACL,gCACA,gDACA,kBACA,SACA,iBACS,EAmBT,EAlBA,EACA,iBACA,mBACA,UACA,+BACA,sBACA,sCACA,0BACA,aACA,WAEA,YACA,4CAEA,KAIA,sCACA,4BACA,SACA,UACA,sDACA,qDACA,CAAS,EACT,aACA,GACA,CAAK,EACL,kBACA,WACA,CAAK,EACL,WA9IA,MAAsB,EAAQ,KAAa,EAC3C,EAAmB,EAAQ,KAAU,CADR,CAE7B,EAA0B,EAAQ,KAA8B,CADtC,CAE1B,EAAsB,EAAQ,KAAe,CADZ,CAEjC,EAAmB,EAAQ,KAAY,CADV,WACH,oBCN1B,qCAA6C,CAAE,SAAa,EAAC,EAC7D,eAAuB,QACvB,MAAoB,EAAQ,KAAW,EACvC,EAAqB,EAAQ,KAAY,CADd,CAE3B,EAAkB,EAAQ,KAAW,CADT,CAE5B,EAAqB,EAAQ,IAAc,EADlB,EAER,EAAQ,KAAU,CAOnC,CAR4B,MAQ5B,IAPwB,MAOxB,eACA,iBAGA,IAFA,EACA,EAEA,EADA,OAEA,sBACA,SAEA,GAXA,WAYA,IAfA,YAiBA,CAjBA,uBAkBA,aACA,eAGA,EADA,OACA,OAGA,MAEA,SACA,KA6BA,GA3BA,UACA,eACA,KAEA,WACA,YACA,kBACA,+BACA,+CACA,aACA,2CACA,UACA,kCACA,gCACA,gDACA,4CACA,0BACA,oCACA,0CACA,qDACA,4CACA,8BACA,4BACA,qBACA,2CACA,mCAEA,gBACA,gCACA,YACA,cAEA,kDACA,mBAEA,oDACA,oBAEA,CACA,CACA,kBACA,MACA,YACA,YACA,QACA,UACA,UACA,OACA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aAAmC,MAEnC,2BACA,iCACA,eASe,EAT0B,KAS1B,KARf,mBAAyC,IAAS,IAClD,gBACA,UACY,kBACZ,UACA,GAAiC,UAUjC,GALiD,EAAjD,+BAAiD,gDAAyE,EAAP,KAKnH,EAL0H,EAK1H,MAEA,SAKA,OAJA,kBACA,mBACA,sBAEA,KAKA,GAFA,IAEA,wCACA,kBAIA,KACA,eACA,IACA,sBAIA,GAHA,IACA,YACA,IACA,sBACA,YACA,aACA,GACA,CACA,CAAS,EACT,oBACA,cACA,CAD8B,CAC9B,UACA,uBACA,YACA,aACA,GACA,CACA,EACA,yBAEA,cACA,oBACA,kBACA,MAAgC,qBAChC,eACA,cACA,6BACA,gBACA,MACA,CAAY,YAA6B,aAEzC,aACA,EAEA,aACA,SACA,YACA,CACA,EAAQ,IAER,SAKA,OAJA,mBACA,oBACA,uBAEA,IAGA,KACA,IACA,SACA,KACA,IAEA,cACA,oBACA,qBACA,4BACA,KACA,4BACA,EAAY,IAAO,uBACnB,EAEA,aACA,SACA,WAA+B,mBAC/B,6BACA,IACA,GACA,CACA,CAOA,yBAEA,eACA,aACA,CAAK,yBACL,GAAqB,iBACrB,CAAK,CACL,CAAG,yBACH,iBACA,CAAG,yBACH,KACA,GACA,CAAG,CACH,CAyBA,cACA,UACA,CAEA,cACA,eAEA,iBAEA,iBACA,CAlRA,kCAiPA,gCACA,0BACA,iBACA,KAEA,mBACA,WAEA,EAEA,2BACA,WAEA,kBACA,eACI,cACJ,4BACA,gBACA,qBACA,CAAK,CAEL,EAcA,OAEA,gCAEA,oCCjTA,2DCCA,qCAA6C,CAAE,SAAa,EAC5D,mBAAyB,QACzB,cAAoB,CASpB,WAGA,uCAGA,gDACA,EAfA,mBAAyB,EACzB,cACA,4CACA,CAAK,CACL,mBACA,sDACA,CAAK,kCCPL,+BACA,WACA,YACA,WACA,EAuCA,GACA,YACA,aACA,IAEA,oBACA,qBAEA,yBAGA,cACA,aACA,GAEA,mBACA,EAEA,0BAGA,eACA,aACA,IAEA,oBACA,qBAEA,yBAGA,cACA,aACA,IAEA,oBACA,qBAEA,2BAGA,cACA,gBACA,SAMA,GAJA,oBACA,qBAGA,uBACA,IACA,4BACA,CAAQ,OAER,yBACA,EACA,YACA,CACA,CASA,WAPA,uBACA,EACA,CAnGA,YACA,MACA,OACA,UACA,YACA,WACA,kBACA,SACA,YACA,eACA,iBACA,gBACA,eACA,iBACA,mBACA,sBACA,aACA,eACA,oBACA,UACA,eACA,WACA,YACA,gBACA,cACA,wBAEA,eACA,KACA,kBACA,QACA,CACA,sBACA,CAEA,GAgEA,QAEA,CACA,0BC/GA,4DCAA,IACA,EADA,EAA2B,EAAQ,IAAsB,EAGzD,WAHkC,QAGlC,IAAsD,EACtD,eAUA,CARA,mCAGA,cAEA,gBADqC,KAAqB,EAC1D,YAGA,qBACA,CACA,uBACA,2BACA,2BACA,6BACA,6BACA,yCACA,yCACA,2CACA,+CACA,mDACA,+CACA,+CACA,qBACA,qBACA,yBACA,qBACA,mCACA,mCACA,wBACA,mBACA,6CAIA,IAAmB,EAAQ,KAAyB,EAEpD,gBACA,oBACA,sBACA,oBACA,sBACA,kCAEA,YACA,oCAEA,kCACA,oCACA,wCACA,4CACA,wCACA,wCAEA,cACA,cACA,2BACA,cACA,4BACA,4BAEA,mBACA,4BACA,iBACA,SACA,gCACA,KACS,CACT,CACA,EACA,kCACA,iBACA,SACA,gCACA,KACS,CACT,CACA,EACA,oCACA,iBACA,SACA,gCACA,KACS,CACT,CACA,GAGA,UAEA,UADyB,EAAQ,KAAQ,EACzC,UADgC,CAIhC,EACA,0BCnGA,wDCAA,sGCAA,kECAA,qDCEA,YAEA,GACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,CAEA,aACA,kBACA,CACA,8BAEA,mBACA,SACA,IAAa,IAAW,WACxB,KAAS,IAAS,IAClB,qBACA,oBAKA,kBACA,IACA,yBACA,iDACA,sBARA,mBACA,mBACA,KASM,aACN,MACA,oBACA,KAEA,eACA,KAIA,OADA,4BAA8C,mBAC9C,CACA,EACA,6BACA,kBACA,EAEA,oCCrDA,4ECCA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,YAAoB,QACpB,iBAAuB,GACvB,sBAA4B,GAC5B,gBAAsB,GACtB,eAAqB,GACrB,iBAAuB,GACvB,iBAAuB,GACvB,kBAAwB,GACxB,eAAqB,GAGrB,MAAsB,EAAQ,IAAa,EAC3C,EAA4B,EAAQ,KAAqB,EAD5B,EAEV,EAAQ,KAAY,CADJ,CAEnC,UAD0B,CAC1B,SACA,mBACA,iBAEA,qBACA,EAEA,2BACA,kDAGA,gBAEA,CACA,cACA,4DAEA,cACA,sEAEA,cACA,0DAEA,cACA,wDAEA,cACA,wCAEA,cACA,4DAEA,cACA,+CAEA,cACA,iDACA,CAGA,QACA,SACA,MACA,SACA,uBACA,QAKA,GAJA,iBACA,8CACA,kCACA,yBACA,sBACA,YAGA,aACA,SACA,gBACA,sCAEA,8BACA,+BACA,KACA,oBACA,eACA,eAGA,KACA,mBACA,8BACA,eAGA,KACA,yBACA,4CACA,gBAGA,kBACA,gCACA,CACA,SACA,4BACA,UACA,2BACA,MACA,CAAiB,GAGjB,UACA,gCACA,mCACA,CAAiB,GAGjB,UACA,0BACA,qBACA,CAAiB,GAIjB,aAGA,WACA,+DAEA,wDACA,CACA,cACA,gBAEA,sCAEA,8BACA,wBACA,2CAEA,wBACA,sCAEA,CAEA,oBACA,CACA,QACA,gBACA,sCAEA,8BACA,wCAEA,OADA,+BACA,qCAEA,0CAEA,OADA,8CACA,qCAEA,wBACA,iCAEA,wBACA,iCAEA,CACA,oBACA,CACA,WACA,OACA,cACA,oCAEA,8BACA,wBACA,sBAEA,OADA,aACA,8BAEA,QACA,yBACA,aACA,aAGA,WAEA,OADA,qCACA,6BACA,CACA,8BACA,qCACA,YAEA,CACA,WACA,cACA,WACA,8BAEA,qBACA,yBACA,YAEA,CACA,eACA,WACA,kBACA,uCAEA,+BACA,CACA,WACA,oBAEA,aADA,aACA,gBACA,mBACA,mCAEA,KACA,mBAEA,4BACA,2BAIA,kBAEA,aAsBA,EArBA,8BACA,wBACA,QACA,kBAEA,WACA,qCACA,UACA,aACA,SACA,CAAiB,CACJ,CACb,YAEA,yBADA,mBACA,CACA,UACA,wBACA,SACA,CAAiB,CACJ,CAGb,CACA,UACA,yCACA,UAGA,mCACA,CAAa,CACb,SACA,IAAwB,gBAAwB,SAChD,iBACA,UAGA,MACA,QACA,2BACA,YACA,CAAyB,EAEzB,QACA,0BACA,uBACA,YACA,CAAyB,EAEzB,QACA,gCACA,qCACA,YACA,CAAyB,EAEzB,WACA,YACA,CACA,CAAa,CACJ,CACT,CACA,QACA,8BACA,CACA,CACA,cAAoB,2BClSpB,mDCAA,oDCAA,wDCAA,2EECA,qCAA6C,CAAE,SAAa,EAC5D,wBAA8B,QAC9B,MAAsB,EAAQ,KAAa,EAC3C,EAAsB,EAAQ,KAAa,CADd,CAE7B,EAA0B,EAAQ,KAA8B,CADnC,CAE7B,EAAmB,EAAQ,KAAY,CADN,OAEjC,EACA,EAF0B,MAE1B,aACA,GACA,2BACA,qBAEA,MACA,sBACA,aACA,IACA,oBACA,sBACA,YACA,GACA,CAA6B,KAC7B,IACA,CAA6B,EAG7B,GAEA,CACA,SACA,IACA,CACA,CAAiB,CACjB,SACA,iBACA,sBACA,YACA,GACA,CAAyB,KACzB,IACA,CAAyB,EAGzB,GAEA,CAAiB,CACJ,CACb,iBACA,0BACA,GACA,gBACA,SACA,YACA,CAAiB,EAEjB,8BACA,6BACA,MAEA,6BAGA,YACA,oBACA,OACA,aACA,2BACA,CAAa,CACb,kBACA,wBACa,CACb,YACA,2BACA,CAAa,CACb,cAEA,CAAa,CACb,SACA,iCACA,QACA,EAEA,gCACA,CAAa,CACb,UACA,qBACA,oBAEA,UACA,mCAEA,iDAEA,UACA,aACA,sBAEA,CACA,CACA,cACA,6CACA,oBAEA,sBACA,+CAEA,4DACA,CACA,SAEA,OADA,yBACA,iCACA,CACA,UAEA,wBAA8B,iCCjH9B,qCAA6C,CAAE,SAAa,EAAC,EAC7D,sBAA8B,QAC9B,MAAsB,EAAQ,IAAa,EAC3C,EAAsB,EAAQ,KAAa,EADd,EAEP,EAAQ,KAAa,CADd,CAE7B,EAAmB,EAAQ,KAAsB,CADpB,CAE7B,EAA0B,EAAQ,KAA8B,CADtC,CAE1B,EAAmB,EAAQ,KAAY,CADN,CAEjC,UAD0B,CAC1B,KACA,SACA,KACA,KACA,OACA,cACA,WACA,4CACA,EAIA,UAHA,SAKA,CAAS,CACT,QACA,YACA,cAEA,aACA,IACA,CAAS,CACT,SACA,YACA,cAEA,YACA,CAAS,CACT,cACA,QACA,CAAS,CACT,SAEA,GADA,KACA,YACA,yCACA,UACA,KAEA,CAAS,CAET,CAIA,cACA,yBACA,CACA,QACA,qBACA,GACA,oCACA,8BAEA,GAXA,cAYA,qBAEA,QACA,wCAEA,CACA,SACA,KACA,MACA,OACA,yBAEA,OADA,KACA,+CAEA,CADA,YACA,WAKA,CACA,QACA,EACA,KACA,sCACA,MACA,OAEA,yBACA,qDACA,WACA,IACA,CAAqB,CACrB,CAAiB,CAEjB,+BACA,QACA,MAIA,OADA,KACA,IACA,CAAiB,CACjB,aACA,aACA,IACA,kBACA,WACA,mBACA,OACA,CAAiC,KACjC,IACA,CAAiC,CAEjC,CACA,SACA,KACA,MACA,CAEA,OACA,CAAiB,CACJ,CACb,CACA,CACA,UAGA,OAFA,yBAEA,iCACA,CACA,UACA,aACA,2CACA,gBACA,oBACA,OACA,SACA,SAEA,iBACA,aACA,iBACA,sBACA,YACA,cACA,CAAyB,CAGzB,CACA,cACA,CAAa,CACb,WACA,aACA,kBACA,UACA,mBACA,cACA,CAAyB,CAEzB,CAEA,OADA,eACA,mBACA,CAAa,CACb,aACA,qBACA,oBACA,iDACA,CACA,CAAa,CAEb,CACA,yBACA,4CACA,OACA,yBACA,YACa,CACb,kBACA,YACA,yBACA,wBAEA,iCAA4E,qBAA8B,GAE1G,UACA,yBACA,yBAEA,iCAA8E,qBAA8B,EAE5G,CACA,CACA,MACA,8BACA,CACA,sBACA,IACA,wBACA,gBAEA,gBACA,CACA,SACA,gBACA,CACA,CACA,cAkCA,EAjCA,GAiCA,EAjCA,EAkCA,kBAjCA,+CACA,MACA,CAAa,CAEb,EACA,oBACA,2BACA,CACA,CACA,sBAAkB,aAAqB,MAoBvC,EAXA,OARA,yBACA,wBACA,CAAS,EAiBT,EAhBA,EAiBA,oBAhBA,qDACA,uDA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SACA,8BAAqD,WAAc,kCAEnE,OADA,OACA,CACA,CAEO,cACP,0BAA2C,UAC3C,CAEO,oBACP,gFACA,wIACA,oDACA,CAEO,sBACP,6DACA,gFACA,uIACA,kDACA,CAEO,gBACP,gHACA,yCACA,CAEO,kBACP,gBAEA,IADA,gFAEA,MACA,+EACA,yBAEA,eACA,qEACA,oBACA,QACA,CACA,iEACA,kBAAsC,IAAM,aAAoB,SAAY,4BAC5E,cAAqB,0BAA8C,CACnE,MACA,GACA,cAAqB,SAAa,EAElC,QACA,CAEA,yEACA,eACA,0DACA,EAEO,cACP,cACA,iFACA,aACA,CACA,UAkBA,gBAjBA,IACA,sBACA,IACA,wEACA,cACA,8BACA,6DAAgG,OAAT,KAAS,IAAgB,CAChH,MACA,IACA,CACA,SACA,IACA,CAEA,qEACA,8BAGA,CAEO,sBACP,uCACA,iFACA,+DACA,CAAO,EAEP,CACA,CAEA,MAAe,CACf,YACA,WACA,SACA,aACA,UACA,eACA,oBACA,YACA,oBACA,aACA,YACA,cACA,kBACA,eACA,WACA,SACA,WACA,iBACA,gBACA,UACA,mBACA,mBACA,gBACA,uBACA,eACA,kBACA,yBACA,yBACA,wBACA,0BACA,qBACA,kCACA,CAAC,EAAC,6BC9YF,MAAqB,sBAAmC,EACvC,kBAA6B,EAC7B,EAAQ,IAA6B,EAEtD,EAAqB,EAAQ,KAAyB,EAF9B,EAIxB,QAF4B,GAE5B,aACA,UACA,oCAEA,cACA,aAEA,QACA,WACA,aACA,cACA,cACA,8CACA,8CACA,eACA,eACA,iBACA,iBACA,oCACA,cACA,8BACA,4BACA,wBACA,YACe,aAEf,oCAEA,GAAmB,WACnB,CAAG,CACH,CACA,OAEA,6BACA,sBACA,iBAAuB,QACvB,EAEA,6BACA,iBACA,eACA,eACA,eACA,EAEA,+BACA,aAAqB,oBACrB,mCACA,iBACA,gBACA,eACA,iBACA,yBACA,cACA,qBACA,EAEA,wCAKA,IAJA,qCAA6C,OAE7C,2BACA,WAGA,YAAkB,IAAS,KAC3B,CADkC,EAClC,gBAAiC,SACjC,mCAIA,GAC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,aAAkB,qCAAsC,MACxD,OACA,EACA,4BACA,SACA,KACA,KACA,CAAK,CACL,iBACA,aAAkB,kCAAyC,KAC3D,MACA,4BACA,sBACA,KACA,EACA,eACA,CAAK,CACL,sBACA,QAAkB,0CAAsC,uCACxD,CAAK,CACL,yBACA,aAAkB,qCAAsC,MACxD,YACA,EACA,4BACA,SACA,KACA,KACA,CAAK,CACL,qBACA,aAAkB,uBAAyB,iDAC3C,CAAK,CACL,oBACA,aAAkB,wBAA0B,kCAC5C,CAAK,CACL,qBACA,aAAkB,eAAkB,sBACpC,CAAK,CACL,2BACA,aAAkB,wBAA0B,mCAC5C,CAAK,CACL,qBACA,aAAkB,uCAA8C,iBAChE,EACA,MACA,4BACA,sBACA,qBACA,OACA,UACA,CAAK,CACL,iBACA,mBAAkB,mBAA4B,yCAC9C,CAAK,CACL,qBACA,aAAkB,eAAkB,sCACpC,CAAK,CACL,qBACA,aAAkB,qCAAsC,MACxD,cACA,EACA,4BACA,SACA,KACA,KACA,CAAK,CACL,wBACA,aAAkB,qCAAsC,MACxD,mBACA,EACA,4BACA,SACA,KACA,KACA,CAAK,CACL,oBACA,aAAkB,uBAAyB,wDAC3C,CAAK,CACL,mBACA,aAAkB,wBAA0B,yCAC5C,CAAK,CACL,0BACA,aAAkB,wBAA0B,0CAC5C,CAAK,EAEL,oCAnNA,QAmNA,CACA,KACA,KACA,OAtNA,EAsNA,WArNA,cACA,SACA,mBACA,qDACA,qBAEA,MACS,MACT,kDACA,KAIA,OAHA,qCACA,gBAEA,gDACA,EAwMA,CAAK,CACJ,IAAK,EAqFN,cACA,QACA,2CACA,IAEA,QACA,CACA,cACA,uBC5XO,cACP,cACA,CACA,gBACA,iBACA,aACA,wBACA,gBACA,2BAA6C,OAAW,eACxD,cACA,OAYA,cACA,YACA,aAEA,4BACA,0BACA,KACA,KACA,cAEA,KAEA,iBACA,mBAEA,eACA,GAaA,4BAbA,CACA,iBAEA,SACA,iCAEA,MACA,oBACA,kBAOA,EALA,EAKA,EALA,EAMA,+BACA,aACA,GAAkB,EAElB,SA9DA,EA+DA,aAmBA,GACA,gCACA,QACA,yBACA,iBACA,mDACA,yBACA,8BACA,QAEA,CACA,QACA,EA/BA,OAGA,GAAc,EADd,8BACc,cAA+B,CAb7C,EAvCA,IACA,SACA,gBACA,CACA,CACA,cAGA,OADA,sBACA,YAGA,CA2CA,gBACA,gBACA,WAEA,YAxEA,EAyEA,gBAEA,eACA,KACA,YAAoB,IAAS,IAC7B,kBAEA,0BACA,CCjFO,cACP,GAAQ,mBAAa,KACrB,kBACA,YAA+B,MAAI,eACnC,iCAAiD,EAAO,GAAO,EAAP,sDAAO,GAE/D,OACA,KAAkB,MAAI,eACtB,MACA,CACA,OACa,gBAAU,IACvB,CACA,KAAkB,MAAI,WACtB,gBACA,EAEA,CACA,KAAc,MAAI,YAClB,MACA,KAAkB,MAAI,MACtB,aACS,CAET,CCTO,cAEP,YACA,OAAiB,KAAM,MAAI,OAG3B,cACA,YAIA,qBACA,SACA,gBACA,UACA,UACA,SAEA,CACA,OAAiB,KAAM,MAAI,eAC3B,CACA,uBACA,aACA,qBAEA,SACA,gBAEA,QADA,KAEA,IACA,QACA,KAA0B,MAAI,cAC9B,MAA4B,KAAM,MAAI,cAAyB,CAC/D,OACA,CAAiB,CAEjB,CACA,OAAiB,KAAM,MAAI,iBAC3B,CAEA,uBACA,OAAiB,KAAM,MAAI,kBAE3B,sBACA,OAAiB,KAAM,MAAI,sBAG3B,oCACA,gBACA,iBACA,CAAgB,KAAM,MAAI,cAC1B,CAAgB,KAAM,MAAI,eAC1B,CACA,sBACA,OAAiB,KAAM,MAAI,gBAE3B,iDAAwD,EAAM,GAC9D,CAMA,8BChFA,yDACO,SAAS,EAAS,GACzB,QADyB,EACzB,UACA,CAKO,oBACP,4BAIA,OAHA,GACA,iBAEA,IACA,CACO,kBAXA,SAYP,GAVA,CAFO,EAYP,IAXA,EACA,eADA,EACA,QAWA,EAEQ,EAAS,GACjB,CACA,OAFiB,CAEjB,mBACA,2BACA,gBA8MO,WA9MP,KA8MO,EA9MP,EA8MO,EA9MP,EA+MA,cACA,aAEA,WACA,UACA,OAAe,EAAS,kBACxB,CAAK,KACL,UACA,GAAY,EAAS,GACrB,QADqB,CACrB,UACA,OACA,CAAa,CAGb,QAEA,CAAK,GA/NL,IACA,8BACA,EAIA,CACA,QACA,KACA,IACA,cACA,CACA,SACA,WACA,CAEA,YACS,CACT,QACA,YACS,CACT,WACA,KACA,IACA,+BACA,CACA,SACA,WACA,CAEA,YACS,CACT,+BACA,qBACA,cACA,CACA,CACO,iBAIP,EACA,SAJA,sBACA,wBAQA,CACA,QALA,0BACA,IACA,GACA,CAAK,EAGL,cACA,QACA,CAAS,CACT,aACA,QACA,CAAS,CAET,CAEO,kBACP,iBACA,OAEA,2BACA,IAsBA,gBArBA,IACA,IAAgB,gBAA6B,SAC7C,KACA,OAEA,SACA,aACA,IACA,CACA,oBACA,iBACA,CAAS,aAIT,GAHA,GACA,YAEA,EAGA,UACA,CAAS,CACT,GAEA,CACO,cACP,OACA,UACA,KACA,IACA,cACA,CACA,SACA,WACA,CAEA,YACS,CACT,SACA,KACA,IACA,cACA,CACA,SACA,WACA,CAEA,WACA,CAAS,CACT,WACA,KACA,IACA,GACA,CACA,SACA,WACA,CAEA,WACA,CAAS,CACT,oBACA,+BACA,cACA,CACA,CAQO,wBAIP,EACA,EACA,EAuBA,EAtBA,GANA,2BACA,8BAKA,GACA,MACA,KACA,oBAGA,CAUA,qBACA,OACA,SAEA,iCACA,CAEA,GAhBA,8BACA,WACA,MACA,WACA,OACA,EACA,0BACA,GASA,GACA,MAGA,KACA,qBAFA,EAEA,QAGA,CACA,OACA,SACA,mBAEA,SACA,QACA,oBACA,GAAgC,qBAA8B,EAC9D,oBACA,CAAS,CACT,SACA,2BACA,qBAEA,EACA,KAEA,KAEA,yBACA,YACS,CAET,CACA,cACA,OAAa,gBACb,CA0BO,cACP,MAzBA,iBA0BA,4BAEA,MAzBA,iBA0BA,0BAEA,QACA,CC/PO,cACP,wDACA,CACO,SAAS,EAAY,GAC5B,eAD4B,CAC5B,kBACA,CASO,SAAS,EAAc,KAC9B,eAD8B,QAC9B,yBACA,CCSO,gBACP,GAAQ,mBAAa,KACrB,2BACA,UAA+B,MAAI,MACnC,KAEA,CACA,CAEA,YACA,OAAiB,KAAM,M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AmC,GAAyB,IAE5D,UACA,YAEA,WACA,QACA,UACA,yEACA,2BACA,kDAEA,kDACA,oDAGA,oCACA,GAqKA,iBAA6C,OArK7C,oBAqKwE,CAAE,4BAA0B,CArKpG,EAEA,wBACA,kCAKA,oBAHA,CACA,IAFA,oCAIA,EAQA,OANA,SACA,UAEA,SACA,UAEA,CACA,CACO,mBACP,OACA,KAAc,MAAI,wBAClB,YAAqB,EAAkB,GACvC,MACA,KAAkB,EAFqB,IAEjB,MACtB,aACS,CACT,KAAc,EAAW,QAEzB,CAFyB,YAEzB,wBACe,EAAY,+BAC3B,OACA,oBACA,CACA,CA4FO,mBACP,OACA,KAAc,MAAI,kBAClB,YAAqB,EAAkB,GACvC,MACA,KAAkB,EAFqB,IAEjB,MACtB,aACS,CACT,mCACA,KAAc,EAAW,QAEzB,CAFyB,UAEzB,SACA,CACA,CA6BO,mBACP,SACA,gBACA,IACA,EADA,OAEA,YACA,gCACA,IACA,GAAwB,EAAY,WAGpC,SACA,GAAoB,EAAmB,IAEvC,SACA,IAHuC,EAGvC,EACA,KAAsB,MAAI,UAC1B,MACA,KAA0B,MAAI,MAC9B,OACA,CAAiB,CACjB,OACA,CAAa,CAEb,CACA,OACA,KAAc,MAAI,WAClB,MACA,KAAkB,MAAI,MACtB,OACA,CAAS,CACT,WACA,CACA,CACO,iBACP,SACA,aAAiB,UAAa,KAC9B,yBACA,iBACA,CACA,QACA,CEnWA,iBACA,qCACA,CACA,iBACA,sBAA4B,EAAO,eACnC,CACA,iBACA,aACA,gBACA,kDACA,SACA,WACA,+BACA,qBACA,iBAEA,8BACA,cACA,iCACA,CAAiB,CACjB,MAEA,qBAIA,SAEA,CACA,QACA,CAcO,2BACP,6BAGA,EAhBA,IAcA,MAEA,CAfA,cACA,kDACA,gBAaA,GAbA,CACA,WAEA,OADA,wCACA,IACA,CACA,QACA,CAAK,EACL,OAAgB,IAOhB,EAPsB,EAOtB,SAFA,MAGA,GArDA,cACA,8CACA,EAmDA,MACA,UACA,kDACA,OACA,kDACA,MAEA,UAGA,QACA,CAcA,mBACA,oCACA,CI1EO,eACP,QACA,cAAg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,+BACA,2BACA,KACA,4CACA,2CAC4B,GAAM,IAClC,4BAEA,CAEA,CACA,eACA,SACA,OAEA,OACA,KAAkC,GAAS,mBAG3C,eASA,EALA,kBACA,iBAIyB,GAAS,aAHlC,EAUA,CAPkC,MAOlC,CACA,CACA,eACA,+CACA,CEzEA,iBACA,2BAGA,kBACA,eACA,MACA,CACA,aAAqB,GAAS,wBAC9B,CCbO,iBACP,qBACA,gBACA,WACA,IAAa,kBAAY,0BACzB,IAAgB,kBAAY,KAC5B,oBACA,eAEA,cADA,IACA,KACA,uCAGA,MACA,GAAqB,uBAAiB,KACtC,oBACA,gBACA,WACA,uCACA,CACA,EAEA,CACA,CCtBO,+BACP,WACA,SAEA,MAAyB,qBAAe,IACxC,GAAQ,gBAAU,IAClB,eACA,OACA,EAEA,GAAa,gBAAU,IACvB,OAAe,GAAO,8BAEtB,GAAa,uBAAiB,KAC9B,oBACA,KACA,gBACA,iBACA,GACA,0BAEA,CACA,eACA,OACA,CACA,CAEA,CACO,iBACP,sBACA,IACA,qBACA,CACA,MACA,QACA,CACA,CAAK,CACL,CACO,iBACP,sBACA,IACA,sBACA,CACA,MACA,QACA,CACA,CAAK,CACL,CEhDO,iBACP,qBACA,gBACA,WAEA,IAAa,kBAAY,2BAAgC,kBAAY,KACrE,oBACA,eAEA,EADA,KACA,IAEA,CACA,CACA,CCbO,iBACP,MACA,gBACA,GAAY,kBAAY,IACxB,QAEA,CACA,CIHO,kBAA4C,EACnD,2BAqCA,OACA,eA2TA,GACA,QAAyC,EAAU,YACnD,qBACA,EA9TA,UACA,EAGA,QACA,CAAS,EAAU,eACnB,mBACA,WACA,KACA,gBACA,WACA,kBACA,cACA,YAEA,qBACA,UACA,MACA,cACA,MACA,UACA,QAEA,CACA,cAAuC,iBAAe,EACtD,KACA,QACA,CAAa,EACb,CACA,CAAK,IAAU,gBAAU,KA3BzB,CA4BA,EApEA,uBAA6I,IAAmB,OAAiC,QAAjC,OAAiC,CAAU,YAAwC,IAAe,QAAkC,gBAAU,eAG9S,SAAY,gBAAsB,SDP3B,ECOwC,CDPxC,EACP,0BACA,eACA,UAEA,0BACA,gBACA,WACA,+BACA,SAEA,aACA,wBAGA,eACA,2CAAuD,GAAS,OAAO,+CACvE,QACA,CACA,OACA,CACA,eACA,aAGA,OACA,UACA,WAHA,UAKA,YACA,GAAY,0BAAoB,IAChC,SAEA,mBAEA,OADA,iBACA,IAAmB,kBAAgB,GACnC,GAZA,GAIA,EASA,cACA,SACA,gBACA,WACA,WACA,WACA,SACA,OAEA,CACA,QACA,CACA,cACA,GAAY,kBAAY,KACxB,mBACA,GACA,KACA,uBACA,8BACA,EACA,WAAuB,mBAAiB,GACxC,CACA,GAAiB,qBAAe,KAChC,mBACA,GACA,KACA,sBACA,EAIA,MAHA,kBACA,mCAEA,IAAuB,sBAAoB,GAC3C,CACA,GAAiB,iBAAW,KAC5B,mBACA,GACA,KACA,oBACA,EACA,WAAuB,kBAAgB,GACvC,CACA,GAAiB,uBAAiB,KAClC,mBACA,GACA,KACA,YA8BA,YACA,SACA,gBACA,WACA,WACA,WACA,SACA,OAEA,CACA,QACA,GAzCA,SACA,EACA,WAAuB,wBAAsB,GAC7C,CACA,GAAiB,gBAAU,KAC3B,mBACA,WAAuB,iBAAe,GACtC,MACA,GAAiB,kBAAY,KAC7B,GAAgB,2BAAqB,IACrC,SAEA,mBACA,WAAuB,mBAAiB,GACxC,CACA,uCAAmD,EAAK,EACxD,CACA,cACA,SACA,gBACA,WACA,WACA,mBACA,SACA,iBACA,OAEA,CACA,QACA,CAaA,cACA,SACA,gBACA,UACA,UACA,SAEA,CACA,QACA,CACA,cACA,GAAY,gBAAU,KACtB,kBACA,mBAA6C,aAAW,QACxD,CACA,GAAiB,mBAAa,KAC9B,kBACA,mBAA6C,gBAAc,QAC3D,CACA,GAAiB,iBAAW,KAC5B,gBAKA,OAJA,YAEA,GADA,IDlHO,WCkHkC,CDjHzC,oBACA,oBAEA,eAEA,gBADA,KACA,KAGA,QACA,ECwGyC,GAA0B,KAAjB,SDvG3C,GACP,KCsGmE,EDtGnE,QACA,KAAa,YAAU,MACvB,OAAmB,YAAU,MAChB,cAAY,MACzB,OAAmB,cAAY,MAClB,eAAa,MAC1B,OAAmB,eAAa,MACnB,gBAAc,MAC3B,OAAmB,gBAAc,MACpB,WAAS,MACtB,OAAmB,WAAS,SAE5B,QACA,CACA,ECwFmE,IACnE,mBAEA,sBACA,CACA,WACA,CACA,EClJ+C,EAD/C,SAwPA,OACA,eAkGA,GACA,QAAyC,EAAU,WACnD,qBACA,EArGA,GACA,WACA,iBAEA,SACA,gBACA,YACA,YACA,UAEA,UACA,SAEA,CACA,QACA,EAzQA,kBACA,MAEA,WAAe,eAAa,EAC5B,gBACA,MAAe,GAAwB,EAAU,GAAwB,gBAAlC,KAAkC,SACvD,GAAwB,EAAU,GAAwB,gBAAlC,GAAkC,KAC5E,aAAsB,GAAwB,EAAU,GAAwB,gBAAlC,KAAkC,OAChF,uBACA,YACA,CAAK,CACL,CACA,4BACA,SACA,eACA,wBACA,WACA,mBACA,OACA,QACA,CACA,eAqRA,OAGA,IADA,EACA,MAFA,SAjCA,KACA,mBACA,GAAwB,EAAU,MA4BlC,EA5BkC,IAC1B,kBAAY,KACpB,OAAwB,EAAU,eAAiB,EAAU,aAC7D,2BACA,OAA4B,EAAU,YAAc,EAAU,OAE9D,CAF8D,GAE9D,0BACA,OAA4B,EAAU,YAAc,EAAU,UAE9D,mCACA,OAA4B,EAAU,YAAc,EAAU,eAGjD,uBAAiB,IAC9B,OAAwB,EAAU,mBAErB,qBAAe,IAC5B,OAAwB,EAAU,eAAiB,EAAU,cAAgB,EAAU,gBAE1E,iBAAW,IACxB,OAAwB,EAAU,eAAiB,EAAU,cAAgB,EAAU,YAE1E,gBAAU,IACvB,OAAwB,EAAU,WAErB,kBAAY,KACzB,OAAwB,EAAU,aAElC,CACA,EAEA,KAEA,CACA,qBAGA,IADA,QACA,CAEA,qBACA,EA/RA,OACA,YACA,OACA,QACA,CACA,aACA,eACA,OACA,QACA,CACA,MACA,CAEA,QACA,CAiCA,mBACA,cACA,CAAS,EAAU,cACnB,2BACA,SAEA,mBACA,WACA,OACA,KACA,gCACA,CAEA,CAAS,CACJ,EACL,eACA,CAAS,EAAU,wBACnB,2BACA,SAEA,mBACA,WACA,OACA,KACA,gCACA,CAEA,CAAS,CACJ,CACL,CACA,iBACA,GAAQ,gBAAU,KAClB,qBACA,mBAAqC,aAAW,QAChD,CACA,GAAa,mBAAa,KAC1B,qBACA,mBAAqC,gBAAc,QACnD,CACA,GAAa,iBAAW,KACxB,gBACA,qBACA,CACA,WACA,CACA,mBACA,SACA,eACA,wBACA,WACA,IAAiB,kBAAY,KAC7B,CAAiB,qBAAe,KAChC,CAAiB,uBAAiB,KAClC,OACA,QACA,CACA,eAgNA,OAGA,IADA,EACA,MA1BA,cACA,mBACA,GAAwB,EAAU,OAmBlC,CAnBkC,KAC1B,kBAAY,KACpB,OAAwB,EAAU,gBAAkB,EAAU,cAC9D,2BACA,OAA4B,EAAU,WAAa,EAAU,kBAE7D,8BACA,OAA4B,EAAU,WAAa,EAAU,qBAE7D,mCACA,OAA4B,EAAU,WAAa,EAAU,0BAGhD,qBAAe,IAC5B,OAAwB,EAAU,gBAAkB,EAAU,iBAEjD,uBAAiB,KAC9B,OAAwB,EAAU,oBAElC,CACA,EAEA,KAEA,CACA,qBAIA,IAFA,QAEA,CAEA,cACA,EA3NA,OACA,YACA,OACA,QACA,CACA,mBACA,WACA,KACA,gBACA,WACA,aACA,cACA,YAEA,qBACA,UACA,kBACA,YACA,aACA,MACA,kBACA,OACA,CAA6B,CAC7B,EAEA,KACA,cACA,MACA,UACA,QAEA,CACgB,kBAAY,IAC5B,YAA2D,mBAAiB,EAC5E,KACA,QACA,CAAiB,GAEI,qBAAe,IACpC,YAA2D,sBAAoB,EAC/E,KACA,QACA,CAAiB,GAGjB,YAA2D,wBAAsB,EACjF,KACA,QACA,CAAiB,EAEjB,CAEA,QACA,CACA,mBACA,SACA,eACA,wBACA,WACA,IAAiB,kBAAY,MAAmB,qBAAe,KAC/D,OACA,QACA,CACA,eA6JA,GACA,QAAwC,EAAU,UAClD,qBACA,EAhKA,GACA,YACA,OACA,QACA,CACA,mBACA,WACA,KACA,gBACA,WACA,SACA,YACA,OACA,QACA,CACA,qBACA,cACA,OACA,QACA,CACA,SACA,gBACA,WACA,aACA,cACA,YAEA,qBACA,UACA,OACA,MACA,UACA,QAEA,CACA,MACA,KACA,MACA,CACA,CACgB,kBAAY,IAC5B,SAA2C,mBAAiB,EAC5D,KACA,QACA,CAAiB,EAEI,qBAAe,IACpC,SAA2C,sBAAoB,EAC/D,KACA,QACA,CAAiB,EAGjB,SAA2C,wBAAsB,EACjE,KACA,QACA,CAAiB,CAEjB,CAEA,QACA,CA4GO,eACP,GAAQ,kBAAY,KACpB,mBACA,oBACA,SACA,uBACA,wBACA,WACA,iBAEA,CACA,WACA,aACA,KAAsB,MAAI,wBAC1B,QACA,CACA,CAQA,OAPA,2BACA,kDACA,KACA,KAAsB,MAAI,uBAC1B,aACA,EAAa,GAEb,IAAmB,mBAAiB,GACpC,CACA,GAAa,qBAAe,KAC5B,mBACA,oBACA,SACA,uBACA,wBACA,WACA,iBAEA,CACA,WACA,aACA,KAAsB,MAAI,2BAC1B,QACA,CACA,CAQA,OAPA,2BACA,kDACA,KACA,KAAsB,MAAI,0BAC1B,aACA,EAAa,GAEb,IAAmB,sBAAoB,GACvC,CACA,GAAa,uBAAiB,KAC9B,mBACA,oBACA,SACA,uBACA,wBACA,WACA,iBAEA,CACA,WACA,aACA,KAAsB,MAAI,8BAC1B,QACA,CACA,CAQA,OAPA,2BACA,kDACA,KACA,KAAsB,MAAI,6BAC1B,aACA,EAAa,GAEb,IAAmB,wBAAsB,GACzC,CACuB,CAAvB,IAAa,gBAAU,IAwBvB,SAvBA,mBACA,oBACA,SACA,uBACA,iBACA,kBACA,iBAEA,CACA,WACA,aACA,QACA,CACA,CAOA,OANA,2BACA,kDACA,KACA,aACA,EAAa,GAEb,IAAmB,iBAAe,GAClC,CAIA,CGrIA,iBACA,eACA,UCtTA,uBACA,eACA,+BAAiD,EAAS,GAAG,EAAU;AACvE;AACA;AACA,MAAM,EAAU;AAChB,GAAG,EACH,eACA,cAEA,aACA,gBAEA,MACA,CACA,gCACA,yBAAqC,EAAS,GAAG,EAAU,sBAE3D,EPzCA,YACA,yBACA,uCACA,mCACA,6CACA,uCACA,mDACA,2CACA,qCACA,6CACA,uCACA,2BACA,iCACA,yCACA,mCACA,2BACA,+CACA,yCACA,qCACA,iDACA,uDACA,+DACA,+CACA,qDACA,iCACA,oCACA,CAAC,UAAgC,EU3B1B,UACP,EACA,YAAsB,eAAc,IACpC,WACA,YAEA,CAAS,CACT,qBAAoB,EAAY,IAChC,SACA,UAEA,CAAS,CACT,6BAAuB,sBAAoC,IAC3D,YACA,cAEA,wBACA,CAAS,CACT,6BAAwB,EAAgB,IACxC,aACA,cAEA,CAAS,CACT,ECtBO,QACP,4BAAwB,kBAAwB,GACjC,EAAkB,kBAEjC,CAAC,CCJM,mCAqBA,oBAjBP,YACA,oBACA,KACA,CACA,YACA,cACA,eACA,kBACA,oBACA,mBACA,mBACA,2BACA,CACA,EAIO,IAmBA,gBAjBP,YACA,oBACA,KACA,CACA,YACA,cACA,eACA,kBACA,oBACA,mBACA,mBACA,kBAEA,EAIO,IAOA,eACP,0BACA,SACA,2CASO,iBACP,gBACA,OAAiB,UAEjB,GACA,YACA,gBACA,sBACK,CAEL,CACO,iBACP,gCACA,KACA,GACA,2BACA,EAEA,SACA,kBACA,iBACA,KACA,KAEA,IAGA,SACA,mBAKA,MAJA,SACA,KACA,KAEA,GAA8B,EAAW,CAAG,QAAH,MAAG,OAA8B,CAC1E,CAAS,CACT,SACA,kBACA,KACA,QAIA,QACA,CAAS,EAET,QACA,CC9DO,QAPA,EAMP,kDANO,OACP,UAjCO,YACP,aAHA,wBAGA,EAHA,MAIA,wBACA,kBACA,CAIA,EAyBA,GAxBA,gBACA,eAEA,GADA,sBACA,GACA,yBACA,CAAgB,iCAChB,CAAgB,mBAChB,sCACA,QACA,CAEA,CAAS,CACT,CASA,OARA,kCACA,UACA,EACA,kBACA,wBACA,CAEA,CAAK,EACL,CACA,EAKA,OAFA,GAMA,mBAAoD,cAAoB,IACxE,gBACA,GAAoB,oCAA0E,CAE9F,EC5CO,iBACP,OAAqB,WACrB,4BACA,gBACA,oCAGA,QACA,CAbC,mDAAwD,2BAAgC,+CAAiD,kCAA0C,+CAAiI,IA8C9S,QAKP,UACA,EAGA,SACA,MAIA,OAHA,SACA,SACA,CAAa,EACb,CACA,EARA,EAcA,eACA,EAGA,SACA,MACA,OAAmB,EAAkB,YAEd,EADvB,EADqC,KACrC,IACgC,2BACnB,IACb,EAEA,EAVA,EAYA,CAAC,CCjFM,eCIP,eACA,oBAAwB,EAAK,0DAC7B,CCJA,eACA,cACA,CCDO,qBACP,0BACA,sBACA,CACA,SACA,iBACA,YACA,gBAGA,SAEA,CACA,CCZO,WAAkC,kBAAgB,EACzD,aACA,uGACA,WAAgB,mBAAiB,iBAAkB,mBAAiB,kBACpE,MACA,IACA,SAAsB,gBAAc,CAAC,gBAAc,EACnD,+CACA,eACA,CAAS,CACT,OACA,KAAkB,eAAa,CAC/B,yBACA,CACA,CAAK,CACJ,EAIM,OAAmC,kBAAgB,EAC1D,cACA,wGACA,WAAgB,mBAAiB,QACjC,MACA,IACA,SAAsB,gBAAc,CAAC,gBAAc,EACnD,6CACA,eACA,CAAS,CACT,OACA,KAAkB,eAAa,CAC/B,yBACA,CAAS,CACT,cACA,eACA,KAAkB,YAAU,CAC5B,mDACA,CAAS,CACJ,CACJ,ECvCD,6BACA,0BACA,eACA,KAAiB,MAAI,WA4Gd,EA3GP,YACA,SAEA,MAyGA,CADO,EAxGP,GAyGA,iCAzGA,GACA,KAEA,MAAiB,MAAI,kBACrB,aACA,WACA,SAEA,cACA,MACA,UAA4C,GAC5C,iCACA,QACA,cACA,QACA,CAAqB,CACrB,MAEA,iCAEA,KACA,CACA,KAAiB,MAAI,kBACrB,mBACA,YACA,SAEA,cACA,gBACA,SAEA,WACA,kBACA,SAKA,GAHA,GACA,SAEA,GACA,UAA4C,GAC5C,iCACA,QACA,cACA,QACA,CAAqB,CACrB,MAEA,gCAGA,CACA,CAEA,CASO,uBACP,UAAuB,GACvB,KAEA,MAHqC,CAErC,0BACA,QAAa,YACb,CAKO,iBACP,MAAiB,wBAAkB,CAAC,sBAAoB,MACxD,cACA,SAEA,MAAoB,wBAAkB,CAAC,yBAAuB,aAC9D,UAIA,CAIO,mBACP,sBACA,MACA,SAEA,MAA4B,iBAAW,aACvC,SAGQ,oBAAc,KAEtB,EADA,oBACA,WAGA,CAYO,iBACP,MAAkB,wBAAkB,CAAC,GAAqB,KAC1D,MAGA,OAJ0D,EAI1D,CAGA,OACA,6CACA,CACA,CAUO,OlDxCA,QkDwCiC,ClDxCjC,GACP,kBACA,2BACA,eACA,OACA,cACA,WACA,kBACA,WACA,kBACA,WACA,kBACA,WACA,mBAEA,OADA,WACA,CACA,CACA,eACA,OACA,cACA,WACA,kBACA,WACA,kBACA,WACA,mBAEA,OADA,WACA,CACA,CACA,eACA,OACA,cACA,WACA,kBACA,WACA,mBAEA,OADA,WACA,CACA,CACA,eACA,OACA,cACA,WACA,mBAEA,OADA,WACA,CACA,CACA,eACA,eACA,mBAEA,OADA,WACA,CACA,CACA,QACA,CACA,EkDfwC,oBACxC,UAA8B,GAC9B,UACA,CAF4C,CAE5C,GAKA,eACA,gBACA,iCAGA,MATA,CACA,SACA,SACA,CAOA,CAAC,EC3JM,mBACP,YAAa,mBACb,CAIO,eACP,SACA,IACA,QACA,cACA,SAEA,kBACA,CCjBO,SAAS,GAAe,GAC/B,yBAD+B,MAC/B,OACA,CCFO,QACP,cACA,4CACA,CAAK,CACL,mBACA,sDACA,CAAK,ECNE,eACP,sBACA,SAEA,gCACA,+CACA,CACA,cACA,IAAiC,gBAEjC,yBAOA,MANA,uCACA,kBAEA,qCACA,gBAEA,CACA,CAEA,uBACA,CErBO,iBACP,MACA,wDAEA,CCIO,mBACP,oBACA,0BACA,KACA,gBACA,MAA0B,EAAkB,aAC5C,GAD4C,CAC5C,EACA,CAAS,EACG,EAAS,IACrB,OADqB,EAGrB,CACA,aACA,SAEA,8CACA,EACA,gCAEA,aACA,CEdA,O3DkBO,Q2DlB0B,C3DkB1B,GACP,kBACA,uBACA,eACA,OACA,cACA,WACA,kBACA,WACA,eAEA,OADA,WACA,CACA,CACA,eACA,OACA,cACA,WACA,eAEA,OADA,WACA,CACA,CACA,eACA,eACA,eAEA,OADA,WACA,CACA,CACA,QACA,CACA,E2D/CiC,SAAyC,GAAiB,4CAoC3F,eAaA,OAZA,2BAYW,EAAkB,KAqL7B,WArL6B,KAgN7B,QA1BA,IASA,EATA,WAAY,qDAA0D,EACtE,EAAqB,SvDpPd,OAEP,EuDkPuC,EvDlPvC,KADA,GACA,OACA,WACA,MAAc,EAAkB,uCAAwC,GAAW,aACnF,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CA,iBAGS,CAET,EAOO,qBAEP,GAAQ,EAAY,0BACpB,2BACA,qBACA,sBAEA,CACA,CACA,EA4DO,eACP,0BACA,KACA,KACA,OACA,yBACA,YACS,CACT,SACA,EACuB,EAAW,CAAG,QAAH,GAAG,SAAwB,EAE7D,EACA,UAEA,KACmB,EAAW,CAC9B,QAD8B,aAC9B,CACA,MACA,CAAa,GAEb,YACA,KACA,YAEA,UACA,KACA,YAEA,CAAS,GAAiB,mBAC1B,KACA,IAAwC,GAAiB,kBAEzD,CACA,CACA,qBACA,oBACA,YAGA,OAEA,CACA,wBACA,GAAwB,GJh4BjB,YAUP,IACA,EACA,EI63B+B,EJ/3B/B,GIs3BwB,MJt3BxB,iBAGA,KACA,mBACA,KACA,OAAqB,sBAErB,IACA,WAOA,EALA,KAEA,OADA,QACA,UAIA,kBACA,GACA,CAAiB,EACjB,qBACA,UAIA,OADA,KACA,UASA,OAHA,kCACA,SACA,IACA,SACA,CACA,QACA,iBACA,WACA,SAOA,OAHA,OACA,WAEA,SACA,CACA,SAEA,MADA,KACA,CACA,CACA,CACA,OACA,OACA,iBACA,KACA,gDACA,CAAqB,uBAErB,eAIA,MAHA,KACA,gDAEA,CACA,CAAS,CACT,yBACA,YACS,CACT,OAAe,GAAiB,gBAChC,KACA,mBACA,IAAwC,GAAiB,kBACzD,IAA8B,GAAiB,kBAC/C,CACA,CAAS,CAET,EIkzBgC,EAAgB,KAA8B,EAAkB,OApqBhG,CACA,GAmqBgG,EAlqBhG,GAkqBgG,SAjqBhG,2BACA,SACA,GA+pBgG,QAChG,+BACA,kEAEA,wBACA,CAAK,GAbL,CAcA,CACA,iBACA,OAAW,EAAkB,WAC7B,KAD6B,SAC7B,EACA,UACK,CACL,CA2DA,mBAEA,GADA,oBACA,mBACA,QAGA,IAAS,GAAe,GACxB,MAAc,EAAkB,iBADR,yCACQ,EAAkE,EAAO,GAAS,EAAT,SAEzG,EACA,CACA,yBACA,gCAMA,OALA,UACA,SACA,YACA,CAAqB,EAErB,CACA,CAAa,EAGb,CACA,CACA,2BACA,IAMA,EANA,UACA,QACA,OACA,gBACA,YACA,CAAK,EAEL,IACA,kBACY,EAAS,IACrB,OADqB,EACrB,UACA,iBACA,MACa,CAEb,CACA,SACA,iBACA,MACA,CACA,YACA,CAwDA,qCACA,EAgBA,EAfA,IACA,UAAgB,UAAc,eAC9B,KAEA,OADA,2BACA,CAAqB,qBAErB,GACA,CACA,SACA,MAA6B,GAAW,GAIxC,KAJwC,CAIxC,CAAiB,cAFjB,GADsB,kBAAY,KAA2B,GAAW,IACxE,WAEiB,CACjB,CAEA,IAUA,OATA,oBACY,EAAS,IACrB,OADqB,EACrB,YACA,MAA8B,kBAAY,KAAuB,GAAW,IAC5E,IAD4E,CAC5E,cAEA,OADA,UACA,CACA,EAAa,EAEb,CAAiB,gBACjB,CACA,SAEA,SADsB,kBAAY,KAAuB,GAAW,IACpE,IADoE,MACpE,EAEA,OADA,UACA,CAAiB,gBACjB,CACA,CACA,qCACA,QACA,YACA,QACA,IAQA,EAiBA,EAzBA,EAAyB,GAAO,YAChC,UACA,QACA,OACA,gBACA,WACA,YACA,CAAS,EAET,IACA,yBACA,CACA,SACA,iBACA,UACA,iBAEA,WACA,sBAEA,CAAiB,EAEjB,MACA,CACA,SAAgB,WAA6B,EAa7C,GAVA,EADY,EAAS,GACrB,QADqB,EACrB,QACA,iBACA,UACA,OAIA,IAEA,cACA,EACA,MAEA,IACA,GACA,CACA,CACA,mBACA,MAA0B,GAAW,GACrC,KADqC,eACrC,aACA,UAIA,YAAwB,WAA0B,IAClD,oBAEA,MAIA,4BACA,+BAEA,CAAa,EAEb,+BACA,CAAK,CACL,CA4FA,SACA,KACA,OACA,MACA,IACA,SACA,KACA,cACA,YACA,YACA,qBACA,GACA,kBACA,mBACA,UAAoB,GAAW,YAC/B,+BACA,eACA,8BACA,8CACA,oBACA,eACA,6BACA,kBACA,IACA,CACA,CAAS,WACT,YACA,mBACA,CAAS,CACT,CACA,WACA,kCACA,iBACA,8BAGA,mBACA,CACA,CACA,SACA,KACA,OACA,MACA,KACA,MACA,QACA,aACA,UACA,oBACA,YACA,YACA,qBACA,GACA,mBACA,gBACA,mBACA,UAAoB,GAAW,YAC/B,+BACA,yBACA,eACA,8BACA,8CACA,oBACA,gBACA,6BACA,kBACA,IACA,CACA,CAAS,WACT,aACA,mBACA,CAAS,CACT,CACA,YACA,kCACA,iBACA,8BAGA,mBACA,CACA,yBACA,2BACA,CACA,CACA,eACA,wBAaO,mBACP,0BACA,IAAsB,oBAAkB,4BACzB,oBAAkB,CAEjC,IAA2B,kBAAgB,4BAC5B,kBAAgB,CAE/B,IAA2B,sBAAoB,MAChC,sBAAoB,CAEnC,gBACA,CC52CO,eACP,MAAyB,qBAAe,6BACxC,WACA,0CAEA,gCACe,CDwzBf,QCxzBwB,ID0zBxB,oBACA,gBAEA,uBAEA,CADA,aAA6D,CAC7D,WACA,kCACA,CACA,OACA,QACA,CACA,CACA,eA2EA,GACA,IACA,MAUA,YACA,WAAY,wDAA0D,EACtE,0BACA,WACA,MAAc,EAAkB,+DAChC,OACA,CAAS,EAET,IAAY,UAAuB,GAAa,wBAChD,0BACA,kBACA,eACA,MACA,MAAc,EAAkB,2BAA4B,EAAU,oBACtE,OACA,CAAS,EAET,MAAiB,GAAO,iBACxB,gBACA,IAKA,MAAqB,EAAiB,UAItC,KAJsC,WAItC,CAIA,EADA,wCACA,SACA,GAAY,EAAS,GACrB,QADqB,CAErB,wCACA,gBACA,KAAsB,kBAAY,KAAoB,GAAW,GACjE,CAAa,EAEb,EAHiE,KAGjE,8BACA,CACA,SACA,KAAc,kBAAY,KAAoB,GAAW,GACzD,CACA,EAvDA,EAqDyD,CApDzD,GAAY,EAAS,GACrB,QADqB,CACrB,iBAA2D,YAAiB,EAE5E,QACA,CACA,SACA,OAAiB,WACjB,CACA,EAtFA,UACA,EAAiB,GACjB,QADiB,EACjB,SAEA,OC10BwB,CAExB,OAAW,EAAkB,IDetB,OCfoC,GDepC,ECfsB,CDkB7B,kBAEA,aAgBA,MAfA,CACA,iBACA,sCACA,OACA,gBACA,MACA,yBAA4D,CAC5D,UACA,CAAyB,CACJ,CACJ,EACjB,GAEA,EAGA,ECrC2C,MAC3C,GD00BA,CC10BY,aACO,GAAyB,GAE5C,CAHgC,CAKhC,CACkC,EAAQ,YAC1C,EAN4C,KAM5C,YACA,WACA,SACA,oBACA,2BACA,8BACA,sBACA,uBACA,+BACA,CAAS,CACT,CACA,CAAC,EC7BD,QACA,eACA,kBACA,mBACA,gBACA,eACA,EACO,6BACA,2BACA,yBACA,+BACP,IACA,QACA,OACA,OACA,QACA,QACA,EACA,UACA,kCACA,iBACA,+BACA,OACA,gBACA,8BACA,OACA,gBACA,8BACA,OACA,iBACA,+BACA,OACO,4DACP,YACA,OACA,uBACA,qBACA,qBACA,sBACA,CACA,8BE1CO,wBACP,MACA,uBAEA,OACA,SACA,aACA,kBACA,4BACA,8CACA,CACA,CCVO,eACP,WAAiB,GAAiB,eCElC,mCAAsD,EAC/C,UACP,WAF6E,CAE7E,KACA,WACA,iCAEA,OAOA,OAN6B,GDN7B,CAAiB,GAAiB,oBCOlC,0BAA4C,GAAiB,iBAE5C,GAAgB,IACjC,SADiC,KACjC,YAA4C,GAAiB,YAE7D,CACA,CACA,WAIA,OAHA,GACA,8BAEA,CACA,CACA,SACA,GACA,sBAEA,CACA,OACA,aAGA,OAFA,2BACA,kBACA,CACA,CACA,eACA,YAAoB,GAAiB,eACrC,CACA,MACA,qBACA,2BACA,KACA,OAAmB,EAAkB,mCACrC,gDACA,0BAGA,CACA,CAAK,GAAiB,gBACtB,+BACA,WACA,mBACA,gBACA,wBACA,mBACA,CACA,CACA,CAAa,EAEb,gBACA,wBACA,mBACA,CACA,CAEA,CACA,4CChEA,IAAM,GAAe,8BACd,UACP,WAF6E,CAE7E,KACA,WACA,gCACA,CACA,OAIA,OAHY,GAAgB,IAC5B,SAD4B,KAC5B,YAA4C,GAAiB,YAE7D,CACA,CACA,WAIA,OAHA,GACA,8BAEA,CACA,CACA,SACA,GACA,sBAEA,CACA,OACA,aAGA,OAFA,2BACA,kBACA,CACA,CACA,UACA,YAAoB,GAAiB,UACrC,CACA,GAFqC,GAErC,CACA,oBACA,2BACA,MACA,IACA,GACA,CACA,SACA,4BAAgD,GAAe,gBAC/D,CACA,+BACA,CACA,CACA,CAAK,GAAiB,WAEtB,GAFsB,IACtB,qBACA,aACA,wBACA,mBACA,CACA,CACA,CACA,uCCrDO,2BACA,GADsD,CACtD,sBAD6E,YAC7E,EAAgE,GCFhE,SAAS,GAAe,GAC/B,UDCmG,GCDnG,EAD+B,CAC/B,+DAgDO,qBACP,sBACA,WApBA,GACA,MAlBA,YACA,6BACA,iCAEA,mBACA,uBAEA,eAlBA,GACA,uBACA,2BAEA,iDACA,4BACA,GAGA,EACA,EAQA,GACA,cACA,wBAEA,mCACA,2CAGA,YAFA,GAAkB,EAAQ,GAAG,EAAK,CAGlC,EAEA,GACA,mDACA,mCACA,SAAc,EAAS,KAAK,EAAiB,EAAE,EAAS,GAgBxD,GACA,YACA,mBACA,qBACA,iCAEA,cACA,CACA,gBACA,0BAEA,aADA,KACA,UACA,mBACA,oBAIA,QACA,KACA,oBACA,YACA,WACA,mBACA,mCAA+D,SAAa,EAC5E,2BAEA,EACA,kBACA,kBACA,qBACA,2BACA,CAAS,CACT,CACA,uCACA,wBACA,gBACA,UACA,gBACS,EAQT,aACA,qCACA,GA9DA,YACA,oCACA,qBACA,kBACA,YACA,gBACA,uBACQ,GAAe,GAIvB,EAmDA,GACA,UAxDuB,CAwDvB,aACA,uBACA,UACA,OACA,gBACa,EAEb,uBACA,uBACA,UACA,gBACS,EAIT,OAHA,iDACA,gDAAmE,gBAEnE,aACA,cACA,UACA,WACA,UAAqC,EAAW,EAChD,OADgD,KAEhD,UAAqC,EAAW,kBAChD,SACA,kBAGA,wBAEA,yBACA,CACA,CAAa,CACJ,CACT,CAEA,wBACA,gBACA,UACA,gBAEA,OACA,aACA,CAAK,CACL,CACO,eACP,oBAKO,eAEP,gBACA,mBACA,aACA,cACA,cAaA,eAEA,qBACA,CAqBA,iBAGA,IADA,WAEA,wCAEA,CA2HO,kBACP,qDAoBA,OAnBA,cAGA,mDACA,sCAEA,4CAEA,GACS,EAAI,EAEb,4CACA,0CACA,gBACA,QAEA,CAAS,EACT,4BACA,CAAK,EACL,CACA,CAEO,iBACP,+CACA,oBACA,CAAK,CACL,CACO,wBACP,QACA,QACA,GAEA,CACA,WACA,EAEA,qBACA,WACA,CAAK,GACL,CACO,iBACP,cACA,eAEA,GAAQ,EAAS,OACjB,IADiB,EACS,IAC1B,aACA,IAF+C,IAE/C,UACA,CAYA,OAXA,8BAA8E,QAAY,EAC1F,EACA,iBACA,YACA,CAAS,EACT,kBACA,WACA,CAAS,EACT,aACA,gCACA,CAAS,EACT,UAEA,QACA,CD/X4B,2BCgYrB,GDhYsD,CCgYtD,QACP,YADO,EDhY6E,ECybpF,+BACA,WACA,KAuBA,8BACA,WACA,cACA,qBACA,CACA,QACA,2DAEA,8BAEA,oCAEA,CACA,iBACA,4CACA,gDAEA,gBACA,mBAGA,WACA,oBACA,sBACA,mBACA,qCACA,GACA,oCAEA,CACA,wBAEA,SACA,2BACA,iCAEA,6EACA,gBACA,sCACA,CACA,oBACA,yBACA,wBAEA,KAEA,oBACA,yBACA,+BAEA,aAEA,cAIA,OAHA,cAGA,cAEA,eACA,6BACA,kCACA,MACA,CACA,eACA,gDAEA,gBACA,GACA,gCAEA,CACA,CACO,qBACP,gCACA,oBAEA,kBACA,WACA,+CACA,2BACA,uCACA,CACA,yBACA,CAAS,CACT,aACA,+CACA,2BACA,yCACA,CACA,2BACA,CAAS,CACT,mBACA,sBAEK,CACL,CEviBA,UCPO,SAAS,GAAc,GAC9B,cAD8B,MACJ,cAAY,CAE/B,SAAS,GAAsB,UACtC,aAAuB,cAAY,EACnC,wBACmB,GAAsB,gBACzC,CAIA,CACO,OANkC,EAMlC,MACP,0BACA,uCACA,wBACA,wBACA,CACO,mBACP,cACA,GAzBA,MAyBA,GAzBA,iBAyBA,GAzBA,WAyBA,EACA,sBAEA,aADA,UAEA,cAIA,SACA,gCAEA,MACA,2CACA,QACA,WAEA,MAAmB,GAAc,GACjC,EACc,EAAkB,UAFC,CAGjC,KADgC,SAChC,CACA,CAAa,EACb,MACa,GAAc,GAC3B,SAEA,KAH2B,QAG3B,MACA,MAAmB,EAAkB,WACrC,KADqC,SACrC,CACA,CAAS,GAET,mBACA,MAAmB,EAAkB,GACrC,YACA,CAFqC,IAErC,wBACA,aACA,CAAa,CACJ,GA1DT,MA4DA,GA5DA,8BA6DA,MAAmB,EAAkB,cACrC,EADqC,SACrC,CACA,6BACA,aACA,CAAa,CACJ,IAGT,WACA,MAAmB,EAAkB,qBACrC,YACA,MACA,aACA,CAAiB,CACJ,CACJ,IAET,oBACA,CACO,kBAA+D,OAEtE,IADA,EACA,KASA,GARA,uCACA,2BACA,2CAEA,0BACA,8BAGA,+BACA,sBACA,uBAIA,GAHA,2BACA,2CAEA,0BACA,QAEA,2BACA,kCACA,4BAEA,KACA,EAAsB,GAAsB,+BAC5C,YAKA,QAUA,OARA,IAKA,EAJA,eAIA,IAHA,KAMA,CACA,SACA,SACA,CACA,CClIO,eACP,qCACA,yBACA,6BACA,8BACA,OACA,gBACA,QACA,iCACA,iCACA,CACA,CACO,eAEP,UADA,IAA6B,kBAAe,IAE5C,CACO,iBACP,oCAGA,MADA,6BACA,sBAAgF,GAAqB,EACrG,CCpBO,eACP,uBAEO,eACP,4CAEA,OAAW,GADX,IAA6B,cACG,IADY,IAE5C,CCRO,eACP,yBAAyC,GAAkB,sCAC3D,CACO,eACP,qBAA+B,GAC/B,CCLO,eACP,CDGmD,KCHnD,mBAAwC,GAAkB,wBAC1D,CACO,eACP,gCAA2C,GAAO,CAClD,CCFO,eACP,0BACS,GAAkB,uBACf,GAAkB,8BAC9B,CACO,eACP,OAAW,EAAkB,iBAC7B,WACA,MAAkB,EAAkB,mDAAoD,EAAY,GACpG,YACA,MACA,UACA,CAAqB,CACrB,kBACA,CACA,CAAa,EAEb,eACA,gBACA,MAAkB,EAAkB,mDAAoD,EAAkB,GAC1G,YACA,MACA,UACA,CAAqB,CACrB,kBACA,CAAiB,CACJ,EAEb,QACA,CAAK,KACL,gBAA2B,cAAY,CACvC,QAEA,OACA,MACA,QACA,UACA,CAAa,CACb,kBACA,CAOA,OANA,oBACA,kBACA,YACA,kBACA,EAEc,EAAkB,gCAChC,YACA,CAAS,CACT,CAAK,CACL,CElDO,eACP,yBAAwC,GAAkB,wBAC1D,CACO,eACP,OAAW,EAAkB,qBAC7B,IAOA,EAPA,sBACA,MACA,MAAkB,EAAkB,6CAEpC,sBACA,MAAkB,EAAkB,sDAGpC,IACA,eA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CACJ,EA1CT,SA4CA,GA5CA,iBA4CA,EA3CA,MAAc,EAAkB,wCAChC,YACA,MACA,QACA,UACA,CAAiB,CACjB,kBACA,CAAa,CACJ,EAET,aAiCA,EAhCA,SAgCA,CAhCA,KAGA,YACA,GA4BA,GA5BA,YACA,QAEA,OAAkB,EAAkB,yBAA0B,EAAS,yBACvE,YACA,MACA,UACA,CAAqB,CACrB,kBACA,CAAiB,CACJ,CACb,CAkBA,iBACA,MAAc,EAAkB,8BAChC,YACA,MACA,QACA,WACA,SACA,iBACA,CAAqB,CACJ,CACjB,kBACA,CAAa,CACJ,EAET,kBACA,gBACA,MAAc,EAAkB,oDAAqD,EAAU,IAC/F,YACA,MACA,WACA,SACA,iBACA,CAAqB,CACJ,CACjB,kBACA,CAAa,CACJ,EAET,sBACA,8CACA,MAAc,EAAkB,kEAAmE,EAAmB,IACtH,YACA,MACA,WACA,SACA,iBACA,CAAqB,CACJ,CACjB,kBACA,CAAa,CACJ,EAET,uBACA,8CACA,MAAc,EAAkB,mEAAoE,EAAoB,IACxH,YACA,MACA,WACA,SACA,iBACA,CACA,CAAiB,CACjB,kBACA,CAAa,CACJ,EAGT,EAaA,IACA,CAAS,IsB0DT,EHpKO,gBACP,CGqKqC,CHpKrC,uBAA6B,EAAY,EAIzC,OAHA,WACA,2BACS,CAET,CACA,gCACA,OACA,mBAAoB,iCAAqC,EACzD,uCACA,mBAAyC,kBAAqB,KAC9D,gCACA,gBAAoC,kBAAqB,IACzD,eACA,2BACA,kBACA,iDACA,SACA,UACA,WACA,MACA,kCACA,iBACA,WACA,CAAyB,CACJ,SACG,EAAS,GACjC,QADiC,OAGjC,IAEA,CACA,qBACA,WACA,sBACA,CAAiB,EACjB,CACA,CAAS,CAET,EG6HqC,CACrC,kBACA,gBALA,uBAMA,0EACA,CAAqB,GAGrB,ErBrLA,CACA,OqBoL8B,QrBpL9B,SAAyB,EAAS,KqBoLoB,CrBzL/C,EAMP,GALA,SADO,EAMP,WALA,WAMA,MAAsB,EAAkB,gDACxC,YACA,MACA,WACA,SACA,iBACA,CACA,CAAyB,CACzB,kBACA,CAAqB,CACJ,CAEjB,CACA,GqBwKA,ElB9JA,CACA,OkB6J8B,ClB7J9B,IAEA,SAAsB,UkB2JgC,ClB3Jb,UAGzC,sBAAsB,GAAgB,EAAI,CAAG,CAAG,IAIhD,KAGA,sBACA,iBAA0C,cAAY,EAEtD,uBAAoE,CACpE,gCACA,iBAAyE,CACzE,YACA,cACA,MAGA,KArDO,EAqDP,SApDA,MAoDA,EAnDW,qBAAe,CAmD1B,MAnD0B,OAC1B,OACA,MACA,MAAc,EAAkB,kDAChC,YACA,oCACA,MACA,UACA,CACA,CAAa,CACJ,EAET,uCACA,MAAc,EAAkB,8DAChC,YACA,MACA,WACA,SACA,YACA,CAAqB,CACJ,CACjB,kBACA,CAAa,CACJ,CA4BT,CAEA,CAEA,GkBmIA,IAEA,GACA,gBACA,EACA,wBAAuD,EAAO,EAC9D,GAA4C,GAAY,GACxD,MADwD,CAGxD,CAAqC,CACrC,CAEA,CAAyB,EACzB,EAAkC,S1DzJ3B,GACP,G0DwJiD,C1DxJjD,mBACA,mBAnDO,oBAoDP,UACA,OACA,gBACA,sCAAmD,aAAiB,IACpE,SACA,CAAa,CACb,CAAS,CACT,cACA,EACA,iBAC2B,GAAmC,IAE9D,GAEA,gBACA,EACA,OAN8D,WAM9D,GAC2B,GAAmC,KAE9D,wBAAmC,GAF2B,QAE3B,EAAiB,EACpD,SACA,CAAiB,CACjB,CAEA,CACA,E0D6HiD,KAEjD,EpB5MA,CACA,eACA,QAAsB,WAAe,IACrC,MACA,eACA,kBACA,gDACA,uBACA,uBACA,qDACA,8BAGA,CAEA,EoBgMA,CAAiB,CACJ,CACb,CACA,kBtD9MO,OsD8M4B,EtD9M5B,GACP,2BACA,EDAO,kBAAqC,EAAU,EACtD,GCDkD,CDOlD,EANA,OACA,KACA,kBACA,qBACA,oBACA,sBAKA,aACA,WAGA,IACA,GACA,2BACA,OACA,kBACA,kBACA,SACA,kBACA,MACA,CAA6B,CACJ,CAIzB,EACA,KAEA,YAAoB,WAAoB,KACxC,WACA,KACA,kBACA,UACA,cACA,SACA,CAAa,CACb,oBACA,wCACA,CAAS,EACT,8BACA,CAEA,OACA,QACA,SACA,YACA,aACA,WACA,YAEA,0BAAiB,oFAAuH,IACxI,kBACA,qBACA,qBACA,mBACA,uBACA,sBACA,GACA,KACkB,GAAK,KACvB,GAiBA,qBACA,WACA,WACA,IAEA,KACA,sBACA,SACA,QAJA,EAKA,kBACA,cANA,EAMA,EACA,CAAqB,CACrB,eAA8B,YAA+B,CAC7D,UACA,eACA,GACA,CAAqB,CACrB,sBACA,GACA,CAAqB,CACJ,CACjB,IACA,SAEA,CACA,YACA,IACA,QACA,CACA,SACA,GACA,CAEA,eACA,GACA,QA/BA,EAgCA,kBACA,cAjCA,EAiCA,EACA,CAAqB,CACrB,uBACA,GACA,CAAqB,CACrB,QACA,CAAiB,EAEjB,YACA,yCAEA,sBACA,QAGA,OADY,GAAiB,oBAC7B,CACA,EACA,MACA,aACA,OACA,iBACA,sBACA,IACA,OAEA,KACA,yBACA,SACA,QAJA,EAKA,kBACA,cANA,EAMA,EACA,CAAqB,CACrB,QACA,SACA,cACA,QACA,WACA,SACA,CAAqB,CACrB,aACA,sBACA,GACA,OAEA,SACA,CAAqB,CACrB,oBACA,GACA,CAAqB,CACrB,cACA,GACA,CAAqB,CACJ,CACjB,aACA,CAIA,GAHA,GACA,iBAEA,GACA,OAEA,mBACA,eACA,GACA,QACA,SACA,QA1CA,EA2CA,kBACA,cA5CA,EA4CA,EACA,CAAqB,CACrB,cACA,GACA,CAAqB,CACJ,EAEjB,QACA,EACA,MACA,mBACA,OACA,SAGA,GACA,cAFA,EAEA,GAEA,SACA,OAAmB,EAAkB,IAAO,EAAY,UAAnB,CAAmB,SACxD,QANA,EAOA,kBACA,cARA,EAQA,EACA,CAAiB,CACjB,0BACA,KACA,GACA,CAAiB,CACJ,SACb,EAfA,EAgB2B,EAAkB,IAAO,EAAY,QAChE,EAD6C,MAhB7C,EAkBA,iBACA,cAnBA,EAmBA,EACA,CAAyB,CACJ,OArBrB,GAwBa,IACb,QACA,eACA,GACA,QA5BA,EA6BA,QACA,aACA,GACA,CACA,CAAqB,CAErB,QACA,CAAa,CACb,EACA,OACA,GACA,mBAEA,GAGA,EADA,mBAEU,GAAa,IACvB,IAGA,EAJuB,EACvB,EACA,KACA,qBAEA,OAAmB,EAAkB,IAAO,EAAY,UAAnB,CAAmB,WACxD,cACA,mBACA,GACA,CAAiB,CACjB,UACA,kBACA,kBACA,CAAiB,CACjB,OACA,8BACA,IACA,GACA,CAAiB,CACJ,UACb,SACA,KACA,QAA6B,wCAAsC,IACnE,GACA,UAEA,GACA,UAGA,OAAuB,EAAkB,oBACzC,KACA,KACA,gBACA,SACA,OACA,SACA,cACA,GACA,CAA6B,CACJ,EACzB,IACA,UACA,iBAEA,SACA,gBAGA,CA6BA,OA5BA,UAAgD,GAAe,IAC/D,GAAiC,EAAgB,GADc,EACO,EAAkB,IAAO,EAAY,CAA1D,CAA0D,MAC3G,EADwF,GACxF,EACA,SACA,gBACA,CAAyB,YAEzB,UAA+C,GAAe,IAC9D,GAAiC,GAAkB,EADW,KAE9D,QADmD,KACnD,EACA,GAEA,EAAyB,EAEzB,UAAyD,GAAe,IACxE,GJnNO,KIkNiE,IJlNjE,KACP,IIkNmD,EJlNnD,0BACA,GACA,2BACA,EAEA,SACA,mBACA,KACA,CAAyB,wBAGzB,WACA,cAC8B,EAAW,CAAG,QAAH,MAAG,OAA8B,EAE1E,SACA,kBACA,KACA,QAIA,QACA,CAAS,EAET,QACA,EIwLmD,MACnD,QACA,eACA,GACA,QACA,aACA,GACA,CAAqC,CACJ,CAEjC,QACA,EAAyB,EAEzB,CACA,CAAiB,CACjB,CAAa,CACb,CAAS,EACC,GAAa,GAEvB,IADA,GADuB,IACvB,QAEU,GAAW,IACrB,IADqB,EACrB,IAEA,KACA,KACA,qBACA,OAAmB,EAAkB,IAAO,EAAY,oBACxD,YACA,iBACA,GACA,CAAiB,CACjB,8BACA,IACA,GACA,CAAiB,CACjB,UACA,kBACA,sBACA,wBAGA,4EAAwG,kBAA0B,KAAK,SAAiB,GAExJ,CAAiB,CACjB,MACA,CAAa,SAAsB,EAAkB,OACrD,GACA,KACA,CAHqD,YAGrD,CACA,CAAiB,KAAa,EAAkB,IAAO,EAAY,UAAnB,UAAmB,IACnE,OACA,SACA,cACA,GACA,CAAiB,CACJ,UACb,SACA,KACA,eAA6B,WAAgB,IAC7C,GACA,UAEA,GACA,UAmBA,OAhBA,UAA4C,GAAe,IAC3D,GAA6B,EAAgB,GADc,EACK,EAAkB,IAAO,EAAgB,CAA5D,CAA4D,MACzG,EADkF,GAClF,EACA,SACA,cACA,GACA,CAAyB,CACJ,YAErB,UAA2C,GAAe,IAC1D,GAA6B,GAAkB,EADW,KAE1D,eACA,GAEA,EAAqB,EAErB,CACA,CAAa,GACb,CAAS,EACC,GAAW,GAIrB,GAHA,EADqB,CACrB,EAGA,EACA,2BACA,oBACA,SACA,uBACA,CAAa,EAGb,OACA,qBACA,EAEA,KAzVA,IACA,gCACA,GACA,UACA,kBACA,GAGA,kBACA,CAAiB,CACjB,mBACA,CAAa,CAEb,EA6UA,QACA,WACA,UACA,YACA,iBACA,iBACA,CACA,ECpakD,CAClD,SACA,CAAK,EACL,oBACA,OAAsC,IACtC,MAA6B,GAAe,SAAG,EAAS,CAAZ,CAG5C,OADA,wBACA,CACA,gCACA,0BAJA,EAIA,aACA,+BALA,EAKA,mBACA,wCACA,8CACA,2BACA,CACA,EAEA,OADA,aACA,CACA,EsDyLmC,CACnC,qBACS,EACT,wCACA,4BACA,sBACA,+BACA,6BACA,cACA,IACA,cACA,cACA,UACqB,EAErB,kBACA,gDAEA,YACA,oCAEA,qBACA,sDAEA,mBACA,kDAEA,mBACA,2CAC0B,GAAK,wCAC/B,mBAIA,CACA,eAAsB,6BAA0B,IAChD,oBACA,CACA,QACA,EACA,CACA,UACA,QACA,EACA,mBACA,2BAEA,OADA,mDACe,EAAkB,IAAO,EAAkB,IAAO,CFjO1D,KEiO0B,IFjO1B,EEiOmD,EAA2B,IFjOpD,cAAoB,EAErD,uBAEA,gCACA,WACA,QAAiB,GAGN,EAAkB,2BAC7B,OACA,gBACA,WACA,eACA,2BACA,6BACA,EAEA,EAA0B,qBAAe,oBAIzC,MAFA,sDAEA,EACA,CAAK,CACL,GEyMqF,QAAG,cAAmB,MAC3G,yDACA,GACS,GAET,EACA,OAF2B,GAAW,oCAGtC,IACS,IACO,GAAe,IAC/B,GAAyB,EAAgB,GADV,EACU,MACzC,yBAEA,MADA,qCACA,EAGA,OACA,OAFmC,GAAW,oCAG9C,CACA,EAAiB,EAEjB,GAEA,EACA,4BAA4B,YAAkB,MAE9C,IADA,EACA,oBACA,OAAe,EAAkB,IAAO,EAAY,yBACpD,SACA,UACA,aACA,GACA,CAAa,CACb,gBACA,oBACA,GACA,CAAa,CACb,aACA,GACA,CAAa,CACb,uBACA,SACA,CAAS,OAAU,EAAkB,OACrC,GACA,MAFqC,EAErC,EACA,SACA,SACA,CAAa,KAAa,EAAkB,IAAO,EAAY,UAAnB,iBAAmB,OAC/D,SACA,aACA,GACA,CAAa,CACb,UACA,SACA,CAAS,WACT,EACA,qBACA,IAMA,EANA,cAA8B,EAC9B,aAEA,YADA,kDACA,IAEA,CAAS,EAET,KACA,OAAe,EAAkB,IAAO,EAAY,UAAnB,cAAmB,IAA6C,EAAkB,OACnH,SADmH,CAEnH,MACA,gBACA,gBACA,oBACA,GACA,CAAa,CACJ,mCAET,CADA,mEACA,GAQmB,EAAkB,YACd,EAAkB,EADJ,EACW,EAAgB,QAChE,EADyC,kBACzC,EACA,0BACA,GACA,CAAqB,CACJ,SACjB,qBACA,EAAiB,GAfjB,CACA,0CACA,WACA,mCACA,CAAqB,CACrB,EAaA,CACA,gBACA,4BAAqD,GAAe,SAAG,EAAS,CAAZ,CACpE,qCACA,gEACA,kBACA,OAAe,EAAc,IAC7B,OAD4B,EAC5B,QACA,gBAAqB,wBAA+B,IACpD,KACA,SAEA,sCACA,OACyC,GAAe,SAAG,GAAH,OAAG,UAAmC,EAC9F,iEACA,KAEA,wBACA,OAAmB,EAAkB,qBACrC,wBACA,SACA,SACA,CAAiB,qBACjB,GACA,SACA,SACA,CAAiB,OACjB,qCACA,6CAAgF,IAC1D,GAAa,CACnC,CACA,IAH6F,IAG7F,EACA,SACA,uBACA,+CACA,eACA,CAAiB,EAEjB,CAAS,EACT,SAKmB,GAAa,CAChC,SADgC,CAEhC,OALA,CACA,OAF2B,GAAW,oCAGtC,EAIA,uBACA,+CACA,eACA,CAAa,GAEb,CACA,iBEnXA,GAAM,eAAEA,EAAa,CAAE,CAAGC,SFoXnB,GACP,gBACA,O/BzYA,cACA,IAaA,C+B2X8B,C/BzX9B,EAfA,wDACA,GACA,GAAW,EAAe,CAC1B,gBAEA,gCACA,+BACA,uBACA,uBACA,EACA,SACA,KACA,KAEA,UAEA,aAgBA,OAfA,IACA,MAAmC,GACnC,iBADuD,aAEvC,SFuaT,GACP,uBAXA,OAIA,OEjaiE,CFiajE,KADA,MACA,IACA,qCACA,wEACA,CAAS,EAMT,YACA,UACA,aACA,YACA,CAAa,EAEb,CACA,EEjbiE,GAEjE,aACA,YACA,uCACA,SACA,CAAqB,MACrB,SACA,CAAqB,CAErB,CAAa,GAEb,CACA,CACA,cAEY,EAAS,KACrB,IACA,EAFqB,GAErB,IACA,YACA,WACA,CAAa,KACb,iDAAiE,aAAmB,GACpF,WACA,CAAa,EAEb,CACA,oBACA,wBACA,mBACA,KACsB,GAAK,qBAC3B,mBAEA,aACA,oBAEA,cACA,qBAEA,QAAqC,GAAiB,SACtD,GACA,EAFsD,EAEtD,SAEA,QAA0C,GAAiB,iBAE3D,aAEA,aACA,sBAEA,CAEA,6BACA,cACA,IACA,EADA,IAEA,gBACA,WAEA,mBACA,cACA,aAEA,YADA,sCACA,IAEA,CAAiB,EACjB,qBACA,aACA,EAEuB,EAAkB,IAAO,EAAgB,QAChE,EADyC,MACzC,EACA,WACA,gBACA,eACA,GACA,CAAqB,CACrB,UACA,CAAiB,SACjB,CACA,oBACA,EAGA,KAF2B,EAAkB,aAG7C,CACA,EAJ6C,KAI1B,EAAkB,IAAO,EAAgB,UAAvB,CAAuB,CAC5D,UACA,cACA,GACA,CAAiB,CACjB,gBACA,WACA,MACA,iBACA,qBACA,GACA,CAAiB,CACjB,eACA,IACA,GACA,GAEA,CAAiB,CACJ,KACb,EACA,EACA,eACA,QACA,SACmB,GAAe,SAAG,EAAS,CAAZ,CAAY,yBAE9C,CAWA,qBACA,eACA,aAA+C,MAAc,WAE7D,cACA,gBAEA,MAAwB,GAAoB,SAC5C,QAD4C,CAC5C,IACA,CACA,qBACA,OACA,MACA,MACA,WACA,EACA,OAAe,EAAc,IAC7B,OAD4B,EAC5B,eACA,SAA0B,GAA6B,eACvD,QAA8B,CFqBvB,EEtBgD,OFsBhD,SACP,0CACA,OAEA,OACA,iBACA,MACA,MACA,CACA,MAEA,wBAEA,uCAEA,4BAEA,iBAEA,+BACA,kCAEA,2BAEA,CAEA,gBAEA,4BAEA,CACA,SACA,0BACA,qBACA,KACA,OAEA,KACA,iCACA,iBACA,2BAGA,CACA,gBACA,CAAa,CACb,CACA,kCACA,CAEA,yBACA,OAAe,EAEf,gBAFiC,CAEjC,eAGA,MAEA,UACA,KACA,OAAe,EAAkB,uBAGjC,aACA,uBACA,MAGA,GAEA,qCACA,OAAe,EAAkB,uBAGjC,GADA,GA5GA,wBA4GA,GA3GA,yBA2GA,GA1GA,2BA2GA,OACA,oBACA,WACA,CAAS,EACT,UACA,MACA,CAAS,EACT,MACA,CACA,GA5HA,MA4HA,GA5HA,MA4HA,EA5HA,UA6HA,KAMA,EANA,EAMA,EANA,EAMA,EANA,EAOA,2BACA,sBACA,WACA,CAAK,EACL,aACA,SACA,OACA,YAAqB,UAAa,KAClC,MACc,EAAkB,eAChC,CADgC,EAhBhC,CAEA,GAAQ,GAAe,GACvB,CAjHA,SACA,KA+GuB,EA9GvB,IACA,EA8GA,EA7GA,gBA6GA,EA5GA,gBA4GA,EA3GA,mBA2GA,EA1GA,0BA0GA,EAzGA,yBACA,CAAK,EACL,MAuGA,CAvGA,yBACA,sBAA+C,eAAa,IAC5D,UAGA,OAAe,EAAkB,SAkGjC,GAlGiC,SAkGjC,GAlGiC,IACjC,CAAK,EACL,UAgGA,CAEA,GE9G8C,UAC9C,mEAAoF,aAAmB,IACvG,CACA,qBACA,OACA,MACA,MACA,WACA,EAEA,EADA,qBACA,SACc,GAAc,QAC5B,EACA,CAF4B,CAE5B,EACc,KACd,oBACA,QAF+C,IAE/C,IACA,IACA,mBAEA,OADA,KACA,IACA,EACA,oBACA,WACA,SACA,CAAS,EACT,wBACA,qCAA8D,QAAY,CAC1E,EACA,MAAwB,SD7MjB,KAAoC,UC6MK,OD7ML,eAAiC,EAC5E,IACA,EA6BA,EA6CA,EA3EA,gBAEA,KACA,GACA,IACA,SACA,CAAS,CACT,CACA,MACA,eACA,IAEA,EACA,KACA,GACA,KACA,IACA,CAAS,CACT,CACA,OACA,eACA,GAEA,EAQA,GAPA,uBACA,8CACA,GACA,GAEA,CAAK,EAEL,2BAKA,EAJA,SACA,uCACA,GACA,CAAS,EAAI,QAAY,EAEzB,OACA,GACA,yBACA,SACA,eACA,aAEA,iBACA,UAGA,WACA,YACA,CAAyB,EACzB,YACA,+BACA,wBAGA,gBACA,SAEA,CAAyB,CACzB,CAAqB,EACJ,EAEjB,EAEA,CACA,oBACA,kBACA,aACA,CAAK,EACL,yBAAiC,WAAa,EAC9C,eAKA,oBACA,EAGA,EACA,IAEA,IALA,IAMA,CAZA,GACA,QAAmB,EAAM,GAYzB,uBACA,SACA,UACA,WACA,UACA,CAAS,CACT,gBAGA,QACA,CAAK,EACL,aAIA,OAHA,GACA,uCAEA,CACA,CACA,oBACA,EACmB,EAAW,KAE9B,IAF8B,QAE9B,QACA,IACA,YACA,MACA,CAAiB,CACjB,CACA,SACA,IACA,CACA,CAAS,CACT,CAiCA,OAhCA,2BACA,MACA,QACA,IAEA,gBACA,aACA,CAAS,CACT,MACA,UACA,IACA,4BACA,uBAEA,gBACA,aACA,CAAS,CACT,MACA,UACA,gCAEA,gBACA,aACA,CAAS,CACT,aACA,UACA,IAEA,gBACA,aACA,CAAS,CACJ,EACL,CACA,ECsDgD,CAChD,MACA,MACA,WACA,YACA,CAAS,EACT,OAAe,EAAkB,IAAO,EAAkB,UAAzB,CAAyB,QAA2E,GAA6B,mBAClK,OADkK,KAClK,aACA,OAAuB,EAAkB,IAAO,CD/CzC,WC+CkC,CD/ClC,MACP,EC8CqE,CD9CrE,IACA,+BACA,QACA,MACA,CACA,gBACA,uBAGA,YAEA,eADA,iBAAmC,UAAsB,EAAE,aAAyB,GACpF,WAEA,yBACA,qBACA,iCACA,MACA,eACA,mBAEA,QACA,CACA,CACA,kBACA,CAEA,EACA,SAEA,QACA,OAEA,CAAK,EACL,YAQA,OALA,uCACA,gBACA,+BAEA,CAAK,EAAI,QAAY,EACrB,OACA,OAxDA,IAwDA,EAxDA,gBACA,SACA,YAsDA,EArDA,QACA,CAAa,CACb,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AFA,aACA,IAGA,qBACA,SAA2C,EAAS,GAAG,GAAW,yCAClE,eACA,eAGA,gBAEA,MAEA,CAEA,WACA,4CACA,wBAAwD,EAAS,GAAG,GAAW,4BAE/E,CAEA,CAEA,CAOA,OANA,IACA,SAOA,OACA,qBACA,gBACA,mBACA,OACA,GAAY,kBAAY,IACxB,eACA,mBACA,uBAEA,+BACA,WACA,aACA,qCACA,sBACA,wEACA,EAEA,mDACA,yEAEA,kBACA,oBACA,mBACA,0EAGA,eAIA,GAAiB,gBAAU,KAC3B,mBACA,WACA,eACA,mBACA,uBAEA,+BACA,WACA,aACA,qCACA,sBACA,wEACA,EAEA,mDACA,yEAEA,kBACA,oBACA,mBACA,0EAEA,MACA,iBAGA,UAAoC,iBAAe,GACnD,MACA,GAAiB,iBAAW,IAC5B,eACA,oBACA,8BAIA,GAAiB,kBAAY,KAAU,qBAAe,IACtD,gBACA,uBAEA,uBACA,QACA,CAEA,MADA,aACA,IACA,YACA,UACA,sBAEA,oBAGA,OAEA,CACA,CAEA,CAcA,OAZI,GAAmB,EAAS,ITrKhC,SAGO,KACP,CSiKmD,GTjKnD,sBAIA,gBACA,WACA,+BACA,SAEA,aACA,wBAGA,eACA,2CAAuD,GAAY,OAAO,+CAC1E,QACA,CACA,OAIA,CAEA,gBACA,WACA,MACA,CAEA,eACA,yBACA,iBACA,gBAGA,gBACA,YAEA,4BACA,SACA,SASA,GACA,GAAY,kBAAY,KACxB,KACA,KACA,MACA,CACA,GAAiB,qBAAe,KAChC,KACA,qBACA,KAEA,MACA,CACA,GAAiB,iBAAW,IAC5B,KA6CA,EA7CA,EA8CA,mBACA,YACA,UACA,aACA,uBAlDA,CAGA,GAAiB,uBAAiB,IAClC,KAgCA,EAhCA,EAiCA,oBACA,iCACA,iBACA,eACA,kBArCA,CAGA,IAAiB,gBAAU,IAG3B,uCAAmD,EAAK,EACxD,EAlCA,EAGA,CACA,eACA,4BACA,YA6BA,cACA,oBACA,iCACA,OACA,QACA,iBACA,uBAEA,gBACA,iBACA,eACA,YAIA,cACA,wBACA,wBACA,YACA,UACA,aACA,gBACA,CACA,CAiB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2BACA,8BAKA,GACA,MACA,KACA,oBAGA,CAUA,qBACA,OACA,SAEA,iCACA,CAEA,GAhBA,8BACA,WACA,MACA,WACA,OACA,EACA,0BACA,GASA,GACA,MAGA,KACA,qBAFA,EAEA,QAGA,CACA,OACA,SACA,mBAEA,SACA,QACA,oBACA,GAAgC,qBAA8B,EAC9D,oBACA,CAAS,CACT,SACA,2BACA,qBAEA,EACA,KAEA,KAEA,yBACA,YAEA,CACA,EA5NA,oBAA0B,GAC1B,eAAqB,GACrB,6DACA,cACA,oBACA,CACA,cAEA,OADA,KACA,MADA,EACA,OADA,EACA,QAEA,oBACA,4BAIA,OAHA,GACA,iBAEA,IACA,CACA,qBACA,QACA,EAEA,KACA,CACA,2BACA,2BACA,yBACA,8BACA,EAIA,CACA,QACA,KACA,IACA,cACA,CACA,SACA,WACA,CAEA,YACS,CACT,QACA,YACS,CACT,WACA,KACA,IACA,+BACA,CACA,SACA,WACA,CAEA,YACS,CACT,+BACA,qBACA,cACA,CACA,CAqBA,kBACA,iBACA,OAEA,2BACA,IAsBA,OArBA,aACA,IAAgB,gBAA6B,SAC7C,KACA,OAEA,SACA,aACA,IACA,CACA,oBACA,iBACA,CAAS,aAIT,GAHA,GACA,YAEA,EAGA,UACA,CAAS,CACT,GAEA,CACA,cACA,OACA,UACA,KACA,IACA,cACA,CACA,SACA,WACA,CAEA,WACA,CAAS,CACT,SACA,KACA,IACA,cACA,CACA,SACA,WACA,CAEA,YACS,CACT,WACA,KACA,IACA,GACA,CACA,SACA,WACA,CAEA,YACS,CACT,oBACA,+BACA,cACA,CACA,CAuEA,cACA,aAAa,UACb,CAOA,sBACA,cACA,aAEA,WACA,UACA,2BACA,CAAK,KACL,UACA,QACA,mBACA,OACA,CAAa,CAGb,QAEA,CAAK,CACL,CACA,cACA,GAzBA,oBA0BA,4BAEA,MAzBA,iBA0BA,0BAEA,QACA,yBC7QA,yDCCA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,mBAA2B,CAAG,qBAA2B,QACzD,cAAoB,CA2CpB,YACA,mDACA,E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B,qDAA4D,SA8U5E,SA6JA,EAGA,EANA,EASA,EAlKA,WACA,OACA,qBACA,iBACA,kBACA,EAEA,uBACA,6BACA,OACA,kBACA,wBAAqC,eACrC,gBACA,cACA,gDACA,sCACA,CAAa,CAEb,CACA,wBAEA,OACA,kBACA,iBACA,uBACA,SACA,cACA,sBAPA,GASA,OADA,+BAEA,CAAa,EAGb,+BACA,wDACA,OACA,kBACA,2BACA,iBACA,SACA,cACA,yBAEA,OADA,+BAEA,CAAa,CAEb,CACA,2DAEA,OACA,0BACA,gBAHA,EAIA,iBACA,kBACA,EAEA,GAoGA,EApGA,EAqGA,6CAnGA,OACA,gBACA,mBACA,qBACA,gBALA,EAMA,QAEA,EAEA,6BACA,mBACA,uCACA,OACA,kBACA,iBACA,gBACA,SACA,cACA,yBAEA,OADA,+BAEA,CACA,CACA,CACA,mCACA,gDACA,kBACA,QACA,CAAS,EACT,OACA,oBACA,iBACA,mBACA,gBACA,+BAEA,CACA,CACA,2BACA,OACA,oBACA,iBACA,mBACA,gBACA,+BAGA,EAEA,GAoDA,EApDA,EAqDA,cAnDA,OACA,kBACA,YAHA,mCAA+D,eAI/D,mBACA,gBACA,2DAGA,EAEA,GAkCA,EAlCA,EAmCA,iBAnCA,CACA,2CACA,wBAAkD,WAAW,EAAS,EACtE,OACA,oBACA,cACA,mBACA,gBACA,gCAEA,CACA,CACA,GA+BA,EA/BA,EAgCA,mBA/BA,OACA,iBACA,mBACA,gBACA,+BAEA,EAEA,+CACA,OACA,iBACA,mBACA,yBACA,cACA,yBACA,sCACA,CAAa,CAGb,iCACA,EAve4E,YAC5E,qBACA,mBACA,qBACA,gBACA,cACA,CACA,SACA,sBACA,oBACA,QACA,eAIA,GAHA,wDACA,6DAEA,oBACA,2BAEA,0BAEA,OADA,sBACA,CACA,CACA,gCACA,uCACA,EAMA,mBALA,kBACA,kDAMA,yCACA,6BACA,qBACA,wCAEA,EAMA,kCALA,oBACA,gEAMA,CACA,WACA,0BACA,YAEA,iBACA,6BACA,SACA,QAJA,EAIA,CACA,iBACA,qBACA,OAPA,GASA,CACA,CACA,WACA,iBACA,qBACA,UAEA,CACA,CACA,CAAiB,CACJ,CACb,CACA,WACA,CACA,aACA,kCACA,oCACA,mBACA,sEACA,eACA,eAGA,4CACA,KACA,oDAA2G,SAAa,GAIxH,CAHA,GACA,UAEA,IAGA,eACA,cAHA,KAKA,UACA,CACA,iCACA,EAIA,8BACA,eACA,gBALA,gBACA,gCAMA,CACA,oCACA,aACA,iCAEA,sDACA,aACA,CACA,WACA,cACA,WACA,+BAEA,2BACA,yBACA,4CACA,mCAAsD,eACtD,wBACa,GAEb,yBACA,yBACA,+BAEA,cACA,8CACA,0BACA,wBACa,EACb,+BAEA,qFACA,iCACA,0BACA,wBACa,EACb,aAEA,CACA,eACA,YACA,kBACA,wCAEA,8BAEA,OADA,6BACA,kCAIA,GAFA,sCAEA,MADA,oBAEA,wCAEA,OACA,+BACA,sBAEA,2BACA,0BACA,MACA,uCAIA,WACA,gBACA,SACA,qDACA,8BACA,uBACA,mCACA,CAAiB,CACjB,SACA,kBACA,CAAa,CACb,eACA,qCAEA,SACA,MACA,IAEA,KACA,YACA,YACA,IACA,YACA,QAEA,EACA,KAIA,kBAEA,EAIA,gBACA,wBACA,EACA,qCAA2E,kBAA+B,SAE1G,EACA,sCAA4E,cAA2B,cAEvG,yBAEA,0BACA,IACA,SACA,gBACA,SACA,CAAiB,EACjB,gBACA,kBACA,qCAAoE,aAA0B,QAC9F,CAAiB,EACjB,kBACA,aACA,qCAAwE,aAA0B,SAElG,OACA,8BAAgF,OAAgB,EAChG,uBACA,CAAiB,CACjB,CAAa,EACb,wBACA,kCAA6D,UAAuB,GACpF,CAAa,EACb,uBACA,iCAA4D,SAAsB,GAClF,CAAa,EACb,uBACA,iCAA4D,SAAsB,GAClF,CAAa,EACb,cACA,iBACA,gBACA,gBACA,SACA,CAAS,CACT,CACA,SACA,gBACA,sCAEA,cAEA,OADA,+CACA,gCAEA,4BACA,4BACA,aACA,sCACA,eAGA,2BACA,wCACA,uCACA,eACA,eAGA,uCACA,sCACA,8BACA,eAGA,6CACA,4CACA,kDACA,cAGA,CACA,2FACA,aACA,kBAGA,gCACA,eAEA,CACA,QACA,oBACA,CACA,cAEA,oBACA,CACA,WACA,cACA,WACA,8BAEA,qBACA,IACA,wBACA,CACA,SAIA,MAHA,0BACA,kBAAuC,EAAK,sBAE5C,CACA,CACA,kBACS,CACT,CACA,WACA,cACA,WACA,8BAEA,0BACA,yBACA,+BAEA,uBACA,+BACA,YAEA,CACA,CACA,cAAoB,2BChXpB,kECCA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,gBAAwB,CAGxB,YACA,6CACA,EAJA,mBAAyB,CAKzB,YACA,kDACA,EANA,MAAqB,EAAQ,KAAc,YAAf,CCJ5B,cACA,yCAEA,OADA,0BACA,CACA,CACA,cACA,YACA,WACA,0CCNA,MAAiB,kBAA6B,EACvB,kBAA+B,SAEtD,KACA,cACA,CACA,OAEA,gCAEA,0CCTA,MAAmB,EAAQ,KAAc,EAEzC,UAF0B,mBAI1B,GACA,+DACA,4DACA,uDACA,2DACA,iEACA,iEACA,iEACA,iEACA,8DACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,mDACA,mDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,kDACA,8DACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,iEACA,mDACA,EAEA,cACA,YAuFA,UA/EA,YACA,SACA,EAPA,EAQA,KACA,KACA,KACA,IACA,KACA,WAEA,YAAkB,IAAS,KAC3B,CADkC,GAClC,OACA,eACA,KAAsB,SAAmB,CACzC,CADyC,CACzC,GACA,QACA,MACM,WACN,KAMe,SANf,CACA,GACA,KACA,EA1BA,GA2BiB,KACjB,QACA,EAAQ,GACF,CAGN,GAFA,MAAiC,UACjC,KACA,yBACA,OACA,EAhCA,EAiCA,kBACiB,EApCjB,EAqCA,KACA,QACA,CAAQ,GAxCR,IAwCQ,GACR,oBACA,UACA,UAzCA,EADA,EA6CA,gBACA,KACA,QACA,CAAQ,QAAgC,IAAhC,EAgBA,2BAAwD,aAhBxB,CACxC,EAlDA,EAmDA,GACA,UACA,oBACA,SACA,IAEA,MACU,UACV,yBAEA,cAAoC,OAAsB,IAAP,CAAO,KAC1D,KACA,IACA,QACA,CACA,CACA,IACA,CAaA,OAZA,YACA,mBACA,SACA,GACI,GACJ,yBAGA,cACA,IAAe,QACJ,UAEX,CACA,0BCjMA,uDCkBY,kBAAoF,+BCjBhG,qCAA6C,CAAE,SAAa,EAAC,EAC7D,sBAA8B,QAC9B,MAAoB,EAAQ,KAAW,EACvC,EAA0B,EAAQ,KAA8B,CADrC,CAE3B,EAAmB,EAAQ,KAAY,CACvC,SACA,EAF0B,cAE1B,EACA,iDACA,KACA,wBACA,0BACA,CACA,QACA,QACA,mCACA,cAGA,CACA,WACA,QACA,mCACA,UACA,SAIA,CACA,YACA,QACA,IACA,mCACA,aAEA,QACA,CACA,WACA,QACA,mCACA,QAEA,CACA,SACA,QACA,oCACA,QACA,KAEA,SACA,GACA,CAEA,CACA,SACA,QACA,mCACA,MACA,UAEA,GAGA,CACA,YACA,QACA,oCACA,eACA,uBACA,eACA,aAIA,aACA,uBACA,CAAiB,CACjB,OAGA,CAEA,CACA,QACA,QACA,mCACA,YACA,SAGA,QACA,CACA,SACA,QACA,mCACA,aACA,SAGA,QACA,CACA,QACA,QACA,mCACA,YACA,QAIA,CACA,UACA,wCACA,CACA,gCACA,gCACA,CACA,aACA,oCACA,CACA,oBACA,YAEA,6CACA,SAOA,OANA,qBACA,sBACA,sBACA,8BACA,CACA,CAAS,EACT,GAAkB,0BAA0B,EAAE,iBAAiC,EAE/E,CACA,wBAA8B,2BCrI9B,0DCCA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,WAAmB,QAEnB,MADgB,EAAQ,KAAO,EAC/B,UADuB,KACvB,CAA8C,EAAQ,IAAa,GACnE,EAAsB,EAAQ,KAAa,CADU,CAErD,UAD6B,GAC7B,GACA,mBAEA,mCACA,mBACA,yBAA2C,mBAAgC,EAE3E,OADA,2BACA,CACA,CACA,0BACA,yBAIA,4BAHA,oBAKA,CACA,yBACA,iEACA,CACA,CACA,aAAmB,2BCzBnB,sBACA,sBAAkC,SAClC,qBAAgC,KAAQ,IACxC,GAD+C,IAC/C,iBACA,QACA,QAEA,aADA,kBACA,YACA,CAEA,4BACA,aCbA,cACA,yCAEA,OADA,0BACA,CACA,CACA,cACA,YACA,WACA,uBCRA,cACA,yCAEA,OADA,0BACA,CACA,CACA,cACA,YACA,WACA,0CCPA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,gBAAwB,QACxB,MAAoB,EAAQ,KAAW,EACvC,EAAkB,EAAQ,KAAW,CADV,CAE3B,EAAqB,EAAQ,IAAc,EADlB,EAEzB,SAD4B,UACiB,cAC7C,gCACA,oBACA,KACA,iBACA,aACA,2CACA,UACA,kCACA,2BACA,iEACA,oBACA,kCACA,6BACA,gCACA,CACA,SACA,wCACA,CACA,OACA,WACA,IACA,WACA,KACA,QACA,YAEA,eACA,mBACA,WACA,kCACA,CAAS,CACT,CACA,yBACA,gBACA,wCAEA,mBACA,SACA,UACA,CAAa,CACb,QACA,CAAS,CACT,CACA,iBACA,wBACA,KAQA,aAMA,kCACA,+BACA,gCAEA,iCACA,qEAGA,6BACA,SACA,KACA,wBACA,QACA,KAEA,qCAGA,uCACA,OAHA,IAKA,CACA,GACA,mCAEA,GACA,kEAEA,KACA,6BACA,mCACA,8BAEA,qCACA,oEAvCA,WACA,iBACA,gDACA,OAXA,GACA,SACA,iBACA,gDACA,CAAiB,EA8CjB,iBACA,CACA,gCAEA,kBAAwB","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+fetch@0.10.8/node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js","webpack://@hijraah/web/external node-commonjs \"node:buffer\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/cjs/DisposableStack.js","webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/Headers.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+instrumentat_04f370d515cee0be955272f826166073/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoderStream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/cjs/AsyncDisposableStack.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/cjs/index.js","webpack://@hijraah/web/external commonjs2 \"punycode\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/FormData.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/cjs/SupressedError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/File.js","webpack://@hijraah/web/external commonjs2 \"stream\"","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/Request.js","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/main.js","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/CompressionStream.js","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"tls\"","webpack://@hijraah/web/../../node_modules/.pnpm/urlpattern-polyfill@10.1.0/node_modules/urlpattern-polyfill/index.cjs","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/types/multipart.js","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/cjs/symbols.js","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+fetch@0.10.8/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://@hijraah/web/external node-commonjs \"node:stream/promises\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/Blob.js","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external commonjs2 \"https\"","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/ignored|E:\\downloads\\Hijraah\\node_modules\\.pnpm\\ws@8.18.2_bufferutil@4.0.9\\node_modules\\ws\\lib|utf-8-validate","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+fetch@0.10.8/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/DecompressionStream.js","webpack://@hijraah/web/external commonjs \"graphql\"","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/comments.js","webpack://@hijraah/web/../../node_modules/.pnpm/cross-inspect@1.0.1/node_modules/cross-inspect/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/astFromType.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+promise-helpers@1.3.2/node_modules/@whatwg-node/promise-helpers/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/jsutils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/astFromValue.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/descriptionFromObject.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/errors.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/getArgumentValues.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/memoize.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/getDirectiveExtensions.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/get-directives.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/helpers.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/rootTypes.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/isDocumentNode.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/mergeDeep.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/merge-resolvers.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+merge@9.0.24_graphql@16.11.0/node_modules/@graphql-tools/merge/esm/extensions.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/transformInputValue.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/heal.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/forEachField.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/Interfaces.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/stub.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/rewire.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/mapSchema.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+schema@10.0.23_graphql@16.11.0/node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+schema@10.0.23_graphql@16.11.0/node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+schema@10.0.23_graphql@16.11.0/node_modules/@graphql-tools/schema/esm/addResolversToSchema.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+schema@10.0.23_graphql@16.11.0/node_modules/@graphql-tools/schema/esm/assertResolversPresent.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+schema@10.0.23_graphql@16.11.0/node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/schema.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+core@5.3.0/node_modules/@envelop/core/esm/plugins/use-engine.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+core@5.3.0/node_modules/@envelop/core/esm/plugins/use-extend-context.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+core@5.3.0/node_modules/@envelop/core/esm/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+core@5.3.0/node_modules/@envelop/core/esm/plugins/use-masked-errors.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+instrumentation@1.0.0/node_modules/@envelop/instrumentation/esm/instrumentation.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+core@5.3.0/node_modules/@envelop/core/esm/document-string-map.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+core@5.3.0/node_modules/@envelop/core/esm/orchestrator.js","webpack://@hijraah/web/../../node_modules/.pnpm/@envelop+core@5.3.0/node_modules/@envelop/core/esm/create.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/AccumulatorMap.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/directives.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/collectFields.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/Path.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+utils@10.8.6_graphql@16.11.0/node_modules/@graphql-tools/utils/esm/isAsyncIterable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/symbols.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+executor@1.4.7_graphql@16.11.0/node_modules/@graphql-tools/executor/esm/execution/coerceError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+executor@1.4.7_graphql@16.11.0/node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+executor@1.4.7_graphql@16.11.0/node_modules/@graphql-tools/executor/esm/execution/invariant.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+executor@1.4.7_graphql@16.11.0/node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+executor@1.4.7_graphql@16.11.0/node_modules/@graphql-tools/executor/esm/execution/values.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+executor@1.4.7_graphql@16.11.0/node_modules/@graphql-tools/executor/esm/execution/execute.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-tools+executor@1.4.7_graphql@16.11.0/node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js","webpack://@hijraah/web/../../node_modules/.pnpm/@graphql-yoga+logger@2.0.1/node_modules/@graphql-yoga/logger/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+server@0.10.10/node_modules/@whatwg-node/server/esm/plugins/useCors.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/SupressedError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/AsyncDisposableStack.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/DisposableStack.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+server@0.10.10/node_modules/@whatwg-node/server/esm/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+server@0.10.10/node_modules/@whatwg-node/server/esm/uwebsockets.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+server@0.10.10/node_modules/@whatwg-node/server/esm/createServerAdapter.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/error.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-parser/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-parser/get.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js","webpack://@hijraah/web/../../node_modules/.pnpm/dset@3.1.4/node_modules/dset/dist/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/graphiql-html.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/use-graphiql.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/use-health-check.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/utils/create-lru-cache.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/use-request-parser.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/result-processor/accept.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/result-processor/regular.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/result-processor/sse.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/use-result-processor.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/use-schema.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/landing-page-html.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/process-request.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/utils/mask-error.js","webpack://@hijraah/web/../../node_modules/.pnpm/graphql-yoga@5.13.5_graphql@16.11.0/node_modules/graphql-yoga/esm/server.js","webpack://@hijraah/web/./src/graphql/resolvers.ts","webpack://@hijraah/web/src/app/api/graphql/route.ts","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/?fbdf","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external node-commonjs \"node:url\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/fetch.js","webpack://@hijraah/web/external commonjs2 \"zlib\"","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/../../node_modules/.pnpm/urlpattern-polyfill@10.1.0/node_modules/urlpattern-polyfill/dist/urlpattern.cjs","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external node-commonjs \"node:crypto\"","webpack://@hijraah/web/external node-commonjs \"node:events\"","webpack://@hijraah/web/external commonjs2 \"buffer\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+promise-helpers@1.3.2/node_modules/@whatwg-node/promise-helpers/cjs/index.js","webpack://@hijraah/web/external commonjs2 \"http\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/Body.js","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/cjs/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+fetch@0.10.8/node_modules/@whatwg-node/fetch/dist/ sync","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js","webpack://@hijraah/web/external commonjs2 \"net\"","webpack://@hijraah/web/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/server/route-modules/app-route/module.compiled.js","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/IteratorObject.js","webpack://@hijraah/web/external commonjs2 \"events\"","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/URL.js","webpack://@hijraah/web/../../node_modules/.pnpm/@fastify+busboy@3.1.1/node_modules/@fastify/busboy/lib/utils/basename.js","webpack://@hijraah/web/../../node_modules/.pnpm/require-in-the-middle@7.5.2/node_modules/require-in-the-middle/ sync","webpack://@hijraah/web/../../node_modules/.pnpm/@supabase+realtime-js@2.11.10_bufferutil@4.0.9/node_modules/@supabase/realtime-js/dist/main/ sync","webpack://@hijraah/web/../../node_modules/.pnpm/@whatwg-node+node-fetch@0.7.21/node_modules/@whatwg-node/node-fetch/cjs/Response.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchNodeHttp = fetchNodeHttp;\nconst node_http_1 = require(\"node:http\");\nconst node_https_1 = require(\"node:https\");\nconst node_stream_1 = require(\"node:stream\");\nconst node_zlib_1 = require(\"node:zlib\");\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst Request_js_1 = require(\"./Request.js\");\nconst Response_js_1 = require(\"./Response.js\");\nconst URL_js_1 = require(\"./URL.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction getRequestFnForProtocol(url) {\n    if (url.startsWith('http:')) {\n        return node_http_1.request;\n    }\n    else if (url.startsWith('https:')) {\n        return node_https_1.request;\n    }\n    throw new Error(`Unsupported protocol: ${url.split(':')[0] || url}`);\n}\nfunction fetchNodeHttp(fetchRequest) {\n    return new Promise((resolve, reject) => {\n        try {\n            const requestFn = getRequestFnForProtocol(fetchRequest.parsedUrl?.protocol || fetchRequest.url);\n            const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;\n            const nodeHeaders = headersSerializer(fetchRequest.headers);\n            if (nodeHeaders['accept-encoding'] == null) {\n                nodeHeaders['accept-encoding'] = 'gzip, deflate, br';\n            }\n            let signal;\n            if (fetchRequest._signal === null) {\n                signal = undefined;\n            }\n            else if (fetchRequest._signal) {\n                signal = fetchRequest._signal;\n            }\n            else {\n                signal = fetchRequest.signal;\n            }\n            let nodeRequest;\n            // If it is our ponyfilled Request, it should have `parsedUrl` which is a `URL` object\n            if (fetchRequest.parsedUrl) {\n                nodeRequest = requestFn(fetchRequest.parsedUrl, {\n                    method: fetchRequest.method,\n                    headers: nodeHeaders,\n                    signal,\n                    agent: fetchRequest.agent,\n                });\n            }\n            else {\n                nodeRequest = requestFn(fetchRequest.url, {\n                    method: fetchRequest.method,\n                    headers: nodeHeaders,\n                    signal,\n                    agent: fetchRequest.agent,\n                });\n            }\n            nodeRequest.once('error', reject);\n            nodeRequest.once('response', nodeResponse => {\n                let outputStream;\n                const contentEncoding = nodeResponse.headers['content-encoding'];\n                switch (contentEncoding) {\n                    case 'x-gzip':\n                    case 'gzip':\n                        outputStream = (0, node_zlib_1.createGunzip)();\n                        break;\n                    case 'x-deflate':\n                    case 'deflate':\n                        outputStream = (0, node_zlib_1.createInflate)();\n                        break;\n                    case 'x-deflate-raw':\n                    case 'deflate-raw':\n                        outputStream = (0, node_zlib_1.createInflateRaw)();\n                        break;\n                    case 'br':\n                        outputStream = (0, node_zlib_1.createBrotliDecompress)();\n                        break;\n                }\n                if (nodeResponse.headers.location && (0, utils_js_1.shouldRedirect)(nodeResponse.statusCode)) {\n                    if (fetchRequest.redirect === 'error') {\n                        const redirectError = new Error('Redirects are not allowed');\n                        reject(redirectError);\n                        nodeResponse.resume();\n                        return;\n                    }\n                    if (fetchRequest.redirect === 'follow') {\n                        const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.parsedUrl || fetchRequest.url);\n                        const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));\n                        resolve(redirectResponse$.then(redirectResponse => {\n                            redirectResponse.redirected = true;\n                            return redirectResponse;\n                        }));\n                        nodeResponse.resume();\n                        return;\n                    }\n                }\n                if (outputStream != null) {\n                    outputStream = (0, utils_js_1.wrapIncomingMessageWithPassthrough)({\n                        incomingMessage: nodeResponse,\n                        passThrough: outputStream,\n                        signal,\n                        onError: reject,\n                    });\n                }\n                const statusCode = nodeResponse.statusCode || 200;\n                let statusText = nodeResponse.statusMessage || node_http_1.STATUS_CODES[statusCode];\n                if (statusText == null) {\n                    statusText = '';\n                }\n                const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream || nodeResponse, {\n                    status: statusCode,\n                    statusText,\n                    headers: nodeResponse.headers,\n                    url: fetchRequest.url,\n                    signal,\n                });\n                resolve(ponyfillResponse);\n            });\n            if (fetchRequest['_buffer'] != null) {\n                (0, promise_helpers_1.handleMaybePromise)(() => (0, utils_js_1.safeWrite)(fetchRequest['_buffer'], nodeRequest, signal), () => (0, utils_js_1.endStream)(nodeRequest), reject);\n            }\n            else {\n                const nodeReadable = (fetchRequest.body != null\n                    ? (0, utils_js_1.isNodeReadable)(fetchRequest.body)\n                        ? fetchRequest.body\n                        : node_stream_1.Readable.from(fetchRequest.body)\n                    : null);\n                if (nodeReadable) {\n                    nodeReadable.pipe(nodeRequest);\n                }\n                else {\n                    (0, utils_js_1.endStream)(nodeRequest);\n                }\n            }\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n}\n","\nfunction isNextJs() {\n  return Object.keys(globalThis).some(key => key.startsWith('__NEXT'))\n}\n\nmodule.exports = function shouldSkipPonyfill() {\n  if (globalThis.Deno) {\n    return true\n  }\n  if (globalThis.Bun) {\n    return true\n  }\n  if (isNextJs()) {\n    return true\n  }\n  return false\n}","module.exports = require(\"node:buffer\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillDisposableStack = void 0;\nconst SupressedError_js_1 = require(\"./SupressedError.js\");\nconst symbols_js_1 = require(\"./symbols.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\nclass PonyfillDisposableStack {\n    callbacks = [];\n    get disposed() {\n        return this.callbacks.length === 0;\n    }\n    use(value) {\n        if ((0, utils_js_1.isSyncDisposable)(value)) {\n            this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.dispose]());\n        }\n        return value;\n    }\n    adopt(value, onDispose) {\n        if (onDispose) {\n            this.callbacks.push(() => onDispose(value));\n        }\n        return value;\n    }\n    defer(onDispose) {\n        if (onDispose) {\n            this.callbacks.push(onDispose);\n        }\n    }\n    move() {\n        const stack = new PonyfillDisposableStack();\n        stack.callbacks = this.callbacks;\n        this.callbacks = [];\n        return stack;\n    }\n    dispose() {\n        return this[symbols_js_1.DisposableSymbols.dispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n        const cb = this.callbacks.pop();\n        if (cb) {\n            try {\n                cb();\n            }\n            catch (error) {\n                this._error = this._error ? new SuppressedError(error, this._error) : error;\n            }\n            return this._iterateCallbacks();\n        }\n    }\n    [symbols_js_1.DisposableSymbols.dispose]() {\n        this._iterateCallbacks();\n        if (this._error) {\n            const error = this._error;\n            this._error = undefined;\n            throw error;\n        }\n    }\n    [Symbol.toStringTag] = 'DisposableStack';\n}\nexports.PonyfillDisposableStack = PonyfillDisposableStack;\n","module.exports = require(\"module\");","'use strict'\n\nmodule.exports = function getLimit (limits, name, defaultLimit) {\n  if (\n    !limits ||\n    limits[name] === undefined ||\n    limits[name] === null\n  ) { return defaultLimit }\n\n  if (\n    typeof limits[name] !== 'number' ||\n    isNaN(limits[name])\n  ) { throw new TypeError('Limit ' + name + ' is not a valid number') }\n\n  return limits[name]\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillHeaders = void 0;\nexports.isHeadersLike = isHeadersLike;\nconst node_util_1 = require(\"node:util\");\nconst IteratorObject_js_1 = require(\"./IteratorObject.js\");\nfunction isHeadersLike(headers) {\n    return headers?.get && headers?.forEach;\n}\nclass PonyfillHeaders {\n    headersInit;\n    _map;\n    objectNormalizedKeysOfHeadersInit = [];\n    objectOriginalKeysOfHeadersInit = [];\n    _setCookies;\n    constructor(headersInit) {\n        this.headersInit = headersInit;\n    }\n    // perf: we don't need to build `this.map` for Requests, as we can access the headers directly\n    _get(key) {\n        const normalized = key.toLowerCase();\n        if (normalized === 'set-cookie' && this._setCookies?.length) {\n            return this._setCookies.join(', ');\n        }\n        // If the map is built, reuse it\n        if (this._map) {\n            return this._map.get(normalized) || null;\n        }\n        // If the map is not built, try to get the value from the this.headersInit\n        if (this.headersInit == null) {\n            return null;\n        }\n        if (Array.isArray(this.headersInit)) {\n            const found = this.headersInit.filter(([headerKey]) => headerKey.toLowerCase() === normalized);\n            if (found.length === 0) {\n                return null;\n            }\n            if (found.length === 1) {\n                return found[0][1];\n            }\n            return found.map(([, value]) => value).join(', ');\n        }\n        else if (isHeadersLike(this.headersInit)) {\n            return this.headersInit.get(normalized);\n        }\n        else {\n            const initValue = this.headersInit[key] || this.headersInit[normalized];\n            if (initValue != null) {\n                return initValue;\n            }\n            if (!this.objectNormalizedKeysOfHeadersInit.length) {\n                Object.keys(this.headersInit).forEach(k => {\n                    this.objectOriginalKeysOfHeadersInit.push(k);\n                    this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());\n                });\n            }\n            const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);\n            if (index === -1) {\n                return null;\n            }\n            const originalKey = this.objectOriginalKeysOfHeadersInit[index];\n            return this.headersInit[originalKey];\n        }\n    }\n    // perf: Build the map of headers lazily, only when we need to access all headers or write to it.\n    // I could do a getter here, but I'm too lazy to type `getter`.\n    getMap() {\n        if (!this._map) {\n            this._setCookies ||= [];\n            if (this.headersInit != null) {\n                if (Array.isArray(this.headersInit)) {\n                    this._map = new Map();\n                    for (const [key, value] of this.headersInit) {\n                        const normalizedKey = key.toLowerCase();\n                        if (normalizedKey === 'set-cookie') {\n                            this._setCookies.push(value);\n                            continue;\n                        }\n                        this._map.set(normalizedKey, value);\n                    }\n                }\n                else if (isHeadersLike(this.headersInit)) {\n                    this._map = new Map();\n                    this.headersInit.forEach((value, key) => {\n                        if (key === 'set-cookie') {\n                            this._setCookies ||= [];\n                            this._setCookies.push(value);\n                            return;\n                        }\n                        this._map.set(key, value);\n                    });\n                }\n                else {\n                    this._map = new Map();\n                    for (const initKey in this.headersInit) {\n                        const initValue = this.headersInit[initKey];\n                        if (initValue != null) {\n                            const normalizedKey = initKey.toLowerCase();\n                            if (normalizedKey === 'set-cookie') {\n                                this._setCookies ||= [];\n                                this._setCookies.push(initValue);\n                                continue;\n                            }\n                            this._map.set(normalizedKey, initValue);\n                        }\n                    }\n                }\n            }\n            else {\n                this._map = new Map();\n            }\n        }\n        return this._map;\n    }\n    append(name, value) {\n        const key = name.toLowerCase();\n        if (key === 'set-cookie') {\n            this._setCookies ||= [];\n            this._setCookies.push(value);\n            return;\n        }\n        const existingValue = this.getMap().get(key);\n        const finalValue = existingValue ? `${existingValue}, ${value}` : value;\n        this.getMap().set(key, finalValue);\n    }\n    get(name) {\n        const value = this._get(name);\n        if (value == null) {\n            return null;\n        }\n        return value.toString();\n    }\n    has(name) {\n        const key = name.toLowerCase();\n        if (key === 'set-cookie') {\n            return !!this._setCookies?.length;\n        }\n        return !!this._get(name); // we might need to check if header exists and not just check if it's not nullable\n    }\n    set(name, value) {\n        const key = name.toLowerCase();\n        if (key === 'set-cookie') {\n            this._setCookies = [value];\n            return;\n        }\n        if (!this._map && this.headersInit != null) {\n            if (Array.isArray(this.headersInit)) {\n                const found = this.headersInit.find(([headerKey]) => headerKey.toLowerCase() === key);\n                if (found) {\n                    found[1] = value;\n                }\n                else {\n                    this.headersInit.push([key, value]);\n                }\n                return;\n            }\n            else if (isHeadersLike(this.headersInit)) {\n                this.headersInit.set(key, value);\n                return;\n            }\n            else {\n                this.headersInit[key] = value;\n                return;\n            }\n        }\n        this.getMap().set(key, value);\n    }\n    delete(name) {\n        const key = name.toLowerCase();\n        if (key === 'set-cookie') {\n            this._setCookies = [];\n            return;\n        }\n        this.getMap().delete(key);\n    }\n    forEach(callback) {\n        this._setCookies?.forEach(setCookie => {\n            callback(setCookie, 'set-cookie', this);\n        });\n        if (!this._map) {\n            if (this.headersInit) {\n                if (Array.isArray(this.headersInit)) {\n                    this.headersInit.forEach(([key, value]) => {\n                        callback(value, key, this);\n                    });\n                    return;\n                }\n                if (isHeadersLike(this.headersInit)) {\n                    this.headersInit.forEach(callback);\n                    return;\n                }\n                Object.entries(this.headersInit).forEach(([key, value]) => {\n                    if (value != null) {\n                        callback(value, key, this);\n                    }\n                });\n            }\n            return;\n        }\n        this.getMap().forEach((value, key) => {\n            callback(value, key, this);\n        });\n    }\n    *_keys() {\n        if (this._setCookies?.length) {\n            yield 'set-cookie';\n        }\n        if (!this._map) {\n            if (this.headersInit) {\n                if (Array.isArray(this.headersInit)) {\n                    yield* this.headersInit.map(([key]) => key)[Symbol.iterator]();\n                    return;\n                }\n                if (isHeadersLike(this.headersInit)) {\n                    yield* this.headersInit.keys();\n                    return;\n                }\n                yield* Object.keys(this.headersInit)[Symbol.iterator]();\n                return;\n            }\n        }\n        yield* this.getMap().keys();\n    }\n    keys() {\n        return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), 'HeadersIterator');\n    }\n    *_values() {\n        if (this._setCookies?.length) {\n            yield* this._setCookies;\n        }\n        if (!this._map) {\n            if (this.headersInit) {\n                if (Array.isArray(this.headersInit)) {\n                    yield* this.headersInit.map(([, value]) => value)[Symbol.iterator]();\n                    return;\n                }\n                if (isHeadersLike(this.headersInit)) {\n                    yield* this.headersInit.values();\n                    return;\n                }\n                yield* Object.values(this.headersInit)[Symbol.iterator]();\n                return;\n            }\n        }\n        yield* this.getMap().values();\n    }\n    values() {\n        return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), 'HeadersIterator');\n    }\n    *_entries() {\n        if (this._setCookies?.length) {\n            yield* this._setCookies.map(cookie => ['set-cookie', cookie]);\n        }\n        if (!this._map) {\n            if (this.headersInit) {\n                if (Array.isArray(this.headersInit)) {\n                    yield* this.headersInit;\n                    return;\n                }\n                if (isHeadersLike(this.headersInit)) {\n                    yield* this.headersInit.entries();\n                    return;\n                }\n                yield* Object.entries(this.headersInit);\n                return;\n            }\n        }\n        yield* this.getMap().entries();\n    }\n    entries() {\n        return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), 'HeadersIterator');\n    }\n    getSetCookie() {\n        if (!this._setCookies) {\n            this.getMap();\n        }\n        return this._setCookies;\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        const record = {};\n        this.forEach((value, key) => {\n            if (key === 'set-cookie') {\n                record['set-cookie'] = this._setCookies || [];\n            }\n            else {\n                record[key] = value?.includes(',') ? value.split(',').map(el => el.trim()) : value;\n            }\n        });\n        return `Headers ${(0, node_util_1.inspect)(record)}`;\n    }\n}\nexports.PonyfillHeaders = PonyfillHeaders;\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 8963;\nmodule.exports = webpackEmptyContext;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillTextEncoderStream = exports.PonyfillTextDecoderStream = void 0;\nconst TextEncoderDecoder_js_1 = require(\"./TextEncoderDecoder.js\");\nconst TransformStream_js_1 = require(\"./TransformStream.js\");\nclass PonyfillTextDecoderStream extends TransformStream_js_1.PonyfillTransformStream {\n    textDecoder;\n    constructor(encoding, options) {\n        super({\n            transform: (chunk, controller) => controller.enqueue(this.textDecoder.decode(chunk, { stream: true })),\n        });\n        this.textDecoder = new TextEncoderDecoder_js_1.PonyfillTextDecoder(encoding, options);\n    }\n    get encoding() {\n        return this.textDecoder.encoding;\n    }\n    get fatal() {\n        return this.textDecoder.fatal;\n    }\n    get ignoreBOM() {\n        return this.textDecoder.ignoreBOM;\n    }\n}\nexports.PonyfillTextDecoderStream = PonyfillTextDecoderStream;\nclass PonyfillTextEncoderStream extends TransformStream_js_1.PonyfillTransformStream {\n    textEncoder;\n    constructor(encoding) {\n        super({\n            transform: (chunk, controller) => controller.enqueue(this.textEncoder.encode(chunk)),\n        });\n        this.textEncoder = new TextEncoderDecoder_js_1.PonyfillTextEncoder(encoding);\n    }\n    get encoding() {\n        return this.textEncoder.encoding;\n    }\n    encode(input) {\n        return this.textEncoder.encode(input);\n    }\n}\nexports.PonyfillTextEncoderStream = PonyfillTextEncoderStream;\n","'use strict'\n\n/**\n * Copyright Brian White. All rights reserved.\n *\n * @see https://github.com/mscdex/streamsearch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n */\n\nconst { EventEmitter } = require('node:events')\nconst { inherits } = require('node:util')\n\nfunction SBMH (needle) {\n  if (typeof needle === 'string') {\n    needle = Buffer.from(needle)\n  }\n\n  if (!Buffer.isBuffer(needle)) {\n    throw new TypeError('The needle has to be a String or a Buffer.')\n  }\n\n  const needleLength = needle.length\n  const needleLastCharIndex = needleLength - 1\n\n  if (needleLength === 0) {\n    throw new Error('The needle cannot be an empty String/Buffer.')\n  }\n\n  if (needleLength > 256) {\n    throw new Error('The needle cannot have a length bigger than 256.')\n  }\n\n  this.maxMatches = Infinity\n  this.matches = 0\n\n  this._occ = new Uint8Array(256)\n    .fill(needleLength) // Initialize occurrence table.\n  this._lookbehind_size = 0\n  this._needle = needle\n  this._bufpos = 0\n\n  this._lookbehind = Buffer.alloc(needleLastCharIndex)\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  for (var i = 0; i < needleLastCharIndex; ++i) { // eslint-disable-line no-var\n    this._occ[needle[i]] = needleLastCharIndex - i\n  }\n}\ninherits(SBMH, EventEmitter)\n\nSBMH.prototype.reset = function () {\n  this._lookbehind_size = 0\n  this.matches = 0\n  this._bufpos = 0\n}\n\nSBMH.prototype.push = function (chunk, pos) {\n  if (!Buffer.isBuffer(chunk)) {\n    chunk = Buffer.from(chunk, 'binary')\n  }\n  const chlen = chunk.length\n  this._bufpos = pos || 0\n  let r\n  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk) }\n  return r\n}\n\nSBMH.prototype._sbmh_feed = function (data) {\n  const len = data.length\n  const needle = this._needle\n  const needleLength = needle.length\n  const needleLastCharIndex = needleLength - 1\n  const needleLastChar = needle[needleLastCharIndex]\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  let pos = -this._lookbehind_size\n  let ch\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needleLength) {\n      ch = data[pos + needleLastCharIndex]\n\n      if (\n        ch === needleLastChar &&\n        this._sbmh_memcmp(data, pos, needleLastCharIndex)\n      ) {\n        this._lookbehind_size = 0\n        ++this.matches\n        this.emit('info', true)\n        return (this._bufpos = pos + needleLength)\n      }\n\n      pos += this._occ[ch]\n    }\n\n    // No match.\n\n    while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      ++pos\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size)\n      this._lookbehind_size = 0\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = this._lookbehind_size + pos\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, this._lookbehind, 0, bytesToCutOff)\n      }\n\n      this._lookbehind_size -= bytesToCutOff\n      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size)\n\n      data.copy(this._lookbehind, this._lookbehind_size)\n      this._lookbehind_size += len\n\n      this._bufpos = len\n      return len\n    }\n  }\n\n  // Lookbehind buffer is now empty. We only need to check if the\n  // needle is in the haystack.\n  pos = data.indexOf(needle, pos + this._bufpos)\n\n  if (pos !== -1) {\n    ++this.matches\n    if (pos === 0) { this.emit('info', true) } else { this.emit('info', true, data, this._bufpos, pos) }\n    return (this._bufpos = pos + needleLength)\n  }\n\n  pos = len - needleLastCharIndex\n  if (pos < 0) {\n    pos = 0\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  while (\n    pos !== len &&\n    (\n      data[pos] !== needle[0] ||\n      Buffer.compare(\n        data.subarray(pos + 1, len),\n        needle.subarray(1, len - pos)\n      ) !== 0\n    )\n  ) {\n    ++pos\n  }\n\n  if (pos !== len) {\n    data.copy(this._lookbehind, 0, pos, len)\n    this._lookbehind_size = len - pos\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos !== 0) { this.emit('info', false, data, this._bufpos, pos) }\n\n  this._bufpos = len\n  return len\n}\n\nSBMH.prototype._sbmh_lookup_char = function (data, pos) {\n  return pos < 0\n    ? this._lookbehind[this._lookbehind_size + pos]\n    : data[pos]\n}\n\nSBMH.prototype._sbmh_memcmp = function (data, pos, len) {\n  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var\n    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }\n  }\n  return true\n}\n\nmodule.exports = SBMH\n","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillAsyncDisposableStack = void 0;\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst SupressedError_js_1 = require(\"./SupressedError.js\");\nconst symbols_js_1 = require(\"./symbols.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\nclass PonyfillAsyncDisposableStack {\n    callbacks = [];\n    get disposed() {\n        return this.callbacks.length === 0;\n    }\n    use(value) {\n        if ((0, utils_js_1.isAsyncDisposable)(value)) {\n            this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.asyncDispose]());\n        }\n        else if ((0, utils_js_1.isSyncDisposable)(value)) {\n            this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.dispose]());\n        }\n        return value;\n    }\n    adopt(value, onDisposeAsync) {\n        if (onDisposeAsync) {\n            this.callbacks.push(() => onDisposeAsync(value));\n        }\n        return value;\n    }\n    defer(onDisposeAsync) {\n        if (onDisposeAsync) {\n            this.callbacks.push(onDisposeAsync);\n        }\n    }\n    move() {\n        const stack = new PonyfillAsyncDisposableStack();\n        stack.callbacks = this.callbacks;\n        this.callbacks = [];\n        return stack;\n    }\n    disposeAsync() {\n        return this[symbols_js_1.DisposableSymbols.asyncDispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n        const cb = this.callbacks.pop();\n        if (cb) {\n            return (0, promise_helpers_1.handleMaybePromise)(cb, () => this._iterateCallbacks(), error => {\n                this._error = this._error ? new SuppressedError(error, this._error) : error;\n                return this._iterateCallbacks();\n            });\n        }\n    }\n    [symbols_js_1.DisposableSymbols.asyncDispose]() {\n        const res$ = this._iterateCallbacks();\n        if (res$?.then) {\n            return res$.then(() => {\n                if (this._error) {\n                    const error = this._error;\n                    this._error = undefined;\n                    throw error;\n                }\n            });\n        }\n        if (this._error) {\n            const error = this._error;\n            this._error = undefined;\n            throw error;\n        }\n        return undefined;\n    }\n    [Symbol.toStringTag] = 'AsyncDisposableStack';\n}\nexports.PonyfillAsyncDisposableStack = PonyfillAsyncDisposableStack;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SuppressedError = exports.AsyncDisposableStack = exports.DisposableStack = void 0;\nconst tslib_1 = require(\"tslib\");\nconst AsyncDisposableStack_js_1 = require(\"./AsyncDisposableStack.js\");\nconst DisposableStack_js_1 = require(\"./DisposableStack.js\");\nconst SupressedError_js_1 = require(\"./SupressedError.js\");\nexports.DisposableStack = globalThis.DisposableStack || DisposableStack_js_1.PonyfillDisposableStack;\nexports.AsyncDisposableStack = globalThis.AsyncDisposableStack || AsyncDisposableStack_js_1.PonyfillAsyncDisposableStack;\nexports.SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\ntslib_1.__exportStar(require(\"./symbols.js\"), exports);\n","module.exports = require(\"punycode\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fakePromise = void 0;\nexports.getHeadersObj = getHeadersObj;\nexports.defaultHeadersSerializer = defaultHeadersSerializer;\nexports.isArrayBufferView = isArrayBufferView;\nexports.isNodeReadable = isNodeReadable;\nexports.isIterable = isIterable;\nexports.shouldRedirect = shouldRedirect;\nexports.wrapIncomingMessageWithPassthrough = wrapIncomingMessageWithPassthrough;\nexports.endStream = endStream;\nexports.safeWrite = safeWrite;\nconst node_events_1 = require(\"node:events\");\nconst node_stream_1 = require(\"node:stream\");\nconst promises_1 = require(\"node:stream/promises\");\nfunction isHeadersInstance(obj) {\n    return obj?.forEach != null;\n}\nfunction getHeadersObj(headers) {\n    if (headers == null || !isHeadersInstance(headers)) {\n        return headers;\n    }\n    // @ts-expect-error - `headersInit` is not a public property\n    if (headers.headersInit && !headers._map && !isHeadersInstance(headers.headersInit)) {\n        // @ts-expect-error - `headersInit` is not a public property\n        return headers.headersInit;\n    }\n    return Object.fromEntries(headers.entries());\n}\nfunction defaultHeadersSerializer(headers, onContentLength) {\n    const headerArray = [];\n    headers.forEach((value, key) => {\n        if (onContentLength && key === 'content-length') {\n            onContentLength(value);\n        }\n        headerArray.push(`${key}: ${value}`);\n    });\n    return headerArray;\n}\nvar promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nObject.defineProperty(exports, \"fakePromise\", { enumerable: true, get: function () { return promise_helpers_1.fakePromise; } });\nfunction isArrayBufferView(obj) {\n    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;\n}\nfunction isNodeReadable(obj) {\n    return obj != null && obj.pipe != null;\n}\nfunction isIterable(value) {\n    return value?.[Symbol.iterator] != null;\n}\nfunction shouldRedirect(status) {\n    return status === 301 || status === 302 || status === 303 || status === 307 || status === 308;\n}\nfunction wrapIncomingMessageWithPassthrough({ incomingMessage, signal, passThrough = new node_stream_1.PassThrough(), onError = (e) => {\n    passThrough.destroy(e);\n}, }) {\n    (0, promises_1.pipeline)(incomingMessage, passThrough, {\n        signal,\n        end: true,\n    })\n        .then(() => {\n        if (!incomingMessage.destroyed) {\n            incomingMessage.resume();\n        }\n    })\n        .catch(onError);\n    return passThrough;\n}\nfunction endStream(stream) {\n    // @ts-expect-error Avoid arguments adaptor trampoline https://v8.dev/blog/adaptor-frame\n    return stream.end(null, null, null);\n}\nfunction safeWrite(chunk, stream, signal) {\n    const result = stream.write(chunk);\n    if (!result) {\n        return (0, node_events_1.once)(stream, 'drain', {\n            signal,\n        });\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillFormData = void 0;\nexports.getStreamFromFormData = getStreamFromFormData;\nconst node_buffer_1 = require(\"node:buffer\");\nconst IteratorObject_js_1 = require(\"./IteratorObject.js\");\nconst ReadableStream_js_1 = require(\"./ReadableStream.js\");\nclass PonyfillFormData {\n    map = new Map();\n    append(name, value, fileName) {\n        let values = this.map.get(name);\n        if (!values) {\n            values = [];\n            this.map.set(name, values);\n        }\n        const entry = isBlob(value)\n            ? getNormalizedFile(name, value, fileName)\n            : value;\n        values.push(entry);\n    }\n    delete(name) {\n        this.map.delete(name);\n    }\n    get(name) {\n        const values = this.map.get(name);\n        return values ? values[0] : null;\n    }\n    getAll(name) {\n        return this.map.get(name) || [];\n    }\n    has(name) {\n        return this.map.has(name);\n    }\n    set(name, value, fileName) {\n        const entry = isBlob(value)\n            ? getNormalizedFile(name, value, fileName)\n            : value;\n        this.map.set(name, [entry]);\n    }\n    [Symbol.iterator]() {\n        return this._entries();\n    }\n    *_entries() {\n        for (const [key, values] of this.map) {\n            for (const value of values) {\n                yield [key, value];\n            }\n        }\n    }\n    entries() {\n        return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), 'FormDataIterator');\n    }\n    _keys() {\n        return this.map.keys();\n    }\n    keys() {\n        return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), 'FormDataIterator');\n    }\n    *_values() {\n        for (const values of this.map.values()) {\n            for (const value of values) {\n                yield value;\n            }\n        }\n    }\n    values() {\n        return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), 'FormDataIterator');\n    }\n    forEach(callback) {\n        for (const [key, value] of this) {\n            callback(value, key, this);\n        }\n    }\n}\nexports.PonyfillFormData = PonyfillFormData;\nfunction getStreamFromFormData(formData, boundary = '---') {\n    let entriesIterator;\n    let sentInitialHeader = false;\n    let currentAsyncIterator;\n    let hasBefore = false;\n    function handleNextEntry(controller) {\n        const { done, value } = entriesIterator.next();\n        if (done) {\n            controller.enqueue(node_buffer_1.Buffer.from(`\\r\\n--${boundary}--\\r\\n`));\n            return controller.close();\n        }\n        if (hasBefore) {\n            controller.enqueue(node_buffer_1.Buffer.from(`\\r\\n--${boundary}\\r\\n`));\n        }\n        if (value) {\n            const [key, blobOrString] = value;\n            if (typeof blobOrString === 'string') {\n                controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name=\"${key}\"\\r\\n\\r\\n`));\n                controller.enqueue(node_buffer_1.Buffer.from(blobOrString));\n            }\n            else {\n                let filenamePart = '';\n                if (blobOrString.name) {\n                    filenamePart = `; filename=\"${blobOrString.name}\"`;\n                }\n                controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name=\"${key}\"${filenamePart}\\r\\n`));\n                controller.enqueue(node_buffer_1.Buffer.from(`Content-Type: ${blobOrString.type || 'application/octet-stream'}\\r\\n\\r\\n`));\n                const entryStream = blobOrString.stream();\n                // @ts-expect-error - ReadableStream is async iterable\n                currentAsyncIterator = entryStream[Symbol.asyncIterator]();\n            }\n            hasBefore = true;\n        }\n    }\n    return new ReadableStream_js_1.PonyfillReadableStream({\n        start: () => {\n            entriesIterator = formData.entries();\n        },\n        pull: controller => {\n            if (!sentInitialHeader) {\n                sentInitialHeader = true;\n                return controller.enqueue(node_buffer_1.Buffer.from(`--${boundary}\\r\\n`));\n            }\n            if (currentAsyncIterator) {\n                return currentAsyncIterator.next().then(({ done, value }) => {\n                    if (done) {\n                        currentAsyncIterator = undefined;\n                    }\n                    if (value) {\n                        return controller.enqueue(value);\n                    }\n                    else {\n                        return handleNextEntry(controller);\n                    }\n                });\n            }\n            return handleNextEntry(controller);\n        },\n        cancel: err => {\n            entriesIterator?.return?.(err);\n            currentAsyncIterator?.return?.(err);\n        },\n    });\n}\nfunction getNormalizedFile(name, blob, fileName) {\n    Object.defineProperty(blob, 'name', {\n        configurable: true,\n        enumerable: true,\n        value: fileName || blob.name || name,\n    });\n    return blob;\n}\nfunction isBlob(value) {\n    return value?.arrayBuffer != null;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillURLSearchParams = void 0;\nexports.PonyfillURLSearchParams = globalThis.URLSearchParams;\n","module.exports = require(\"process\");","module.exports = require(\"os\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillSuppressedError = void 0;\nclass PonyfillSuppressedError extends Error {\n    error;\n    suppressed;\n    // eslint-disable-next-line n/handle-callback-err\n    constructor(error, suppressed, message) {\n        super(message);\n        this.error = error;\n        this.suppressed = suppressed;\n        this.name = 'SuppressedError';\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nexports.PonyfillSuppressedError = PonyfillSuppressedError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillFile = void 0;\nconst Blob_js_1 = require(\"./Blob.js\");\nclass PonyfillFile extends Blob_js_1.PonyfillBlob {\n    name;\n    lastModified;\n    constructor(fileBits, name, options) {\n        super(fileBits, options);\n        this.name = name;\n        this.lastModified = options?.lastModified || Date.now();\n    }\n    webkitRelativePath = '';\n}\nexports.PonyfillFile = PonyfillFile;\n","module.exports = require(\"stream\");","module.exports = require(\"util\");","'use strict'\n\nconst Decoder = require('../utils/Decoder')\nconst decodeText = require('../utils/decodeText')\nconst getLimit = require('../utils/getLimit')\n\nconst RE_CHARSET = /^charset$/i\n\nUrlEncoded.detect = /^application\\/x-www-form-urlencoded/i\nfunction UrlEncoded (boy, cfg) {\n  const limits = cfg.limits\n  const parsedConType = cfg.parsedConType\n  this.boy = boy\n\n  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)\n  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100)\n  this.fieldsLimit = getLimit(limits, 'fields', Infinity)\n\n  let charset\n  for (var i = 0, len = parsedConType.length; i < len; ++i) { // eslint-disable-line no-var\n    if (Array.isArray(parsedConType[i]) &&\n        RE_CHARSET.test(parsedConType[i][0])) {\n      charset = parsedConType[i][1].toLowerCase()\n      break\n    }\n  }\n\n  if (charset === undefined) { charset = cfg.defCharset || 'utf8' }\n\n  this.decoder = new Decoder()\n  this.charset = charset\n  this._fields = 0\n  this._state = 'key'\n  this._checkingBytes = true\n  this._bytesKey = 0\n  this._bytesVal = 0\n  this._key = ''\n  this._val = ''\n  this._keyTrunc = false\n  this._valTrunc = false\n  this._hitLimit = false\n}\n\nUrlEncoded.prototype.write = function (data, cb) {\n  if (this._fields === this.fieldsLimit) {\n    if (!this.boy.hitFieldsLimit) {\n      this.boy.hitFieldsLimit = true\n      this.boy.emit('fieldsLimit')\n    }\n    return cb()\n  }\n\n  let idxeq; let idxamp; let i; let p = 0; const len = data.length\n\n  while (p < len) {\n    if (this._state === 'key') {\n      idxeq = idxamp = undefined\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) { ++p }\n        if (data[i] === 0x3D/* = */) {\n          idxeq = i\n          break\n        } else if (data[i] === 0x26/* & */) {\n          idxamp = i\n          break\n        }\n        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n          this._hitLimit = true\n          break\n        } else if (this._checkingBytes) { ++this._bytesKey }\n      }\n\n      if (idxeq !== undefined) {\n        // key with assignment\n        if (idxeq > p) { this._key += this.decoder.write(data.toString('binary', p, idxeq)) }\n        this._state = 'val'\n\n        this._hitLimit = false\n        this._checkingBytes = true\n        this._val = ''\n        this._bytesVal = 0\n        this._valTrunc = false\n        this.decoder.reset()\n\n        p = idxeq + 1\n      } else if (idxamp !== undefined) {\n        // key with no assignment\n        ++this._fields\n        let key; const keyTrunc = this._keyTrunc\n        if (idxamp > p) { key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))) } else { key = this._key }\n\n        this._hitLimit = false\n        this._checkingBytes = true\n        this._key = ''\n        this._bytesKey = 0\n        this._keyTrunc = false\n        this.decoder.reset()\n\n        if (key.length) {\n          this.boy.emit('field', decodeText(key, 'binary', this.charset),\n            '',\n            keyTrunc,\n            false)\n        }\n\n        p = idxamp + 1\n        if (this._fields === this.fieldsLimit) { return cb() }\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) { this._key += this.decoder.write(data.toString('binary', p, i)) }\n        p = i\n        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false\n          this._keyTrunc = true\n        }\n      } else {\n        if (p < len) { this._key += this.decoder.write(data.toString('binary', p)) }\n        p = len\n      }\n    } else {\n      idxamp = undefined\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) { ++p }\n        if (data[i] === 0x26/* & */) {\n          idxamp = i\n          break\n        }\n        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n          this._hitLimit = true\n          break\n        } else if (this._checkingBytes) { ++this._bytesVal }\n      }\n\n      if (idxamp !== undefined) {\n        ++this._fields\n        if (idxamp > p) { this._val += this.decoder.write(data.toString('binary', p, idxamp)) }\n        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n          decodeText(this._val, 'binary', this.charset),\n          this._keyTrunc,\n          this._valTrunc)\n        this._state = 'key'\n\n        this._hitLimit = false\n        this._checkingBytes = true\n        this._key = ''\n        this._bytesKey = 0\n        this._keyTrunc = false\n        this.decoder.reset()\n\n        p = idxamp + 1\n        if (this._fields === this.fieldsLimit) { return cb() }\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) { this._val += this.decoder.write(data.toString('binary', p, i)) }\n        p = i\n        if ((this._val === '' && this.fieldSizeLimit === 0) ||\n            (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false\n          this._valTrunc = true\n        }\n      } else {\n        if (p < len) { this._val += this.decoder.write(data.toString('binary', p)) }\n        p = len\n      }\n    }\n  }\n  cb()\n}\n\nUrlEncoded.prototype.end = function () {\n  if (this.boy._done) { return }\n\n  if (this._state === 'key' && this._key.length > 0) {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n      '',\n      this._keyTrunc,\n      false)\n  } else if (this._state === 'val') {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n      decodeText(this._val, 'binary', this.charset),\n      this._keyTrunc,\n      this._valTrunc)\n  }\n  this.boy._done = true\n  this.boy.emit('finish')\n}\n\nmodule.exports = UrlEncoded\n","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchCurl = fetchCurl;\nconst node_stream_1 = require(\"node:stream\");\nconst node_tls_1 = require(\"node:tls\");\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst Response_js_1 = require(\"./Response.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction fetchCurl(fetchRequest) {\n    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis['libcurl'];\n    const curlHandle = new Curl();\n    curlHandle.enable(CurlFeature.NoDataParsing);\n    curlHandle.setOpt('URL', fetchRequest.url);\n    if (process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0') {\n        curlHandle.setOpt('SSL_VERIFYPEER', false);\n    }\n    if (process.env.NODE_EXTRA_CA_CERTS) {\n        curlHandle.setOpt('CAINFO', process.env.NODE_EXTRA_CA_CERTS);\n    }\n    else {\n        curlHandle.setOpt('CAINFO_BLOB', node_tls_1.rootCertificates.join('\\n'));\n    }\n    curlHandle.enable(CurlFeature.StreamResponse);\n    let signal;\n    if (fetchRequest._signal === null) {\n        signal = undefined;\n    }\n    else if (fetchRequest._signal) {\n        signal = fetchRequest._signal;\n    }\n    else {\n        signal = fetchRequest.signal;\n    }\n    curlHandle.setStreamProgressCallback(function () {\n        return signal?.aborted ? (process.env.DEBUG ? CurlProgressFunc.Continue : 1) : 0;\n    });\n    if (fetchRequest['bodyType'] === 'String') {\n        curlHandle.setOpt('POSTFIELDS', fetchRequest['bodyInit']);\n    }\n    else {\n        const nodeReadable = (fetchRequest.body != null\n            ? (0, utils_js_1.isNodeReadable)(fetchRequest.body)\n                ? fetchRequest.body\n                : node_stream_1.Readable.from(fetchRequest.body)\n            : null);\n        if (nodeReadable) {\n            curlHandle.setOpt('UPLOAD', true);\n            curlHandle.setUploadStream(nodeReadable);\n        }\n    }\n    if (process.env.DEBUG) {\n        curlHandle.setOpt('VERBOSE', true);\n    }\n    curlHandle.setOpt('TRANSFER_ENCODING', false);\n    curlHandle.setOpt('HTTP_TRANSFER_DECODING', true);\n    curlHandle.setOpt('FOLLOWLOCATION', fetchRequest.redirect === 'follow');\n    curlHandle.setOpt('MAXREDIRS', 20);\n    curlHandle.setOpt('ACCEPT_ENCODING', '');\n    curlHandle.setOpt('CUSTOMREQUEST', fetchRequest.method);\n    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;\n    let size;\n    const curlHeaders = headersSerializer(fetchRequest.headers, value => {\n        size = Number(value);\n    });\n    if (size != null) {\n        curlHandle.setOpt('INFILESIZE', size);\n    }\n    curlHandle.setOpt('HTTPHEADER', curlHeaders);\n    curlHandle.enable(CurlFeature.NoHeaderParsing);\n    const deferredPromise = (0, promise_helpers_1.createDeferredPromise)();\n    let streamResolved;\n    function onAbort() {\n        if (curlHandle.isOpen) {\n            try {\n                curlHandle.pause(CurlPause.Recv);\n            }\n            catch (e) {\n                deferredPromise.reject(e);\n            }\n        }\n    }\n    signal?.addEventListener('abort', onAbort, { once: true });\n    curlHandle.once('end', function endListener() {\n        try {\n            curlHandle.close();\n        }\n        catch (e) {\n            deferredPromise.reject(e);\n        }\n        signal?.removeEventListener('abort', onAbort);\n    });\n    curlHandle.once('error', function errorListener(error) {\n        if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {\n            streamResolved.destroy(error);\n        }\n        else {\n            if (error.message === 'Operation was aborted by an application callback') {\n                error.message = 'The operation was aborted.';\n            }\n            deferredPromise.reject(error);\n        }\n        try {\n            curlHandle.close();\n        }\n        catch (e) {\n            deferredPromise.reject(e);\n        }\n    });\n    curlHandle.once('stream', function streamListener(stream, status, headersBuf) {\n        const outputStream = (0, utils_js_1.wrapIncomingMessageWithPassthrough)({\n            incomingMessage: stream,\n            signal,\n            onError: deferredPromise.reject,\n        });\n        const headersFlat = headersBuf\n            .toString('utf8')\n            .split(/\\r?\\n|\\r/g)\n            .filter(headerFilter => {\n            if (headerFilter && !headerFilter.startsWith('HTTP/')) {\n                if (fetchRequest.redirect === 'error' &&\n                    headerFilter.toLowerCase().includes('location') &&\n                    (0, utils_js_1.shouldRedirect)(status)) {\n                    if (!stream.destroyed) {\n                        stream.resume();\n                    }\n                    outputStream.destroy();\n                    deferredPromise.reject(new Error('redirect is not allowed'));\n                }\n                return true;\n            }\n            return false;\n        });\n        const headersInit = headersFlat.map(headerFlat => headerFlat.split(/:\\s(.+)/).slice(0, 2));\n        const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {\n            status,\n            headers: headersInit,\n            url: curlHandle.getInfo(Curl.info.REDIRECT_URL)?.toString() || fetchRequest.url,\n            redirected: Number(curlHandle.getInfo(Curl.info.REDIRECT_COUNT)) > 0,\n        });\n        deferredPromise.resolve(ponyfillResponse);\n        streamResolved = outputStream;\n    });\n    setImmediate(() => {\n        curlHandle.perform();\n    });\n    return deferredPromise.promise;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillRequest = void 0;\nconst node_http_1 = require(\"node:http\");\nconst node_https_1 = require(\"node:https\");\nconst Body_js_1 = require(\"./Body.js\");\nconst Headers_js_1 = require(\"./Headers.js\");\nconst URL_js_1 = require(\"./URL.js\");\nfunction isRequest(input) {\n    return input[Symbol.toStringTag] === 'Request';\n}\nfunction isURL(obj) {\n    return obj?.href != null;\n}\nclass PonyfillRequest extends Body_js_1.PonyfillBody {\n    constructor(input, options) {\n        let _url;\n        let _parsedUrl;\n        let bodyInit = null;\n        let requestInit;\n        if (typeof input === 'string') {\n            _url = input;\n        }\n        else if (isURL(input)) {\n            _parsedUrl = input;\n        }\n        else if (isRequest(input)) {\n            if (input._parsedUrl) {\n                _parsedUrl = input._parsedUrl;\n            }\n            else if (input._url) {\n                _url = input._url;\n            }\n            else {\n                _url = input.url;\n            }\n            bodyInit = input.body;\n            requestInit = input;\n        }\n        if (options != null) {\n            bodyInit = options.body || null;\n            requestInit = options;\n        }\n        super(bodyInit, requestInit);\n        this._url = _url;\n        this._parsedUrl = _parsedUrl;\n        this.cache = requestInit?.cache || 'default';\n        this.credentials = requestInit?.credentials || 'same-origin';\n        this.headers =\n            requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers)\n                ? requestInit.headers\n                : new Headers_js_1.PonyfillHeaders(requestInit?.headers);\n        this.integrity = requestInit?.integrity || '';\n        this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;\n        this.method = requestInit?.method?.toUpperCase() || 'GET';\n        this.mode = requestInit?.mode || 'cors';\n        this.redirect = requestInit?.redirect || 'follow';\n        this.referrer = requestInit?.referrer || 'about:client';\n        this.referrerPolicy = requestInit?.referrerPolicy || 'no-referrer';\n        this.headersSerializer = requestInit?.headersSerializer;\n        this.duplex = requestInit?.duplex || 'half';\n        this.destination = 'document';\n        this.priority = 'auto';\n        if (this.method !== 'GET' && this.method !== 'HEAD') {\n            this.handleContentLengthHeader(true);\n        }\n        if (requestInit?.agent != null) {\n            const protocol = _parsedUrl?.protocol || _url || this.url;\n            if (requestInit.agent === false) {\n                this.agent = false;\n            }\n            else if (protocol.startsWith('http:') && requestInit.agent instanceof node_http_1.Agent) {\n                this.agent = requestInit.agent;\n            }\n            else if (protocol.startsWith('https:') && requestInit.agent instanceof node_https_1.Agent) {\n                this.agent = requestInit.agent;\n            }\n        }\n    }\n    headersSerializer;\n    cache;\n    credentials;\n    destination;\n    headers;\n    integrity;\n    keepalive;\n    method;\n    mode;\n    priority;\n    redirect;\n    referrer;\n    referrerPolicy;\n    _url;\n    get signal() {\n        this._signal ||= new AbortController().signal;\n        return this._signal;\n    }\n    get url() {\n        if (this._url == null) {\n            if (this._parsedUrl) {\n                this._url = this._parsedUrl.toString();\n            }\n            else {\n                throw new TypeError('Invalid URL');\n            }\n        }\n        return this._url;\n    }\n    _parsedUrl;\n    get parsedUrl() {\n        if (this._parsedUrl == null) {\n            if (this._url != null) {\n                this._parsedUrl = new URL_js_1.PonyfillURL(this._url, 'http://localhost');\n            }\n            else {\n                throw new TypeError('Invalid URL');\n            }\n        }\n        return this._parsedUrl;\n    }\n    duplex;\n    agent;\n    clone() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'Request';\n}\nexports.PonyfillRequest = PonyfillRequest;\n","'use strict'\n\nconst WritableStream = require('node:stream').Writable\nconst { inherits } = require('node:util')\nconst Dicer = require('../deps/dicer/lib/Dicer')\n\nconst MultipartParser = require('./types/multipart')\nconst UrlencodedParser = require('./types/urlencoded')\nconst parseParams = require('./utils/parseParams')\n\nfunction Busboy (opts) {\n  if (!(this instanceof Busboy)) { return new Busboy(opts) }\n\n  if (typeof opts !== 'object') {\n    throw new TypeError('Busboy expected an options-Object.')\n  }\n  if (typeof opts.headers !== 'object') {\n    throw new TypeError('Busboy expected an options-Object with headers-attribute.')\n  }\n  if (typeof opts.headers['content-type'] !== 'string') {\n    throw new TypeError('Missing Content-Type-header.')\n  }\n\n  const {\n    headers,\n    ...streamOptions\n  } = opts\n\n  this.opts = {\n    autoDestroy: false,\n    ...streamOptions\n  }\n  WritableStream.call(this, this.opts)\n\n  this._done = false\n  this._parser = this.getParserByHeaders(headers)\n  this._finished = false\n}\ninherits(Busboy, WritableStream)\n\nBusboy.prototype.emit = function (ev) {\n  if (ev === 'finish') {\n    if (!this._done) {\n      this._parser?.end()\n      return\n    } else if (this._finished) {\n      return\n    }\n    this._finished = true\n  }\n  WritableStream.prototype.emit.apply(this, arguments)\n}\n\nBusboy.prototype.getParserByHeaders = function (headers) {\n  const parsed = parseParams(headers['content-type'])\n\n  const cfg = {\n    defCharset: this.opts.defCharset,\n    fileHwm: this.opts.fileHwm,\n    headers,\n    highWaterMark: this.opts.highWaterMark,\n    isPartAFile: this.opts.isPartAFile,\n    limits: this.opts.limits,\n    parsedConType: parsed,\n    preservePath: this.opts.preservePath\n  }\n\n  if (MultipartParser.detect.test(parsed[0])) {\n    return new MultipartParser(this, cfg)\n  }\n  if (UrlencodedParser.detect.test(parsed[0])) {\n    return new UrlencodedParser(this, cfg)\n  }\n  throw new Error('Unsupported Content-Type.')\n}\n\nBusboy.prototype._write = function (chunk, encoding, cb) {\n  this._parser.write(chunk, cb)\n}\n\nmodule.exports = Busboy\nmodule.exports.default = Busboy\nmodule.exports.Busboy = Busboy\n\nmodule.exports.Dicer = Dicer\n","module.exports = require(\"node:child_process\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillTransformStream = void 0;\nconst node_stream_1 = require(\"node:stream\");\nconst ReadableStream_js_1 = require(\"./ReadableStream.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst WritableStream_js_1 = require(\"./WritableStream.js\");\nclass PonyfillTransformStream {\n    transform;\n    writable;\n    readable;\n    constructor(transformer) {\n        if (transformer instanceof node_stream_1.Transform) {\n            this.transform = transformer;\n        }\n        else if (transformer) {\n            const controller = {\n                enqueue(chunk) {\n                    transform.push(chunk);\n                },\n                error(reason) {\n                    transform.destroy(reason);\n                },\n                terminate() {\n                    (0, utils_js_1.endStream)(transform);\n                },\n                get desiredSize() {\n                    return transform.writableLength;\n                },\n            };\n            const transform = new node_stream_1.Transform({\n                read() { },\n                write(chunk, _encoding, callback) {\n                    try {\n                        const result = transformer.transform?.(chunk, controller);\n                        if (result instanceof Promise) {\n                            result.then(() => {\n                                callback();\n                            }, err => {\n                                callback(err);\n                            });\n                        }\n                        else {\n                            callback();\n                        }\n                    }\n                    catch (err) {\n                        callback(err);\n                    }\n                },\n                final(callback) {\n                    try {\n                        const result = transformer.flush?.(controller);\n                        if (result instanceof Promise) {\n                            result.then(() => {\n                                callback();\n                            }, err => {\n                                callback(err);\n                            });\n                        }\n                        else {\n                            callback();\n                        }\n                    }\n                    catch (err) {\n                        callback(err);\n                    }\n                },\n            });\n            this.transform = transform;\n        }\n        else {\n            this.transform = new node_stream_1.Transform();\n        }\n        this.writable = new WritableStream_js_1.PonyfillWritableStream(this.transform);\n        this.readable = new ReadableStream_js_1.PonyfillReadableStream(this.transform);\n    }\n}\nexports.PonyfillTransformStream = PonyfillTransformStream;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillCompressionStream = void 0;\nconst node_zlib_1 = require(\"node:zlib\");\nconst TransformStream_js_1 = require(\"./TransformStream.js\");\nclass PonyfillCompressionStream extends TransformStream_js_1.PonyfillTransformStream {\n    static supportedFormats = globalThis.process?.version?.startsWith('v2')\n        ? ['gzip', 'deflate', 'br']\n        : ['gzip', 'deflate', 'deflate-raw', 'br'];\n    constructor(compressionFormat) {\n        switch (compressionFormat) {\n            case 'x-gzip':\n            case 'gzip':\n                super((0, node_zlib_1.createGzip)());\n                break;\n            case 'x-deflate':\n            case 'deflate':\n                super((0, node_zlib_1.createDeflate)());\n                break;\n            case 'deflate-raw':\n                super((0, node_zlib_1.createDeflateRaw)());\n                break;\n            case 'br':\n                super((0, node_zlib_1.createBrotliCompress)());\n                break;\n            default:\n                throw new Error(`Unsupported compression format: ${compressionFormat}`);\n        }\n    }\n}\nexports.PonyfillCompressionStream = PonyfillCompressionStream;\n","module.exports = require(\"path\");","module.exports = require(\"tls\");","const { URLPattern } = require(\"./dist/urlpattern.cjs\");\n\nmodule.exports = { URLPattern };\n\nif (!globalThis.URLPattern) {\n  globalThis.URLPattern = URLPattern;\n}\n","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","'use strict'\n\n// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\n\nconst { Readable } = require('node:stream')\nconst { inherits } = require('node:util')\n\nconst Dicer = require('../../deps/dicer/lib/Dicer')\n\nconst parseParams = require('../utils/parseParams')\nconst decodeText = require('../utils/decodeText')\nconst basename = require('../utils/basename')\nconst getLimit = require('../utils/getLimit')\n\nconst RE_BOUNDARY = /^boundary$/i\nconst RE_FIELD = /^form-data$/i\nconst RE_CHARSET = /^charset$/i\nconst RE_FILENAME = /^filename$/i\nconst RE_NAME = /^name$/i\n\nMultipart.detect = /^multipart\\/form-data/i\nfunction Multipart (boy, cfg) {\n  let i\n  let len\n  const self = this\n  let boundary\n  const limits = cfg.limits\n  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined))\n  const parsedConType = cfg.parsedConType || []\n  const defCharset = cfg.defCharset || 'utf8'\n  const preservePath = cfg.preservePath\n  const fileOpts = { highWaterMark: cfg.fileHwm }\n\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) &&\n      RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1]\n      break\n    }\n  }\n\n  function checkFinished () {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false\n      self.end()\n    }\n  }\n\n  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }\n\n  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)\n  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity)\n  const filesLimit = getLimit(limits, 'files', Infinity)\n  const fieldsLimit = getLimit(limits, 'fields', Infinity)\n  const partsLimit = getLimit(limits, 'parts', Infinity)\n  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000)\n  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024)\n\n  let nfiles = 0\n  let nfields = 0\n  let nends = 0\n  let curFile\n  let curField\n  let finished = false\n\n  this._needDrain = false\n  this._pause = false\n  this._cb = undefined\n  this._nparts = 0\n  this._boy = boy\n\n  const parserCfg = {\n    boundary,\n    maxHeaderPairs: headerPairsLimit,\n    maxHeaderSize: headerSizeLimit,\n    partHwm: fileOpts.highWaterMark,\n    highWaterMark: cfg.highWaterMark\n  }\n\n  this.parser = new Dicer(parserCfg)\n  this.parser.on('drain', function () {\n    self._needDrain = false\n    if (self._cb && !self._pause) {\n      const cb = self._cb\n      self._cb = undefined\n      cb()\n    }\n  }).on('part', function onPart (part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart)\n      self.parser.on('part', skipPart)\n      boy.hitPartsLimit = true\n      boy.emit('partsLimit')\n      return skipPart(part)\n    }\n\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n    if (curField) {\n      const field = curField\n      field.emit('end')\n      field.removeAllListeners('end')\n    }\n\n    part.on('header', function (header) {\n      let contype\n      let fieldname\n      let parsed\n      let charset\n      let encoding\n      let filename\n      let nsize = 0\n\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0])\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase()\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase()\n              break\n            }\n          }\n        }\n      }\n\n      if (contype === undefined) { contype = 'text/plain' }\n      if (charset === undefined) { charset = defCharset }\n\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0])\n        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = parsed[i][1]\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = parsed[i][1]\n            if (!preservePath) { filename = basename(filename) }\n          }\n        }\n      } else { return skipPart(part) }\n\n      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase() } else { encoding = '7bit' }\n\n      let onData,\n        onEnd\n\n      if (isPartAFile(fieldname, contype, filename)) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true\n            boy.emit('filesLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfiles\n\n        if (boy.listenerCount('file') === 0) {\n          self.parser._ignore()\n          return\n        }\n\n        ++nends\n        const file = new FileStream(fileOpts)\n        curFile = file\n        file.on('end', function () {\n          --nends\n          self._pause = false\n          checkFinished()\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        })\n        file._read = function (n) {\n          if (!self._pause) { return }\n          self._pause = false\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        }\n        boy.emit('file', fieldname, file, filename, encoding, contype)\n\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            const extralen = fileSizeLimit - nsize + data.length\n            if (extralen > 0) { file.push(data.slice(0, extralen)) }\n            file.truncated = true\n            file.bytesRead = fileSizeLimit\n            part.removeAllListeners('data')\n            file.emit('limit')\n            return\n          } else if (!file.push(data)) { self._pause = true }\n\n          file.bytesRead = nsize\n        }\n\n        onEnd = function () {\n          curFile = undefined\n          file.push(null)\n        }\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true\n            boy.emit('fieldsLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfields\n        ++nends\n        let buffer = ''\n        let truncated = false\n        curField = part\n\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            const extralen = (fieldSizeLimit - (nsize - data.length))\n            buffer += data.toString('binary', 0, extralen)\n            truncated = true\n            part.removeAllListeners('data')\n          } else { buffer += data.toString('binary') }\n        }\n\n        onEnd = function () {\n          curField = undefined\n          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset) }\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype)\n          --nends\n          checkFinished()\n        }\n      }\n\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n      part._readableState.sync = false\n\n      part.on('data', onData)\n      part.on('end', onEnd)\n    }).on('error', function (err) {\n      if (curFile) { curFile.emit('error', err) }\n    })\n  }).on('error', function (err) {\n    boy.emit('error', err)\n  }).on('finish', function () {\n    finished = true\n    checkFinished()\n  })\n}\n\nMultipart.prototype.write = function (chunk, cb) {\n  const r = this.parser.write(chunk)\n  if (r && !this._pause) {\n    cb()\n  } else {\n    this._needDrain = !r\n    this._cb = cb\n  }\n}\n\nMultipart.prototype.end = function () {\n  const self = this\n\n  if (self.parser.writable) {\n    self.parser.end()\n  } else if (!self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true\n      self._boy.emit('finish')\n    })\n  }\n}\n\nfunction skipPart (part) {\n  part.resume()\n}\n\nfunction FileStream (opts) {\n  Readable.call(this, opts)\n\n  this.bytesRead = 0\n\n  this.truncated = false\n}\n\ninherits(FileStream, Readable)\n\nFileStream.prototype._read = function (n) {}\n\nmodule.exports = Multipart\n","module.exports = require(\"node:zlib\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisposableSymbols = void 0;\nexports.patchSymbols = patchSymbols;\nexports.DisposableSymbols = {\n    get dispose() {\n        return Symbol.dispose || Symbol.for('dispose');\n    },\n    get asyncDispose() {\n        return Symbol.asyncDispose || Symbol.for('asyncDispose');\n    },\n};\nfunction patchSymbols() {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - we ponyfill these symbols\n    Symbol.dispose ||= Symbol.for('dispose');\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - we ponyfill these symbols\n    Symbol.asyncDispose ||= Symbol.for('asyncDispose');\n}\n","'use strict'\n\n// Node has always utf-8\nconst utf8Decoder = new TextDecoder('utf-8')\nconst textDecoders = new Map([\n  ['utf-8', utf8Decoder],\n  ['utf8', utf8Decoder]\n])\n\nfunction getDecoder (charset) {\n  let lc\n  while (true) {\n    switch (charset) {\n      case 'utf-8':\n      case 'utf8':\n        return decoders.utf8\n      case 'latin1':\n      case 'ascii': // TODO: Make these a separate, strict decoder?\n      case 'us-ascii':\n      case 'iso-8859-1':\n      case 'iso8859-1':\n      case 'iso88591':\n      case 'iso_8859-1':\n      case 'windows-1252':\n      case 'iso_8859-1:1987':\n      case 'cp1252':\n      case 'x-cp1252':\n        return decoders.latin1\n      case 'utf16le':\n      case 'utf-16le':\n      case 'ucs2':\n      case 'ucs-2':\n        return decoders.utf16le\n      case 'base64':\n        return decoders.base64\n      default:\n        if (lc === undefined) {\n          lc = true\n          charset = charset.toLowerCase()\n          continue\n        }\n        return decoders.other.bind(charset)\n    }\n  }\n}\n\nconst decoders = {\n  utf8: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n    return data.utf8Slice(0, data.length)\n  },\n\n  latin1: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      return data\n    }\n    return data.latin1Slice(0, data.length)\n  },\n\n  utf16le: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n    return data.ucs2Slice(0, data.length)\n  },\n\n  base64: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n    return data.base64Slice(0, data.length)\n  },\n\n  other: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n\n    if (textDecoders.has(this.toString())) {\n      try {\n        return textDecoders.get(this).decode(data)\n      } catch {}\n    }\n    return typeof data === 'string'\n      ? data\n      : data.toString()\n  }\n}\n\nfunction decodeText (text, sourceEncoding, destEncoding) {\n  if (text) {\n    return getDecoder(destEncoding)(text, sourceEncoding)\n  }\n  return text\n}\n\nmodule.exports = decodeText\n","module.exports = require(\"node:tls\");","const shouldSkipPonyfill = require('./shouldSkipPonyfill');\nlet newNodeFetch;\n\nmodule.exports = function createNodePonyfill(opts = {}) {\n  const ponyfills = {};\n  \n  ponyfills.URLPattern = globalThis.URLPattern;\n\n  // We call this previously to patch `Bun`\n  if (!ponyfills.URLPattern) {\n    const urlPatternModule = require('urlpattern-polyfill');\n    ponyfills.URLPattern = urlPatternModule.URLPattern;\n  }\n\n  if (opts.skipPonyfill || shouldSkipPonyfill()) {\n    return {\n      fetch: globalThis.fetch,\n      Headers: globalThis.Headers,\n      Request: globalThis.Request,\n      Response: globalThis.Response,\n      FormData: globalThis.FormData,\n      ReadableStream: globalThis.ReadableStream,\n      WritableStream: globalThis.WritableStream,\n      TransformStream: globalThis.TransformStream,\n      CompressionStream: globalThis.CompressionStream,\n      DecompressionStream: globalThis.DecompressionStream,\n      TextDecoderStream: globalThis.TextDecoderStream,\n      TextEncoderStream: globalThis.TextEncoderStream,\n      Blob: globalThis.Blob,\n      File: globalThis.File,\n      crypto: globalThis.crypto,\n      btoa: globalThis.btoa,\n      TextEncoder: globalThis.TextEncoder,\n      TextDecoder: globalThis.TextDecoder,\n      URLPattern: ponyfills.URLPattern,\n      URL: globalThis.URL,\n      URLSearchParams: globalThis.URLSearchParams\n    };\n  }\n\n  newNodeFetch ||= require('@whatwg-node/node-fetch');\n\n  ponyfills.fetch = newNodeFetch.fetch;\n  ponyfills.Request = newNodeFetch.Request;\n  ponyfills.Response = newNodeFetch.Response;\n  ponyfills.Headers = newNodeFetch.Headers;\n  ponyfills.FormData = newNodeFetch.FormData;\n  ponyfills.ReadableStream = newNodeFetch.ReadableStream;\n\n  ponyfills.URL = newNodeFetch.URL;\n  ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;\n\n  ponyfills.WritableStream = newNodeFetch.WritableStream;\n  ponyfills.TransformStream = newNodeFetch.TransformStream;\n  ponyfills.CompressionStream = newNodeFetch.CompressionStream;\n  ponyfills.DecompressionStream = newNodeFetch.DecompressionStream;\n  ponyfills.TextDecoderStream = newNodeFetch.TextDecoderStream;\n  ponyfills.TextEncoderStream = newNodeFetch.TextEncoderStream;\n\n  ponyfills.Blob = newNodeFetch.Blob;\n  ponyfills.File = newNodeFetch.File;\n  ponyfills.crypto = globalThis.crypto;\n  ponyfills.btoa = newNodeFetch.btoa;\n  ponyfills.TextEncoder = newNodeFetch.TextEncoder;\n  ponyfills.TextDecoder = newNodeFetch.TextDecoder;\n\n  if (opts.formDataLimits) {\n    ponyfills.Body = class Body extends newNodeFetch.Body {\n      constructor(body, userOpts) {\n        super(body, {\n          formDataLimits: opts.formDataLimits,\n          ...userOpts,\n        });\n      }\n    }\n    ponyfills.Request = class Request extends newNodeFetch.Request {\n      constructor(input, userOpts) {\n        super(input, {\n          formDataLimits: opts.formDataLimits,\n          ...userOpts,\n        });\n      }\n    }\n    ponyfills.Response = class Response extends newNodeFetch.Response {\n      constructor(body, userOpts) {\n        super(body, {\n          formDataLimits: opts.formDataLimits,\n          ...userOpts,\n        });\n      }\n    }\n  }\n\n  if (!ponyfills.crypto) {\n    const cryptoModule = require(\"crypto\");\n    ponyfills.crypto = cryptoModule.webcrypto;\n  }\n\n  return ponyfills;\n}\n","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","module.exports = require(\"node:stream/promises\");","module.exports = require(\"node:os\");","'use strict'\n\nconst RE_PLUS = /\\+/g\n\nconst HEX = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]\n\nfunction Decoder () {\n  this.buffer = undefined\n}\nDecoder.prototype.write = function (str) {\n  // Replace '+' with ' ' before decoding\n  str = str.replace(RE_PLUS, ' ')\n  let res = ''\n  let i = 0; let p = 0; const len = str.length\n  for (; i < len; ++i) {\n    if (this.buffer !== undefined) {\n      if (!HEX[str.charCodeAt(i)]) {\n        res += '%' + this.buffer\n        this.buffer = undefined\n        --i // retry character\n      } else {\n        this.buffer += str[i]\n        ++p\n        if (this.buffer.length === 2) {\n          res += String.fromCharCode(parseInt(this.buffer, 16))\n          this.buffer = undefined\n        }\n      }\n    } else if (str[i] === '%') {\n      if (i > p) {\n        res += str.substring(p, i)\n        p = i\n      }\n      this.buffer = ''\n      ++p\n    }\n  }\n  if (p < len && this.buffer === undefined) { res += str.substring(p) }\n  return res\n}\nDecoder.prototype.reset = function () {\n  this.buffer = undefined\n}\n\nmodule.exports = Decoder\n","module.exports = require(\"node:diagnostics_channel\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillBlob = void 0;\nexports.hasBufferMethod = hasBufferMethod;\nexports.hasArrayBufferMethod = hasArrayBufferMethod;\nexports.hasBytesMethod = hasBytesMethod;\nexports.hasTextMethod = hasTextMethod;\nexports.hasSizeProperty = hasSizeProperty;\nexports.hasStreamMethod = hasStreamMethod;\nexports.hasBlobSignature = hasBlobSignature;\nexports.isArrayBuffer = isArrayBuffer;\n/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nconst node_buffer_1 = require(\"node:buffer\");\nconst ReadableStream_js_1 = require(\"./ReadableStream.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction getBlobPartAsBuffer(blobPart) {\n    if (typeof blobPart === 'string') {\n        return node_buffer_1.Buffer.from(blobPart);\n    }\n    else if (node_buffer_1.Buffer.isBuffer(blobPart)) {\n        return blobPart;\n    }\n    else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {\n        return node_buffer_1.Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);\n    }\n    else {\n        return node_buffer_1.Buffer.from(blobPart);\n    }\n}\nfunction hasBufferMethod(obj) {\n    return obj != null && obj.buffer != null && typeof obj.buffer === 'function';\n}\nfunction hasArrayBufferMethod(obj) {\n    return obj != null && obj.arrayBuffer != null && typeof obj.arrayBuffer === 'function';\n}\nfunction hasBytesMethod(obj) {\n    return obj != null && obj.bytes != null && typeof obj.bytes === 'function';\n}\nfunction hasTextMethod(obj) {\n    return obj != null && obj.text != null && typeof obj.text === 'function';\n}\nfunction hasSizeProperty(obj) {\n    return obj != null && typeof obj.size === 'number';\n}\nfunction hasStreamMethod(obj) {\n    return obj != null && obj.stream != null && typeof obj.stream === 'function';\n}\nfunction hasBlobSignature(obj) {\n    return obj != null && obj[Symbol.toStringTag] === 'Blob';\n}\nfunction isArrayBuffer(obj) {\n    return obj != null && obj.byteLength != null && obj.slice != null;\n}\n// Will be removed after v14 reaches EOL\n// Needed because v14 doesn't have .stream() implemented\nclass PonyfillBlob {\n    blobParts;\n    type;\n    encoding;\n    _size = null;\n    constructor(blobParts = [], options) {\n        this.blobParts = blobParts;\n        this.type = options?.type || 'application/octet-stream';\n        this.encoding = options?.encoding || 'utf8';\n        this._size = options?.size || null;\n        if (blobParts.length === 1 && hasBlobSignature(blobParts[0])) {\n            return blobParts[0];\n        }\n    }\n    _buffer = null;\n    buffer() {\n        if (this._buffer) {\n            return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (this.blobParts.length === 1) {\n            const blobPart = this.blobParts[0];\n            if (hasBufferMethod(blobPart)) {\n                return blobPart.buffer().then(buf => {\n                    this._buffer = buf;\n                    return this._buffer;\n                });\n            }\n            if (hasBytesMethod(blobPart)) {\n                return blobPart.bytes().then(bytes => {\n                    this._buffer = node_buffer_1.Buffer.from(bytes);\n                    return this._buffer;\n                });\n            }\n            if (hasArrayBufferMethod(blobPart)) {\n                return blobPart.arrayBuffer().then(arrayBuf => {\n                    this._buffer = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);\n                    return this._buffer;\n                });\n            }\n            this._buffer = getBlobPartAsBuffer(blobPart);\n            return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        const jobs = [];\n        const bufferChunks = this.blobParts.map((blobPart, i) => {\n            if (hasBufferMethod(blobPart)) {\n                jobs.push(blobPart.buffer().then(buf => {\n                    bufferChunks[i] = buf;\n                }));\n                return undefined;\n            }\n            else if (hasArrayBufferMethod(blobPart)) {\n                jobs.push(blobPart.arrayBuffer().then(arrayBuf => {\n                    bufferChunks[i] = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);\n                }));\n                return undefined;\n            }\n            else if (hasBytesMethod(blobPart)) {\n                jobs.push(blobPart.bytes().then(bytes => {\n                    bufferChunks[i] = node_buffer_1.Buffer.from(bytes);\n                }));\n                return undefined;\n            }\n            else {\n                return getBlobPartAsBuffer(blobPart);\n            }\n        });\n        if (jobs.length > 0) {\n            return Promise.all(jobs).then(() => node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));\n        }\n        return (0, utils_js_1.fakePromise)(node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));\n    }\n    arrayBuffer() {\n        if (this._buffer) {\n            // @ts-ignore - Mismatch between Buffer and ArrayBuffer\n            return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (this.blobParts.length === 1) {\n            if (isArrayBuffer(this.blobParts[0])) {\n                return (0, utils_js_1.fakePromise)(this.blobParts[0]);\n            }\n            if (hasArrayBufferMethod(this.blobParts[0])) {\n                return this.blobParts[0].arrayBuffer();\n            }\n        }\n        // @ts-ignore - Mismatch between Buffer and ArrayBuffer\n        return this.buffer();\n    }\n    bytes() {\n        if (this._buffer) {\n            return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (this.blobParts.length === 1) {\n            if (node_buffer_1.Buffer.isBuffer(this.blobParts[0])) {\n                this._buffer = this.blobParts[0];\n                return (0, utils_js_1.fakePromise)(this.blobParts[0]);\n            }\n            if (this.blobParts[0] instanceof Uint8Array) {\n                this._buffer = node_buffer_1.Buffer.from(this.blobParts[0]);\n                return (0, utils_js_1.fakePromise)(this.blobParts[0]);\n            }\n            if (hasBytesMethod(this.blobParts[0])) {\n                return this.blobParts[0].bytes();\n            }\n            if (hasBufferMethod(this.blobParts[0])) {\n                return this.blobParts[0].buffer();\n            }\n        }\n        return this.buffer();\n    }\n    _text = null;\n    text() {\n        if (this._text) {\n            return (0, utils_js_1.fakePromise)(this._text);\n        }\n        if (this.blobParts.length === 1) {\n            const blobPart = this.blobParts[0];\n            if (typeof blobPart === 'string') {\n                this._text = blobPart;\n                return (0, utils_js_1.fakePromise)(this._text);\n            }\n            if (hasTextMethod(blobPart)) {\n                return blobPart.text().then(text => {\n                    this._text = text;\n                    return this._text;\n                });\n            }\n            const buf = getBlobPartAsBuffer(blobPart);\n            this._text = buf.toString(this.encoding);\n            return (0, utils_js_1.fakePromise)(this._text);\n        }\n        return this.buffer().then(buf => {\n            this._text = buf.toString(this.encoding);\n            return this._text;\n        });\n    }\n    _json = null;\n    json() {\n        if (this._json) {\n            return (0, utils_js_1.fakePromise)(this._json);\n        }\n        return this.text().then(text => {\n            this._json = JSON.parse(text);\n            return this._json;\n        });\n    }\n    _formData = null;\n    formData() {\n        if (this._formData) {\n            return (0, utils_js_1.fakePromise)(this._formData);\n        }\n        throw new Error('Not implemented');\n    }\n    get size() {\n        if (this._size == null) {\n            this._size = 0;\n            for (const blobPart of this.blobParts) {\n                if (typeof blobPart === 'string') {\n                    this._size += node_buffer_1.Buffer.byteLength(blobPart);\n                }\n                else if (hasSizeProperty(blobPart)) {\n                    this._size += blobPart.size;\n                }\n                else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {\n                    this._size += blobPart.byteLength;\n                }\n            }\n        }\n        return this._size;\n    }\n    stream() {\n        if (this.blobParts.length === 1) {\n            const blobPart = this.blobParts[0];\n            if (hasStreamMethod(blobPart)) {\n                return blobPart.stream();\n            }\n            const buf = getBlobPartAsBuffer(blobPart);\n            return new ReadableStream_js_1.PonyfillReadableStream({\n                start: controller => {\n                    controller.enqueue(buf);\n                    controller.close();\n                },\n            });\n        }\n        if (this._buffer != null) {\n            return new ReadableStream_js_1.PonyfillReadableStream({\n                start: controller => {\n                    controller.enqueue(this._buffer);\n                    controller.close();\n                },\n            });\n        }\n        let blobPartIterator;\n        return new ReadableStream_js_1.PonyfillReadableStream({\n            start: controller => {\n                if (this.blobParts.length === 0) {\n                    controller.close();\n                    return;\n                }\n                blobPartIterator = this.blobParts[Symbol.iterator]();\n            },\n            pull: controller => {\n                const { value: blobPart, done } = blobPartIterator.next();\n                if (done) {\n                    controller.close();\n                    return;\n                }\n                if (blobPart) {\n                    if (hasBufferMethod(blobPart)) {\n                        return blobPart.buffer().then(buf => {\n                            controller.enqueue(buf);\n                        });\n                    }\n                    if (hasBytesMethod(blobPart)) {\n                        return blobPart.bytes().then(bytes => {\n                            const buf = node_buffer_1.Buffer.from(bytes);\n                            controller.enqueue(buf);\n                        });\n                    }\n                    if (hasArrayBufferMethod(blobPart)) {\n                        return blobPart.arrayBuffer().then(arrayBuffer => {\n                            const buf = node_buffer_1.Buffer.from(arrayBuffer, undefined, blobPart.size);\n                            controller.enqueue(buf);\n                        });\n                    }\n                    const buf = getBlobPartAsBuffer(blobPart);\n                    controller.enqueue(buf);\n                }\n            },\n        });\n    }\n    slice() {\n        throw new Error('Not implemented');\n    }\n}\nexports.PonyfillBlob = PonyfillBlob;\n","module.exports = require(\"crypto\");","module.exports = require(\"https\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","/* (ignored) */","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillWritableStream = void 0;\nconst node_events_1 = require(\"node:events\");\nconst node_stream_1 = require(\"node:stream\");\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst utils_js_1 = require(\"./utils.js\");\nclass PonyfillWritableStream {\n    writable;\n    constructor(underlyingSink) {\n        if (underlyingSink instanceof node_stream_1.Writable) {\n            this.writable = underlyingSink;\n        }\n        else if (underlyingSink) {\n            const writable = new node_stream_1.Writable({\n                write(chunk, _encoding, callback) {\n                    try {\n                        const result = underlyingSink.write?.(chunk, controller);\n                        if (result instanceof Promise) {\n                            result.then(() => {\n                                callback();\n                            }, err => {\n                                callback(err);\n                            });\n                        }\n                        else {\n                            callback();\n                        }\n                    }\n                    catch (err) {\n                        callback(err);\n                    }\n                },\n                final(callback) {\n                    const result = underlyingSink.close?.();\n                    if (result instanceof Promise) {\n                        result.then(() => {\n                            callback();\n                        }, err => {\n                            callback(err);\n                        });\n                    }\n                    else {\n                        callback();\n                    }\n                },\n            });\n            this.writable = writable;\n            const abortCtrl = new AbortController();\n            const controller = {\n                signal: abortCtrl.signal,\n                error(e) {\n                    writable.destroy(e);\n                },\n            };\n            writable.once('error', err => abortCtrl.abort(err));\n            writable.once('close', () => abortCtrl.abort());\n        }\n        else {\n            this.writable = new node_stream_1.Writable();\n        }\n    }\n    getWriter() {\n        const writable = this.writable;\n        return {\n            get closed() {\n                return (0, node_events_1.once)(writable, 'close');\n            },\n            get desiredSize() {\n                return writable.writableLength;\n            },\n            get ready() {\n                return (0, node_events_1.once)(writable, 'drain');\n            },\n            releaseLock() {\n                // no-op\n            },\n            write(chunk) {\n                const promise = (0, utils_js_1.fakePromise)();\n                if (chunk == null) {\n                    return promise;\n                }\n                return promise.then(() => (0, utils_js_1.safeWrite)(chunk, writable));\n            },\n            close() {\n                if (!writable.errored && writable.closed) {\n                    return (0, utils_js_1.fakePromise)();\n                }\n                if (writable.errored) {\n                    return (0, promise_helpers_1.fakeRejectPromise)(writable.errored);\n                }\n                return (0, utils_js_1.fakePromise)().then(() => (0, utils_js_1.endStream)(writable));\n            },\n            abort(reason) {\n                writable.destroy(reason);\n                return (0, node_events_1.once)(writable, 'close');\n            },\n        };\n    }\n    close() {\n        if (!this.writable.errored && this.writable.closed) {\n            return (0, utils_js_1.fakePromise)();\n        }\n        if (this.writable.errored) {\n            return (0, promise_helpers_1.fakeRejectPromise)(this.writable.errored);\n        }\n        return (0, utils_js_1.fakePromise)().then(() => (0, utils_js_1.endStream)(this.writable));\n    }\n    abort(reason) {\n        this.writable.destroy(reason);\n        return (0, node_events_1.once)(this.writable, 'close');\n    }\n    locked = false;\n}\nexports.PonyfillWritableStream = PonyfillWritableStream;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillReadableStream = void 0;\nconst node_buffer_1 = require(\"node:buffer\");\nconst node_events_1 = require(\"node:events\");\nconst node_stream_1 = require(\"node:stream\");\nconst promises_1 = require(\"node:stream/promises\");\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction createController(desiredSize, readable) {\n    let chunks = [];\n    let _closed = false;\n    let flushed = false;\n    return {\n        desiredSize,\n        enqueue(chunk) {\n            const buf = typeof chunk === 'string' ? node_buffer_1.Buffer.from(chunk) : chunk;\n            if (!flushed) {\n                chunks.push(buf);\n            }\n            else {\n                readable.push(buf);\n            }\n        },\n        close() {\n            if (chunks.length > 0) {\n                this._flush();\n            }\n            readable.push(null);\n            _closed = true;\n        },\n        error(error) {\n            if (chunks.length > 0) {\n                this._flush();\n            }\n            readable.destroy(error);\n        },\n        get _closed() {\n            return _closed;\n        },\n        _flush() {\n            flushed = true;\n            if (chunks.length > 0) {\n                const concatenated = chunks.length > 1 ? node_buffer_1.Buffer.concat(chunks) : chunks[0];\n                readable.push(concatenated);\n                chunks = [];\n            }\n        },\n    };\n}\nfunction isNodeReadable(obj) {\n    return obj?.read != null;\n}\nfunction isReadableStream(obj) {\n    return obj?.getReader != null;\n}\nclass PonyfillReadableStream {\n    readable;\n    constructor(underlyingSource) {\n        if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {\n            this.readable = underlyingSource.readable;\n        }\n        else if (isNodeReadable(underlyingSource)) {\n            this.readable = underlyingSource;\n        }\n        else if (isReadableStream(underlyingSource)) {\n            this.readable = node_stream_1.Readable.fromWeb(underlyingSource);\n        }\n        else {\n            let started = false;\n            let ongoing = false;\n            const handleStart = (desiredSize) => {\n                if (!started) {\n                    const controller = createController(desiredSize, this.readable);\n                    started = true;\n                    return (0, promise_helpers_1.handleMaybePromise)(() => underlyingSource?.start?.(controller), () => {\n                        controller._flush();\n                        if (controller._closed) {\n                            return false;\n                        }\n                        return true;\n                    });\n                }\n                return true;\n            };\n            const readImpl = (desiredSize) => {\n                return (0, promise_helpers_1.handleMaybePromise)(() => handleStart(desiredSize), shouldContinue => {\n                    if (!shouldContinue) {\n                        return;\n                    }\n                    const controller = createController(desiredSize, this.readable);\n                    return (0, promise_helpers_1.handleMaybePromise)(() => underlyingSource?.pull?.(controller), () => {\n                        controller._flush();\n                        ongoing = false;\n                    });\n                });\n            };\n            this.readable = new node_stream_1.Readable({\n                read(desiredSize) {\n                    if (ongoing) {\n                        return;\n                    }\n                    ongoing = true;\n                    return readImpl(desiredSize);\n                },\n                destroy(err, callback) {\n                    if (underlyingSource?.cancel) {\n                        try {\n                            const res$ = underlyingSource.cancel(err);\n                            if (res$?.then) {\n                                return res$.then(() => {\n                                    callback(null);\n                                }, err => {\n                                    callback(err);\n                                });\n                            }\n                        }\n                        catch (err) {\n                            callback(err);\n                            return;\n                        }\n                    }\n                    callback(null);\n                },\n            });\n        }\n    }\n    cancel(reason) {\n        this.readable.destroy(reason);\n        // @ts-expect-error - we know it is void\n        return (0, node_events_1.once)(this.readable, 'close');\n    }\n    locked = false;\n    getReader(_options) {\n        const iterator = this.readable[Symbol.asyncIterator]();\n        this.locked = true;\n        const thisReadable = this.readable;\n        return {\n            read() {\n                return iterator.next();\n            },\n            releaseLock: () => {\n                if (iterator.return) {\n                    const retResult$ = iterator.return();\n                    if (retResult$.then) {\n                        retResult$.then(() => {\n                            this.locked = false;\n                        });\n                        return;\n                    }\n                }\n                this.locked = false;\n            },\n            cancel: reason => {\n                if (iterator.return) {\n                    const retResult$ = iterator.return(reason);\n                    if (retResult$.then) {\n                        return retResult$.then(() => {\n                            this.locked = false;\n                        });\n                    }\n                }\n                this.locked = false;\n                return (0, utils_js_1.fakePromise)();\n            },\n            get closed() {\n                return Promise.race([\n                    (0, node_events_1.once)(thisReadable, 'end'),\n                    (0, node_events_1.once)(thisReadable, 'error').then(err => Promise.reject(err)),\n                ]);\n            },\n        };\n    }\n    [Symbol.asyncIterator]() {\n        const iterator = this.readable[Symbol.asyncIterator]();\n        return {\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            next: () => iterator.next(),\n            return: () => {\n                if (!this.readable.destroyed) {\n                    this.readable.destroy();\n                }\n                return iterator.return?.() || (0, utils_js_1.fakePromise)({ done: true, value: undefined });\n            },\n            throw: (err) => {\n                if (!this.readable.destroyed) {\n                    this.readable.destroy(err);\n                }\n                return iterator.throw?.(err) || (0, utils_js_1.fakePromise)({ done: true, value: undefined });\n            },\n        };\n    }\n    tee() {\n        throw new Error('Not implemented');\n    }\n    async pipeToWriter(writer) {\n        try {\n            for await (const chunk of this) {\n                await writer.write(chunk);\n            }\n            await writer.close();\n        }\n        catch (err) {\n            await writer.abort(err);\n        }\n    }\n    pipeTo(destination) {\n        if (isPonyfillWritableStream(destination)) {\n            return (0, promises_1.pipeline)(this.readable, destination.writable, {\n                end: true,\n            });\n        }\n        else {\n            const writer = destination.getWriter();\n            return this.pipeToWriter(writer);\n        }\n    }\n    pipeThrough({ writable, readable, }) {\n        this.pipeTo(writable).catch(err => {\n            this.readable.destroy(err);\n        });\n        if (isPonyfillReadableStream(readable)) {\n            readable.readable.once('error', err => this.readable.destroy(err));\n            readable.readable.once('finish', () => this.readable.push(null));\n            readable.readable.once('close', () => this.readable.push(null));\n        }\n        return readable;\n    }\n    static [Symbol.hasInstance](instance) {\n        return isReadableStream(instance);\n    }\n    static from(iterable) {\n        return new PonyfillReadableStream(node_stream_1.Readable.from(iterable));\n    }\n    [Symbol.toStringTag] = 'ReadableStream';\n}\nexports.PonyfillReadableStream = PonyfillReadableStream;\nfunction isPonyfillReadableStream(obj) {\n    return obj?.readable != null;\n}\nfunction isPonyfillWritableStream(obj) {\n    return obj?.writable != null;\n}\n","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","'use strict'\n\nconst EventEmitter = require('node:events').EventEmitter\nconst inherits = require('node:util').inherits\nconst getLimit = require('../../../lib/utils/getLimit')\n\nconst StreamSearch = require('../../streamsearch/sbmh')\n\nconst B_DCRLF = Buffer.from('\\r\\n\\r\\n')\nconst RE_CRLF = /\\r\\n/g\nconst RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/ // eslint-disable-line no-control-regex\n\nfunction HeaderParser (cfg) {\n  EventEmitter.call(this)\n\n  cfg = cfg || {}\n  const self = this\n  this.nread = 0\n  this.maxed = false\n  this.npairs = 0\n  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000)\n  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024)\n  this.buffer = ''\n  this.header = {}\n  this.finished = false\n  this.ss = new StreamSearch(B_DCRLF)\n  this.ss.on('info', function (isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + end - start >= self.maxHeaderSize) {\n        end = self.maxHeaderSize - self.nread + start\n        self.nread = self.maxHeaderSize\n        self.maxed = true\n      } else { self.nread += (end - start) }\n\n      self.buffer += data.toString('binary', start, end)\n    }\n    if (isMatch) { self._finish() }\n  })\n}\ninherits(HeaderParser, EventEmitter)\n\nHeaderParser.prototype.push = function (data) {\n  const r = this.ss.push(data)\n  if (this.finished) { return r }\n}\n\nHeaderParser.prototype.reset = function () {\n  this.finished = false\n  this.buffer = ''\n  this.header = {}\n  this.ss.reset()\n}\n\nHeaderParser.prototype._finish = function () {\n  if (this.buffer) { this._parseHeader() }\n  this.ss.matches = this.ss.maxMatches\n  const header = this.header\n  this.header = {}\n  this.buffer = ''\n  this.finished = true\n  this.nread = this.npairs = 0\n  this.maxed = false\n  this.emit('header', header)\n}\n\nHeaderParser.prototype._parseHeader = function () {\n  if (this.npairs === this.maxHeaderPairs) { return }\n\n  const lines = this.buffer.split(RE_CRLF)\n  const len = lines.length\n  let m, h\n\n  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var\n    if (lines[i].length === 0) { continue }\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      if (h) {\n        this.header[h][this.header[h].length - 1] += lines[i]\n        continue\n      }\n    }\n\n    const posColon = lines[i].indexOf(':')\n    if (\n      posColon === -1 ||\n      posColon === 0\n    ) {\n      return\n    }\n    m = RE_HDR.exec(lines[i])\n    h = m[1].toLowerCase()\n    this.header[h] = this.header[h] || []\n    this.header[h].push((m[2] || ''))\n    if (++this.npairs === this.maxHeaderPairs) { break }\n  }\n}\n\nmodule.exports = HeaderParser\n","\nconst createNodePonyfill = require('./create-node-ponyfill');\nconst shouldSkipPonyfill = require('./shouldSkipPonyfill');\nconst ponyfills = createNodePonyfill();\n\nif (!shouldSkipPonyfill()) {\n  try {\n    const nodelibcurlName = 'node-libcurl'\n    globalThis.libcurl = globalThis.libcurl || require(nodelibcurlName);\n  } catch (e) { }\n}\n\nmodule.exports.fetch = ponyfills.fetch;\nmodule.exports.Headers = ponyfills.Headers;\nmodule.exports.Request = ponyfills.Request;\nmodule.exports.Response = ponyfills.Response;\nmodule.exports.FormData = ponyfills.FormData;\nmodule.exports.ReadableStream = ponyfills.ReadableStream;\nmodule.exports.WritableStream = ponyfills.WritableStream;\nmodule.exports.TransformStream = ponyfills.TransformStream;\nmodule.exports.CompressionStream = ponyfills.CompressionStream;\nmodule.exports.DecompressionStream = ponyfills.DecompressionStream;\nmodule.exports.TextDecoderStream = ponyfills.TextDecoderStream;\nmodule.exports.TextEncoderStream = ponyfills.TextEncoderStream;\nmodule.exports.Blob = ponyfills.Blob;\nmodule.exports.File = ponyfills.File;\nmodule.exports.crypto = ponyfills.crypto;\nmodule.exports.btoa = ponyfills.btoa;\nmodule.exports.TextEncoder = ponyfills.TextEncoder;\nmodule.exports.TextDecoder = ponyfills.TextDecoder;\nmodule.exports.URLPattern = ponyfills.URLPattern;\nmodule.exports.URL = ponyfills.URL;\nmodule.exports.URLSearchParams = ponyfills.URLSearchParams;\n\nexports.createFetch = createNodePonyfill;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillDecompressionStream = void 0;\nconst node_zlib_1 = require(\"node:zlib\");\nconst TransformStream_js_1 = require(\"./TransformStream.js\");\nclass PonyfillDecompressionStream extends TransformStream_js_1.PonyfillTransformStream {\n    static supportedFormats = globalThis.process?.version?.startsWith('v2')\n        ? ['gzip', 'deflate', 'br']\n        : ['gzip', 'deflate', 'deflate-raw', 'br'];\n    constructor(compressionFormat) {\n        switch (compressionFormat) {\n            case 'x-gzip':\n            case 'gzip':\n                super((0, node_zlib_1.createGunzip)());\n                break;\n            case 'x-deflate':\n            case 'deflate':\n                super((0, node_zlib_1.createInflate)());\n                break;\n            case 'deflate-raw':\n                super((0, node_zlib_1.createInflateRaw)());\n                break;\n            case 'br':\n                super((0, node_zlib_1.createBrotliDecompress)());\n                break;\n            default:\n                throw new TypeError(`Unsupported compression format: '${compressionFormat}'`);\n        }\n    }\n}\nexports.PonyfillDecompressionStream = PonyfillDecompressionStream;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"graphql\");","import { TokenKind, visit, } from 'graphql';\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nexport function resetComments() {\n    commentsRegistry = {};\n}\nexport function collectComment(node) {\n    const entityName = node.name?.value;\n    if (entityName == null) {\n        return;\n    }\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            if (node.values) {\n                for (const value of node.values) {\n                    pushComment(value, entityName, value.name.value);\n                }\n            }\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                for (const field of node.fields) {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        for (const arg of field.arguments) {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}\nexport function pushComment(node, entity, field, argument) {\n    const comment = getComment(node);\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nexport function printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n    return maybeArray?.some(str => str.includes('\\n')) ?? false;\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, parent?.name?.value].filter(Boolean).join('.');\n        const items = [];\n        if (node.kind.includes('Definition') && commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n    const escaped = value.replace(/\\\\/g, '\\\\\\\\').replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n    Name: { leave: node => node.value },\n    Variable: { leave: node => '$' + node.name },\n    // Document\n    Document: {\n        leave: node => join(node.definitions, '\\n\\n'),\n    },\n    OperationDefinition: {\n        leave: node => {\n            const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n            const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n            // the query short form.\n            return prefix + ' ' + node.selectionSet;\n        },\n    },\n    VariableDefinition: {\n        leave: ({ variable, type, defaultValue, directives }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' ')),\n    },\n    SelectionSet: { leave: ({ selections }) => block(selections) },\n    Field: {\n        leave({ alias, name, arguments: args, directives, selectionSet }) {\n            const prefix = wrap('', alias, ': ') + name;\n            let argsLine = prefix + wrap('(', join(args, ', '), ')');\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n            }\n            return join([argsLine, join(directives, ' '), selectionSet], ' ');\n        },\n    },\n    Argument: { leave: ({ name, value }) => name + ': ' + value },\n    // Fragments\n    FragmentSpread: {\n        leave: ({ name, directives }) => '...' + name + wrap(' ', join(directives, ' ')),\n    },\n    InlineFragment: {\n        leave: ({ typeCondition, directives, selectionSet }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' '),\n    },\n    FragmentDefinition: {\n        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => \n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n            `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n            selectionSet,\n    },\n    // Value\n    IntValue: { leave: ({ value }) => value },\n    FloatValue: { leave: ({ value }) => value },\n    StringValue: {\n        leave: ({ value, block: isBlockString }) => {\n            if (isBlockString) {\n                return printBlockString(value);\n            }\n            return JSON.stringify(value);\n        },\n    },\n    BooleanValue: { leave: ({ value }) => (value ? 'true' : 'false') },\n    NullValue: { leave: () => 'null' },\n    EnumValue: { leave: ({ value }) => value },\n    ListValue: { leave: ({ values }) => '[' + join(values, ', ') + ']' },\n    ObjectValue: { leave: ({ fields }) => '{' + join(fields, ', ') + '}' },\n    ObjectField: { leave: ({ name, value }) => name + ': ' + value },\n    // Directive\n    Directive: {\n        leave: ({ name, arguments: args }) => '@' + name + wrap('(', join(args, ', '), ')'),\n    },\n    // Type\n    NamedType: { leave: ({ name }) => name },\n    ListType: { leave: ({ type }) => '[' + type + ']' },\n    NonNullType: { leave: ({ type }) => type + '!' },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    OperationTypeDefinition: {\n        leave: ({ operation, type }) => operation + ': ' + type,\n    },\n    ScalarTypeDefinition: {\n        leave: ({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'type',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    FieldDefinition: {\n        leave: ({ name, arguments: args, type, directives }) => name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            ': ' +\n            type +\n            wrap(' ', join(directives, ' ')),\n    },\n    InputValueDefinition: {\n        leave: ({ name, type, defaultValue, directives }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' '),\n    },\n    InterfaceTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'interface',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    UnionTypeDefinition: {\n        leave: ({ name, directives, types }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeDefinition: {\n        leave: ({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    EnumValueDefinition: {\n        leave: ({ name, directives }) => join([name, join(directives, ' ')], ' '),\n    },\n    InputObjectTypeDefinition: {\n        leave: ({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' '),\n    },\n    DirectiveDefinition: {\n        leave: ({ name, arguments: args, repeatable, locations }) => 'directive @' +\n            name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            (repeatable ? ' repeatable' : '') +\n            ' on ' +\n            join(locations, ' | '),\n    },\n    SchemaExtension: {\n        leave: ({ directives, operationTypes }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    ScalarTypeExtension: {\n        leave: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'extend type',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    InterfaceTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'extend interface',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    UnionTypeExtension: {\n        leave: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeExtension: {\n        leave: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    InputObjectTypeExtension: {\n        leave: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n    },\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n    ...prev,\n    [key]: {\n        leave: addDescription(printDocASTReducer[key].leave),\n    },\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nexport function printWithComments(ast) {\n    return visit(ast, printDocASTReducerWithComments);\n}\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nexport function getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options?.commentDescriptions) {\n        return getComment(node);\n    }\n}\nexport function getComment(node) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n        return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n}\nexport function getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexport function dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\n/**\n * @internal\n */\nexport function getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\n","// Taken from graphql-js\n// https://github.com/graphql/graphql-js/blob/main/src/jsutils/inspect.ts\nconst MAX_RECURSIVE_DEPTH = 3;\n/**\n * Used to print values in error messages.\n */\nexport function inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch (typeof value) {\n        case 'string':\n            return JSON.stringify(value);\n        case 'function':\n            return value.name ? `[function ${value.name}]` : '[function]';\n        case 'object':\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatError(value) {\n    // eslint-disable-next-line no-constant-condition\n    if ((value.name = 'GraphQLError')) {\n        return value.toString();\n    }\n    return `${value.name}: ${value.message};\\n ${value.stack}`;\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (value === null) {\n        return 'null';\n    }\n    if (value instanceof Error) {\n        if (value.name === 'AggregateError') {\n            return (formatError(value) +\n                '\\n' +\n                formatArray(value.errors, previouslySeenValues));\n        }\n        return formatError(value);\n    }\n    if (previouslySeenValues.includes(value)) {\n        return '[Circular]';\n    }\n    const seenValues = [...previouslySeenValues, value];\n    if (isJSONable(value)) {\n        const jsonValue = value.toJSON();\n        // check for infinite recursion\n        if (jsonValue !== value) {\n            return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n        }\n    }\n    else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction isJSONable(value) {\n    return typeof value.toJSON === 'function';\n}\nfunction formatObject(object, seenValues) {\n    const entries = Object.entries(object);\n    if (entries.length === 0) {\n        return '{}';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[' + getObjectTag(object) + ']';\n    }\n    const properties = entries.map(([key, value]) => key + ': ' + formatValue(value, seenValues));\n    return '{ ' + properties.join(', ') + ' }';\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return '[]';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[Array]';\n    }\n    const len = array.length;\n    const items = [];\n    for (let i = 0; i < len; ++i) {\n        items.push(formatValue(array[i], seenValues));\n    }\n    return '[' + items.join(', ') + ']';\n}\nfunction getObjectTag(object) {\n    const tag = Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object /, '')\n        .replace(/]$/, '');\n    if (tag === 'Object' && typeof object.constructor === 'function') {\n        const name = object.constructor.name;\n        if (typeof name === 'string' && name !== '') {\n            return name;\n        }\n    }\n    return tag;\n}\n","import { inspect } from 'cross-inspect';\nimport { isListType, isNonNullType, Kind } from 'graphql';\nexport function astFromType(type) {\n    if (isNonNullType(type)) {\n        const innerType = astFromType(type.ofType);\n        if (innerType.kind === Kind.NON_NULL_TYPE) {\n            throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n        }\n        return {\n            kind: Kind.NON_NULL_TYPE,\n            type: innerType,\n        };\n    }\n    else if (isListType(type)) {\n        return {\n            kind: Kind.LIST_TYPE,\n            type: astFromType(type.ofType),\n        };\n    }\n    return {\n        kind: Kind.NAMED_TYPE,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n    };\n}\n","import { Kind } from 'graphql';\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | BigInt        | Int                  |\n * | null          | NullValue            |\n *\n */\nexport function astFromValueUntyped(value) {\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (Array.isArray(value)) {\n        const valuesNodes = [];\n        for (const item of value) {\n            const itemNode = astFromValueUntyped(item);\n            if (itemNode != null) {\n                valuesNodes.push(itemNode);\n            }\n        }\n        return { kind: Kind.LIST, values: valuesNodes };\n    }\n    if (typeof value === 'object') {\n        if (value?.toJSON) {\n            return astFromValueUntyped(value.toJSON());\n        }\n        const fieldNodes = [];\n        for (const fieldName in value) {\n            const fieldValue = value[fieldName];\n            const ast = astFromValueUntyped(fieldValue);\n            if (ast) {\n                fieldNodes.push({\n                    kind: Kind.OBJECT_FIELD,\n                    name: { kind: Kind.NAME, value: fieldName },\n                    value: ast,\n                });\n            }\n        }\n        return { kind: Kind.OBJECT, fields: fieldNodes };\n    }\n    // Others serialize based on their corresponding JavaScript scalar types.\n    if (typeof value === 'boolean') {\n        return { kind: Kind.BOOLEAN, value };\n    }\n    if (typeof value === 'bigint') {\n        return { kind: Kind.INT, value: String(value) };\n    }\n    // JavaScript numbers can be Int or Float values.\n    if (typeof value === 'number' && isFinite(value)) {\n        const stringNum = String(value);\n        return integerStringRegExp.test(stringNum)\n            ? { kind: Kind.INT, value: stringNum }\n            : { kind: Kind.FLOAT, value: stringNum };\n    }\n    if (typeof value === 'string') {\n        return { kind: Kind.STRING, value };\n    }\n    throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n","const kFakePromise = Symbol.for('@whatwg-node/promise-helpers/FakePromise');\nexport function isPromise(value) {\n    return value?.then != null;\n}\nexport function isActualPromise(value) {\n    const maybePromise = value;\n    return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n}\nexport function handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n    let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n    if (finallyFactory) {\n        result$ = result$.finally(finallyFactory);\n    }\n    return unfakePromise(result$);\n}\nexport function fakePromise(value) {\n    if (value && isActualPromise(value)) {\n        return value;\n    }\n    if (isPromise(value)) {\n        return {\n            then: (resolve, reject) => fakePromise(value.then(resolve, reject)),\n            catch: reject => fakePromise(value.then(res => res, reject)),\n            finally: cb => fakePromise(cb ? promiseLikeFinally(value, cb) : value),\n            [Symbol.toStringTag]: 'Promise',\n        };\n    }\n    // Write a fake promise to avoid the promise constructor\n    // being called with `new Promise` in the browser.\n    return {\n        then(resolve) {\n            if (resolve) {\n                try {\n                    return fakePromise(resolve(value));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch() {\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    return fakePromise(cb()).then(() => value, () => value);\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        [Symbol.toStringTag]: 'Promise',\n        __fakePromiseValue: value,\n        [kFakePromise]: 'resolved',\n    };\n}\nexport function createDeferredPromise() {\n    if (Promise.withResolvers) {\n        return Promise.withResolvers();\n    }\n    let resolveFn;\n    let rejectFn;\n    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n        resolveFn = resolve;\n        rejectFn = reject;\n    });\n    return {\n        promise,\n        get resolve() {\n            return resolveFn;\n        },\n        get reject() {\n            return rejectFn;\n        },\n    };\n}\nexport { iterateAsync as iterateAsyncVoid };\nexport function iterateAsync(iterable, callback, results) {\n    if (iterable?.length === 0) {\n        return;\n    }\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n    function iterate() {\n        const { done: endOfIterator, value } = iterator.next();\n        if (endOfIterator) {\n            return;\n        }\n        let endedEarly = false;\n        function endEarly() {\n            endedEarly = true;\n        }\n        return handleMaybePromise(function handleCallback() {\n            return callback(value, endEarly, index++);\n        }, function handleCallbackResult(result) {\n            if (result) {\n                results?.push(result);\n            }\n            if (endedEarly) {\n                return;\n            }\n            return iterate();\n        });\n    }\n    return iterate();\n}\nexport function fakeRejectPromise(error) {\n    return {\n        then(_resolve, reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch(reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    cb();\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        __fakeRejectError: error,\n        [Symbol.toStringTag]: 'Promise',\n        [kFakePromise]: 'rejected',\n    };\n}\nexport function mapMaybePromise(input, onSuccess, onError) {\n    return handleMaybePromise(() => input, onSuccess, onError);\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterator, onNext, onError, onEnd) {\n    if (Symbol.asyncIterator in iterator) {\n        iterator = iterator[Symbol.asyncIterator]();\n    }\n    let $return;\n    let abruptClose;\n    let onEndWithValue;\n    if (onEnd) {\n        let onEndWithValueResult /** R in onEndWithValue */;\n        onEndWithValue = value => {\n            onEndWithValueResult ||= handleMaybePromise(onEnd, () => value, () => value);\n            return onEndWithValueResult;\n        };\n    }\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => {\n                throw error;\n            };\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        if (result.done) {\n            return onEndWithValue ? onEndWithValue(result) : result;\n        }\n        return handleMaybePromise(() => result.value, value => handleMaybePromise(() => onNext(value), iteratorResult, abruptClose));\n    }\n    let mapReject;\n    if (onError) {\n        let onErrorResult;\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = onError;\n        mapReject = (error) => {\n            onErrorResult ||= handleMaybePromise(() => error, error => handleMaybePromise(() => reject(error), iteratorResult, abruptClose));\n            return onErrorResult;\n        };\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            const res$ = $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : fakePromise({ value: undefined, done: true });\n            return onEndWithValue ? res$.then(onEndWithValue) : res$;\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            if (abruptClose) {\n                return abruptClose(error);\n            }\n            return fakeRejectPromise(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\nfunction isFakePromise(value) {\n    return value?.[kFakePromise] === 'resolved';\n}\nfunction isFakeRejectPromise(value) {\n    return value?.[kFakePromise] === 'rejected';\n}\nexport function promiseLikeFinally(value, onFinally) {\n    if ('finally' in value) {\n        return value.finally(onFinally);\n    }\n    return value.then(res => {\n        const finallyRes = onFinally();\n        return isPromise(finallyRes) ? finallyRes.then(() => res) : res;\n    }, err => {\n        const finallyRes = onFinally();\n        if (isPromise(finallyRes)) {\n            return finallyRes.then(() => {\n                throw err;\n            });\n        }\n        else {\n            throw err;\n        }\n    });\n}\nexport function unfakePromise(promise) {\n    if (isFakePromise(promise)) {\n        return promise.__fakePromiseValue;\n    }\n    if (isFakeRejectPromise(promise)) {\n        throw promise.__fakeRejectError;\n    }\n    return promise;\n}\n","import { handleMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\nexport function isIterableObject(value) {\n    return value != null && typeof value === 'object' && Symbol.iterator in value;\n}\nexport function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport { isPromise };\nexport function promiseReduce(values, callbackFn, initialValue) {\n    let accumulator = initialValue;\n    for (const value of values) {\n        accumulator = handleMaybePromise(() => accumulator, resolved => callbackFn(resolved, value));\n    }\n    return accumulator;\n}\nexport function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { inspect } from 'cross-inspect';\nimport { isEnumType, isInputObjectType, isLeafType, isListType, isNonNullType, Kind, } from 'graphql';\nimport { astFromValueUntyped } from './astFromValueUntyped.js';\nimport { isIterableObject, isObjectLike } from './jsutils.js';\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using suggested GraphQLInputType. For example:\n *\n *     astFromValue(\"value\", GraphQLString)\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | BigInt        | Int                  |\n * | Unknown       | Enum Value           |\n * | null          | NullValue            |\n *\n */\nexport function astFromValue(value, type) {\n    if (isNonNullType(type)) {\n        const astValue = astFromValue(value, type.ofType);\n        if (astValue?.kind === Kind.NULL) {\n            return null;\n        }\n        return astValue;\n    }\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (isListType(type)) {\n        const itemType = type.ofType;\n        if (isIterableObject(value)) {\n            const valuesNodes = [];\n            for (const item of value) {\n                const itemNode = astFromValue(item, itemType);\n                if (itemNode != null) {\n                    valuesNodes.push(itemNode);\n                }\n            }\n            return { kind: Kind.LIST, values: valuesNodes };\n        }\n        return astFromValue(value, itemType);\n    }\n    // Populate the fields of the input object by creating ASTs from each value\n    // in the JavaScript object according to the fields in the input type.\n    if (isInputObjectType(type)) {\n        if (!isObjectLike(value)) {\n            return null;\n        }\n        const fieldNodes = [];\n        for (const field of Object.values(type.getFields())) {\n            const fieldValue = astFromValue(value[field.name], field.type);\n            if (fieldValue) {\n                fieldNodes.push({\n                    kind: Kind.OBJECT_FIELD,\n                    name: { kind: Kind.NAME, value: field.name },\n                    value: fieldValue,\n                });\n            }\n        }\n        return { kind: Kind.OBJECT, fields: fieldNodes };\n    }\n    if (isLeafType(type)) {\n        // Since value is an internally represented value, it must be serialized\n        // to an externally represented value before converting into an AST.\n        const serialized = type.serialize(value);\n        if (serialized == null) {\n            return null;\n        }\n        if (isEnumType(type)) {\n            return { kind: Kind.ENUM, value: serialized };\n        }\n        // ID types can use Int literals.\n        if (type.name === 'ID' &&\n            typeof serialized === 'string' &&\n            integerStringRegExp.test(serialized)) {\n            return { kind: Kind.INT, value: serialized };\n        }\n        return astFromValueUntyped(serialized);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n    console.assert(false, 'Unexpected input type: ' + inspect(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n","import { Kind } from 'graphql';\nexport function getDescriptionNode(obj) {\n    if (obj.astNode?.description) {\n        return {\n            ...obj.astNode.description,\n            block: true,\n        };\n    }\n    if (obj.description) {\n        return {\n            kind: Kind.STRING,\n            value: obj.description,\n            block: true,\n        };\n    }\n}\n","import { GraphQLError, versionInfo } from 'graphql';\nconst possibleGraphQLErrorProperties = [\n    'message',\n    'locations',\n    'path',\n    'nodes',\n    'source',\n    'positions',\n    'originalError',\n    'name',\n    'stack',\n    'extensions',\n];\nfunction isGraphQLErrorLike(error) {\n    return (error != null &&\n        typeof error === 'object' &&\n        Object.keys(error).every(key => possibleGraphQLErrorProperties.includes(key)));\n}\nexport function createGraphQLError(message, options) {\n    if (options?.originalError &&\n        !(options.originalError instanceof Error) &&\n        isGraphQLErrorLike(options.originalError)) {\n        options.originalError = createGraphQLError(options.originalError.message, options.originalError);\n    }\n    if (versionInfo.major >= 17) {\n        return new GraphQLError(message, options);\n    }\n    return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);\n}\nexport function relocatedError(originalError, path) {\n    return createGraphQLError(originalError.message, {\n        nodes: originalError.nodes,\n        source: originalError.source,\n        positions: originalError.positions,\n        path: path == null ? originalError.path : path,\n        originalError,\n        extensions: originalError.extensions,\n    });\n}\n","import { inspect } from 'cross-inspect';\nimport { isNonNullType, Kind, print, valueFromAST, } from 'graphql';\nimport { createGraphQLError } from './errors.js';\nimport { hasOwnProperty } from './jsutils.js';\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(def, node, variableValues = {}) {\n    const coercedValues = {};\n    const argumentNodes = node.arguments ?? [];\n    const argNodeMap = argumentNodes.reduce((prev, arg) => ({\n        ...prev,\n        [arg.name.value]: arg,\n    }), {});\n    for (const { name, type: argType, defaultValue } of def.args) {\n        const argumentNode = argNodeMap[name];\n        if (!argumentNode) {\n            if (defaultValue !== undefined) {\n                coercedValues[name] = defaultValue;\n            }\n            else if (isNonNullType(argType)) {\n                throw createGraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', {\n                    nodes: [node],\n                });\n            }\n            continue;\n        }\n        const valueNode = argumentNode.value;\n        let isNull = valueNode.kind === Kind.NULL;\n        if (valueNode.kind === Kind.VARIABLE) {\n            const variableName = valueNode.name.value;\n            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {\n                if (defaultValue !== undefined) {\n                    coercedValues[name] = defaultValue;\n                }\n                else if (isNonNullType(argType)) {\n                    throw createGraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n                        `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, {\n                        nodes: [valueNode],\n                    });\n                }\n                continue;\n            }\n            isNull = variableValues[variableName] == null;\n        }\n        if (isNull && isNonNullType(argType)) {\n            throw createGraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', {\n                nodes: [valueNode],\n            });\n        }\n        const coercedValue = valueFromAST(valueNode, argType, variableValues);\n        if (coercedValue === undefined) {\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\n            // execution. This is a runtime check to ensure execution does not\n            // continue with an invalid argument value.\n            throw createGraphQLError(`Argument \"${name}\" has invalid value ${print(valueNode)}.`, {\n                nodes: [valueNode],\n            });\n        }\n        coercedValues[name] = coercedValue;\n    }\n    return coercedValues;\n}\n","export function memoize1(fn) {\n    const memoize1cache = new WeakMap();\n    return function memoized(a1) {\n        const cachedValue = memoize1cache.get(a1);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1);\n            memoize1cache.set(a1, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize2(fn) {\n    const memoize2cache = new WeakMap();\n    return function memoized(a1, a2) {\n        let cache2 = memoize2cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2cache.set(a1, cache2);\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize3(fn) {\n    const memoize3Cache = new WeakMap();\n    return function memoized(a1, a2, a3) {\n        let cache2 = memoize3Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize3Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        const cachedValue = cache3.get(a3);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize4(fn) {\n    const memoize4Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize4Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize4Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cache4 = cache3.get(a3);\n        if (!cache4) {\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cachedValue = cache4.get(a4);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize5(fn) {\n    const memoize5Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4, a5) {\n        let cache2 = memoize5Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize5Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache4 = cache3.get(a3);\n        if (!cache4) {\n            cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache5 = cache4.get(a4);\n        if (!cache5) {\n            cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        const cachedValue = cache5.get(a5);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize2of4(fn) {\n    const memoize2of4cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize2of4cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2of4cache.set(a1, cache2);\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize2of5(fn) {\n    const memoize2of4cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4, a5) {\n        let cache2 = memoize2of4cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2of4cache.set(a1, cache2);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\n","import { valueFromAST, valueFromASTUntyped } from 'graphql';\nimport { getArgumentValues } from './getArgumentValues.js';\nimport { memoize1 } from './memoize.js';\nexport function getDirectiveExtensions(directableObj, schema, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = {};\n    if (directableObj.extensions) {\n        let directivesInExtensions = directableObj.extensions;\n        for (const pathSegment of pathToDirectivesInExtensions) {\n            directivesInExtensions = directivesInExtensions?.[pathSegment];\n        }\n        if (directivesInExtensions != null) {\n            for (const directiveNameProp in directivesInExtensions) {\n                const directiveObjs = directivesInExtensions[directiveNameProp];\n                const directiveName = directiveNameProp;\n                if (Array.isArray(directiveObjs)) {\n                    for (const directiveObj of directiveObjs) {\n                        let existingDirectiveExtensions = directiveExtensions[directiveName];\n                        if (!existingDirectiveExtensions) {\n                            existingDirectiveExtensions = [];\n                            directiveExtensions[directiveName] = existingDirectiveExtensions;\n                        }\n                        existingDirectiveExtensions.push(directiveObj);\n                    }\n                }\n                else {\n                    let existingDirectiveExtensions = directiveExtensions[directiveName];\n                    if (!existingDirectiveExtensions) {\n                        existingDirectiveExtensions = [];\n                        directiveExtensions[directiveName] = existingDirectiveExtensions;\n                    }\n                    existingDirectiveExtensions.push(directiveObjs);\n                }\n            }\n        }\n    }\n    const memoizedStringify = memoize1(obj => JSON.stringify(obj));\n    const astNodes = [];\n    if (directableObj.astNode) {\n        astNodes.push(directableObj.astNode);\n    }\n    if (directableObj.extensionASTNodes) {\n        astNodes.push(...directableObj.extensionASTNodes);\n    }\n    for (const astNode of astNodes) {\n        if (astNode.directives?.length) {\n            for (const directive of astNode.directives) {\n                const directiveName = directive.name.value;\n                let existingDirectiveExtensions = directiveExtensions[directiveName];\n                if (!existingDirectiveExtensions) {\n                    existingDirectiveExtensions = [];\n                    directiveExtensions[directiveName] = existingDirectiveExtensions;\n                }\n                const directiveInSchema = schema?.getDirective(directiveName);\n                let value = {};\n                if (directiveInSchema) {\n                    value = getArgumentValues(directiveInSchema, directive);\n                }\n                if (directive.arguments) {\n                    for (const argNode of directive.arguments) {\n                        const argName = argNode.name.value;\n                        if (value[argName] == null) {\n                            const argInDirective = directiveInSchema?.args.find(arg => arg.name === argName);\n                            if (argInDirective) {\n                                value[argName] = valueFromAST(argNode.value, argInDirective.type);\n                            }\n                        }\n                        if (value[argName] == null) {\n                            value[argName] = valueFromASTUntyped(argNode.value);\n                        }\n                    }\n                }\n                if (astNodes.length > 0 && existingDirectiveExtensions.length > 0) {\n                    const valStr = memoizedStringify(value);\n                    if (existingDirectiveExtensions.some(val => memoizedStringify(val) === valStr)) {\n                        continue;\n                    }\n                }\n                existingDirectiveExtensions.push(value);\n            }\n        }\n    }\n    return directiveExtensions;\n}\n","import { getDirectiveExtensions } from './getDirectiveExtensions.js';\nexport function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, undefined, pathToDirectivesInExtensions);\n    return Object.entries(directiveExtensions)\n        .map(([directiveName, directiveArgsArr]) => directiveArgsArr?.map(directiveArgs => ({\n        name: directiveName,\n        args: directiveArgs,\n    })))\n        .flat(Infinity)\n        .filter(Boolean);\n}\nexport function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, undefined, pathToDirectivesInExtensions);\n    return directiveExtensions[directiveName];\n}\nexport function getDirectives(schema, node, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, schema, pathToDirectivesInExtensions);\n    return Object.entries(directiveExtensions)\n        .map(([directiveName, directiveArgsArr]) => directiveArgsArr?.map(directiveArgs => ({\n        name: directiveName,\n        args: directiveArgs,\n    })))\n        .flat(Infinity)\n        .filter(Boolean);\n}\nexport function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, schema, pathToDirectivesInExtensions);\n    return directiveExtensions[directiveName];\n}\n","import { parse } from 'graphql';\nconst URL_REGEXP = /^(https?|wss?|file):\\/\\//;\n/**\n * Checks if the given string is a valid URL.\n *\n * @param str - The string to validate as a URL\n * @returns A boolean indicating whether the string is a valid URL\n *\n * @remarks\n * This function first attempts to use the `URL.canParse` method if available.\n * If not, it falls back to creating a new `URL` object to validate the string.\n */\nexport function isUrl(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    if (!URL_REGEXP.test(str)) {\n        return false;\n    }\n    if (URL.canParse) {\n        return URL.canParse(str);\n    }\n    try {\n        const url = new URL(str);\n        return !!url;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexport const asArray = (fns) => (Array.isArray(fns) ? fns : fns ? [fns] : []);\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\n/**\n * Determines if a given input is a valid GraphQL document string.\n *\n * @param str - The input to validate as a GraphQL document\n * @returns A boolean indicating whether the input is a valid GraphQL document string\n *\n * @remarks\n * This function performs several validation checks:\n * - Ensures the input is a string\n * - Filters out strings with invalid document extensions\n * - Excludes URLs\n * - Attempts to parse the string as a GraphQL document\n *\n * @throws {Error} If the document fails to parse and is empty except GraphQL comments\n */\nexport function isDocumentString(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (invalidDocRegex.test(str) || isUrl(str)) {\n        return false;\n    }\n    try {\n        parse(str);\n        return true;\n    }\n    catch (e) {\n        if (!e.message.includes('EOF') &&\n            str.replace(/(\\#[^*]*)/g, '').trim() !== '' &&\n            str.includes(' ')) {\n            throw new Error(`Failed to parse the GraphQL document. ${e.message}\\n${str}`);\n        }\n    }\n    return false;\n}\nconst invalidPathRegex = /[!%^<>`\\n]/;\n/**\n * Checkes whether the `str` contains any path illegal characters.\n *\n * A string may sometimes look like a path but is not (like an SDL of a simple\n * GraphQL schema). To make sure we don't yield false-positives in such cases,\n * we disallow new lines in paths (even though most Unix systems support new\n * lines in file names).\n */\nexport function isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nexport function compareStrings(a, b) {\n    if (String(a) < String(b)) {\n        return -1;\n    }\n    if (String(a) > String(b)) {\n        return 1;\n    }\n    return 0;\n}\nexport function nodeToString(a) {\n    let name;\n    if ('alias' in a) {\n        name = a.alias?.value;\n    }\n    if (name == null && 'name' in a) {\n        name = a.name?.value;\n    }\n    if (name == null) {\n        name = a.kind;\n    }\n    return name;\n}\nexport function compareNodes(a, b, customFn) {\n    const aStr = nodeToString(a);\n    const bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\nexport function isSome(input) {\n    return input != null;\n}\nexport function assertSome(input, message = 'Value should be something') {\n    if (input == null) {\n        throw new Error(message);\n    }\n}\n","import { createGraphQLError } from './errors.js';\nimport { memoize1 } from './memoize.js';\nexport function getDefinedRootType(schema, operation, nodes) {\n    const rootTypeMap = getRootTypeMap(schema);\n    const rootType = rootTypeMap.get(operation);\n    if (rootType == null) {\n        throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {\n            nodes,\n        });\n    }\n    return rootType;\n}\nexport const getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n    const rootTypes = getRootTypes(schema);\n    return new Set([...rootTypes].map(type => type.name));\n});\nexport const getRootTypes = memoize1(function getRootTypes(schema) {\n    const rootTypeMap = getRootTypeMap(schema);\n    return new Set(rootTypeMap.values());\n});\nexport const getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n    const rootTypeMap = new Map();\n    const queryType = schema.getQueryType();\n    if (queryType) {\n        rootTypeMap.set('query', queryType);\n    }\n    const mutationType = schema.getMutationType();\n    if (mutationType) {\n        rootTypeMap.set('mutation', mutationType);\n    }\n    const subscriptionType = schema.getSubscriptionType();\n    if (subscriptionType) {\n        rootTypeMap.set('subscription', subscriptionType);\n    }\n    return rootTypeMap;\n});\n","import { GraphQLDeprecatedDirective, isEnumType, isInputObjectType, isInterfaceType, isIntrospectionType, isObjectType, isScalarType, isSpecifiedDirective, isSpecifiedScalarType, isUnionType, Kind, print, } from 'graphql';\nimport { astFromType } from './astFromType.js';\nimport { astFromValue } from './astFromValue.js';\nimport { astFromValueUntyped } from './astFromValueUntyped.js';\nimport { getDescriptionNode } from './descriptionFromObject.js';\nimport { getDirectivesInExtensions, } from './get-directives.js';\nimport { isSome } from './helpers.js';\nimport { getRootTypeMap } from './rootTypes.js';\nexport function getDocumentNodeFromSchema(schema, options = {}) {\n    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n    const typesMap = schema.getTypeMap();\n    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n    const definitions = schemaNode != null ? [schemaNode] : [];\n    const directives = schema.getDirectives();\n    for (const directive of directives) {\n        if (isSpecifiedDirective(directive)) {\n            continue;\n        }\n        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n    }\n    for (const typeName in typesMap) {\n        const type = typesMap[typeName];\n        const isPredefinedScalar = isSpecifiedScalarType(type);\n        const isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (isObjectType(type)) {\n            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInterfaceType(type)) {\n            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isUnionType(type)) {\n            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInputObjectType(type)) {\n            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isEnumType(type)) {\n            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isScalarType(type)) {\n            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n        }\n        else {\n            throw new Error(`Unknown type ${type}.`);\n        }\n    }\n    return {\n        kind: Kind.DOCUMENT,\n        definitions,\n    };\n}\n// this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\nexport function printSchemaWithDirectives(schema, options = {}) {\n    const documentNode = getDocumentNodeFromSchema(schema, options);\n    return print(documentNode);\n}\nexport function astFromSchema(schema, pathToDirectivesInExtensions) {\n    const operationTypeMap = new Map([\n        ['query', undefined],\n        ['mutation', undefined],\n        ['subscription', undefined],\n    ]);\n    const nodes = [];\n    if (schema.astNode != null) {\n        nodes.push(schema.astNode);\n    }\n    if (schema.extensionASTNodes != null) {\n        for (const extensionASTNode of schema.extensionASTNodes) {\n            nodes.push(extensionASTNode);\n        }\n    }\n    for (const node of nodes) {\n        if (node.operationTypes) {\n            for (const operationTypeDefinitionNode of node.operationTypes) {\n                operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n            }\n        }\n    }\n    const rootTypeMap = getRootTypeMap(schema);\n    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n        const rootType = rootTypeMap.get(operationTypeNode);\n        if (rootType != null) {\n            const rootTypeAST = astFromType(rootType);\n            if (operationTypeDefinitionNode != null) {\n                operationTypeDefinitionNode.type = rootTypeAST;\n            }\n            else {\n                operationTypeMap.set(operationTypeNode, {\n                    kind: Kind.OPERATION_TYPE_DEFINITION,\n                    operation: operationTypeNode,\n                    type: rootTypeAST,\n                });\n            }\n        }\n    }\n    const operationTypes = [...operationTypeMap.values()].filter(isSome);\n    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n    if (!operationTypes.length && !directives.length) {\n        return null;\n    }\n    const schemaNode = {\n        kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,\n        operationTypes,\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n    const descriptionNode = getDescriptionNode(schema);\n    if (descriptionNode) {\n        schemaNode.description = descriptionNode;\n    }\n    return schemaNode;\n}\nexport function astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.DIRECTIVE_DEFINITION,\n        description: getDescriptionNode(directive),\n        name: {\n            kind: Kind.NAME,\n            value: directive.name,\n        },\n        arguments: directive.args?.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        repeatable: directive.isRepeatable,\n        locations: directive.locations?.map(location => ({\n            kind: Kind.NAME,\n            value: location,\n        })) || [],\n    };\n}\nexport function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    let directiveNodesBesidesDeprecatedAndSpecifiedBy = [];\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    let deprecatedDirectiveNode = null;\n    let specifiedByDirectiveNode = null;\n    if (directives != null) {\n        directiveNodesBesidesDeprecatedAndSpecifiedBy = directives.filter(directive => directive.name.value !== 'deprecated' && directive.name.value !== 'specifiedBy');\n        if (entity.deprecationReason != null) {\n            deprecatedDirectiveNode = directives.filter(directive => directive.name.value === 'deprecated')?.[0];\n        }\n        if (entity.specifiedByUrl != null || entity.specifiedByURL != null) {\n            specifiedByDirectiveNode = directives.filter(directive => directive.name.value === 'specifiedBy')?.[0];\n        }\n    }\n    if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {\n        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n    }\n    if (entity.specifiedByUrl != null ||\n        (entity.specifiedByURL != null && specifiedByDirectiveNode == null)) {\n        const specifiedByValue = entity.specifiedByUrl || entity.specifiedByURL;\n        const specifiedByArgs = {\n            url: specifiedByValue,\n        };\n        specifiedByDirectiveNode = makeDirectiveNode('specifiedBy', specifiedByArgs);\n    }\n    if (deprecatedDirectiveNode != null) {\n        directiveNodesBesidesDeprecatedAndSpecifiedBy.push(deprecatedDirectiveNode);\n    }\n    if (specifiedByDirectiveNode != null) {\n        directiveNodesBesidesDeprecatedAndSpecifiedBy.push(specifiedByDirectiveNode);\n    }\n    return directiveNodesBesidesDeprecatedAndSpecifiedBy;\n}\nexport function astFromArg(arg, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: getDescriptionNode(arg),\n        name: {\n            kind: Kind.NAME,\n            value: arg.name,\n        },\n        type: astFromType(arg.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        defaultValue: arg.defaultValue !== undefined\n            ? (astFromValue(arg.defaultValue, arg.type) ?? undefined)\n            : undefined,\n        directives: getDirectiveNodes(arg, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n    const node = {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n    if ('getInterfaces' in type) {\n        node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n    }\n    return node;\n}\nexport function astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.UNION_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n        types: type.getTypes().map(type => astFromType(type)),\n    };\n}\nexport function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.ENUM_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n    const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n    const directives = makeDirectiveNodes(schema, directivesInExtensions);\n    const specifiedByValue = (type['specifiedByUrl'] ||\n        type['specifiedByURL']);\n    if (specifiedByValue &&\n        !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n        const specifiedByArgs = {\n            url: specifiedByValue,\n        };\n        directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n    }\n    return {\n        kind: Kind.SCALAR_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n}\nexport function astFromField(field, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.FIELD_DEFINITION,\n        description: getDescriptionNode(field),\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromInputField(field, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: getDescriptionNode(field),\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n        defaultValue: astFromValue(field.defaultValue, field.type) ?? undefined,\n    };\n}\nexport function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.ENUM_VALUE_DEFINITION,\n        description: getDescriptionNode(value),\n        name: {\n            kind: Kind.NAME,\n            value: value.name,\n        },\n        directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function makeDeprecatedDirective(deprecationReason) {\n    return makeDirectiveNode('deprecated', { reason: deprecationReason }, GraphQLDeprecatedDirective);\n}\nexport function makeDirectiveNode(name, args, directive) {\n    const directiveArguments = [];\n    for (const argName in args) {\n        const argValue = args[argName];\n        let value;\n        if (directive != null) {\n            const arg = directive.args.find(arg => arg.name === argName);\n            if (arg) {\n                value = astFromValue(argValue, arg.type);\n            }\n        }\n        if (value == null) {\n            value = astFromValueUntyped(argValue);\n        }\n        if (value != null) {\n            directiveArguments.push({\n                kind: Kind.ARGUMENT,\n                name: {\n                    kind: Kind.NAME,\n                    value: argName,\n                },\n                value,\n            });\n        }\n    }\n    return {\n        kind: Kind.DIRECTIVE,\n        name: {\n            kind: Kind.NAME,\n            value: name,\n        },\n        arguments: directiveArguments,\n    };\n}\nexport function makeDirectiveNodes(schema, directiveValues) {\n    const directiveNodes = [];\n    for (const { name, args } of directiveValues) {\n        const directive = schema?.getDirective(name);\n        directiveNodes.push(makeDirectiveNode(name, args, directive));\n    }\n    return directiveNodes;\n}\n","import { Kind } from 'graphql';\nexport function isDocumentNode(object) {\n    return object && typeof object === 'object' && 'kind' in object && object.kind === Kind.DOCUMENT;\n}\n","import { isSome } from '@graphql-tools/utils';\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction isRepeatableDirective(directive, directives) {\n    return !!directives?.[directive.name.value]?.repeatable;\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives, definitions) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(isSome);\n}\nexport function mergeDirectives(d1 = [], d2 = [], config, directives) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext], directives);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive) &&\n            !isRepeatableDirective(directive, directives)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nexport function mergeDirective(node, existingNode) {\n    if (existingNode) {\n        return {\n            ...node,\n            arguments: deduplicateLists(existingNode.arguments || [], node.arguments || [], (arg, existingArgs) => !nameAlreadyExists(arg.name, existingArgs.map(a => a.name))),\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n","import { compareNodes } from '@graphql-tools/utils';\nimport { mergeDirectives } from './directives.js';\nexport function mergeEnumValues(first, second, config, directives) {\n    if (config?.consistentEnumMerge) {\n        const reversed = [];\n        if (first) {\n            reversed.push(...first);\n        }\n        first = second;\n        second = reversed;\n    }\n    const enumValueMap = new Map();\n    if (first) {\n        for (const firstValue of first) {\n            enumValueMap.set(firstValue.name.value, firstValue);\n        }\n    }\n    if (second) {\n        for (const secondValue of second) {\n            const enumValue = secondValue.name.value;\n            if (enumValueMap.has(enumValue)) {\n                const firstValue = enumValueMap.get(enumValue);\n                firstValue.description = secondValue.description || firstValue.description;\n                firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives, directives);\n            }\n            else {\n                enumValueMap.set(enumValue, secondValue);\n            }\n        }\n    }\n    const result = [...enumValueMap.values()];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n","import { Kind, } from 'graphql';\nimport { mergeDirectives } from './directives.js';\nimport { mergeEnumValues } from './enum-values.js';\nexport function mergeEnum(e1, e2, config, directives) {\n    if (e2) {\n        return {\n            name: e1.name,\n            description: e1['description'] || e2['description'],\n            kind: config?.convertExtensions ||\n                e1.kind === 'EnumTypeDefinition' ||\n                e2.kind === 'EnumTypeDefinition'\n                ? 'EnumTypeDefinition'\n                : 'EnumTypeExtension',\n            loc: e1.loc,\n            directives: mergeDirectives(e1.directives, e2.directives, config, directives),\n            values: mergeEnumValues(e1.values, e2.values, config),\n        };\n    }\n    return config?.convertExtensions\n        ? {\n            ...e1,\n            kind: Kind.ENUM_TYPE_DEFINITION,\n        }\n        : e1;\n}\n","import { compareNodes, isSome } from '@graphql-tools/utils';\nexport function mergeArguments(args1, args2, config) {\n    const result = deduplicateArguments([...args2, ...args1].filter(isSome), config);\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\nfunction deduplicateArguments(args, config) {\n    return args.reduce((acc, current) => {\n        const dupIndex = acc.findIndex(arg => arg.name.value === current.name.value);\n        if (dupIndex === -1) {\n            return acc.concat([current]);\n        }\n        else if (!config?.reverseArguments) {\n            acc[dupIndex] = current;\n        }\n        return acc;\n    }, []);\n}\n","import { Kind, Source } from 'graphql';\nexport function isStringTypes(types) {\n    return typeof types === 'string';\n}\nexport function isSourceTypes(types) {\n    return types instanceof Source;\n}\nexport function extractType(type) {\n    let visitedType = type;\n    while (visitedType.kind === Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n        visitedType = visitedType.type;\n    }\n    return visitedType;\n}\nexport function isWrappingTypeNode(type) {\n    return type.kind !== Kind.NAMED_TYPE;\n}\nexport function isListTypeNode(type) {\n    return type.kind === Kind.LIST_TYPE;\n}\nexport function isNonNullTypeNode(type) {\n    return type.kind === Kind.NON_NULL_TYPE;\n}\nexport function printTypeNode(type) {\n    if (isListTypeNode(type)) {\n        return `[${printTypeNode(type.type)}]`;\n    }\n    if (isNonNullTypeNode(type)) {\n        return `${printTypeNode(type.type)}!`;\n    }\n    return type.name.value;\n}\nexport var CompareVal;\n(function (CompareVal) {\n    CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n    CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n    CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(CompareVal || (CompareVal = {}));\nexport function defaultStringComparator(a, b) {\n    if (a == null && b == null) {\n        return CompareVal.A_EQUALS_B;\n    }\n    if (a == null) {\n        return CompareVal.A_SMALLER_THAN_B;\n    }\n    if (b == null) {\n        return CompareVal.A_GREATER_THAN_B;\n    }\n    if (a < b)\n        return CompareVal.A_SMALLER_THAN_B;\n    if (a > b)\n        return CompareVal.A_GREATER_THAN_B;\n    return CompareVal.A_EQUALS_B;\n}\n","import { compareNodes } from '@graphql-tools/utils';\nimport { mergeArguments } from './arguments.js';\nimport { mergeDirectives } from './directives.js';\nimport { extractType, isListTypeNode, isNonNullTypeNode, isWrappingTypeNode, printTypeNode, } from './utils.js';\nfunction fieldAlreadyExists(fieldsArr, otherField) {\n    const resultIndex = fieldsArr.findIndex(field => field.name.value === otherField.name.value);\n    return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];\n}\nexport function mergeFields(type, f1, f2, config, directives) {\n    const result = [];\n    if (f2 != null) {\n        result.push(...f2);\n    }\n    if (f1 != null) {\n        for (const field of f1) {\n            const [existing, existingIndex] = fieldAlreadyExists(result, field);\n            if (existing && !config?.ignoreFieldConflicts) {\n                const newField = (config?.onFieldTypeConflict &&\n                    config.onFieldTypeConflict(existing, field, type, config?.throwOnConflict)) ||\n                    preventConflicts(type, existing, field, config?.throwOnConflict);\n                newField.arguments = mergeArguments(field['arguments'] || [], existing['arguments'] || [], config);\n                newField.directives = mergeDirectives(field.directives, existing.directives, config, directives);\n                newField.description = field.description || existing.description;\n                result[existingIndex] = newField;\n            }\n            else {\n                result.push(field);\n            }\n        }\n    }\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    if (config && config.exclusions) {\n        const exclusions = config.exclusions;\n        return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = printTypeNode(a.type);\n    const bType = printTypeNode(b.type);\n    if (aType !== bType) {\n        const t1 = extractType(a.type);\n        const t2 = extractType(b.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${b.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n        if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {\n            throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n        }\n    }\n    if (isNonNullTypeNode(b.type) && !isNonNullTypeNode(a.type)) {\n        a.type = b.type;\n    }\n    return a;\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if (isNonNullTypeNode(newType)) {\n        const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if (isNonNullTypeNode(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if (isListTypeNode(oldType)) {\n        return ((isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            (isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n","import { Kind, } from 'graphql';\nimport { mergeDirectives } from './directives.js';\nimport { mergeFields } from './fields.js';\nexport function mergeInputType(node, existingNode, config, directives) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: config?.convertExtensions ||\n                    node.kind === 'InputObjectTypeDefinition' ||\n                    existingNode.kind === 'InputObjectTypeDefinition'\n                    ? 'InputObjectTypeDefinition'\n                    : 'InputObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config, directives),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n","import { compareNodes } from '@graphql-tools/utils';\nfunction alreadyExists(arr, other) {\n    return !!arr.find(i => i.name.value === other.name.value);\n}\nexport function mergeNamedTypeArray(first = [], second = [], config = {}) {\n    const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n","import { Kind, } from 'graphql';\nimport { mergeDirectives } from './directives.js';\nimport { mergeFields } from './fields.js';\nimport { mergeNamedTypeArray } from './merge-named-type-array.js';\nexport function mergeInterface(node, existingNode, config, directives) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: config?.convertExtensions ||\n                    node.kind === 'InterfaceTypeDefinition' ||\n                    existingNode.kind === 'InterfaceTypeDefinition'\n                    ? 'InterfaceTypeDefinition'\n                    : 'InterfaceTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config, directives),\n                directives: mergeDirectives(node.directives, existingNode.directives, config, directives),\n                interfaces: node['interfaces']\n                    ? mergeNamedTypeArray(node['interfaces'], existingNode['interfaces'], config)\n                    : undefined,\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: Kind.INTERFACE_TYPE_DEFINITION,\n        }\n        : node;\n}\n","import { Kind, } from 'graphql';\nimport { mergeDirectives } from './directives.js';\nexport function mergeScalar(node, existingNode, config, directives) {\n    if (existingNode) {\n        return {\n            name: node.name,\n            description: node['description'] || existingNode['description'],\n            kind: config?.convertExtensions ||\n                node.kind === 'ScalarTypeDefinition' ||\n                existingNode.kind === 'ScalarTypeDefinition'\n                ? 'ScalarTypeDefinition'\n                : 'ScalarTypeExtension',\n            loc: node.loc,\n            directives: mergeDirectives(node.directives, existingNode.directives, config, directives),\n        };\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: Kind.SCALAR_TYPE_DEFINITION,\n        }\n        : node;\n}\n","import { Kind, } from 'graphql';\nimport { mergeDirectives } from './directives.js';\nexport const DEFAULT_OPERATION_TYPE_NAME_MAP = {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription',\n};\nfunction mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {\n    const finalOpNodeList = [];\n    for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n        const opNode = opNodeList.find(n => n.operation === opNodeType) ||\n            existingOpNodeList.find(n => n.operation === opNodeType);\n        if (opNode) {\n            finalOpNodeList.push(opNode);\n        }\n    }\n    return finalOpNodeList;\n}\nexport function mergeSchemaDefs(node, existingNode, config, directives) {\n    if (existingNode) {\n        return {\n            kind: node.kind === Kind.SCHEMA_DEFINITION || existingNode.kind === Kind.SCHEMA_DEFINITION\n                ? Kind.SCHEMA_DEFINITION\n                : Kind.SCHEMA_EXTENSION,\n            description: node['description'] || existingNode['description'],\n            directives: mergeDirectives(node.directives, existingNode.directives, config, directives),\n            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes),\n        };\n    }\n    return (config?.convertExtensions\n        ? {\n            ...node,\n            kind: Kind.SCHEMA_DEFINITION,\n        }\n        : node);\n}\n","import { Kind, } from 'graphql';\nimport { mergeDirectives } from './directives.js';\nimport { mergeFields } from './fields.js';\nimport { mergeNamedTypeArray } from './merge-named-type-array.js';\nexport function mergeType(node, existingNode, config, directives) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: config?.convertExtensions ||\n                    node.kind === 'ObjectTypeDefinition' ||\n                    existingNode.kind === 'ObjectTypeDefinition'\n                    ? 'ObjectTypeDefinition'\n                    : 'ObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config, directives),\n                directives: mergeDirectives(node.directives, existingNode.directives, config, directives),\n                interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: Kind.OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n","import { Kind, } from 'graphql';\nimport { mergeDirectives } from './directives.js';\nimport { mergeNamedTypeArray } from './merge-named-type-array.js';\nexport function mergeUnion(first, second, config, directives) {\n    if (second) {\n        return {\n            name: first.name,\n            description: first['description'] || second['description'],\n            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n            directives: mergeDirectives(first.directives, second.directives, config, directives),\n            kind: config?.convertExtensions ||\n                first.kind === 'UnionTypeDefinition' ||\n                second.kind === 'UnionTypeDefinition'\n                ? Kind.UNION_TYPE_DEFINITION\n                : Kind.UNION_TYPE_EXTENSION,\n            loc: first.loc,\n            types: mergeNamedTypeArray(first.types, second.types, config),\n        };\n    }\n    return config?.convertExtensions\n        ? {\n            ...first,\n            kind: Kind.UNION_TYPE_DEFINITION,\n        }\n        : first;\n}\n","import { Kind, } from 'graphql';\nimport { collectComment } from '@graphql-tools/utils';\nimport { mergeDirective } from './directives.js';\nimport { mergeEnum } from './enum.js';\nimport { mergeInputType } from './input-type.js';\nimport { mergeInterface } from './interface.js';\nimport { mergeScalar } from './scalar.js';\nimport { mergeSchemaDefs } from './schema-def.js';\nimport { mergeType } from './type.js';\nimport { mergeUnion } from './union.js';\nexport const schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\nexport function isNamedDefinitionNode(definitionNode) {\n    return 'name' in definitionNode;\n}\nexport function mergeGraphQLNodes(nodes, config, directives = {}) {\n    const mergedResultMap = directives;\n    for (const nodeDefinition of nodes) {\n        if (isNamedDefinitionNode(nodeDefinition)) {\n            const name = nodeDefinition.name?.value;\n            if (config?.commentDescriptions) {\n                collectComment(nodeDefinition);\n            }\n            if (name == null) {\n                continue;\n            }\n            if (config?.exclusions?.includes(name + '.*') || config?.exclusions?.includes(name)) {\n                delete mergedResultMap[name];\n            }\n            else {\n                switch (nodeDefinition.kind) {\n                    case Kind.OBJECT_TYPE_DEFINITION:\n                    case Kind.OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case Kind.ENUM_TYPE_DEFINITION:\n                    case Kind.ENUM_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case Kind.UNION_TYPE_DEFINITION:\n                    case Kind.UNION_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case Kind.SCALAR_TYPE_DEFINITION:\n                    case Kind.SCALAR_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n                    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case Kind.INTERFACE_TYPE_DEFINITION:\n                    case Kind.INTERFACE_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case Kind.DIRECTIVE_DEFINITION:\n                        if (mergedResultMap[name]) {\n                            const isInheritedFromPrototype = name in {}; // i.e. toString\n                            if (isInheritedFromPrototype) {\n                                if (!isASTNode(mergedResultMap[name])) {\n                                    mergedResultMap[name] = undefined;\n                                }\n                            }\n                        }\n                        mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);\n                        break;\n                }\n            }\n        }\n        else if (nodeDefinition.kind === Kind.SCHEMA_DEFINITION ||\n            nodeDefinition.kind === Kind.SCHEMA_EXTENSION) {\n            mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);\n        }\n    }\n    return mergedResultMap;\n}\nfunction isASTNode(node) {\n    return (node != null && typeof node === 'object' && 'kind' in node && typeof node.kind === 'string');\n}\n","import { isDefinitionNode, isSchema, Kind, parse, } from 'graphql';\nimport { getDocumentNodeFromSchema, isDocumentNode, printWithComments, resetComments, } from '@graphql-tools/utils';\nimport { mergeGraphQLNodes, schemaDefSymbol } from './merge-nodes.js';\nimport { DEFAULT_OPERATION_TYPE_NAME_MAP } from './schema-def.js';\nimport { defaultStringComparator, isSourceTypes, isStringTypes } from './utils.js';\nexport function mergeTypeDefs(typeSource, config) {\n    resetComments();\n    const doc = {\n        kind: Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(typeSource, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config?.commentDescriptions) {\n        result = printWithComments(doc);\n    }\n    else {\n        result = doc;\n    }\n    resetComments();\n    return result;\n}\nfunction visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = new Set()) {\n    if (typeSource && !visitedTypeSources.has(typeSource)) {\n        visitedTypeSources.add(typeSource);\n        if (typeof typeSource === 'function') {\n            visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else if (Array.isArray(typeSource)) {\n            for (const type of typeSource) {\n                visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);\n            }\n        }\n        else if (isSchema(typeSource)) {\n            const documentNode = getDocumentNodeFromSchema(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {\n            const documentNode = parse(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else if (typeof typeSource === 'object' && isDefinitionNode(typeSource)) {\n            if (typeSource.kind === Kind.DIRECTIVE_DEFINITION) {\n                allDirectives.push(typeSource);\n            }\n            else {\n                allNodes.push(typeSource);\n            }\n        }\n        else if (isDocumentNode(typeSource)) {\n            visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else {\n            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n        }\n    }\n    return { allDirectives, allNodes };\n}\nexport function mergeGraphQLTypes(typeSource, config) {\n    resetComments();\n    const { allDirectives, allNodes } = visitTypeSources(typeSource, config);\n    const mergedDirectives = mergeGraphQLNodes(allDirectives, config);\n    const mergedNodes = mergeGraphQLNodes(allNodes, config, mergedDirectives);\n    if (config?.useSchemaDefinition) {\n        // XXX: right now we don't handle multiple schema definitions\n        const schemaDef = mergedNodes[schemaDefSymbol] || {\n            kind: Kind.SCHEMA_DEFINITION,\n            operationTypes: [],\n        };\n        const operationTypes = schemaDef.operationTypes;\n        for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n            const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n            if (!opTypeDefNode) {\n                const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n                const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n                    operationTypes.push({\n                        kind: Kind.OPERATION_TYPE_DEFINITION,\n                        type: {\n                            kind: Kind.NAMED_TYPE,\n                            name: existingPossibleRootType.name,\n                        },\n                        operation: opTypeDefNodeType,\n                    });\n                }\n            }\n        }\n        if (schemaDef?.operationTypes?.length != null && schemaDef.operationTypes.length > 0) {\n            mergedNodes[schemaDefSymbol] = schemaDef;\n        }\n    }\n    if (config?.forceSchemaDefinition && !mergedNodes[schemaDefSymbol]?.operationTypes?.length) {\n        mergedNodes[schemaDefSymbol] = {\n            kind: Kind.SCHEMA_DEFINITION,\n            operationTypes: [\n                {\n                    kind: Kind.OPERATION_TYPE_DEFINITION,\n                    operation: 'query',\n                    type: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: 'Query',\n                        },\n                    },\n                },\n            ],\n        };\n    }\n    const mergedNodeDefinitions = Object.values(mergedNodes);\n    if (config?.sort) {\n        const sortFn = typeof config.sort === 'function' ? config.sort : defaultStringComparator;\n        mergedNodeDefinitions.sort((a, b) => sortFn(a.name?.value, b.name?.value));\n    }\n    return mergedNodeDefinitions;\n}\n","import { isSome } from './helpers.js';\nexport function mergeDeep(sources, respectPrototype = false, respectArrays = false, respectArrayLength = false) {\n    let expectedLength;\n    let allArrays = true;\n    const areArraysInTheSameLength = sources.every(source => {\n        if (Array.isArray(source)) {\n            if (expectedLength === undefined) {\n                expectedLength = source.length;\n                return true;\n            }\n            else if (expectedLength === source.length) {\n                return true;\n            }\n        }\n        else {\n            allArrays = false;\n        }\n        return false;\n    });\n    if (respectArrayLength && areArraysInTheSameLength) {\n        return new Array(expectedLength).fill(null).map((_, index) => mergeDeep(sources.map(source => source[index]), respectPrototype, respectArrays, respectArrayLength));\n    }\n    if (allArrays) {\n        return sources.flat(1);\n    }\n    let output;\n    let firstObjectSource;\n    if (respectPrototype) {\n        firstObjectSource = sources.find(source => isObject(source));\n        if (output == null) {\n            output = {};\n        }\n        if (firstObjectSource) {\n            Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(firstObjectSource)));\n        }\n    }\n    for (const source of sources) {\n        if (isObject(source)) {\n            if (firstObjectSource) {\n                const outputPrototype = Object.getPrototypeOf(output);\n                const sourcePrototype = Object.getPrototypeOf(source);\n                if (sourcePrototype) {\n                    for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n                        const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n                        if (isSome(descriptor)) {\n                            Object.defineProperty(outputPrototype, key, descriptor);\n                        }\n                    }\n                }\n            }\n            for (const key in source) {\n                if (output == null) {\n                    output = {};\n                }\n                if (key in output) {\n                    output[key] = mergeDeep([output[key], source[key]], respectPrototype, respectArrays, respectArrayLength);\n                }\n                else {\n                    output[key] = source[key];\n                }\n            }\n        }\n        else if (Array.isArray(source)) {\n            if (!Array.isArray(output)) {\n                output = source;\n            }\n            else {\n                output = mergeDeep([output, source], respectPrototype, respectArrays, respectArrayLength);\n            }\n        }\n        else {\n            output = source;\n        }\n    }\n    return output;\n}\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n","import { mergeDeep } from '@graphql-tools/utils';\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\nexport function mergeResolvers(resolversDefinitions, options) {\n    if (!resolversDefinitions ||\n        (Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0)) {\n        return {};\n    }\n    if (!Array.isArray(resolversDefinitions)) {\n        return resolversDefinitions;\n    }\n    if (resolversDefinitions.length === 1) {\n        return resolversDefinitions[0] || {};\n    }\n    const resolvers = new Array();\n    for (let resolversDefinition of resolversDefinitions) {\n        if (Array.isArray(resolversDefinition)) {\n            resolversDefinition = mergeResolvers(resolversDefinition);\n        }\n        if (typeof resolversDefinition === 'object' && resolversDefinition) {\n            resolvers.push(resolversDefinition);\n        }\n    }\n    const result = mergeDeep(resolvers, true);\n    if (options?.exclusions) {\n        for (const exclusion of options.exclusions) {\n            const [typeName, fieldName] = exclusion.split('.');\n            if (['__proto__', 'constructor', 'prototype'].includes(typeName) ||\n                ['__proto__', 'constructor', 'prototype'].includes(fieldName)) {\n                continue;\n            }\n            if (!fieldName || fieldName === '*') {\n                delete result[typeName];\n            }\n            else if (result[typeName]) {\n                delete result[typeName][fieldName];\n            }\n        }\n    }\n    return result;\n}\n","import { mergeDeep } from '@graphql-tools/utils';\nexport { extractExtensionsFromSchema } from '@graphql-tools/utils';\nexport function mergeExtensions(extensions) {\n    return mergeDeep(extensions, false, true);\n}\nfunction applyExtensionObject(obj, extensions) {\n    if (!obj || !extensions || extensions === obj.extensions) {\n        return;\n    }\n    if (!obj.extensions) {\n        obj.extensions = extensions;\n        return;\n    }\n    obj.extensions = mergeDeep([obj.extensions, extensions], false, true);\n}\nexport function applyExtensions(schema, extensions) {\n    applyExtensionObject(schema, extensions.schemaExtensions);\n    for (const [typeName, data] of Object.entries(extensions.types || {})) {\n        const type = schema.getType(typeName);\n        if (type) {\n            applyExtensionObject(type, data.extensions);\n            if (data.type === 'object' || data.type === 'interface') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    if (field) {\n                        applyExtensionObject(field, fieldData.extensions);\n                        for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n                            applyExtensionObject(field.args.find(a => a.name === arg), argData);\n                        }\n                    }\n                }\n            }\n            else if (data.type === 'input') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    applyExtensionObject(field, fieldData.extensions);\n                }\n            }\n            else if (data.type === 'enum') {\n                for (const [valueName, valueData] of Object.entries(data.values)) {\n                    const value = type.getValue(valueName);\n                    applyExtensionObject(value, valueData);\n                }\n            }\n        }\n    }\n    return schema;\n}\n","import { getNamedType, isInputObjectType, isObjectType } from 'graphql';\nexport function forEachDefaultValue(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if (!getNamedType(type).name.startsWith('__')) {\n            if (isObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    for (const arg of field.args) {\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\n                    }\n                }\n            }\n            else if (isInputObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    field.defaultValue = fn(field.type, field.defaultValue);\n                }\n            }\n        }\n    }\n}\n","import { getNullableType, isInputObjectType, isLeafType, isListType, } from 'graphql';\nimport { asArray } from './helpers.js';\nexport function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = getNullableType(type);\n    if (isLeafType(nullableType)) {\n        return inputLeafValueTransformer != null\n            ? inputLeafValueTransformer(nullableType, value)\n            : value;\n    }\n    else if (isListType(nullableType)) {\n        return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n    }\n    else if (isInputObjectType(nullableType)) {\n        const fields = nullableType.getFields();\n        const newValue = {};\n        for (const key in value) {\n            const field = fields[key];\n            if (field != null) {\n                newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n            }\n        }\n        return inputObjectValueTransformer != null\n            ? inputObjectValueTransformer(nullableType, newValue)\n            : newValue;\n    }\n    // unreachable, no other possible return value\n}\nexport function serializeInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => {\n        try {\n            return t.serialize(v);\n        }\n        catch {\n            return v;\n        }\n    });\n}\nexport function parseInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => {\n        try {\n            return t.parseValue(v);\n        }\n        catch {\n            return v;\n        }\n    });\n}\nexport function parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n","import { GraphQLList, GraphQLNonNull, isInputObjectType, isInterfaceType, isLeafType, isListType, isNamedType, isNonNullType, isObjectType, isUnionType, } from 'graphql';\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nexport function healSchema(schema) {\n    healTypes(schema.getTypeMap(), schema.getDirectives());\n    return schema;\n}\nexport function healTypes(originalTypeMap, directives) {\n    const actualNamedTypeMap = Object.create(null);\n    // If any of the .name properties of the GraphQLNamedType objects in\n    // schema.getTypeMap() have changed, the keys of the type map need to\n    // be updated accordingly.\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const actualName = namedType.name;\n        if (actualName.startsWith('__')) {\n            continue;\n        }\n        if (actualNamedTypeMap[actualName] != null) {\n            console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);\n            continue;\n        }\n        actualNamedTypeMap[actualName] = namedType;\n        // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n    }\n    // Now add back every named type by its actual name.\n    for (const typeName in actualNamedTypeMap) {\n        const namedType = actualNamedTypeMap[typeName];\n        originalTypeMap[typeName] = namedType;\n    }\n    // Directive declaration argument types can refer to named types.\n    for (const decl of directives) {\n        decl.args = decl.args.filter(arg => {\n            arg.type = healType(arg.type);\n            return arg.type !== null;\n        });\n    }\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        // Heal all named types, except for dangling references, kept only to redirect.\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n            if (namedType != null) {\n                healNamedType(namedType);\n            }\n        }\n    }\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n            delete originalTypeMap[typeName];\n        }\n    }\n    function healNamedType(type) {\n        if (isObjectType(type)) {\n            healFields(type);\n            healInterfaces(type);\n            return;\n        }\n        else if (isInterfaceType(type)) {\n            healFields(type);\n            if ('getInterfaces' in type) {\n                healInterfaces(type);\n            }\n            return;\n        }\n        else if (isUnionType(type)) {\n            healUnderlyingTypes(type);\n            return;\n        }\n        else if (isInputObjectType(type)) {\n            healInputFields(type);\n            return;\n        }\n        else if (isLeafType(type)) {\n            return;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function healFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.args\n                .map(arg => {\n                arg.type = healType(arg.type);\n                return arg.type === null ? null : arg;\n            })\n                .filter(Boolean);\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healInterfaces(type) {\n        if ('getInterfaces' in type) {\n            const interfaces = type.getInterfaces();\n            interfaces.push(...interfaces\n                .splice(0)\n                .map(iface => healType(iface))\n                .filter(Boolean));\n        }\n    }\n    function healInputFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healUnderlyingTypes(type) {\n        const types = type.getTypes();\n        types.push(...types\n            .splice(0)\n            .map(t => healType(t))\n            .filter(Boolean));\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (isListType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLList(healedType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLNonNull(healedType) : null;\n        }\n        else if (isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            // Note that new types can still be simply added by adding a field, as\n            // the official type will be undefined, not null.\n            const officialType = originalTypeMap[type.name];\n            if (officialType && type !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\n","import { getNamedType, isObjectType } from 'graphql';\nexport function forEachField(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n            const fields = type.getFields();\n            for (const fieldName in fields) {\n                const field = fields[fieldName];\n                fn(field, typeName, fieldName);\n            }\n        }\n    }\n}\n","import { isObjectType } from 'graphql';\nexport function getObjectTypeFromTypeMap(typeMap, type) {\n    if (type) {\n        const maybeObjectType = typeMap[type.name];\n        if (isObjectType(maybeObjectType)) {\n            return maybeObjectType;\n        }\n    }\n}\n","export var MapperKind;\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n","import { GraphQLBoolean, GraphQLFloat, GraphQLID, GraphQLInputObjectType, GraphQLInt, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLString, Kind, } from 'graphql';\nexport function createNamedStub(name, type) {\n    let constructor;\n    if (type === 'object') {\n        constructor = GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = GraphQLInterfaceType;\n    }\n    else {\n        constructor = GraphQLInputObjectType;\n    }\n    return new constructor({\n        name,\n        fields: {\n            _fake: {\n                type: GraphQLString,\n            },\n        },\n    });\n}\nexport function createStub(node, type) {\n    switch (node.kind) {\n        case Kind.LIST_TYPE:\n            return new GraphQLList(createStub(node.type, type));\n        case Kind.NON_NULL_TYPE:\n            return new GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nexport function isNamedStub(type) {\n    if ('getFields' in type) {\n        const fields = type.getFields();\n        // eslint-disable-next-line no-unreachable-loop\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            return field.name === '_fake';\n        }\n    }\n    return false;\n}\nexport function getBuiltInForStub(type) {\n    switch (type.name) {\n        case GraphQLInt.name:\n            return GraphQLInt;\n        case GraphQLFloat.name:\n            return GraphQLFloat;\n        case GraphQLString.name:\n            return GraphQLString;\n        case GraphQLBoolean.name:\n            return GraphQLBoolean;\n        case GraphQLID.name:\n            return GraphQLID;\n        default:\n            return type;\n    }\n}\n","import { GraphQLDirective, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isEnumType, isInputObjectType, isInterfaceType, isListType, isNamedType, isNonNullType, isObjectType, isScalarType, isSpecifiedDirective, isSpecifiedScalarType, isUnionType, } from 'graphql';\nimport { getBuiltInForStub, isNamedStub } from './stub.js';\nexport function rewireTypes(originalTypeMap, directives) {\n    const referenceTypeMap = Object.create(null);\n    for (const typeName in originalTypeMap) {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    }\n    const newTypeMap = Object.create(null);\n    for (const typeName in referenceTypeMap) {\n        const namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const newName = namedType.name;\n        if (newName.startsWith('__')) {\n            continue;\n        }\n        if (newTypeMap[newName] != null) {\n            console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);\n            continue;\n        }\n        newTypeMap[newName] = namedType;\n    }\n    for (const typeName in newTypeMap) {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    }\n    const newDirectives = directives.map(directive => rewireDirective(directive));\n    return {\n        typeMap: newTypeMap,\n        directives: newDirectives,\n    };\n    function rewireDirective(directive) {\n        if (isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        const directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        const rewiredArgs = {};\n        for (const argName in args) {\n            const arg = args[argName];\n            const rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        }\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (isObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n                interfaces: () => rewireNamedTypes(config.interfaces),\n            };\n            return new GraphQLObjectType(newConfig);\n        }\n        else if (isInterfaceType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n            };\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n            }\n            return new GraphQLInterfaceType(newConfig);\n        }\n        else if (isUnionType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                types: () => rewireNamedTypes(config.types),\n            };\n            return new GraphQLUnionType(newConfig);\n        }\n        else if (isInputObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireInputFields(config.fields),\n            };\n            return new GraphQLInputObjectType(newConfig);\n        }\n        else if (isEnumType(type)) {\n            const enumConfig = type.toConfig();\n            return new GraphQLEnumType(enumConfig);\n        }\n        else if (isScalarType(type)) {\n            if (isSpecifiedScalarType(type)) {\n                return type;\n            }\n            const scalarConfig = type.toConfig();\n            return new GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function rewireFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null && field.args) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        const rewiredTypes = [];\n        for (const namedType of namedTypes) {\n            const rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        }\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (isListType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n        }\n        else if (isNamedType(type)) {\n            let rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n","import { GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLSchema, isEnumType, isInputObjectType, isInterfaceType, isLeafType, isListType, isNamedType, isNonNullType, isObjectType, isScalarType, isUnionType, Kind, } from 'graphql';\nimport { getObjectTypeFromTypeMap } from './getObjectTypeFromTypeMap.js';\nimport { MapperKind, } from './Interfaces.js';\nimport { rewireTypes } from './rewire.js';\nimport { parseInputValue, serializeInputValue } from './transformInputValue.js';\nexport function mapSchema(schema, schemaMapper = {}) {\n    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n    return new GraphQLSchema({\n        ...schema.toConfig(),\n        query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n        mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n        subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    }\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            for (const externalValue in originalEnumValueConfigMap) {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            }\n            return correctASTNodes(new GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => isEnumType(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if (isListType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLList(newType) : null;\n    }\n    else if (isNonNullType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLNonNull(newType) : null;\n    }\n    else if (isNamedType(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) &&\n                !isInterfaceType(originalType) &&\n                !isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] =\n                        newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            }\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const newArgumentConfigMap = {};\n                for (const argumentName of argumentNames) {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                }\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            }\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    for (const directive of originalDirectives) {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    }\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.TYPE];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n        if (typeName === schema.getQueryType()?.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n        }\n        else if (typeName === schema.getMutationType()?.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n        }\n        else if (typeName === schema.getSubscriptionType()?.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n    }\n    else if (isUnionType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n    }\n    else if (isEnumType(type)) {\n        specifiers.push(MapperKind.ENUM_TYPE);\n    }\n    else if (isScalarType(type)) {\n        specifiers.push(MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.FIELD];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n        if (typeName === schema.getQueryType()?.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (typeName === schema.getMutationType()?.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (typeName === schema.getSubscriptionType()?.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        // TODO: fix this as unknown cast\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper ?? null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nexport function correctASTNodes(type) {\n    if (isObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLObjectType(config);\n    }\n    else if (isInterfaceType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInterfaceType(config);\n    }\n    else if (isInputObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInputObjectType(config);\n    }\n    else if (isEnumType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            for (const enumKey in config.values) {\n                const enumValueConfig = config.values[enumKey];\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\n","import { MapperKind, mapSchema } from '@graphql-tools/utils';\n// If we have any union or interface types throw if no there is no resolveType resolver\nexport function checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    mapSchema(schema, {\n        [MapperKind.ABSTRACT_TYPE]: type => {\n            if (!type.resolveType) {\n                const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` +\n                    '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n                if (requireResolversForResolveType === 'error') {\n                    throw new Error(message);\n                }\n                if (requireResolversForResolveType === 'warn') {\n                    console.warn(message);\n                }\n            }\n            return undefined;\n        },\n    });\n}\n","export function extendResolversFromInterfaces(schema, resolvers) {\n    const extendedResolvers = {};\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if ('getInterfaces' in type) {\n            extendedResolvers[typeName] = {};\n            for (const iFace of type.getInterfaces()) {\n                if (resolvers[iFace.name]) {\n                    for (const fieldName in resolvers[iFace.name]) {\n                        if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n                        }\n                    }\n                }\n            }\n            const typeResolvers = resolvers[typeName];\n            extendedResolvers[typeName] = {\n                ...extendedResolvers[typeName],\n                ...typeResolvers,\n            };\n        }\n        else {\n            const typeResolvers = resolvers[typeName];\n            if (typeResolvers != null) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    }\n    return extendedResolvers;\n}\n","import { GraphQLEnumType, GraphQLInterfaceType, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isEnumType, isInterfaceType, isObjectType, isScalarType, isSpecifiedScalarType, isUnionType, } from 'graphql';\nimport { forEachDefaultValue, forEachField, healSchema, MapperKind, mapSchema, parseInputValue, serializeInputValue, } from '@graphql-tools/utils';\nimport { checkForResolveTypeResolver } from './checkForResolveTypeResolver.js';\nimport { extendResolversFromInterfaces } from './extendResolversFromInterfaces.js';\nexport function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, }) {\n    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    for (const typeName in resolvers) {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (resolverType !== 'object') {\n            throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n        }\n        const type = schema.getType(typeName);\n        if (type == null) {\n            const msg = `\"${typeName}\" defined in resolvers, but not in schema`;\n            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'error') {\n                if (requireResolversToMatchSchema === 'warn') {\n                    console.warn(msg);\n                }\n                continue;\n            }\n            throw new Error(msg);\n        }\n        else if (isSpecifiedScalarType(type)) {\n            // allow -- without recommending -- overriding of specified scalar types\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (isEnumType(type)) {\n            const values = type.getValues();\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    !values.some(value => value.name === fieldName) &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    const msg = `${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`;\n                    if (requireResolversToMatchSchema === 'error') {\n                        throw new Error(msg);\n                    }\n                    else {\n                        console.warn(msg);\n                    }\n                }\n            }\n        }\n        else if (isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    const msg = `${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`;\n                    if (requireResolversToMatchSchema === 'error') {\n                        throw new Error(msg);\n                    }\n                    else {\n                        console.warn(msg);\n                    }\n                }\n            }\n        }\n        else if (isObjectType(type) || isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__')) {\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field == null) {\n                        // Field present in resolver but not in schema\n                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n                            const msg = `${typeName}.${fieldName} defined in resolvers, but not in schema`;\n                            if (requireResolversToMatchSchema === 'error') {\n                                throw new Error(msg);\n                            }\n                            else {\n                                console.error(msg);\n                            }\n                        }\n                    }\n                    else {\n                        // Field present in both the resolver and schema\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n        checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    }\n    return schema;\n}\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in resolvers) {\n        const type = schema.getType(typeName);\n        const resolverValue = resolvers[typeName];\n        if (isScalarType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && type.astNode != null) {\n                    type.astNode = {\n                        ...type.astNode,\n                        description: resolverValue?.astNode?.description ??\n                            type.astNode.description,\n                        directives: (type.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                    type.extensionASTNodes = type.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (isEnumType(type)) {\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    config[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && config.astNode != null) {\n                    config.astNode = {\n                        ...config.astNode,\n                        description: resolverValue?.astNode?.description ??\n                            config.astNode.description,\n                        directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                    config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else if (enumValueConfigMap[fieldName]) {\n                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                }\n            }\n            typeMap[typeName] = new GraphQLEnumType(config);\n        }\n        else if (isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (isObjectType(type) || isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    // this is for isTypeOf and resolveType and all the other stuff.\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                    continue;\n                }\n                const fields = type.getFields();\n                const field = fields[fieldName];\n                if (field != null) {\n                    const fieldResolve = resolverValue[fieldName];\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        field.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(field, fieldResolve);\n                    }\n                }\n            }\n        }\n    }\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    forEachDefaultValue(schema, serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    healSchema(schema);\n    // reparse all default values with new parsing functions.\n    forEachDefaultValue(schema, parseInputValue);\n    if (defaultFieldResolver != null) {\n        forEachField(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = mapSchema(schema, {\n        [MapperKind.SCALAR_TYPE]: type => {\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!isSpecifiedScalarType(type) && resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: resolverValue?.astNode?.description ??\n                                config.astNode.description,\n                            directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                }\n                return new GraphQLScalarType(config);\n            }\n        },\n        [MapperKind.ENUM_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: resolverValue?.astNode?.description ??\n                                config.astNode.description,\n                            directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                }\n                return new GraphQLEnumType(config);\n            }\n        },\n        [MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new GraphQLUnionType(config);\n            }\n        },\n        [MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__isTypeOf']) {\n                    config.isTypeOf = resolverValue['__isTypeOf'];\n                }\n                return new GraphQLObjectType(config);\n            }\n        },\n        [MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new GraphQLInterfaceType(config);\n            }\n        },\n        [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = mapSchema(schema, {\n            [MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    for (const propertyName in propertiesObj) {\n        field[propertyName] = propertiesObj[propertyName];\n    }\n}\n","import { getNamedType, isScalarType } from 'graphql';\nimport { forEachField } from '@graphql-tools/utils';\nexport function assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    forEachField(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar !== 'ignore' && !isScalarType(getNamedType(field.type))) {\n            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n    if (!field.resolve) {\n        const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n        if (behavior === 'error') {\n            throw new Error(message);\n        }\n        if (behavior === 'warn') {\n            console.warn(message);\n        }\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n","import { buildASTSchema, buildSchema, isSchema } from 'graphql';\nimport { applyExtensions, mergeResolvers, mergeTypeDefs } from '@graphql-tools/merge';\nimport { asArray } from '@graphql-tools/utils';\nimport { addResolversToSchema } from './addResolversToSchema.js';\nimport { assertResolversPresent } from './assertResolversPresent.js';\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use GraphQL magic comment provide additional syntax\n * highlighting in your editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = /* GraphQL *\\/ `\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nexport function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, defaultFieldResolver, ...otherOptions }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    let schema;\n    if (isSchema(typeDefs)) {\n        schema = typeDefs;\n    }\n    else if (otherOptions?.commentDescriptions) {\n        const mergedTypeDefs = mergeTypeDefs(typeDefs, {\n            ...otherOptions,\n            commentDescriptions: true,\n        });\n        schema = buildSchema(mergedTypeDefs, otherOptions);\n    }\n    else {\n        const mergedTypeDefs = mergeTypeDefs(typeDefs, otherOptions);\n        schema = buildASTSchema(mergedTypeDefs, otherOptions);\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    schema = addResolversToSchema({\n        schema,\n        resolvers: mergeResolvers(resolvers),\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n        defaultFieldResolver,\n    });\n    if (Object.keys(resolverValidationOptions).length > 0) {\n        assertResolversPresent(schema, resolverValidationOptions);\n    }\n    if (schemaExtensions) {\n        for (const schemaExtension of asArray(schemaExtensions)) {\n            applyExtensions(schema, schemaExtension);\n        }\n    }\n    return schema;\n}\n","import { makeExecutableSchema } from '@graphql-tools/schema';\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport function createSchema(opts) {\n    return makeExecutableSchema(opts);\n}\n","export const useEngine = (engine) => {\n    return {\n        onExecute: ({ setExecuteFn }) => {\n            if (engine.execute) {\n                setExecuteFn(engine.execute);\n            }\n        },\n        onParse: ({ setParseFn }) => {\n            if (engine.parse) {\n                setParseFn(engine.parse);\n            }\n        },\n        onValidate: ({ setValidationFn, addValidationRule }) => {\n            if (engine.validate) {\n                setValidationFn(engine.validate);\n            }\n            engine.specifiedRules?.map(addValidationRule);\n        },\n        onSubscribe: ({ setSubscribeFn }) => {\n            if (engine.subscribe) {\n                setSubscribeFn(engine.subscribe);\n            }\n        },\n    };\n};\n","import { handleMaybePromise } from '@whatwg-node/promise-helpers';\nexport const useExtendContext = (contextFactory) => ({\n    onContextBuilding({ context, extendContext }) {\n        return handleMaybePromise(() => contextFactory(context), result => extendContext(result));\n    },\n});\n","import { fakePromise } from '@whatwg-node/promise-helpers';\nexport const envelopIsIntrospectionSymbol = Symbol('ENVELOP_IS_INTROSPECTION');\nexport function isIntrospectionOperationString(operation) {\n    return (typeof operation === 'string' ? operation : operation.body).indexOf('__schema') !== -1;\n}\nfunction getSubscribeArgs(args) {\n    return args.length === 1\n        ? args[0]\n        : {\n            schema: args[0],\n            document: args[1],\n            rootValue: args[2],\n            contextValue: args[3],\n            variableValues: args[4],\n            operationName: args[5],\n            fieldResolver: args[6],\n            subscribeFieldResolver: args[7],\n        };\n}\n/**\n * Utility function for making a subscribe function that handles polymorphic arguments.\n */\nexport const makeSubscribe = (subscribeFn) => ((...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs)));\nexport { mapAsyncIterator } from '@whatwg-node/promise-helpers';\nfunction getExecuteArgs(args) {\n    return args.length === 1\n        ? args[0]\n        : {\n            schema: args[0],\n            document: args[1],\n            rootValue: args[2],\n            contextValue: args[3],\n            variableValues: args[4],\n            operationName: args[5],\n            fieldResolver: args[6],\n            typeResolver: args[7],\n        };\n}\n/**\n * Utility function for making a execute function that handles polymorphic arguments.\n */\nexport const makeExecute = (executeFn) => ((...polyArgs) => executeFn(getExecuteArgs(polyArgs)));\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n *\n * Source: https://github.com/graphql/graphql-js/blob/main/src/jsutils/isAsyncIterable.ts\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n    return (typeof maybeAsyncIterable === 'object' &&\n        maybeAsyncIterable != null &&\n        typeof maybeAsyncIterable[Symbol.asyncIterator] === 'function');\n}\n/**\n * A utility function for handling `onExecuteDone` hook result, for simplifying the handling of AsyncIterable returned from `execute`.\n *\n * @param payload The payload send to `onExecuteDone` hook function\n * @param fn The handler to be executed on each result\n * @returns a subscription for streamed results, or undefined in case of an non-async\n */\nexport function handleStreamOrSingleExecutionResult(payload, fn) {\n    if (isAsyncIterable(payload.result)) {\n        return { onNext: fn };\n    }\n    fn({\n        args: payload.args,\n        result: payload.result,\n        setResult: payload.setResult,\n    });\n    return undefined;\n}\nexport function finalAsyncIterator(source, onFinal) {\n    const iterator = source[Symbol.asyncIterator]();\n    let isDone = false;\n    const stream = {\n        [Symbol.asyncIterator]() {\n            return stream;\n        },\n        next() {\n            return iterator.next().then(result => {\n                if (result.done && isDone === false) {\n                    isDone = true;\n                    onFinal();\n                }\n                return result;\n            });\n        },\n        return() {\n            const promise = iterator.return?.();\n            if (isDone === false) {\n                isDone = true;\n                onFinal();\n            }\n            return promise || fakePromise({ done: true, value: undefined });\n        },\n        throw(error) {\n            const promise = iterator.throw?.();\n            if (promise) {\n                return promise;\n            }\n            // if the source has no throw method we just re-throw error\n            // usually throw is not called anyways\n            throw error;\n        },\n    };\n    return stream;\n}\nexport function errorAsyncIterator(source, onError) {\n    const iterator = source[Symbol.asyncIterator]();\n    const stream = {\n        [Symbol.asyncIterator]() {\n            return stream;\n        },\n        next() {\n            return iterator.next().catch(error => {\n                onError(error);\n                return { done: true, value: undefined };\n            });\n        },\n        return() {\n            const promise = iterator.return?.();\n            return promise || fakePromise({ done: true, value: undefined });\n        },\n        throw(error) {\n            const promise = iterator.throw?.();\n            if (promise) {\n                return promise;\n            }\n            // if the source has no throw method we just re-throw error\n            // usually throw is not called anyways\n            throw error;\n        },\n    };\n    return stream;\n}\nexport { mapMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\n","import { handleStreamOrSingleExecutionResult } from '../utils.js';\nexport const DEFAULT_ERROR_MESSAGE = 'Unexpected error.';\nexport function isGraphQLError(error) {\n    return error instanceof Error && error.name === 'GraphQLError';\n}\nexport function isOriginalGraphQLError(error) {\n    if (isGraphQLError(error)) {\n        if (error.originalError != null) {\n            return isOriginalGraphQLError(error.originalError);\n        }\n        return true;\n    }\n    return false;\n}\nfunction createSerializableGraphQLError(message, originalError, isDev) {\n    const error = new Error(message);\n    error.name = 'GraphQLError';\n    if (isDev) {\n        const extensions = originalError instanceof Error\n            ? { message: originalError.message, stack: originalError.stack }\n            : { message: String(originalError) };\n        Object.defineProperty(error, 'extensions', {\n            get() {\n                return extensions;\n            },\n        });\n    }\n    Object.defineProperty(error, 'toJSON', {\n        value() {\n            return {\n                message: error.message,\n                extensions: error.extensions,\n            };\n        },\n    });\n    return error;\n}\nexport const createDefaultMaskError = (isDev) => (error, message) => {\n    if (isOriginalGraphQLError(error)) {\n        return error;\n    }\n    return createSerializableGraphQLError(message, error, isDev);\n};\nconst isDev = globalThis.process?.env?.NODE_ENV === 'development';\nexport const defaultMaskError = createDefaultMaskError(isDev);\nconst makeHandleResult = (maskError, message) => ({ result, setResult, }) => {\n    if (result.errors != null) {\n        setResult({ ...result, errors: result.errors.map(error => maskError(error, message)) });\n    }\n};\nexport function useMaskedErrors(opts) {\n    const maskError = opts?.maskError ?? defaultMaskError;\n    const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;\n    const handleResult = makeHandleResult(maskError, message);\n    return {\n        onPluginInit(context) {\n            context.registerContextErrorHandler(({ error, setError }) => {\n                setError(maskError(error, message));\n            });\n        },\n        onExecute() {\n            return {\n                onExecuteDone(payload) {\n                    return handleStreamOrSingleExecutionResult(payload, handleResult);\n                },\n            };\n        },\n        onSubscribe() {\n            return {\n                onSubscribeResult(payload) {\n                    return handleStreamOrSingleExecutionResult(payload, handleResult);\n                },\n                onSubscribeError({ error, setError }) {\n                    setError(maskError(error, message));\n                },\n            };\n        },\n    };\n}\n",";globalThis[\"_sentryRewritesTunnelPath\"] = \"/monitoring\";globalThis[\"SENTRY_RELEASE\"] = {\"id\":\"d92a5e8d8d7c20e1f785b33fde2c15257fdb31d2\"};globalThis[\"_sentryBasePath\"] = undefined;globalThis[\"_sentryRewriteFramesDistDir\"] = \".next\";import { handleMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\n/**\n * Composes 2 instrumentations together into one instrumentation.\n * The first one will be the outer call, the second one the inner call.\n */\nexport function chain(first, next) {\n    const merged = { ...next, ...first };\n    for (const key of Object.keys(merged)) {\n        if (key in first && key in next) {\n            merged[key] = (payload, wrapped) => first[key](payload, () => next[key](payload, wrapped));\n        }\n    }\n    return merged;\n}\n/**\n * Composes a list of instrumentation together into one instrumentation object.\n * The order of execution will respect the order of the array,\n * the first one being the outter most call, the last one the inner most call.\n */\nexport function composeInstrumentation(instrumentation) {\n    return instrumentation.length > 0 ? instrumentation.reduce(chain) : undefined;\n}\n/**\n * Extract instrumentation from a list of plugins.\n * It returns instrumentation found, and the list of plugins without their instrumentation.\n *\n * You can use this to easily customize the composition of the instrumentation if the default one\n * doesn't suits your needs.\n */\nexport function getInstrumentationAndPlugin(plugins) {\n    const pluginInstrumentation = [];\n    const newPlugins = [];\n    for (const { instrumentation, ...plugin } of plugins) {\n        if (instrumentation) {\n            pluginInstrumentation.push(instrumentation);\n        }\n        newPlugins.push(plugin);\n    }\n    return { pluginInstrumentation, plugins: newPlugins };\n}\n/**\n * A helper to instrument a function.\n *\n * @param payload: The first argument that will be passed to the instrumentation on each function call\n * @returns Function and Async Functions factories allowing to wrap a function with a given instrument.\n */\nexport const getInstrumented = (payload) => ({\n    /**\n     * Wraps the `wrapped` function with the given `instrument` wrapper.\n     * @returns The wrapped function, or `undefined` if the instrument is `undefined`.\n     */\n    fn(instrument, wrapped) {\n        if (!instrument) {\n            return wrapped;\n        }\n        return (...args) => {\n            let result;\n            instrument(payload, () => {\n                result = wrapped(...args);\n            });\n            return result;\n        };\n    },\n    /**\n     * Wraps the `wrapped` function with the given `instrument` wrapper.\n     * @returns The wrapped function, or `undefined` if the instrument is `undefined`.\n     */\n    asyncFn(instrument, wrapped) {\n        if (!instrument) {\n            return wrapped;\n        }\n        return (...args) => {\n            let result;\n            return handleMaybePromise(() => instrument(payload, () => {\n                result = wrapped(...args);\n                return isPromise(result) ? result.then(() => undefined) : undefined;\n            }), () => {\n                return result;\n            });\n        };\n    },\n});\n","export const documentStringMap = new WeakMap();\nfunction getDocumentString(document, print) {\n    let documentSource = documentStringMap.get(document);\n    if (!documentSource && print) {\n        documentSource = print(document);\n        documentStringMap.set(document, documentSource);\n    }\n    return documentSource;\n}\nexport { getDocumentString };\n","import { chain } from '@envelop/instrumentation';\nimport { handleMaybePromise, iterateAsync, iterateAsyncVoid } from '@whatwg-node/promise-helpers';\nimport { documentStringMap } from './document-string-map.js';\nimport { errorAsyncIterator, finalAsyncIterator, isAsyncIterable, makeExecute, makeSubscribe, mapAsyncIterator, } from './utils.js';\nfunction throwEngineFunctionError(name) {\n    throw Error(`No \\`${name}\\` function found! Register it using \"useEngine\" plugin.`);\n}\nexport function createEnvelopOrchestrator({ plugins, }) {\n    let schema = null;\n    let initDone = false;\n    const parse = () => throwEngineFunctionError('parse');\n    const validate = () => throwEngineFunctionError('validate');\n    const execute = () => throwEngineFunctionError('execute');\n    const subscribe = () => throwEngineFunctionError('subscribe');\n    let instrumentation;\n    // Define the initial method for replacing the GraphQL schema, this is needed in order\n    // to allow setting the schema from the onPluginInit callback. We also need to make sure\n    // here not to call the same plugin that initiated the schema switch.\n    const replaceSchema = (newSchema, ignorePluginIndex = -1) => {\n        if (schema === newSchema) {\n            return;\n        }\n        schema = newSchema;\n        if (initDone) {\n            for (const [i, plugin] of plugins.entries()) {\n                if (i !== ignorePluginIndex) {\n                    plugin.onSchemaChange &&\n                        plugin.onSchemaChange({\n                            schema,\n                            replaceSchema: schemaToSet => {\n                                replaceSchema(schemaToSet, i);\n                            },\n                        });\n                }\n            }\n        }\n    };\n    const contextErrorHandlers = [];\n    // Iterate all plugins and trigger onPluginInit\n    for (let i = 0; i < plugins.length; i++) {\n        const plugin = plugins[i];\n        const pluginsToAdd = [];\n        plugin.onPluginInit?.({\n            plugins,\n            addPlugin: newPlugin => {\n                pluginsToAdd.push(newPlugin);\n            },\n            setSchema: modifiedSchema => replaceSchema(modifiedSchema, i),\n            registerContextErrorHandler: handler => contextErrorHandlers.push(handler),\n        });\n        pluginsToAdd.length && plugins.splice(i + 1, 0, ...pluginsToAdd);\n    }\n    // A set of before callbacks defined here in order to allow it to be used later\n    const beforeCallbacks = {\n        init: [],\n        parse: [],\n        validate: [],\n        subscribe: [],\n        execute: [],\n        context: [],\n    };\n    for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped, instrumentation: pluginInstrumentation, } of plugins) {\n        onEnveloped && beforeCallbacks.init.push(onEnveloped);\n        onContextBuilding && beforeCallbacks.context.push(onContextBuilding);\n        onExecute && beforeCallbacks.execute.push(onExecute);\n        onParse && beforeCallbacks.parse.push(onParse);\n        onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);\n        onValidate && beforeCallbacks.validate.push(onValidate);\n        if (pluginInstrumentation) {\n            instrumentation = instrumentation\n                ? chain(instrumentation, pluginInstrumentation)\n                : pluginInstrumentation;\n        }\n    }\n    const init = initialContext => {\n        for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {\n            onEnveloped({\n                context: initialContext,\n                extendContext: extension => {\n                    if (!initialContext) {\n                        return;\n                    }\n                    Object.assign(initialContext, extension);\n                },\n                setSchema: modifiedSchema => replaceSchema(modifiedSchema, i),\n            });\n        }\n    };\n    const customParse = beforeCallbacks.parse.length\n        ? initialContext => (source, parseOptions) => {\n            let result = null;\n            let parseFn = parse;\n            const context = initialContext;\n            const afterCalls = [];\n            for (const onParse of beforeCallbacks.parse) {\n                const afterFn = onParse({\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    params: { source, options: parseOptions },\n                    parseFn,\n                    setParseFn: newFn => {\n                        parseFn = newFn;\n                    },\n                    setParsedDocument: newDoc => {\n                        result = newDoc;\n                    },\n                });\n                if (afterFn) {\n                    afterCalls.push(afterFn);\n                }\n            }\n            if (result === null) {\n                try {\n                    result = parseFn(source, parseOptions);\n                }\n                catch (e) {\n                    result = e;\n                }\n            }\n            for (const afterCb of afterCalls) {\n                afterCb({\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    replaceParseResult: newResult => {\n                        result = newResult;\n                    },\n                    result,\n                });\n            }\n            if (result === null) {\n                throw new Error(`Failed to parse document.`);\n            }\n            if (result instanceof Error) {\n                throw result;\n            }\n            documentStringMap.set(result, source.toString());\n            return result;\n        }\n        : () => parse;\n    const customValidate = beforeCallbacks.validate\n        .length\n        ? initialContext => (schema, documentAST, rules, typeInfo, validationOptions) => {\n            let actualRules = rules ? [...rules] : undefined;\n            let validateFn = validate;\n            let result = null;\n            const context = initialContext;\n            const afterCalls = [];\n            for (const onValidate of beforeCallbacks.validate) {\n                const afterFn = onValidate({\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    params: {\n                        schema,\n                        documentAST,\n                        rules: actualRules,\n                        typeInfo,\n                        options: validationOptions,\n                    },\n                    validateFn,\n                    addValidationRule: rule => {\n                        if (!actualRules) {\n                            actualRules = [];\n                        }\n                        actualRules.push(rule);\n                    },\n                    setValidationFn: newFn => {\n                        validateFn = newFn;\n                    },\n                    setResult: newResults => {\n                        result = newResults;\n                    },\n                });\n                afterFn && afterCalls.push(afterFn);\n            }\n            if (!result) {\n                result = validateFn(schema, documentAST, actualRules, typeInfo, validationOptions);\n            }\n            if (!result) {\n                return;\n            }\n            const valid = result.length === 0;\n            for (const afterCb of afterCalls) {\n                afterCb({\n                    valid,\n                    result,\n                    context,\n                    extendContext: extension => {\n                        Object.assign(context, extension);\n                    },\n                    setResult: newResult => {\n                        result = newResult;\n                    },\n                });\n            }\n            return result;\n        }\n        : () => validate;\n    const customContextFactory = beforeCallbacks.context.length\n        ? initialContext => orchestratorCtx => {\n            const afterCalls = [];\n            // In order to have access to the \"last working\" context object we keep this outside of the try block:\n            const context = initialContext;\n            if (orchestratorCtx) {\n                Object.assign(context, orchestratorCtx);\n            }\n            let isBreakingContextBuilding = false;\n            return handleMaybePromise(() => iterateAsync(beforeCallbacks.context, (onContext, stopEarly) => onContext({\n                context,\n                extendContext: extension => {\n                    Object.assign(context, extension);\n                },\n                breakContextBuilding: () => {\n                    isBreakingContextBuilding = true;\n                    stopEarly();\n                },\n            }), afterCalls), () => {\n                if (!isBreakingContextBuilding) {\n                    return handleMaybePromise(() => iterateAsync(afterCalls, afterCb => afterCb({\n                        context,\n                        extendContext(extension) {\n                            Object.assign(context, extension);\n                        },\n                    })), () => context);\n                }\n                return context;\n            }, err => {\n                let error = err;\n                for (const errorCb of contextErrorHandlers) {\n                    errorCb({\n                        context,\n                        error,\n                        setError: err => {\n                            error = err;\n                        },\n                    });\n                }\n                throw error;\n            });\n        }\n        : initialContext => orchestratorCtx => {\n            if (orchestratorCtx) {\n                Object.assign(initialContext, orchestratorCtx);\n            }\n            return initialContext;\n        };\n    const useCustomSubscribe = beforeCallbacks.subscribe.length;\n    const customSubscribe = useCustomSubscribe\n        ? makeSubscribe(args => {\n            let subscribeFn = subscribe;\n            const afterCallbacks = [];\n            const context = args.contextValue || {};\n            let result;\n            return handleMaybePromise(() => iterateAsync(beforeCallbacks.subscribe, (onSubscribe, endEarly) => onSubscribe({\n                subscribeFn,\n                setSubscribeFn: newSubscribeFn => {\n                    subscribeFn = newSubscribeFn;\n                },\n                context,\n                extendContext: extension => {\n                    Object.assign(context, extension);\n                },\n                args: args,\n                setResultAndStopExecution: stopResult => {\n                    result = stopResult;\n                    endEarly();\n                },\n            }), afterCallbacks), () => {\n                const afterCalls = [];\n                const subscribeErrorHandlers = [];\n                for (const { onSubscribeResult, onSubscribeError } of afterCallbacks) {\n                    if (onSubscribeResult) {\n                        afterCalls.push(onSubscribeResult);\n                    }\n                    if (onSubscribeError) {\n                        subscribeErrorHandlers.push(onSubscribeError);\n                    }\n                }\n                return handleMaybePromise(() => result || subscribeFn(args), result => {\n                    const onNextHandler = [];\n                    const onEndHandler = [];\n                    for (const afterCb of afterCalls) {\n                        const hookResult = afterCb({\n                            args: args,\n                            result,\n                            setResult: newResult => {\n                                result = newResult;\n                            },\n                        });\n                        if (hookResult) {\n                            if (hookResult.onNext) {\n                                onNextHandler.push(hookResult.onNext);\n                            }\n                            if (hookResult.onEnd) {\n                                onEndHandler.push(hookResult.onEnd);\n                            }\n                        }\n                    }\n                    if (onNextHandler.length && isAsyncIterable(result)) {\n                        result = mapAsyncIterator(result, (result) => handleMaybePromise(() => iterateAsync(onNextHandler, onNext => onNext({\n                            args: args,\n                            result,\n                            setResult: newResult => (result = newResult),\n                        })), () => result));\n                    }\n                    if (onEndHandler.length && isAsyncIterable(result)) {\n                        result = finalAsyncIterator(result, () => {\n                            for (const onEnd of onEndHandler) {\n                                onEnd();\n                            }\n                        });\n                    }\n                    if (subscribeErrorHandlers.length && isAsyncIterable(result)) {\n                        result = errorAsyncIterator(result, err => {\n                            let error = err;\n                            for (const handler of subscribeErrorHandlers) {\n                                handler({\n                                    error,\n                                    setError: err => {\n                                        error = err;\n                                    },\n                                });\n                            }\n                            throw error;\n                        });\n                    }\n                    return result;\n                });\n            });\n        })\n        : makeSubscribe(subscribe);\n    const useCustomExecute = beforeCallbacks.execute.length;\n    const customExecute = useCustomExecute\n        ? makeExecute(args => {\n            let executeFn = execute;\n            let result;\n            const afterCalls = [];\n            const afterDoneCalls = [];\n            const context = args.contextValue || {};\n            return handleMaybePromise(() => iterateAsync(beforeCallbacks.execute, (onExecute, endEarly) => onExecute({\n                executeFn,\n                setExecuteFn: newExecuteFn => {\n                    executeFn = newExecuteFn;\n                },\n                setResultAndStopExecution: stopResult => {\n                    result = stopResult;\n                    endEarly();\n                },\n                context,\n                extendContext: extension => {\n                    if (typeof extension === 'object') {\n                        Object.assign(context, extension);\n                    }\n                    else {\n                        throw new Error(`Invalid context extension provided! Expected \"object\", got: \"${JSON.stringify(extension)}\" (${typeof extension})`);\n                    }\n                },\n                args: args,\n            }), afterCalls), () => handleMaybePromise(() => result ||\n                executeFn({\n                    ...args,\n                    contextValue: context,\n                }), result => handleMaybePromise(() => iterateAsync(afterCalls, afterCb => afterCb.onExecuteDone?.({\n                args: args,\n                result,\n                setResult: newResult => {\n                    result = newResult;\n                },\n            }), afterDoneCalls), () => {\n                const onNextHandler = [];\n                const onEndHandler = [];\n                for (const { onNext, onEnd } of afterDoneCalls) {\n                    if (onNext) {\n                        onNextHandler.push(onNext);\n                    }\n                    if (onEnd) {\n                        onEndHandler.push(onEnd);\n                    }\n                }\n                if (onNextHandler.length && isAsyncIterable(result)) {\n                    result = mapAsyncIterator(result, result => handleMaybePromise(() => iterateAsyncVoid(onNextHandler, onNext => onNext({\n                        args: args,\n                        result: result,\n                        setResult: newResult => {\n                            result = newResult;\n                        },\n                    })), () => result));\n                }\n                if (onEndHandler.length && isAsyncIterable(result)) {\n                    result = finalAsyncIterator(result, () => {\n                        for (const onEnd of onEndHandler) {\n                            onEnd();\n                        }\n                    });\n                }\n                return result;\n            })));\n        })\n        : makeExecute(execute);\n    initDone = true;\n    // This is done in order to trigger the first schema available, to allow plugins that needs the schema\n    // eagerly to have it.\n    if (schema) {\n        for (const [i, plugin] of plugins.entries()) {\n            plugin.onSchemaChange?.({\n                schema,\n                replaceSchema: modifiedSchema => replaceSchema(modifiedSchema, i),\n            });\n        }\n    }\n    return {\n        getCurrentSchema() {\n            return schema;\n        },\n        init,\n        parse: customParse,\n        validate: customValidate,\n        execute: customExecute,\n        subscribe: customSubscribe,\n        contextFactory: customContextFactory,\n        instrumentation,\n    };\n}\n","import { getInstrumented } from '@envelop/instrumentation';\nimport { createEnvelopOrchestrator } from './orchestrator.js';\nfunction notEmpty(value) {\n    return value != null;\n}\nexport function envelop(options) {\n    const plugins = options.plugins.filter(notEmpty);\n    const orchestrator = createEnvelopOrchestrator({\n        plugins,\n    });\n    const instrumentation = orchestrator.instrumentation;\n    const getEnveloped = (context = {}) => {\n        const instrumented = getInstrumented({ context });\n        const typedOrchestrator = orchestrator;\n        instrumented.fn(instrumentation?.init, orchestrator.init)(context);\n        return {\n            parse: instrumented.fn(instrumentation?.parse, typedOrchestrator.parse(context)),\n            validate: instrumented.fn(instrumentation?.validate, typedOrchestrator.validate(context)),\n            contextFactory: instrumented.fn(instrumentation?.context, typedOrchestrator.contextFactory(context)),\n            execute: instrumented.asyncFn(instrumentation?.execute, typedOrchestrator.execute),\n            subscribe: instrumented.asyncFn(instrumentation?.subscribe, typedOrchestrator.subscribe),\n            schema: typedOrchestrator.getCurrentSchema(),\n        };\n    };\n    getEnveloped._plugins = plugins;\n    return getEnveloped;\n}\n","/**\n * ES6 Map with additional `add` method to accumulate items.\n */\nexport class AccumulatorMap extends Map {\n    get [Symbol.toStringTag]() {\n        return 'AccumulatorMap';\n    }\n    add(key, item) {\n        const group = this.get(key);\n        if (group === undefined) {\n            this.set(key, [item]);\n        }\n        else {\n            group.push(item);\n        }\n    }\n}\n","import { DirectiveLocation, GraphQLBoolean, GraphQLDirective, GraphQLInt, GraphQLNonNull, GraphQLString, } from 'graphql';\n/**\n * Used to conditionally defer fragments.\n */\nexport const GraphQLDeferDirective = new GraphQLDirective({\n    name: 'defer',\n    description: 'Directs the executor to defer this fragment when the `if` argument is true or undefined.',\n    locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],\n    args: {\n        if: {\n            type: new GraphQLNonNull(GraphQLBoolean),\n            description: 'Deferred when true or undefined.',\n            defaultValue: true,\n        },\n        label: {\n            type: GraphQLString,\n            description: 'Unique name',\n        },\n    },\n});\n/**\n * Used to conditionally stream list fields.\n */\nexport const GraphQLStreamDirective = new GraphQLDirective({\n    name: 'stream',\n    description: 'Directs the executor to stream plural fields when the `if` argument is true or undefined.',\n    locations: [DirectiveLocation.FIELD],\n    args: {\n        if: {\n            type: new GraphQLNonNull(GraphQLBoolean),\n            description: 'Stream when true or undefined.',\n            defaultValue: true,\n        },\n        label: {\n            type: GraphQLString,\n            description: 'Unique name',\n        },\n        initialCount: {\n            defaultValue: 0,\n            type: GraphQLInt,\n            description: 'Number of items to return immediately',\n        },\n    },\n});\n","import { getDirectiveValues, GraphQLIncludeDirective, GraphQLSkipDirective, isAbstractType, Kind, typeFromAST, } from 'graphql';\nimport { AccumulatorMap } from './AccumulatorMap.js';\nimport { GraphQLDeferDirective } from './directives.js';\nimport { memoize5 } from './memoize.js';\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case Kind.FIELD: {\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                fields.add(getFieldEntryKey(selection), selection);\n                break;\n            }\n            case Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(variableValues, selection) ||\n                    !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n                    continue;\n                }\n                const defer = getDeferValues(variableValues, selection);\n                if (defer) {\n                    const patchFields = new AccumulatorMap();\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);\n                    patches.push({\n                        label: defer.label,\n                        fields: patchFields,\n                    });\n                }\n                else {\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);\n                }\n                break;\n            }\n            case Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                const defer = getDeferValues(variableValues, selection);\n                if (visitedFragmentNames.has(fragName) && !defer) {\n                    continue;\n                }\n                const fragment = fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n                    continue;\n                }\n                if (!defer) {\n                    visitedFragmentNames.add(fragName);\n                }\n                if (defer) {\n                    const patchFields = new AccumulatorMap();\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);\n                    patches.push({\n                        label: defer.label,\n                        fields: patchFields,\n                    });\n                }\n                else {\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);\n                }\n                break;\n            }\n        }\n    }\n}\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n */\nexport function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n    const fields = new AccumulatorMap();\n    const patches = [];\n    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set());\n    return { fields, patches };\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nexport function shouldIncludeNode(variableValues, node) {\n    const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n    if (skip?.['if'] === true) {\n        return false;\n    }\n    const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n    if (include?.['if'] === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nexport function doesFragmentConditionMatch(schema, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = typeFromAST(schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if (isAbstractType(conditionalType)) {\n        const possibleTypes = schema.getPossibleTypes(conditionalType);\n        return possibleTypes.includes(type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nexport function getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\n/**\n * Returns an object containing the `@defer` arguments if a field should be\n * deferred based on the experimental flag, defer directive present and\n * not disabled by the \"if\" argument.\n */\nexport function getDeferValues(variableValues, node) {\n    const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);\n    if (!defer) {\n        return;\n    }\n    if (defer['if'] === false) {\n        return;\n    }\n    return {\n        label: typeof defer['label'] === 'string' ? defer['label'] : undefined,\n    };\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n */\nexport const collectSubFields = memoize5(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n    const subFieldNodes = new AccumulatorMap();\n    const visitedFragmentNames = new Set();\n    const subPatches = [];\n    const subFieldsAndPatches = {\n        fields: subFieldNodes,\n        patches: subPatches,\n    };\n    for (const node of fieldNodes) {\n        if (node.selectionSet) {\n            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);\n        }\n    }\n    return subFieldsAndPatches;\n});\n","/**\n * Given a Path and a key, return a new Path containing the new key.\n */\nexport function addPath(prev, key, typename) {\n    return { prev, key, typename };\n}\n/**\n * Given a Path, return an Array of the path keys.\n */\nexport function pathToArray(path) {\n    const flattened = [];\n    let curr = path;\n    while (curr) {\n        flattened.push(curr.key);\n        curr = curr.prev;\n    }\n    return flattened.reverse();\n}\n/**\n * Build a string describing the path.\n */\nexport function printPathArray(path) {\n    return path\n        .map(key => (typeof key === 'number' ? '[' + key.toString() + ']' : '.' + key))\n        .join('');\n}\n","export function isAsyncIterable(value) {\n    return value?.[Symbol.asyncIterator] != null;\n}\n","export const DisposableSymbols = {\n    get dispose() {\n        return Symbol.dispose || Symbol.for('dispose');\n    },\n    get asyncDispose() {\n        return Symbol.asyncDispose || Symbol.for('asyncDispose');\n    },\n};\nexport function patchSymbols() {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - we ponyfill these symbols\n    Symbol.dispose ||= Symbol.for('dispose');\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - we ponyfill these symbols\n    Symbol.asyncDispose ||= Symbol.for('asyncDispose');\n}\n","export function coerceError(error) {\n    if (error instanceof Error) {\n        return error;\n    }\n    if (typeof error === 'object' && error != null) {\n        if ('message' in error && typeof error.message === 'string') {\n            let errorOptions;\n            if ('cause' in error) {\n                errorOptions = { cause: error.cause };\n            }\n            const coercedError = new Error(error.message, errorOptions);\n            if ('stack' in error && typeof error.stack === 'string') {\n                coercedError.stack = error.stack;\n            }\n            if ('name' in error && typeof error.name === 'string') {\n                coercedError.name = error.name;\n            }\n            return coercedError;\n        }\n    }\n    return new Error(String(error));\n}\n","import { DisposableSymbols } from '@whatwg-node/disposablestack';\n/**\n * Given an AsyncIterable of AsyncIterables, flatten all yielded results into a\n * single AsyncIterable.\n */\nexport function flattenAsyncIterable(iterable) {\n    // You might think this whole function could be replaced with\n    //\n    //    async function* flattenAsyncIterable(iterable) {\n    //      for await (const subIterator of iterable) {\n    //        yield* subIterator;\n    //      }\n    //    }\n    //\n    // but calling `.return()` on the iterator it returns won't interrupt the `for await`.\n    const topIterator = iterable[Symbol.asyncIterator]();\n    let currentNestedIterator;\n    let waitForCurrentNestedIterator;\n    let done = false;\n    async function next() {\n        if (done) {\n            return { value: undefined, done: true };\n        }\n        try {\n            if (!currentNestedIterator) {\n                // Somebody else is getting it already.\n                if (waitForCurrentNestedIterator) {\n                    await waitForCurrentNestedIterator;\n                    return await next();\n                }\n                // Nobody else is getting it. We should!\n                let resolve;\n                waitForCurrentNestedIterator = new Promise(r => {\n                    resolve = r;\n                });\n                const topIteratorResult = await topIterator.next();\n                if (topIteratorResult.done) {\n                    // Given that done only ever transitions from false to true,\n                    // require-atomic-updates is being unnecessarily cautious.\n                    done = true;\n                    return await next();\n                }\n                // eslint is making a reasonable point here, but we've explicitly protected\n                // ourself from the race condition by ensuring that only the single call\n                // that assigns to waitForCurrentNestedIterator is allowed to assign to\n                // currentNestedIterator or waitForCurrentNestedIterator.\n                currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();\n                waitForCurrentNestedIterator = undefined;\n                resolve();\n                return await next();\n            }\n            const rememberCurrentNestedIterator = currentNestedIterator;\n            const nestedIteratorResult = await currentNestedIterator.next();\n            if (!nestedIteratorResult.done) {\n                return nestedIteratorResult;\n            }\n            // The nested iterator is done. If it's still the current one, make it not\n            // current. (If it's not the current one, somebody else has made us move on.)\n            if (currentNestedIterator === rememberCurrentNestedIterator) {\n                currentNestedIterator = undefined;\n            }\n            return await next();\n        }\n        catch (err) {\n            done = true;\n            throw err;\n        }\n    }\n    return {\n        next,\n        async return() {\n            done = true;\n            await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);\n            return { value: undefined, done: true };\n        },\n        async throw(error) {\n            done = true;\n            await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);\n            /* c8 ignore next */\n            throw error;\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        async [DisposableSymbols.asyncDispose]() {\n            done = true;\n            await Promise.all([\n                currentNestedIterator?.[DisposableSymbols.asyncDispose]?.(),\n                topIterator?.[DisposableSymbols.asyncDispose]?.(),\n            ]);\n        },\n    };\n}\n","export function invariant(condition, message) {\n    if (!condition) {\n        throw new Error(message != null ? message : 'Unexpected invariant triggered.');\n    }\n}\n","import { handleMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\n/**\n * This function transforms a JS object `Record<string, Promise<T>>` into\n * a `Promise<Record<string, T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nexport function promiseForObject(object, signal, signalPromise) {\n    signal?.throwIfAborted();\n    const resolvedObject = Object.create(null);\n    const promises = [];\n    for (const key in object) {\n        const valueSet$ = handleMaybePromise(() => object[key], resolvedValue => {\n            resolvedObject[key] = resolvedValue;\n        });\n        if (isPromise(valueSet$)) {\n            promises.push(valueSet$);\n        }\n    }\n    if (!promises.length) {\n        return resolvedObject;\n    }\n    const promiseAll = promises.length === 1 ? promises[0] : Promise.all(promises);\n    if (signalPromise) {\n        return Promise.race([signalPromise, promiseAll]).then(() => resolvedObject);\n    }\n    return promiseAll.then(() => resolvedObject);\n}\n","import { coerceInputValue, isInputType, isNonNullType, print, typeFromAST, valueFromAST, } from 'graphql';\nimport { createGraphQLError, hasOwnProperty, inspect, printPathArray } from '@graphql-tools/utils';\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n    const errors = [];\n    const maxErrors = options?.maxErrors;\n    try {\n        const coerced = coerceVariableValues(schema, varDefNodes, inputs, error => {\n            if (maxErrors != null && errors.length >= maxErrors) {\n                throw createGraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');\n            }\n            errors.push(error);\n        });\n        if (errors.length === 0) {\n            return { coerced };\n        }\n    }\n    catch (error) {\n        errors.push(error);\n    }\n    return { errors };\n}\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n    const coercedValues = {};\n    for (const varDefNode of varDefNodes) {\n        const varName = varDefNode.variable.name.value;\n        const varType = typeFromAST(schema, varDefNode.type);\n        if (!isInputType(varType)) {\n            // Must use input types for variables. This should be caught during\n            // validation, however is checked again here for safety.\n            const varTypeStr = print(varDefNode.type);\n            onError(createGraphQLError(`Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`, { nodes: varDefNode.type }));\n            continue;\n        }\n        if (!hasOwnProperty(inputs, varName)) {\n            if (varDefNode.defaultValue) {\n                coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n            }\n            else if (isNonNullType(varType)) {\n                const varTypeStr = inspect(varType);\n                onError(createGraphQLError(`Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`, {\n                    nodes: varDefNode,\n                }));\n            }\n            continue;\n        }\n        const value = inputs[varName];\n        if (value === null && isNonNullType(varType)) {\n            const varTypeStr = inspect(varType);\n            onError(createGraphQLError(`Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`, {\n                nodes: varDefNode,\n            }));\n            continue;\n        }\n        coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error) => {\n            let prefix = `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n            if (path.length > 0) {\n                prefix += ` at \"${varName}${printPathArray(path)}\"`;\n            }\n            onError(createGraphQLError(prefix + '; ' + error.message, {\n                nodes: varDefNode,\n                originalError: error,\n            }));\n        });\n    }\n    return coercedValues;\n}\n","import { assertValidSchema, getDirectiveValues, GraphQLError, isAbstractType, isLeafType, isListType, isNonNullType, isObjectType, Kind, locatedError, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, versionInfo, } from 'graphql';\nimport { collectSubFields as _collectSubfields, addPath, collectFields, createGraphQLError, fakePromise, getArgumentValues, getDefinedRootType, GraphQLStreamDirective, inspect, isAsyncIterable, isIterableObject, isObjectLike, isPromise, mapAsyncIterator, memoize1, memoize3, pathToArray, promiseReduce, } from '@graphql-tools/utils';\nimport { DisposableSymbols } from '@whatwg-node/disposablestack';\nimport { createDeferredPromise, handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { coerceError } from './coerceError.js';\nimport { flattenAsyncIterable } from './flattenAsyncIterable.js';\nimport { invariant } from './invariant.js';\nimport { promiseForObject } from './promiseForObject.js';\nimport { getVariableValues } from './values.js';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) => _collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification,\n * including `@defer` and `@stream` as proposed in\n * https://github.com/graphql/graphql-spec/pull/742\n *\n * This function returns a Promise of an IncrementalExecutionResults\n * object. This object either consists of a single ExecutionResult, or an\n * object containing an `initialResult` and a stream of `subsequentResults`.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n    // If a valid execution context cannot be created due to incorrect arguments,\n    // a \"Response\" with only errors is returned.\n    const exeContext = buildExecutionContext(args);\n    // Return early errors if execution context failed.\n    if (!('schema' in exeContext)) {\n        return {\n            errors: exeContext.map(e => {\n                Object.defineProperty(e, 'extensions', {\n                    value: {\n                        ...e.extensions,\n                        http: {\n                            ...(e.extensions?.['http'] || {}),\n                            status: 400,\n                        },\n                    },\n                });\n                return e;\n            }),\n        };\n    }\n    return executeImpl(exeContext);\n}\nfunction executeImpl(exeContext) {\n    exeContext.signal?.throwIfAborted();\n    // Return a Promise that will eventually resolve to the data described by\n    // The \"Response\" section of the GraphQL specification.\n    //\n    // If errors are encountered while executing a GraphQL field, only that\n    // field and its descendants will be omitted, and sibling fields will still\n    // be executed. An execution which encounters errors will still result in a\n    // resolved Promise.\n    //\n    // Errors from sub-fields of a NonNull type may propagate to the top level,\n    // at which point we still log the error and null the parent field, which\n    // in this case is the entire response.\n    return handleMaybePromise(() => executeOperation(exeContext), data => {\n        const initialResult = buildResponse(data, exeContext.errors);\n        if (exeContext.subsequentPayloads.size > 0) {\n            return {\n                initialResult: {\n                    ...initialResult,\n                    hasNext: true,\n                },\n                subsequentResults: yieldSubsequentPayloads(exeContext),\n            };\n        }\n        return initialResult;\n    }, (error) => {\n        exeContext.signal?.throwIfAborted();\n        if (error.errors) {\n            exeContext.errors.push(...error.errors);\n        }\n        else {\n            exeContext.errors.push(error);\n        }\n        return buildResponse(null, exeContext.errors);\n    });\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\nexport function executeSync(args) {\n    const result = execute(args);\n    // Assert that the execution was synchronous.\n    if (isPromise(result) || 'initialResult' in result) {\n        throw new Error('GraphQL execution failed to complete synchronously.');\n    }\n    return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\nfunction buildResponse(data, errors) {\n    return errors.length === 0 ? { data } : { errors, data };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\nexport function assertValidExecutionArguments(schema, document, rawVariableValues) {\n    console.assert(!!document, 'Must provide document.');\n    // If the schema used for execution is invalid, throw an error.\n    assertValidSchema(schema);\n    // Variables, if provided, must be an object.\n    console.assert(rawVariableValues == null || isObjectLike(rawVariableValues), 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\nexport const getFragmentsFromDocument = memoize1(function getFragmentsFromDocument(document) {\n    const fragments = Object.create(null);\n    for (const definition of document.definitions) {\n        if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n            fragments[definition.name.value] = definition;\n        }\n    }\n    return fragments;\n});\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * TODO: consider no longer exporting this function\n * @internal\n */\nexport function buildExecutionContext(args) {\n    const { schema, document, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal, } = args;\n    signal?.throwIfAborted();\n    // If the schema used for execution is invalid, throw an error.\n    assertValidSchema(schema);\n    const fragments = getFragmentsFromDocument(document);\n    let operation;\n    for (const definition of document.definitions) {\n        switch (definition.kind) {\n            case Kind.OPERATION_DEFINITION:\n                if (operationName == null) {\n                    if (operation !== undefined) {\n                        return [\n                            createGraphQLError('Must provide operation name if query contains multiple operations.', {\n                                extensions: {\n                                    code: 'OPERATION_RESOLUTION_FAILURE',\n                                },\n                            }),\n                        ];\n                    }\n                    operation = definition;\n                }\n                else if (definition.name?.value === operationName) {\n                    operation = definition;\n                }\n                break;\n            default:\n            // ignore non-executable definitions\n        }\n    }\n    if (operation == null) {\n        if (operationName != null) {\n            return [\n                createGraphQLError(`Unknown operation named \"${operationName}\".`, {\n                    extensions: {\n                        code: 'OPERATION_RESOLUTION_FAILURE',\n                    },\n                }),\n            ];\n        }\n        return [\n            createGraphQLError('Must provide an operation.', {\n                extensions: {\n                    code: 'OPERATION_RESOLUTION_FAILURE',\n                },\n            }),\n        ];\n    }\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    /* c8 ignore next */\n    const variableDefinitions = operation.variableDefinitions ?? [];\n    const coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues ?? {}, {\n        maxErrors: 50,\n    });\n    if (coercedVariableValues.errors) {\n        return coercedVariableValues.errors;\n    }\n    signal?.throwIfAborted();\n    let onSignalAbort;\n    let signalPromise;\n    if (signal) {\n        const listeners = new Set();\n        const signalDeferred = createDeferredPromise();\n        signalPromise = signalDeferred.promise;\n        const sharedListener = () => {\n            signalDeferred.reject(signal.reason);\n            signal.removeEventListener('abort', sharedListener);\n        };\n        signal.addEventListener('abort', sharedListener, { once: true });\n        signalPromise.catch(() => {\n            for (const listener of listeners) {\n                listener();\n            }\n            listeners.clear();\n        });\n        onSignalAbort = handler => {\n            listeners.add(handler);\n        };\n    }\n    return {\n        schema,\n        fragments,\n        rootValue,\n        contextValue,\n        operation,\n        variableValues: coercedVariableValues.coerced,\n        fieldResolver: fieldResolver ?? defaultFieldResolver,\n        typeResolver: typeResolver ?? defaultTypeResolver,\n        subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver,\n        subsequentPayloads: new Set(),\n        errors: [],\n        signal,\n        onSignalAbort,\n        signalPromise,\n    };\n}\nfunction buildPerEventExecutionContext(exeContext, payload) {\n    return {\n        ...exeContext,\n        rootValue: payload,\n        subsequentPayloads: new Set(),\n        errors: [],\n    };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\nfunction executeOperation(exeContext) {\n    const { operation, schema, fragments, variableValues, rootValue } = exeContext;\n    const rootType = getDefinedRootType(schema, operation.operation, [operation]);\n    if (rootType == null) {\n        createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {\n            nodes: operation,\n        });\n    }\n    const { fields: rootFields, patches } = collectFields(schema, fragments, variableValues, rootType, operation.selectionSet);\n    const path = undefined;\n    let result;\n    if (operation.operation === 'mutation') {\n        result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n    }\n    else {\n        result = executeFields(exeContext, rootType, rootValue, path, rootFields);\n    }\n    for (const patch of patches) {\n        const { label, fields: patchFields } = patch;\n        executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);\n    }\n    return result;\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n    return promiseReduce(fields, (results, [responseName, fieldNodes]) => {\n        const fieldPath = addPath(path, responseName, parentType.name);\n        exeContext.signal?.throwIfAborted();\n        return handleMaybePromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath), result => {\n            if (result === undefined) {\n                return results;\n            }\n            results[responseName] = result;\n            return results;\n        });\n    }, Object.create(null));\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\nfunction executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {\n    const results = Object.create(null);\n    let containsPromise = false;\n    try {\n        for (const [responseName, fieldNodes] of fields) {\n            exeContext.signal?.throwIfAborted();\n            const fieldPath = addPath(path, responseName, parentType.name);\n            const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);\n            if (result !== undefined) {\n                results[responseName] = result;\n                if (isPromise(result)) {\n                    containsPromise = true;\n                }\n            }\n        }\n    }\n    catch (error) {\n        if (error !== exeContext.signal?.reason && containsPromise) {\n            // Ensure that any promises returned by other fields are handled, as they may also reject.\n            return handleMaybePromise(() => promiseForObject(results, exeContext.signal), () => {\n                throw error;\n            }, () => {\n                throw error;\n            });\n        }\n        throw error;\n    }\n    // If there are no promises, we can just return the object\n    if (!containsPromise) {\n        return results;\n    }\n    // Otherwise, results is a map from field name to the result of resolving that\n    // field, which is possibly a promise. Return a promise that will return this\n    // same map, but with any promises replaced with the values they resolved to.\n    return promiseForObject(results, exeContext.signal, exeContext.signalPromise);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\nfunction executeField(exeContext, parentType, source, fieldNodes, path, asyncPayloadRecord) {\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n    if (!fieldDef) {\n        return;\n    }\n    const returnType = fieldDef.type;\n    const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;\n    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);\n    // Get the resolve function, regardless of if its result is normal or abrupt (error).\n    try {\n        exeContext.signal?.throwIfAborted();\n        // Build a JS object of arguments from the field.arguments AST, using the\n        // variables scope to fulfill any variable references.\n        // TODO: find a way to memoize, in case this field is within a List type.\n        const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);\n        // The resolve function's optional third argument is a context value that\n        // is provided to every resolve function within an execution. It is commonly\n        // used to represent an authenticated user, or request-specific caches.\n        const contextValue = exeContext.contextValue;\n        const result = resolveFn(source, args, contextValue, info);\n        let completed;\n        if (isPromise(result)) {\n            completed = result.then(resolved => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));\n        }\n        else {\n            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n        }\n        if (isPromise(completed)) {\n            // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n            // to take a second callback for the error case.\n            return completed.then(undefined, rawError => {\n                if (rawError instanceof AggregateError) {\n                    let result;\n                    for (let rawErrorItem of rawError.errors) {\n                        rawErrorItem = coerceError(rawErrorItem);\n                        const error = locatedError(rawErrorItem, fieldNodes, pathToArray(path));\n                        result = handleFieldError(error, returnType, errors);\n                        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                    }\n                    return result;\n                }\n                rawError = coerceError(rawError);\n                const error = locatedError(rawError, fieldNodes, pathToArray(path));\n                const handledError = handleFieldError(error, returnType, errors);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                return handledError;\n            });\n        }\n        return completed;\n    }\n    catch (rawError) {\n        if (rawError instanceof AggregateError) {\n            let result;\n            for (let rawErrorItem of rawError.errors) {\n                rawErrorItem = coerceError(rawErrorItem);\n                const error = locatedError(rawErrorItem, fieldNodes, pathToArray(path));\n                result = handleFieldError(error, returnType, errors);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            }\n            return result;\n        }\n        const coercedError = coerceError(rawError);\n        const error = locatedError(coercedError, fieldNodes, pathToArray(path));\n        const handledError = handleFieldError(error, returnType, errors);\n        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n        return handledError;\n    }\n}\n/**\n * TODO: consider no longer exporting this function\n * @internal\n */\nexport function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n    // The resolve function's optional fourth argument is a collection of\n    // information about the current execution state.\n    return {\n        fieldName: fieldDef.name,\n        fieldNodes,\n        returnType: fieldDef.type,\n        parentType,\n        path,\n        schema: exeContext.schema,\n        fragments: exeContext.fragments,\n        rootValue: exeContext.rootValue,\n        operation: exeContext.operation,\n        variableValues: exeContext.variableValues,\n        signal: exeContext.signal,\n    };\n}\nexport const CRITICAL_ERROR = 'CRITICAL_ERROR';\nfunction handleFieldError(error, returnType, errors) {\n    // If the field type is non-nullable, then it is resolved without any\n    // protection from errors, however it still properly locates the error.\n    if (isNonNullType(returnType)) {\n        throw error;\n    }\n    if (error.extensions?.[CRITICAL_ERROR]) {\n        throw error;\n    }\n    // Otherwise, error protection is applied, logging the error and resolving\n    // a null value for this field if one is encountered.\n    errors.push(error);\n    return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    // If result is an Error, throw a located error.\n    if (result instanceof Error) {\n        throw result;\n    }\n    // If field type is NonNull, complete for inner type, and throw field error\n    // if result is null.\n    if (isNonNullType(returnType)) {\n        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);\n        if (completed === null) {\n            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);\n        }\n        return completed;\n    }\n    // If result value is null or undefined then return null.\n    if (result == null) {\n        return null;\n    }\n    // If field type is List, complete each item in the list with the inner type\n    if (isListType(returnType)) {\n        return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n    // returning null if serialization is not possible.\n    if (isLeafType(returnType)) {\n        return completeLeafValue(returnType, result);\n    }\n    // If field type is an abstract type, Interface or Union, determine the\n    // runtime Object type and complete for that type.\n    if (isAbstractType(returnType)) {\n        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    // If field type is Object, execute and complete all sub-selections.\n    if (isObjectType(returnType)) {\n        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    /* c8 ignore next 6 */\n    // Not reachable, all possible output types have been considered.\n    console.assert(false, 'Cannot complete value of unexpected output type: ' + inspect(returnType));\n}\n/**\n * Returns an object containing the `@stream` arguments if a field should be\n * streamed based on the experimental flag, stream directive present and\n * not disabled by the \"if\" argument.\n */\nfunction getStreamValues(exeContext, fieldNodes, path) {\n    // do not stream inner lists of multi-dimensional lists\n    if (typeof path.key === 'number') {\n        return;\n    }\n    // validation only allows equivalent streams on multiple fields, so it is\n    // safe to only check the first fieldNode for the stream directive\n    const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);\n    if (!stream) {\n        return;\n    }\n    if (stream.if === false) {\n        return;\n    }\n    invariant(typeof stream['initialCount'] === 'number', 'initialCount must be a number');\n    invariant(stream['initialCount'] >= 0, 'initialCount must be a positive integer');\n    return {\n        initialCount: stream['initialCount'],\n        label: typeof stream['label'] === 'string' ? stream['label'] : undefined,\n    };\n}\n/**\n * Complete a async iterator value by completing the result and calling\n * recursively until all the results are completed.\n */\nasync function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {\n    exeContext.signal?.throwIfAborted();\n    if (iterator.return) {\n        exeContext.onSignalAbort?.(() => {\n            iterator.return?.();\n        });\n    }\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    const stream = getStreamValues(exeContext, fieldNodes, path);\n    let containsPromise = false;\n    const completedResults = [];\n    let index = 0;\n    while (true) {\n        if (stream && typeof stream.initialCount === 'number' && index >= stream.initialCount) {\n            executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);\n            break;\n        }\n        const itemPath = addPath(path, index, undefined);\n        let iteration;\n        try {\n            iteration = await iterator.next();\n            if (iteration.done) {\n                break;\n            }\n        }\n        catch (rawError) {\n            const coercedError = coerceError(rawError);\n            const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath));\n            completedResults.push(handleFieldError(error, itemType, errors));\n            break;\n        }\n        if (completeListItemValue(iteration.value, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {\n            containsPromise = true;\n        }\n        index += 1;\n    }\n    return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    const itemType = returnType.ofType;\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    if (isAsyncIterable(result)) {\n        const iterator = result[Symbol.asyncIterator]();\n        return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);\n    }\n    if (!isIterableObject(result)) {\n        throw createGraphQLError(`Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`);\n    }\n    const stream = getStreamValues(exeContext, fieldNodes, path);\n    // This is specified as a simple map, however we're optimizing the path\n    // where the list contains no Promises by avoiding creating another Promise.\n    let containsPromise = false;\n    let previousAsyncPayloadRecord = asyncPayloadRecord;\n    const completedResults = [];\n    let index = 0;\n    for (const item of result) {\n        // No need to modify the info object containing the path,\n        // since from here on it is not ever accessed by resolver functions.\n        const itemPath = addPath(path, index, undefined);\n        if (stream && typeof stream.initialCount === 'number' && index >= stream.initialCount) {\n            previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);\n            index++;\n            continue;\n        }\n        if (completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {\n            containsPromise = true;\n        }\n        index++;\n    }\n    return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a list item value by adding it to the completed results.\n *\n * Returns true if the value is a Promise.\n */\nfunction completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {\n    try {\n        let completedItem;\n        if (isPromise(item)) {\n            completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));\n        }\n        else {\n            completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n        }\n        if (isPromise(completedItem)) {\n            // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n            // to take a second callback for the error case.\n            completedResults.push(completedItem.then(undefined, rawError => {\n                rawError = coerceError(rawError);\n                const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n                const handledError = handleFieldError(error, itemType, errors);\n                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                return handledError;\n            }));\n            return true;\n        }\n        completedResults.push(completedItem);\n    }\n    catch (rawError) {\n        const coercedError = coerceError(rawError);\n        const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath));\n        const handledError = handleFieldError(error, itemType, errors);\n        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        completedResults.push(handledError);\n    }\n    return false;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\nfunction completeLeafValue(returnType, result) {\n    let serializedResult;\n    // Note: We transform GraphQLError to Error in order to be consistent with\n    // how non-null checks work later on.\n    // See https://github.com/kamilkisiela/graphql-hive/pull/2299\n    // See https://github.com/n1ru4l/envelop/issues/1808\n    try {\n        serializedResult = returnType.serialize(result);\n    }\n    catch (err) {\n        if (err instanceof GraphQLError) {\n            throw new Error(err.message);\n        }\n        throw err;\n    }\n    if (serializedResult == null) {\n        throw new Error(`Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n            `return non-nullable value, returned: ${inspect(serializedResult)}`);\n    }\n    return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;\n    const contextValue = exeContext.contextValue;\n    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n    if (isPromise(runtimeType)) {\n        return runtimeType.then(resolvedRuntimeType => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));\n    }\n    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);\n}\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {\n    if (runtimeTypeName == null) {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`, { nodes: fieldNodes });\n    }\n    // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n    // TODO: remove in 17.0.0 release\n    if (isObjectType(runtimeTypeName)) {\n        if (versionInfo.major >= 16) {\n            throw createGraphQLError('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');\n        }\n        runtimeTypeName = runtimeTypeName.name;\n    }\n    if (typeof runtimeTypeName !== 'string') {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n            `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`);\n    }\n    const runtimeType = exeContext.schema.getType(runtimeTypeName);\n    if (runtimeType == null) {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`, { nodes: fieldNodes });\n    }\n    if (!isObjectType(runtimeType)) {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`, { nodes: fieldNodes });\n    }\n    if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n        throw createGraphQLError(`Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`, { nodes: fieldNodes });\n    }\n    return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    // If there is an isTypeOf predicate function, call it with the\n    // current result. If isTypeOf returns false, then raise an error rather\n    // than continuing execution.\n    if (returnType.isTypeOf) {\n        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n        if (isPromise(isTypeOf)) {\n            return isTypeOf.then(resolvedIsTypeOf => {\n                if (!resolvedIsTypeOf) {\n                    throw invalidReturnTypeError(returnType, result, fieldNodes);\n                }\n                return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);\n            });\n        }\n        if (!isTypeOf) {\n            throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n    }\n    return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);\n}\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n    return createGraphQLError(`Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`, {\n        nodes: fieldNodes,\n    });\n}\nfunction collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {\n    // Collect sub-fields to execute to complete this value.\n    const { fields: subFieldNodes, patches: subPatches } = collectSubfields(exeContext, returnType, fieldNodes);\n    const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);\n    for (const subPatch of subPatches) {\n        const { label, fields: subPatchFieldNodes } = subPatch;\n        executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);\n    }\n    return subFields;\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\nexport const defaultTypeResolver = function (value, contextValue, info, abstractType) {\n    // First, look for `__typename`.\n    if (isObjectLike(value) && typeof value['__typename'] === 'string') {\n        return value['__typename'];\n    }\n    // Otherwise, test each possible type.\n    const possibleTypes = info.schema.getPossibleTypes(abstractType);\n    const promisedIsTypeOfResults = [];\n    for (let i = 0; i < possibleTypes.length; i++) {\n        const type = possibleTypes[i];\n        if (type.isTypeOf) {\n            const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n            if (isPromise(isTypeOfResult)) {\n                promisedIsTypeOfResults[i] = isTypeOfResult;\n            }\n            else if (isTypeOfResult) {\n                return type.name;\n            }\n        }\n    }\n    if (promisedIsTypeOfResults.length) {\n        return Promise.all(promisedIsTypeOfResults).then(isTypeOfResults => {\n            for (let i = 0; i < isTypeOfResults.length; i++) {\n                if (isTypeOfResults[i]) {\n                    return possibleTypes[i].name;\n                }\n            }\n        });\n    }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\nexport const defaultFieldResolver = function (source, args, contextValue, info) {\n    // ensure source is a value for which property access is acceptable.\n    if (isObjectLike(source) || typeof source === 'function') {\n        const property = source[info.fieldName];\n        if (typeof property === 'function') {\n            return source[info.fieldName](args, contextValue, info);\n        }\n        return property;\n    }\n};\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification,\n * including `@defer` and `@stream` as proposed in\n * https://github.com/graphql/graphql-spec/pull/742\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with descriptive\n * errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription resolver\n * logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of result representing the response stream.\n *\n * Each result may be an ExecutionResult with no `hasNext` (if executing the\n * event did not use `@defer` or `@stream`), or an\n * `InitialIncrementalExecutionResult` or `SubsequentIncrementalExecutionResult`\n * (if executing the event used `@defer` or `@stream`). In the case of\n * incremental execution results, each event produces a single\n * `InitialIncrementalExecutionResult` followed by one or more\n * `SubsequentIncrementalExecutionResult`s; all but the last have `hasNext: true`,\n * and the last has `hasNext: false`. There is no interleaving between results\n * generated from the same original event.\n *\n * Accepts an object with named arguments.\n */\nexport function subscribe(args) {\n    // If a valid execution context cannot be created due to incorrect arguments,\n    // a \"Response\" with only errors is returned.\n    const exeContext = buildExecutionContext(args);\n    // Return early errors if execution context failed.\n    if (!('schema' in exeContext)) {\n        for (const error of exeContext) {\n            // @ts-expect-error - We are intentionally modifying the errors\n            const extensions = (error.extensions ||= {});\n            const httpExtensions = (extensions['http'] ||= {});\n            httpExtensions.status = 400;\n            error.extensions['code'] = 'BAD_USER_INPUT';\n        }\n        return {\n            errors: exeContext,\n        };\n    }\n    const resultOrStream = createSourceEventStreamImpl(exeContext);\n    if (isPromise(resultOrStream)) {\n        return resultOrStream.then(resolvedResultOrStream => mapSourceToResponse(exeContext, resolvedResultOrStream));\n    }\n    return mapSourceToResponse(exeContext, resultOrStream);\n}\nexport function isIncrementalResults(results) {\n    return results?.initialResult;\n}\nexport function flattenIncrementalResults(incrementalResults) {\n    const subsequentIterator = incrementalResults.subsequentResults;\n    let initialResultSent = false;\n    let done = false;\n    return {\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        next() {\n            if (done) {\n                return fakePromise({ value: undefined, done });\n            }\n            if (initialResultSent) {\n                return subsequentIterator.next();\n            }\n            initialResultSent = true;\n            return fakePromise({\n                value: incrementalResults.initialResult,\n                done,\n            });\n        },\n        return() {\n            done = true;\n            return subsequentIterator.return();\n        },\n        throw(error) {\n            done = true;\n            return subsequentIterator.throw(error);\n        },\n        [DisposableSymbols.asyncDispose]() {\n            done = true;\n            return subsequentIterator?.[DisposableSymbols.asyncDispose]?.();\n        },\n    };\n}\nasync function* ensureAsyncIterable(someExecutionResult) {\n    if ('initialResult' in someExecutionResult) {\n        yield* flattenIncrementalResults(someExecutionResult);\n    }\n    else {\n        yield someExecutionResult;\n    }\n}\nfunction mapSourceToResponse(exeContext, resultOrStream) {\n    if (!isAsyncIterable(resultOrStream)) {\n        return resultOrStream;\n    }\n    // For each payload yielded from a subscription, map it over the normal\n    // GraphQL `execute` function, with `payload` as the rootValue.\n    // This implements the \"MapSourceToResponseEvent\" algorithm described in\n    // the GraphQL specification. The `execute` function provides the\n    // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n    // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n    return flattenAsyncIterable(mapAsyncIterator(resultOrStream, (payload) => handleMaybePromise(() => executeImpl(buildPerEventExecutionContext(exeContext, payload)), ensureAsyncIterable), (error) => {\n        if (error instanceof AggregateError) {\n            throw new AggregateError(error.errors.map(e => wrapError(e, exeContext.operation)), error.message);\n        }\n        throw wrapError(error, exeContext.operation);\n    }));\n}\nfunction wrapError(error, operation) {\n    return createGraphQLError(error.message, {\n        originalError: error,\n        nodes: [operation],\n    });\n}\nfunction createSourceEventStreamImpl(exeContext) {\n    try {\n        const eventStream = executeSubscription(exeContext);\n        if (isPromise(eventStream)) {\n            return eventStream.then(undefined, error => ({ errors: [error] }));\n        }\n        return eventStream;\n    }\n    catch (error) {\n        return { errors: [error] };\n    }\n}\nfunction executeSubscription(exeContext) {\n    const { schema, fragments, operation, variableValues, rootValue } = exeContext;\n    const rootType = schema.getSubscriptionType();\n    if (rootType == null) {\n        throw createGraphQLError('Schema is not configured to execute subscription operation.', {\n            nodes: operation,\n        });\n    }\n    const { fields: rootFields } = collectFields(schema, fragments, variableValues, rootType, operation.selectionSet);\n    const [responseName, fieldNodes] = [...rootFields.entries()][0];\n    const fieldName = fieldNodes[0].name.value;\n    const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n    if (!fieldDef) {\n        throw createGraphQLError(`The subscription field \"${fieldName}\" is not defined.`, {\n            nodes: fieldNodes,\n        });\n    }\n    const path = addPath(undefined, responseName, rootType.name);\n    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);\n    try {\n        // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n        // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n        // Build a JS object of arguments from the field.arguments AST, using the\n        // variables scope to fulfill any variable references.\n        const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);\n        // The resolve function's optional third argument is a context value that\n        // is provided to every resolve function within an execution. It is commonly\n        // used to represent an authenticated user, or request-specific caches.\n        const contextValue = exeContext.contextValue;\n        // Call the `subscribe()` resolver or the default resolver to produce an\n        // AsyncIterable yielding raw payloads.\n        const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;\n        const result = resolveFn(rootValue, args, contextValue, info);\n        if (isPromise(result)) {\n            return result\n                .then(result => assertEventStream(result, exeContext.signal, exeContext.onSignalAbort))\n                .then(undefined, error => {\n                throw locatedError(error, fieldNodes, pathToArray(path));\n            });\n        }\n        return assertEventStream(result, exeContext.signal, exeContext.onSignalAbort);\n    }\n    catch (error) {\n        throw locatedError(error, fieldNodes, pathToArray(path));\n    }\n}\nfunction assertEventStream(result, signal, onSignalAbort) {\n    signal?.throwIfAborted();\n    if (result instanceof Error) {\n        throw result;\n    }\n    // Assert field returned an event stream, otherwise yield an error.\n    if (!isAsyncIterable(result)) {\n        throw createGraphQLError('Subscription field must return Async Iterable. ' + `Received: ${inspect(result)}.`);\n    }\n    if (onSignalAbort) {\n        return {\n            [Symbol.asyncIterator]() {\n                const asyncIterator = result[Symbol.asyncIterator]();\n                if (asyncIterator.return) {\n                    onSignalAbort?.(() => {\n                        asyncIterator.return?.();\n                    });\n                }\n                return asyncIterator;\n            },\n        };\n    }\n    return result;\n}\nfunction executeDeferredFragment(exeContext, parentType, sourceValue, fields, label, path, parentContext) {\n    const asyncPayloadRecord = new DeferredFragmentRecord({\n        label,\n        path,\n        parentContext,\n        exeContext,\n    });\n    let promiseOrData;\n    try {\n        promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);\n        if (isPromise(promiseOrData)) {\n            promiseOrData = promiseOrData.then(null, e => {\n                asyncPayloadRecord.errors.push(e);\n                return null;\n            });\n        }\n    }\n    catch (e) {\n        asyncPayloadRecord.errors.push(e);\n        promiseOrData = null;\n    }\n    asyncPayloadRecord.addData(promiseOrData);\n}\nfunction executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {\n    const asyncPayloadRecord = new StreamRecord({\n        label,\n        path: itemPath,\n        parentContext,\n        exeContext,\n    });\n    let completedItem;\n    try {\n        try {\n            if (isPromise(item)) {\n                completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));\n            }\n            else {\n                completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n            }\n            if (isPromise(completedItem)) {\n                // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n                // to take a second callback for the error case.\n                completedItem = completedItem.then(undefined, rawError => {\n                    rawError = coerceError(rawError);\n                    const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n                    const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n                    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                    return handledError;\n                });\n            }\n        }\n        catch (rawError) {\n            const coercedError = coerceError(rawError);\n            const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath));\n            completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n            filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        }\n    }\n    catch (error) {\n        asyncPayloadRecord.errors.push(error);\n        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n        asyncPayloadRecord.addItems(null);\n        return asyncPayloadRecord;\n    }\n    let completedItems;\n    if (isPromise(completedItem)) {\n        completedItems = completedItem.then(value => [value], error => {\n            asyncPayloadRecord.errors.push(error);\n            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            return null;\n        });\n    }\n    else {\n        completedItems = [completedItem];\n    }\n    asyncPayloadRecord.addItems(completedItems);\n    return asyncPayloadRecord;\n}\nasync function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {\n    let item;\n    try {\n        const { value, done } = await iterator.next();\n        if (done) {\n            asyncPayloadRecord.setIsCompletedIterator();\n            return { done, value: undefined };\n        }\n        item = value;\n    }\n    catch (rawError) {\n        const coercedError = coerceError(rawError);\n        const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath));\n        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n        // don't continue if iterator throws\n        return { done: true, value };\n    }\n    let completedItem;\n    try {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n        if (isPromise(completedItem)) {\n            completedItem = completedItem.then(undefined, rawError => {\n                const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n                const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                return handledError;\n            });\n        }\n        return { done: false, value: completedItem };\n    }\n    catch (rawError) {\n        const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        return { done: false, value };\n    }\n}\nasync function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {\n    let index = initialIndex;\n    let previousAsyncPayloadRecord = parentContext ?? undefined;\n    while (true) {\n        const itemPath = addPath(path, index, undefined);\n        const asyncPayloadRecord = new StreamRecord({\n            label,\n            path: itemPath,\n            parentContext: previousAsyncPayloadRecord,\n            iterator,\n            exeContext,\n        });\n        let iteration;\n        try {\n            iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);\n        }\n        catch (error) {\n            asyncPayloadRecord.errors.push(error);\n            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            asyncPayloadRecord.addItems(null);\n            // entire stream has errored and bubbled upwards\n            if (iterator?.return) {\n                iterator.return().catch(() => {\n                    // ignore errors\n                });\n            }\n            return;\n        }\n        const { done, value: completedItem } = iteration;\n        let completedItems;\n        if (isPromise(completedItem)) {\n            completedItems = completedItem.then(value => [value], error => {\n                asyncPayloadRecord.errors.push(error);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                return null;\n            });\n        }\n        else {\n            completedItems = [completedItem];\n        }\n        asyncPayloadRecord.addItems(completedItems);\n        if (done) {\n            break;\n        }\n        previousAsyncPayloadRecord = asyncPayloadRecord;\n        index++;\n    }\n}\nfunction filterSubsequentPayloads(exeContext, nullPath, currentAsyncRecord) {\n    const nullPathArray = pathToArray(nullPath);\n    exeContext.subsequentPayloads.forEach(asyncRecord => {\n        if (asyncRecord === currentAsyncRecord) {\n            // don't remove payload from where error originates\n            return;\n        }\n        for (let i = 0; i < nullPathArray.length; i++) {\n            if (asyncRecord.path[i] !== nullPathArray[i]) {\n                // asyncRecord points to a path unaffected by this payload\n                return;\n            }\n        }\n        // asyncRecord path points to nulled error field\n        if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {\n            asyncRecord.iterator.return().catch(() => {\n                // ignore error\n            });\n        }\n        exeContext.subsequentPayloads.delete(asyncRecord);\n    });\n}\nfunction getCompletedIncrementalResults(exeContext) {\n    const incrementalResults = [];\n    for (const asyncPayloadRecord of exeContext.subsequentPayloads) {\n        const incrementalResult = {};\n        if (!asyncPayloadRecord.isCompleted) {\n            continue;\n        }\n        exeContext.subsequentPayloads.delete(asyncPayloadRecord);\n        if (isStreamPayload(asyncPayloadRecord)) {\n            const items = asyncPayloadRecord.items;\n            if (asyncPayloadRecord.isCompletedIterator) {\n                // async iterable resolver just finished but there may be pending payloads\n                continue;\n            }\n            incrementalResult.items = items;\n        }\n        else {\n            const data = asyncPayloadRecord.data;\n            incrementalResult.data = data ?? null;\n        }\n        incrementalResult.path = asyncPayloadRecord.path;\n        if (asyncPayloadRecord.label) {\n            incrementalResult.label = asyncPayloadRecord.label;\n        }\n        if (asyncPayloadRecord.errors.length > 0) {\n            incrementalResult.errors = asyncPayloadRecord.errors;\n        }\n        incrementalResults.push(incrementalResult);\n    }\n    return incrementalResults;\n}\nfunction yieldSubsequentPayloads(exeContext) {\n    let isDone = false;\n    async function next() {\n        if (isDone) {\n            return { value: undefined, done: true };\n        }\n        const subSequentPayloadPromises = Array.from(exeContext.subsequentPayloads).map(record => record.promise);\n        if (exeContext.signalPromise) {\n            await Promise.race([exeContext.signalPromise, ...subSequentPayloadPromises]);\n        }\n        else {\n            await Promise.race(subSequentPayloadPromises);\n        }\n        if (isDone) {\n            // a different call to next has exhausted all payloads\n            return { value: undefined, done: true };\n        }\n        const incremental = getCompletedIncrementalResults(exeContext);\n        const hasNext = exeContext.subsequentPayloads.size > 0;\n        if (!incremental.length && hasNext) {\n            return next();\n        }\n        if (!hasNext) {\n            isDone = true;\n        }\n        return {\n            value: incremental.length ? { incremental, hasNext } : { hasNext },\n            done: false,\n        };\n    }\n    function returnStreamIterators() {\n        const promises = [];\n        exeContext.subsequentPayloads.forEach(asyncPayloadRecord => {\n            if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {\n                promises.push(asyncPayloadRecord.iterator.return());\n            }\n        });\n        return Promise.all(promises);\n    }\n    return {\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        next,\n        async return() {\n            await returnStreamIterators();\n            isDone = true;\n            return { value: undefined, done: true };\n        },\n        async throw(error) {\n            await returnStreamIterators();\n            isDone = true;\n            throw error;\n        },\n        async [DisposableSymbols.asyncDispose]() {\n            await returnStreamIterators();\n            isDone = true;\n        },\n    };\n}\nclass DeferredFragmentRecord {\n    type;\n    errors;\n    label;\n    path;\n    promise;\n    data;\n    parentContext;\n    isCompleted;\n    _exeContext;\n    _resolve;\n    constructor(opts) {\n        this.type = 'defer';\n        this.label = opts.label;\n        this.path = pathToArray(opts.path);\n        this.parentContext = opts.parentContext;\n        this.errors = [];\n        this._exeContext = opts.exeContext;\n        this._exeContext.subsequentPayloads.add(this);\n        this.isCompleted = false;\n        this.data = null;\n        this.promise = new Promise(resolve => {\n            this._resolve = MaybePromise => {\n                resolve(MaybePromise);\n            };\n        }).then(data => {\n            this.data = data;\n            this.isCompleted = true;\n        });\n    }\n    addData(data) {\n        const parentData = this.parentContext?.promise;\n        if (parentData) {\n            this._resolve?.(parentData.then(() => data));\n            return;\n        }\n        this._resolve?.(data);\n    }\n}\nclass StreamRecord {\n    type;\n    errors;\n    label;\n    path;\n    items;\n    promise;\n    parentContext;\n    iterator;\n    isCompletedIterator;\n    isCompleted;\n    _exeContext;\n    _resolve;\n    constructor(opts) {\n        this.type = 'stream';\n        this.items = null;\n        this.label = opts.label;\n        this.path = pathToArray(opts.path);\n        this.parentContext = opts.parentContext;\n        this.iterator = opts.iterator;\n        this.errors = [];\n        this._exeContext = opts.exeContext;\n        this._exeContext.subsequentPayloads.add(this);\n        this.isCompleted = false;\n        this.items = null;\n        this.promise = new Promise(resolve => {\n            this._resolve = MaybePromise => {\n                resolve(MaybePromise);\n            };\n        }).then(items => {\n            this.items = items;\n            this.isCompleted = true;\n        });\n    }\n    addItems(items) {\n        const parentData = this.parentContext?.promise;\n        if (parentData) {\n            this._resolve?.(parentData.then(() => items));\n            return;\n        }\n        this._resolve?.(items);\n    }\n    setIsCompletedIterator() {\n        this.isCompletedIterator = true;\n    }\n}\nfunction isStreamPayload(asyncPayload) {\n    return asyncPayload.type === 'stream';\n}\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\nexport function getFieldDef(schema, parentType, fieldNode) {\n    const fieldName = fieldNode.name.value;\n    if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n        return SchemaMetaFieldDef;\n    }\n    else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n        return TypeMetaFieldDef;\n    }\n    else if (fieldName === TypeNameMetaFieldDef.name) {\n        return TypeNameMetaFieldDef;\n    }\n    return parentType.getFields()[fieldName];\n}\nexport function isIncrementalResult(result) {\n    return 'incremental' in result;\n}\n","import { getOperationAST } from 'graphql';\nimport { memoize1, } from '@graphql-tools/utils';\nimport { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { execute, flattenIncrementalResults, isIncrementalResults, subscribe, } from './execute.js';\nexport function normalizedExecutor(args) {\n    const operationAST = getOperationAST(args.document, args.operationName);\n    if (operationAST == null) {\n        throw new Error('Must provide an operation.');\n    }\n    if (operationAST.operation === 'subscription') {\n        return subscribe(args);\n    }\n    return handleMaybePromise(() => execute(args), result => {\n        if (isIncrementalResults(result)) {\n            return flattenIncrementalResults(result);\n        }\n        return result;\n    });\n}\nexport const executorFromSchema = memoize1(function executorFromSchema(schema) {\n    return function schemaExecutor(request) {\n        return normalizedExecutor({\n            schema,\n            document: request.document,\n            variableValues: request.variables,\n            operationName: request.operationName,\n            rootValue: request.rootValue,\n            contextValue: request.context,\n            signal: request.signal || request.info?.signal,\n        });\n    };\n});\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-console */\nconst ansiCodes = {\n    red: '\\x1b[31m',\n    yellow: '\\x1b[33m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m',\n    reset: '\\x1b[0m',\n};\nexport const warnPrefix = ansiCodes.yellow + 'WARN' + ansiCodes.reset;\nexport const infoPrefix = ansiCodes.cyan + 'INFO' + ansiCodes.reset;\nexport const errorPrefix = ansiCodes.red + 'ERR' + ansiCodes.reset;\nexport const debugPrefix = ansiCodes.magenta + 'DEBUG' + ansiCodes.reset;\nconst logLevelScores = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n    silent: 4,\n};\nconst noop = () => { };\nconst consoleLog = (prefix) => (...args) => console.log(prefix, ...args);\nconst debugLog = console.debug\n    ? (...args) => console.debug(debugPrefix, ...args)\n    : consoleLog(debugPrefix);\nconst infoLog = console.info\n    ? (...args) => console.info(infoPrefix, ...args)\n    : consoleLog(infoPrefix);\nconst warnLog = console.warn\n    ? (...args) => console.warn(warnPrefix, ...args)\n    : consoleLog(warnPrefix);\nconst errorLog = console.error\n    ? (...args) => console.error(errorPrefix, ...args)\n    : consoleLog(errorPrefix);\nexport const createLogger = (logLevel = globalThis.process?.env['DEBUG'] === '1' ? 'debug' : 'info') => {\n    const score = logLevelScores[logLevel];\n    return {\n        debug: score > logLevelScores.debug ? noop : debugLog,\n        info: score > logLevelScores.info ? noop : infoLog,\n        warn: score > logLevelScores.warn ? noop : warnLog,\n        error: score > logLevelScores.error ? noop : errorLog,\n    };\n};\n","import { handleMaybePromise } from '@whatwg-node/promise-helpers';\nexport function getCORSHeadersByRequestAndOptions(request, corsOptions) {\n    const currentOrigin = request.headers.get('origin');\n    if (corsOptions === false || currentOrigin == null) {\n        return null;\n    }\n    const headers = {};\n    // If defined origins have '*' or undefined by any means, we should allow all origins\n    if (corsOptions.origin == null ||\n        corsOptions.origin.length === 0 ||\n        corsOptions.origin.includes('*')) {\n        headers['Access-Control-Allow-Origin'] = currentOrigin;\n        // Vary by origin because there are multiple origins\n        headers['Vary'] = 'Origin';\n    }\n    else if (typeof corsOptions.origin === 'string') {\n        // If there is one specific origin is specified, use it directly\n        headers['Access-Control-Allow-Origin'] = corsOptions.origin;\n    }\n    else if (Array.isArray(corsOptions.origin)) {\n        // If there is only one origin defined in the array, consider it as a single one\n        if (corsOptions.origin.length === 1) {\n            headers['Access-Control-Allow-Origin'] = corsOptions.origin[0];\n        }\n        else if (corsOptions.origin.includes(currentOrigin)) {\n            // If origin is available in the headers, use it\n            headers['Access-Control-Allow-Origin'] = currentOrigin;\n            // Vary by origin because there are multiple origins\n            headers['Vary'] = 'Origin';\n        }\n        else {\n            // There is no origin found in the headers, so we should return null\n            headers['Access-Control-Allow-Origin'] = 'null';\n        }\n    }\n    if (corsOptions.methods?.length) {\n        headers['Access-Control-Allow-Methods'] = corsOptions.methods.join(', ');\n    }\n    else {\n        const requestMethod = request.headers.get('access-control-request-method');\n        if (requestMethod) {\n            headers['Access-Control-Allow-Methods'] = requestMethod;\n        }\n    }\n    if (corsOptions.allowedHeaders?.length) {\n        headers['Access-Control-Allow-Headers'] = corsOptions.allowedHeaders.join(', ');\n    }\n    else {\n        const requestHeaders = request.headers.get('access-control-request-headers');\n        if (requestHeaders) {\n            headers['Access-Control-Allow-Headers'] = requestHeaders;\n            if (headers['Vary']) {\n                headers['Vary'] += ', Access-Control-Request-Headers';\n            }\n            else {\n                headers['Vary'] = 'Access-Control-Request-Headers';\n            }\n        }\n    }\n    if (corsOptions.credentials != null) {\n        if (corsOptions.credentials === true) {\n            headers['Access-Control-Allow-Credentials'] = 'true';\n        }\n    }\n    else if (headers['Access-Control-Allow-Origin'] !== '*') {\n        headers['Access-Control-Allow-Credentials'] = 'true';\n    }\n    if (corsOptions.exposedHeaders) {\n        headers['Access-Control-Expose-Headers'] = corsOptions.exposedHeaders.join(', ');\n    }\n    if (corsOptions.maxAge) {\n        headers['Access-Control-Max-Age'] = corsOptions.maxAge.toString();\n    }\n    return headers;\n}\nfunction getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {\n    return handleMaybePromise(() => corsOptionsFactory(request, serverContext), corsOptions => getCORSHeadersByRequestAndOptions(request, corsOptions));\n}\nexport function useCORS(options) {\n    let corsOptionsFactory = () => ({});\n    if (options != null) {\n        if (typeof options === 'function') {\n            corsOptionsFactory = options;\n        }\n        else if (typeof options === 'object') {\n            const corsOptions = {\n                ...options,\n            };\n            corsOptionsFactory = () => corsOptions;\n        }\n        else if (options === false) {\n            corsOptionsFactory = () => false;\n        }\n    }\n    return {\n        onRequest({ request, fetchAPI, endResponse }) {\n            if (request.method.toUpperCase() === 'OPTIONS') {\n                const response = new fetchAPI.Response(null, {\n                    status: 204,\n                    // Safari (and potentially other browsers) need content-length 0,\n                    // for 204 or they just hang waiting for a body\n                    // see: https://github.com/expressjs/cors/blob/master/lib/index.js#L176\n                    headers: {\n                        'Content-Length': '0',\n                    },\n                });\n                endResponse(response);\n            }\n        },\n        onResponse({ request, serverContext, response }) {\n            return handleMaybePromise(() => getCORSResponseHeaders(request, corsOptionsFactory, serverContext), headers => {\n                if (headers != null) {\n                    for (const headerName in headers) {\n                        response.headers.set(headerName, headers[headerName]);\n                    }\n                }\n            });\n        },\n    };\n}\n","export class PonyfillSuppressedError extends Error {\n    error;\n    suppressed;\n    // eslint-disable-next-line n/handle-callback-err\n    constructor(error, suppressed, message) {\n        super(message);\n        this.error = error;\n        this.suppressed = suppressed;\n        this.name = 'SuppressedError';\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n","import { DisposableSymbols } from './symbols.js';\nexport function isSyncDisposable(obj) {\n    return obj?.[DisposableSymbols.dispose] != null;\n}\nexport function isAsyncDisposable(obj) {\n    return obj?.[DisposableSymbols.asyncDispose] != null;\n}\n","import { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { PonyfillSuppressedError } from './SupressedError.js';\nimport { DisposableSymbols } from './symbols.js';\nimport { isAsyncDisposable, isSyncDisposable } from './utils.js';\nconst SuppressedError = globalThis.SuppressedError || PonyfillSuppressedError;\nexport class PonyfillAsyncDisposableStack {\n    callbacks = [];\n    get disposed() {\n        return this.callbacks.length === 0;\n    }\n    use(value) {\n        if (isAsyncDisposable(value)) {\n            this.callbacks.push(() => value[DisposableSymbols.asyncDispose]());\n        }\n        else if (isSyncDisposable(value)) {\n            this.callbacks.push(() => value[DisposableSymbols.dispose]());\n        }\n        return value;\n    }\n    adopt(value, onDisposeAsync) {\n        if (onDisposeAsync) {\n            this.callbacks.push(() => onDisposeAsync(value));\n        }\n        return value;\n    }\n    defer(onDisposeAsync) {\n        if (onDisposeAsync) {\n            this.callbacks.push(onDisposeAsync);\n        }\n    }\n    move() {\n        const stack = new PonyfillAsyncDisposableStack();\n        stack.callbacks = this.callbacks;\n        this.callbacks = [];\n        return stack;\n    }\n    disposeAsync() {\n        return this[DisposableSymbols.asyncDispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n        const cb = this.callbacks.pop();\n        if (cb) {\n            return handleMaybePromise(cb, () => this._iterateCallbacks(), error => {\n                this._error = this._error ? new SuppressedError(error, this._error) : error;\n                return this._iterateCallbacks();\n            });\n        }\n    }\n    [DisposableSymbols.asyncDispose]() {\n        const res$ = this._iterateCallbacks();\n        if (res$?.then) {\n            return res$.then(() => {\n                if (this._error) {\n                    const error = this._error;\n                    this._error = undefined;\n                    throw error;\n                }\n            });\n        }\n        if (this._error) {\n            const error = this._error;\n            this._error = undefined;\n            throw error;\n        }\n        return undefined;\n    }\n    [Symbol.toStringTag] = 'AsyncDisposableStack';\n}\n","import { PonyfillSuppressedError } from './SupressedError.js';\nimport { DisposableSymbols } from './symbols.js';\nimport { isSyncDisposable } from './utils.js';\nconst SuppressedError = globalThis.SuppressedError || PonyfillSuppressedError;\nexport class PonyfillDisposableStack {\n    callbacks = [];\n    get disposed() {\n        return this.callbacks.length === 0;\n    }\n    use(value) {\n        if (isSyncDisposable(value)) {\n            this.callbacks.push(() => value[DisposableSymbols.dispose]());\n        }\n        return value;\n    }\n    adopt(value, onDispose) {\n        if (onDispose) {\n            this.callbacks.push(() => onDispose(value));\n        }\n        return value;\n    }\n    defer(onDispose) {\n        if (onDispose) {\n            this.callbacks.push(onDispose);\n        }\n    }\n    move() {\n        const stack = new PonyfillDisposableStack();\n        stack.callbacks = this.callbacks;\n        this.callbacks = [];\n        return stack;\n    }\n    dispose() {\n        return this[DisposableSymbols.dispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n        const cb = this.callbacks.pop();\n        if (cb) {\n            try {\n                cb();\n            }\n            catch (error) {\n                this._error = this._error ? new SuppressedError(error, this._error) : error;\n            }\n            return this._iterateCallbacks();\n        }\n    }\n    [DisposableSymbols.dispose]() {\n        this._iterateCallbacks();\n        if (this._error) {\n            const error = this._error;\n            this._error = undefined;\n            throw error;\n        }\n    }\n    [Symbol.toStringTag] = 'DisposableStack';\n}\n","import { PonyfillAsyncDisposableStack } from './AsyncDisposableStack.js';\nimport { PonyfillDisposableStack } from './DisposableStack.js';\nimport { PonyfillSuppressedError } from './SupressedError.js';\nexport const DisposableStack = globalThis.DisposableStack || PonyfillDisposableStack;\nexport const AsyncDisposableStack = globalThis.AsyncDisposableStack || PonyfillAsyncDisposableStack;\nexport const SuppressedError = globalThis.SuppressedError || PonyfillSuppressedError;\nexport * from './symbols.js';\n","import { createDeferredPromise, fakePromise, handleMaybePromise, isPromise, } from '@whatwg-node/promise-helpers';\nexport { isPromise, createDeferredPromise };\nexport function isAsyncIterable(body) {\n    return (body != null && typeof body === 'object' && typeof body[Symbol.asyncIterator] === 'function');\n}\nfunction getPort(nodeRequest) {\n    if (nodeRequest.socket?.localPort) {\n        return nodeRequest.socket?.localPort;\n    }\n    const hostInHeader = nodeRequest.headers?.[':authority'] || nodeRequest.headers?.host;\n    const portInHeader = hostInHeader?.split(':')?.[1];\n    if (portInHeader) {\n        return portInHeader;\n    }\n    return 80;\n}\nfunction getHostnameWithPort(nodeRequest) {\n    if (nodeRequest.headers?.[':authority']) {\n        return nodeRequest.headers?.[':authority'];\n    }\n    if (nodeRequest.headers?.host) {\n        return nodeRequest.headers?.host;\n    }\n    const port = getPort(nodeRequest);\n    if (nodeRequest.hostname) {\n        return nodeRequest.hostname + ':' + port;\n    }\n    const localIp = nodeRequest.socket?.localAddress;\n    if (localIp && !localIp?.includes('::') && !localIp?.includes('ffff')) {\n        return `${localIp}:${port}`;\n    }\n    return 'localhost';\n}\nfunction buildFullUrl(nodeRequest) {\n    const hostnameWithPort = getHostnameWithPort(nodeRequest);\n    const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? 'https' : 'http');\n    const endpoint = nodeRequest.originalUrl || nodeRequest.url || '/graphql';\n    return `${protocol}://${hostnameWithPort}${endpoint}`;\n}\nfunction isRequestBody(body) {\n    const stringTag = body[Symbol.toStringTag];\n    if (typeof body === 'string' ||\n        stringTag === 'Uint8Array' ||\n        stringTag === 'Blob' ||\n        stringTag === 'FormData' ||\n        stringTag === 'URLSearchParams' ||\n        isAsyncIterable(body)) {\n        return true;\n    }\n    return false;\n}\nexport function normalizeNodeRequest(nodeRequest, fetchAPI, nodeResponse, __useCustomAbortCtrl) {\n    const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;\n    let fullUrl = buildFullUrl(rawRequest);\n    if (nodeRequest.query) {\n        const url = new fetchAPI.URL(fullUrl);\n        for (const key in nodeRequest.query) {\n            url.searchParams.set(key, nodeRequest.query[key]);\n        }\n        fullUrl = url.toString();\n    }\n    let normalizedHeaders = nodeRequest.headers;\n    if (nodeRequest.headers?.[':method']) {\n        normalizedHeaders = {};\n        for (const key in nodeRequest.headers) {\n            if (!key.startsWith(':')) {\n                normalizedHeaders[key] = nodeRequest.headers[key];\n            }\n        }\n    }\n    const controller = __useCustomAbortCtrl\n        ? createCustomAbortControllerSignal()\n        : new AbortController();\n    if (nodeResponse?.once) {\n        const closeEventListener = () => {\n            if (!controller.signal.aborted) {\n                Object.defineProperty(rawRequest, 'aborted', { value: true });\n                controller.abort(nodeResponse.errored ?? undefined);\n            }\n        };\n        nodeResponse.once('error', closeEventListener);\n        nodeResponse.once('close', closeEventListener);\n        nodeResponse.once('finish', () => {\n            nodeResponse.removeListener('close', closeEventListener);\n        });\n    }\n    if (nodeRequest.method === 'GET' || nodeRequest.method === 'HEAD') {\n        return new fetchAPI.Request(fullUrl, {\n            method: nodeRequest.method,\n            headers: normalizedHeaders,\n            signal: controller.signal,\n        });\n    }\n    /**\n     * Some Node server frameworks like Serverless Express sends a dummy object with body but as a Buffer not string\n     * so we do those checks to see is there something we can use directly as BodyInit\n     * because the presence of body means the request stream is already consumed and,\n     * rawRequest cannot be used as BodyInit/ReadableStream by Fetch API in this case.\n     */\n    const maybeParsedBody = nodeRequest.body;\n    if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {\n        if (isRequestBody(maybeParsedBody)) {\n            return new fetchAPI.Request(fullUrl, {\n                method: nodeRequest.method || 'GET',\n                headers: normalizedHeaders,\n                body: maybeParsedBody,\n                signal: controller.signal,\n            });\n        }\n        const request = new fetchAPI.Request(fullUrl, {\n            method: nodeRequest.method || 'GET',\n            headers: normalizedHeaders,\n            signal: controller.signal,\n        });\n        if (!request.headers.get('content-type')?.includes('json')) {\n            request.headers.set('content-type', 'application/json; charset=utf-8');\n        }\n        return new Proxy(request, {\n            get: (target, prop, receiver) => {\n                switch (prop) {\n                    case 'json':\n                        return () => fakePromise(maybeParsedBody);\n                    case 'text':\n                        return () => fakePromise(JSON.stringify(maybeParsedBody));\n                    default:\n                        if (globalThis.Bun) {\n                            // workaround for https://github.com/oven-sh/bun/issues/12368\n                            // Proxy.get doesn't seem to get `receiver` correctly\n                            return Reflect.get(target, prop);\n                        }\n                        return Reflect.get(target, prop, receiver);\n                }\n            },\n        });\n    }\n    // perf: instead of spreading the object, we can just pass it as is and it performs better\n    return new fetchAPI.Request(fullUrl, {\n        method: nodeRequest.method,\n        headers: normalizedHeaders,\n        signal: controller.signal,\n        // @ts-expect-error - AsyncIterable is supported as body\n        body: rawRequest,\n        duplex: 'half',\n    });\n}\nexport function isReadable(stream) {\n    return stream.read != null;\n}\nexport function isNodeRequest(request) {\n    return isReadable(request);\n}\nexport function isServerResponse(stream) {\n    // Check all used functions are defined\n    return (stream != null &&\n        stream.setHeader != null &&\n        stream.end != null &&\n        stream.once != null &&\n        stream.write != null);\n}\nexport function isReadableStream(stream) {\n    return stream != null && stream.getReader != null;\n}\nexport function isFetchEvent(event) {\n    return event != null && event.request != null && event.respondWith != null;\n}\nfunction configureSocket(rawRequest) {\n    rawRequest?.socket?.setTimeout?.(0);\n    rawRequest?.socket?.setNoDelay?.(true);\n    rawRequest?.socket?.setKeepAlive?.(true);\n}\nfunction endResponse(serverResponse) {\n    // @ts-expect-error Avoid arguments adaptor trampoline https://v8.dev/blog/adaptor-frame\n    serverResponse.end(null, null, null);\n}\nfunction sendAsyncIterable(serverResponse, asyncIterable) {\n    let closed = false;\n    const closeEventListener = () => {\n        closed = true;\n    };\n    serverResponse.once('error', closeEventListener);\n    serverResponse.once('close', closeEventListener);\n    serverResponse.once('finish', () => {\n        serverResponse.removeListener('close', closeEventListener);\n        serverResponse.removeListener('error', closeEventListener);\n    });\n    const iterator = asyncIterable[Symbol.asyncIterator]();\n    const pump = () => iterator.next().then(({ done, value }) => {\n        if (closed || done) {\n            return;\n        }\n        return handleMaybePromise(() => safeWrite(value, serverResponse), () => (closed ? endResponse(serverResponse) : pump()));\n    });\n    return pump();\n}\nfunction safeWrite(chunk, serverResponse) {\n    // @ts-expect-error http and http2 writes are actually compatible\n    const result = serverResponse.write(chunk);\n    if (!result) {\n        return new Promise(resolve => serverResponse.once('drain', resolve));\n    }\n}\nexport function sendNodeResponse(fetchResponse, serverResponse, nodeRequest, __useSingleWriteHead) {\n    if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {\n        return;\n    }\n    if (!fetchResponse) {\n        serverResponse.statusCode = 404;\n        endResponse(serverResponse);\n        return;\n    }\n    if (__useSingleWriteHead &&\n        // @ts-expect-error - headersInit is a private property\n        fetchResponse.headers?.headersInit &&\n        // @ts-expect-error - headersInit is a private property\n        !Array.isArray(fetchResponse.headers.headersInit) &&\n        // @ts-expect-error - headersInit is a private property\n        !fetchResponse.headers.headersInit.get &&\n        // @ts-expect-error - map is a private property\n        !fetchResponse.headers._map &&\n        // @ts-expect-error - _setCookies is a private property\n        !fetchResponse.headers._setCookies?.length) {\n        serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText, \n        // @ts-expect-error - headersInit is a private property\n        fetchResponse.headers.headersInit);\n    }\n    else {\n        // @ts-expect-error - setHeaders exist\n        if (serverResponse.setHeaders) {\n            // @ts-expect-error - setHeaders exist\n            serverResponse.setHeaders(fetchResponse.headers);\n        }\n        else {\n            let setCookiesSet = false;\n            fetchResponse.headers.forEach((value, key) => {\n                if (key === 'set-cookie') {\n                    if (setCookiesSet) {\n                        return;\n                    }\n                    setCookiesSet = true;\n                    const setCookies = fetchResponse.headers.getSetCookie?.();\n                    if (setCookies) {\n                        serverResponse.setHeader('set-cookie', setCookies);\n                        return;\n                    }\n                }\n                serverResponse.setHeader(key, value);\n            });\n        }\n        serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText);\n    }\n    // @ts-expect-error - Handle the case where the response is a string\n    if (fetchResponse['bodyType'] === 'String') {\n        return handleMaybePromise(\n        // @ts-expect-error - bodyInit is a private property\n        () => safeWrite(fetchResponse.bodyInit, serverResponse), () => endResponse(serverResponse));\n    }\n    // Optimizations for node-fetch\n    const bufOfRes = \n    // @ts-expect-error - _buffer is a private property\n    fetchResponse._buffer;\n    if (bufOfRes) {\n        return handleMaybePromise(() => safeWrite(bufOfRes, serverResponse), () => endResponse(serverResponse));\n    }\n    // Other fetch implementations\n    const fetchBody = fetchResponse.body;\n    if (fetchBody == null) {\n        endResponse(serverResponse);\n        return;\n    }\n    if (\n    // @ts-expect-error - Uint8Array is a valid body type\n    fetchBody[Symbol.toStringTag] === 'Uint8Array') {\n        return handleMaybePromise(() => safeWrite(fetchBody, serverResponse), () => endResponse(serverResponse));\n    }\n    configureSocket(nodeRequest);\n    if (isReadable(fetchBody)) {\n        serverResponse.once('close', () => {\n            fetchBody.destroy();\n        });\n        fetchBody.pipe(serverResponse, {\n            end: true,\n        });\n        return;\n    }\n    if (isReadableStream(fetchBody)) {\n        return sendReadableStream(nodeRequest, serverResponse, fetchBody);\n    }\n    if (isAsyncIterable(fetchBody)) {\n        return sendAsyncIterable(serverResponse, fetchBody);\n    }\n}\nfunction sendReadableStream(nodeRequest, serverResponse, readableStream) {\n    const reader = readableStream.getReader();\n    nodeRequest?.once?.('error', err => {\n        reader.cancel(err);\n    });\n    function pump() {\n        return reader\n            .read()\n            .then(({ done, value }) => done\n            ? endResponse(serverResponse)\n            : handleMaybePromise(() => safeWrite(value, serverResponse), pump));\n    }\n    return pump();\n}\nexport function isRequestInit(val) {\n    return (val != null &&\n        typeof val === 'object' &&\n        ('body' in val ||\n            'cache' in val ||\n            'credentials' in val ||\n            'headers' in val ||\n            'integrity' in val ||\n            'keepalive' in val ||\n            'method' in val ||\n            'mode' in val ||\n            'redirect' in val ||\n            'referrer' in val ||\n            'referrerPolicy' in val ||\n            'signal' in val ||\n            'window' in val));\n}\n// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#copying_accessors\nexport function completeAssign(...args) {\n    const [target, ...sources] = args.filter(arg => arg != null && typeof arg === 'object');\n    sources.forEach(source => {\n        // modified Object.keys to Object.getOwnPropertyNames\n        // because Object.keys only returns enumerable properties\n        const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors, key) => {\n            const descriptor = Object.getOwnPropertyDescriptor(source, key);\n            if (descriptor) {\n                descriptors[key] = Object.getOwnPropertyDescriptor(source, key);\n            }\n            return descriptors;\n        }, {});\n        // By default, Object.assign copies enumerable Symbols, too\n        Object.getOwnPropertySymbols(source).forEach(sym => {\n            const descriptor = Object.getOwnPropertyDescriptor(source, sym);\n            if (descriptor?.enumerable) {\n                descriptors[sym] = descriptor;\n            }\n        });\n        Object.defineProperties(target, descriptors);\n    });\n    return target;\n}\nexport { iterateAsyncVoid } from '@whatwg-node/promise-helpers';\nexport function handleErrorFromRequestHandler(error, ResponseCtor) {\n    return new ResponseCtor(error.stack || error.message || error.toString(), {\n        status: error.status || 500,\n    });\n}\nexport function isolateObject(originalCtx, waitUntilFn) {\n    if (originalCtx == null) {\n        if (waitUntilFn == null) {\n            return {};\n        }\n        return {\n            waitUntil: waitUntilFn,\n        };\n    }\n    return completeAssign(Object.create(originalCtx), {\n        waitUntil: waitUntilFn,\n    }, originalCtx);\n}\nexport function handleAbortSignalAndPromiseResponse(response$, abortSignal) {\n    if (abortSignal?.aborted) {\n        throw abortSignal.reason;\n    }\n    if (isPromise(response$) && abortSignal) {\n        const deferred$ = createDeferredPromise();\n        function abortSignalFetchErrorHandler() {\n            deferred$.reject(abortSignal.reason);\n        }\n        abortSignal.addEventListener('abort', abortSignalFetchErrorHandler, { once: true });\n        response$\n            .then(function fetchSuccessHandler(res) {\n            deferred$.resolve(res);\n        })\n            .catch(function fetchErrorHandler(err) {\n            deferred$.reject(err);\n        })\n            .finally(() => {\n            abortSignal.removeEventListener('abort', abortSignalFetchErrorHandler);\n        });\n        return deferred$.promise;\n    }\n    return response$;\n}\nexport const decompressedResponseMap = new WeakMap();\nconst supportedEncodingsByFetchAPI = new WeakMap();\nexport function getSupportedEncodings(fetchAPI) {\n    let supportedEncodings = supportedEncodingsByFetchAPI.get(fetchAPI);\n    if (!supportedEncodings) {\n        const possibleEncodings = ['deflate', 'gzip', 'deflate-raw', 'br'];\n        if (fetchAPI.DecompressionStream?.['supportedFormats']) {\n            supportedEncodings = fetchAPI.DecompressionStream['supportedFormats'];\n        }\n        else {\n            supportedEncodings = possibleEncodings.filter(encoding => {\n                // deflate-raw is not supported in Node.js >v20\n                if (globalThis.process?.version?.startsWith('v2') &&\n                    fetchAPI.DecompressionStream === globalThis.DecompressionStream &&\n                    encoding === 'deflate-raw') {\n                    return false;\n                }\n                try {\n                    // eslint-disable-next-line no-new\n                    new fetchAPI.DecompressionStream(encoding);\n                    return true;\n                }\n                catch {\n                    return false;\n                }\n            });\n        }\n        supportedEncodingsByFetchAPI.set(fetchAPI, supportedEncodings);\n    }\n    return supportedEncodings;\n}\nexport function handleResponseDecompression(response, fetchAPI) {\n    const contentEncodingHeader = response?.headers.get('content-encoding');\n    if (!contentEncodingHeader || contentEncodingHeader === 'none') {\n        return response;\n    }\n    if (!response?.body) {\n        return response;\n    }\n    let decompressedResponse = decompressedResponseMap.get(response);\n    if (!decompressedResponse || decompressedResponse.bodyUsed) {\n        let decompressedBody = response.body;\n        const contentEncodings = contentEncodingHeader.split(',');\n        if (!contentEncodings.every(encoding => getSupportedEncodings(fetchAPI).includes(encoding))) {\n            return new fetchAPI.Response(`Unsupported 'Content-Encoding': ${contentEncodingHeader}`, {\n                status: 415,\n                statusText: 'Unsupported Media Type',\n            });\n        }\n        for (const contentEncoding of contentEncodings) {\n            decompressedBody = decompressedBody.pipeThrough(new fetchAPI.DecompressionStream(contentEncoding));\n        }\n        decompressedResponse = new fetchAPI.Response(decompressedBody, response);\n        decompressedResponseMap.set(response, decompressedResponse);\n    }\n    return decompressedResponse;\n}\nconst terminateEvents = ['SIGINT', 'exit', 'SIGTERM'];\nconst disposableStacks = new Set();\nlet eventListenerRegistered = false;\nfunction ensureEventListenerForDisposableStacks() {\n    if (eventListenerRegistered) {\n        return;\n    }\n    eventListenerRegistered = true;\n    for (const event of terminateEvents) {\n        globalThis.process.once(event, function terminateHandler() {\n            return Promise.allSettled([...disposableStacks].map(stack => !stack.disposed && stack.disposeAsync()));\n        });\n    }\n}\nexport function ensureDisposableStackRegisteredForTerminateEvents(disposableStack) {\n    if (globalThis.process) {\n        ensureEventListenerForDisposableStacks();\n        if (!disposableStacks.has(disposableStack)) {\n            disposableStacks.add(disposableStack);\n            disposableStack.defer(() => {\n                disposableStacks.delete(disposableStack);\n            });\n        }\n    }\n}\nclass CustomAbortControllerSignal extends EventTarget {\n    aborted = false;\n    _onabort = null;\n    _reason;\n    constructor() {\n        super();\n        const nodeEvents = globalThis.process?.getBuiltinModule?.('node:events');\n        // @ts-expect-error - We know kMaxEventTargetListeners is available in node:events\n        if (nodeEvents?.kMaxEventTargetListeners) {\n            // @ts-expect-error - See https://github.com/nodejs/node/pull/55816/files#diff-03bd4f07a1006cb0daaddced702858751b20f5ab7681cb0719c1b1d80d6ca05cR31\n            this[nodeEvents.kMaxEventTargetListeners] = 0;\n        }\n    }\n    throwIfAborted() {\n        if (this._nativeCtrl?.signal?.throwIfAborted) {\n            return this._nativeCtrl.signal.throwIfAborted();\n        }\n        if (this.aborted) {\n            throw this._reason;\n        }\n    }\n    _nativeCtrl;\n    ensureNativeCtrl() {\n        if (!this._nativeCtrl) {\n            const isAborted = this.aborted;\n            this._nativeCtrl = new AbortController();\n            if (isAborted) {\n                this._nativeCtrl.abort(this._reason);\n            }\n        }\n        return this._nativeCtrl;\n    }\n    abort(reason) {\n        if (this._nativeCtrl?.abort) {\n            return this._nativeCtrl?.abort(reason);\n        }\n        this._reason = reason || new DOMException('This operation was aborted', 'AbortError');\n        this.aborted = true;\n        this.dispatchEvent(new Event('abort'));\n    }\n    get signal() {\n        if (this._nativeCtrl?.signal) {\n            return this._nativeCtrl.signal;\n        }\n        return this;\n    }\n    get reason() {\n        if (this._nativeCtrl?.signal) {\n            return this._nativeCtrl.signal.reason;\n        }\n        return this._reason;\n    }\n    get onabort() {\n        if (this._onabort) {\n            return this._onabort;\n        }\n        return this._onabort;\n    }\n    set onabort(value) {\n        if (this._nativeCtrl?.signal) {\n            this._nativeCtrl.signal.onabort = value;\n            return;\n        }\n        if (this._onabort) {\n            this.removeEventListener('abort', this._onabort);\n        }\n        this._onabort = value;\n        if (value) {\n            this.addEventListener('abort', value);\n        }\n    }\n}\nexport function createCustomAbortControllerSignal() {\n    if (globalThis.Bun || globalThis.Deno) {\n        return new AbortController();\n    }\n    return new Proxy(new CustomAbortControllerSignal(), {\n        get(target, prop, receiver) {\n            if (prop.toString().includes('kDependantSignals')) {\n                const nativeCtrl = target.ensureNativeCtrl();\n                return Reflect.get(nativeCtrl.signal, prop, nativeCtrl.signal);\n            }\n            return Reflect.get(target, prop, receiver);\n        },\n        set(target, prop, value, receiver) {\n            if (prop.toString().includes('kDependantSignals')) {\n                const nativeCtrl = target.ensureNativeCtrl();\n                return Reflect.set(nativeCtrl.signal, prop, value, nativeCtrl.signal);\n            }\n            return Reflect.set(target, prop, value, receiver);\n        },\n        getPrototypeOf() {\n            return AbortSignal.prototype;\n        },\n    });\n}\n","import { fakePromise } from '@whatwg-node/promise-helpers';\nexport function isUWSResponse(res) {\n    return !!res.onData;\n}\nexport function getRequestFromUWSRequest({ req, res, fetchAPI, controller, }) {\n    const method = req.getMethod();\n    let duplex;\n    const chunks = [];\n    const pushFns = [\n        (chunk) => {\n            chunks.push(chunk);\n        },\n    ];\n    const push = (chunk) => {\n        for (const pushFn of pushFns) {\n            pushFn(chunk);\n        }\n    };\n    let stopped = false;\n    const stopFns = [\n        () => {\n            stopped = true;\n        },\n    ];\n    const stop = () => {\n        for (const stopFn of stopFns) {\n            stopFn();\n        }\n    };\n    res.onData(function (ab, isLast) {\n        push(Buffer.from(Buffer.from(ab, 0, ab.byteLength)));\n        if (isLast) {\n            stop();\n        }\n    });\n    let getReadableStream;\n    if (method !== 'get' && method !== 'head') {\n        duplex = 'half';\n        controller.signal.addEventListener('abort', () => {\n            stop();\n        }, { once: true });\n        let readableStream;\n        getReadableStream = () => {\n            if (!readableStream) {\n                readableStream = new fetchAPI.ReadableStream({\n                    start(streamCtrl) {\n                        for (const chunk of chunks) {\n                            streamCtrl.enqueue(chunk);\n                        }\n                        if (stopped) {\n                            streamCtrl.close();\n                            return;\n                        }\n                        pushFns.push((chunk) => {\n                            streamCtrl.enqueue(chunk);\n                        });\n                        stopFns.push(() => {\n                            if (controller.signal.reason) {\n                                streamCtrl.error(controller.signal.reason);\n                                return;\n                            }\n                            if (streamCtrl.desiredSize) {\n                                streamCtrl.close();\n                            }\n                        });\n                    },\n                });\n            }\n            return readableStream;\n        };\n    }\n    const headers = new fetchAPI.Headers();\n    req.forEach((key, value) => {\n        headers.append(key, value);\n    });\n    let url = `http://localhost${req.getUrl()}`;\n    const query = req.getQuery();\n    if (query) {\n        url += `?${query}`;\n    }\n    let buffer;\n    function getBody() {\n        if (!getReadableStream) {\n            return null;\n        }\n        if (stopped) {\n            return getBufferFromChunks();\n        }\n        return getReadableStream();\n    }\n    const request = new fetchAPI.Request(url, {\n        method,\n        headers,\n        get body() {\n            return getBody();\n        },\n        signal: controller.signal,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - not in the TS types yet\n        duplex,\n    });\n    function getBufferFromChunks() {\n        if (!buffer) {\n            buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks);\n        }\n        return buffer;\n    }\n    function collectBuffer() {\n        if (stopped) {\n            return fakePromise(getBufferFromChunks());\n        }\n        return new Promise((resolve, reject) => {\n            try {\n                stopFns.push(() => {\n                    resolve(getBufferFromChunks());\n                });\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    Object.defineProperties(request, {\n        body: {\n            get() {\n                return getBody();\n            },\n            configurable: true,\n            enumerable: true,\n        },\n        json: {\n            value() {\n                return collectBuffer()\n                    .then(b => b.toString('utf8'))\n                    .then(t => JSON.parse(t));\n            },\n            configurable: true,\n            enumerable: true,\n        },\n        text: {\n            value() {\n                return collectBuffer().then(b => b.toString('utf8'));\n            },\n            configurable: true,\n            enumerable: true,\n        },\n        arrayBuffer: {\n            value() {\n                return collectBuffer();\n            },\n            configurable: true,\n            enumerable: true,\n        },\n    });\n    return request;\n}\nexport function createWritableFromUWS(uwsResponse, fetchAPI) {\n    return new fetchAPI.WritableStream({\n        write(chunk) {\n            uwsResponse.cork(() => {\n                uwsResponse.write(chunk);\n            });\n        },\n        close() {\n            uwsResponse.cork(() => {\n                uwsResponse.end();\n            });\n        },\n    });\n}\nexport function sendResponseToUwsOpts(uwsResponse, fetchResponse, controller, fetchAPI) {\n    if (!fetchResponse) {\n        uwsResponse.writeStatus('404 Not Found');\n        uwsResponse.end();\n        return;\n    }\n    const bufferOfRes = fetchResponse._buffer;\n    if (controller.signal.aborted) {\n        return;\n    }\n    uwsResponse.cork(() => {\n        uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);\n        for (const [key, value] of fetchResponse.headers) {\n            // content-length causes an error with Node.js's fetch\n            if (key !== 'content-length') {\n                if (key === 'set-cookie') {\n                    const setCookies = fetchResponse.headers.getSetCookie?.();\n                    if (setCookies) {\n                        for (const setCookie of setCookies) {\n                            uwsResponse.writeHeader(key, setCookie);\n                        }\n                        continue;\n                    }\n                }\n                uwsResponse.writeHeader(key, value);\n            }\n        }\n        if (bufferOfRes) {\n            uwsResponse.end(bufferOfRes);\n        }\n        else if (!fetchResponse.body) {\n            uwsResponse.end();\n        }\n    });\n    if (bufferOfRes || !fetchResponse.body) {\n        return;\n    }\n    controller.signal.addEventListener('abort', () => {\n        if (!fetchResponse.body?.locked) {\n            fetchResponse.body?.cancel(controller.signal.reason);\n        }\n    }, { once: true });\n    return fetchResponse.body\n        .pipeTo(createWritableFromUWS(uwsResponse, fetchAPI), {\n        signal: controller.signal,\n    })\n        .catch(err => {\n        if (controller.signal.aborted) {\n            return;\n        }\n        throw err;\n    });\n}\nexport { fakePromise };\n","import { chain, getInstrumented } from '@envelop/instrumentation';\nimport { AsyncDisposableStack, DisposableSymbols } from '@whatwg-node/disposablestack';\nimport * as DefaultFetchAPI from '@whatwg-node/fetch';\nimport { handleMaybePromise, unfakePromise } from '@whatwg-node/promise-helpers';\nimport { completeAssign, createCustomAbortControllerSignal, ensureDisposableStackRegisteredForTerminateEvents, handleAbortSignalAndPromiseResponse, handleErrorFromRequestHandler, isFetchEvent, isNodeRequest, isolateObject, isPromise, isRequestInit, isServerResponse, iterateAsyncVoid, normalizeNodeRequest, sendNodeResponse, } from './utils.js';\nimport { fakePromise, getRequestFromUWSRequest, isUWSResponse, sendResponseToUwsOpts, } from './uwebsockets.js';\n// Required for envs like nextjs edge runtime\nfunction isRequestAccessible(serverContext) {\n    try {\n        return !!serverContext?.request;\n    }\n    catch {\n        return false;\n    }\n}\nconst EMPTY_OBJECT = {};\nfunction createServerAdapter(serverAdapterBaseObject, options) {\n    const useSingleWriteHead = options?.__useSingleWriteHead == null ? true : options.__useSingleWriteHead;\n    const fetchAPI = {\n        ...DefaultFetchAPI,\n        ...options?.fetchAPI,\n    };\n    const useCustomAbortCtrl = options?.__useCustomAbortCtrl == null\n        ? fetchAPI.Request !== globalThis.Request\n        : options.__useCustomAbortCtrl;\n    const givenHandleRequest = typeof serverAdapterBaseObject === 'function'\n        ? serverAdapterBaseObject\n        : serverAdapterBaseObject.handle;\n    const onRequestHooks = [];\n    const onResponseHooks = [];\n    let instrumentation;\n    const waitUntilPromises = new Set();\n    let _disposableStack;\n    function ensureDisposableStack() {\n        if (!_disposableStack) {\n            _disposableStack = new AsyncDisposableStack();\n            if (options?.disposeOnProcessTerminate) {\n                ensureDisposableStackRegisteredForTerminateEvents(_disposableStack);\n            }\n            _disposableStack.defer(() => {\n                if (waitUntilPromises.size > 0) {\n                    return Promise.allSettled(waitUntilPromises).then(() => {\n                        waitUntilPromises.clear();\n                    }, () => {\n                        waitUntilPromises.clear();\n                    });\n                }\n            });\n        }\n        return _disposableStack;\n    }\n    function waitUntil(maybePromise) {\n        // Ensure that the disposable stack is created\n        if (isPromise(maybePromise)) {\n            ensureDisposableStack();\n            waitUntilPromises.add(maybePromise);\n            maybePromise.then(() => {\n                waitUntilPromises.delete(maybePromise);\n            }, err => {\n                console.error(`Unexpected error while waiting: ${err.message || err}`);\n                waitUntilPromises.delete(maybePromise);\n            });\n        }\n    }\n    if (options?.plugins != null) {\n        for (const plugin of options.plugins) {\n            if (plugin.instrumentation) {\n                instrumentation = instrumentation\n                    ? chain(instrumentation, plugin.instrumentation)\n                    : plugin.instrumentation;\n            }\n            if (plugin.onRequest) {\n                onRequestHooks.push(plugin.onRequest);\n            }\n            if (plugin.onResponse) {\n                onResponseHooks.push(plugin.onResponse);\n            }\n            const disposeFn = plugin[DisposableSymbols.dispose];\n            if (disposeFn) {\n                ensureDisposableStack().defer(disposeFn);\n            }\n            const asyncDisposeFn = plugin[DisposableSymbols.asyncDispose];\n            if (asyncDisposeFn) {\n                ensureDisposableStack().defer(asyncDisposeFn);\n            }\n            if (plugin.onDispose) {\n                ensureDisposableStack().defer(plugin.onDispose);\n            }\n        }\n    }\n    let handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0\n        ? function handleRequest(request, serverContext) {\n            let requestHandler = givenHandleRequest;\n            let response;\n            if (onRequestHooks.length === 0) {\n                return handleEarlyResponse();\n            }\n            let url = request['parsedUrl'] ||\n                new Proxy(EMPTY_OBJECT, {\n                    get(_target, prop, _receiver) {\n                        url = new fetchAPI.URL(request.url, 'http://localhost');\n                        return Reflect.get(url, prop, url);\n                    },\n                });\n            function handleResponse(response) {\n                if (onResponseHooks.length === 0) {\n                    return response;\n                }\n                return handleMaybePromise(() => iterateAsyncVoid(onResponseHooks, onResponseHook => onResponseHook({\n                    request,\n                    response,\n                    serverContext,\n                    setResponse(newResponse) {\n                        response = newResponse;\n                    },\n                    fetchAPI,\n                })), () => response);\n            }\n            function handleEarlyResponse() {\n                if (!response) {\n                    return handleMaybePromise(() => requestHandler(request, serverContext), handleResponse);\n                }\n                return handleResponse(response);\n            }\n            return handleMaybePromise(() => iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({\n                request,\n                setRequest(newRequest) {\n                    request = newRequest;\n                },\n                serverContext,\n                fetchAPI,\n                url,\n                requestHandler,\n                setRequestHandler(newRequestHandler) {\n                    requestHandler = newRequestHandler;\n                },\n                endResponse(newResponse) {\n                    response = newResponse;\n                    if (newResponse) {\n                        stopEarly();\n                    }\n                },\n            })), handleEarlyResponse);\n        }\n        : givenHandleRequest;\n    if (instrumentation?.request) {\n        const originalRequestHandler = handleRequest;\n        handleRequest = (request, initialContext) => {\n            return getInstrumented({ request }).asyncFn(instrumentation.request, originalRequestHandler)(request, initialContext);\n        };\n    }\n    // TODO: Remove this on the next major version\n    function handleNodeRequest(nodeRequest, ...ctx) {\n        const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};\n        // Ensure `waitUntil` is available in the server context\n        if (!serverContext.waitUntil) {\n            serverContext.waitUntil = waitUntil;\n        }\n        const request = normalizeNodeRequest(nodeRequest, fetchAPI, undefined, useCustomAbortCtrl);\n        return handleRequest(request, serverContext);\n    }\n    function handleNodeRequestAndResponse(nodeRequest, nodeResponseOrContainer, ...ctx) {\n        const nodeResponse = nodeResponseOrContainer.raw || nodeResponseOrContainer;\n        const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};\n        // Ensure `waitUntil` is available in the server context\n        if (!serverContext.waitUntil) {\n            serverContext.waitUntil = waitUntil;\n        }\n        const request = normalizeNodeRequest(nodeRequest, fetchAPI, nodeResponse, useCustomAbortCtrl);\n        return handleRequest(request, serverContext);\n    }\n    function requestListener(nodeRequest, nodeResponse, ...ctx) {\n        const defaultServerContext = {\n            req: nodeRequest,\n            res: nodeResponse,\n            waitUntil,\n        };\n        return unfakePromise(fakePromise()\n            .then(() => handleNodeRequestAndResponse(nodeRequest, nodeResponse, defaultServerContext, ...ctx))\n            .catch(err => handleErrorFromRequestHandler(err, fetchAPI.Response))\n            .then(response => sendNodeResponse(response, nodeResponse, nodeRequest, useSingleWriteHead))\n            .catch(err => console.error(`Unexpected error while handling request: ${err.message || err}`)));\n    }\n    function handleUWS(res, req, ...ctx) {\n        const defaultServerContext = {\n            res,\n            req,\n            waitUntil,\n        };\n        const filteredCtxParts = ctx.filter(partCtx => partCtx != null);\n        const serverContext = filteredCtxParts.length > 0\n            ? completeAssign(defaultServerContext, ...ctx)\n            : defaultServerContext;\n        const controller = useCustomAbortCtrl\n            ? createCustomAbortControllerSignal()\n            : new AbortController();\n        const originalResEnd = res.end.bind(res);\n        let resEnded = false;\n        res.end = function (data) {\n            resEnded = true;\n            return originalResEnd(data);\n        };\n        const originalOnAborted = res.onAborted.bind(res);\n        originalOnAborted(function () {\n            controller.abort();\n        });\n        res.onAborted = function (cb) {\n            controller.signal.addEventListener('abort', cb, { once: true });\n        };\n        const request = getRequestFromUWSRequest({\n            req,\n            res,\n            fetchAPI,\n            controller,\n        });\n        return handleMaybePromise(() => handleMaybePromise(() => handleRequest(request, serverContext), response => response, err => handleErrorFromRequestHandler(err, fetchAPI.Response)), response => {\n            if (!controller.signal.aborted && !resEnded) {\n                return handleMaybePromise(() => sendResponseToUwsOpts(res, response, controller, fetchAPI), r => r, err => {\n                    console.error(`Unexpected error while handling request: ${err.message || err}`);\n                });\n            }\n        });\n    }\n    function handleEvent(event, ...ctx) {\n        if (!event.respondWith || !event.request) {\n            throw new TypeError(`Expected FetchEvent, got ${event}`);\n        }\n        const filteredCtxParts = ctx.filter(partCtx => partCtx != null);\n        const serverContext = filteredCtxParts.length > 0\n            ? completeAssign({}, event, ...filteredCtxParts)\n            : isolateObject(event);\n        const response$ = handleRequest(event.request, serverContext);\n        event.respondWith(response$);\n    }\n    function handleRequestWithWaitUntil(request, ...ctx) {\n        const filteredCtxParts = ctx.filter(partCtx => partCtx != null);\n        const serverContext = filteredCtxParts.length > 1\n            ? completeAssign({}, ...filteredCtxParts)\n            : isolateObject(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null\n                ? waitUntil\n                : undefined);\n        return handleRequest(request, serverContext);\n    }\n    const fetchFn = (input, ...maybeCtx) => {\n        if (typeof input === 'string' || 'href' in input) {\n            const [initOrCtx, ...restOfCtx] = maybeCtx;\n            if (isRequestInit(initOrCtx)) {\n                const request = new fetchAPI.Request(input, initOrCtx);\n                const res$ = handleRequestWithWaitUntil(request, ...restOfCtx);\n                const signal = initOrCtx.signal;\n                if (signal) {\n                    return handleAbortSignalAndPromiseResponse(res$, signal);\n                }\n                return res$;\n            }\n            const request = new fetchAPI.Request(input);\n            return handleRequestWithWaitUntil(request, ...maybeCtx);\n        }\n        const res$ = handleRequestWithWaitUntil(input, ...maybeCtx);\n        return handleAbortSignalAndPromiseResponse(res$, input.signal);\n    };\n    const genericRequestHandler = (input, ...maybeCtx) => {\n        // If it is a Node request\n        const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;\n        if (isNodeRequest(input)) {\n            if (!isServerResponse(initOrCtxOrRes)) {\n                throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);\n            }\n            return requestListener(input, initOrCtxOrRes, ...restOfCtx);\n        }\n        if (isUWSResponse(input)) {\n            return handleUWS(input, initOrCtxOrRes, ...restOfCtx);\n        }\n        if (isServerResponse(initOrCtxOrRes)) {\n            throw new TypeError('Got Node response without Node request');\n        }\n        // Is input a container object over Request?\n        if (isRequestAccessible(input)) {\n            // Is it FetchEvent?\n            if (isFetchEvent(input)) {\n                return handleEvent(input, ...maybeCtx);\n            }\n            // In this input is also the context\n            return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);\n        }\n        // Or is it Request itself?\n        // Then ctx is present and it is the context\n        return fetchFn(input, ...maybeCtx);\n    };\n    const adapterObj = {\n        handleRequest: handleRequestWithWaitUntil,\n        fetch: fetchFn,\n        handleNodeRequest,\n        handleNodeRequestAndResponse,\n        requestListener,\n        handleEvent,\n        handleUWS,\n        handle: genericRequestHandler,\n        get disposableStack() {\n            return ensureDisposableStack();\n        },\n        [DisposableSymbols.asyncDispose]() {\n            if (_disposableStack && !_disposableStack.disposed) {\n                return _disposableStack.disposeAsync();\n            }\n            return fakePromise();\n        },\n        dispose() {\n            if (_disposableStack && !_disposableStack.disposed) {\n                return _disposableStack.disposeAsync();\n            }\n            return fakePromise();\n        },\n        waitUntil,\n    };\n    const serverAdapter = new Proxy(genericRequestHandler, {\n        // It should have all the attributes of the handler function and the server instance\n        has: (_, prop) => {\n            return (prop in adapterObj ||\n                prop in genericRequestHandler ||\n                (serverAdapterBaseObject && prop in serverAdapterBaseObject));\n        },\n        get: (_, prop) => {\n            // Somehow Deno and Node 24 don't like bound dispose functions\n            if (globalThis.Deno || prop === Symbol.asyncDispose || prop === Symbol.dispose) {\n                const adapterProp = Reflect.get(adapterObj, prop, adapterObj);\n                if (adapterProp) {\n                    return adapterProp;\n                }\n            }\n            const adapterProp = adapterObj[prop];\n            if (adapterProp) {\n                if (adapterProp.bind) {\n                    return adapterProp.bind(adapterObj);\n                }\n                return adapterProp;\n            }\n            const handleProp = genericRequestHandler[prop];\n            if (handleProp) {\n                if (handleProp.bind) {\n                    return handleProp.bind(genericRequestHandler);\n                }\n                return handleProp;\n            }\n            if (serverAdapterBaseObject) {\n                const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];\n                if (serverAdapterBaseObjectProp) {\n                    if (serverAdapterBaseObjectProp.bind) {\n                        return function (...args) {\n                            const returnedVal = serverAdapterBaseObject[prop](...args);\n                            if (returnedVal === serverAdapterBaseObject) {\n                                return serverAdapter;\n                            }\n                            return returnedVal;\n                        };\n                    }\n                    return serverAdapterBaseObjectProp;\n                }\n            }\n        },\n        apply(_, __, args) {\n            return genericRequestHandler(...args);\n        },\n    });\n    return serverAdapter;\n}\nexport { createServerAdapter };\n","import { GraphQLError } from 'graphql';\nimport { createGraphQLError } from '@graphql-tools/utils';\nfunction isAggregateError(obj) {\n    return obj != null && typeof obj === 'object' && 'errors' in obj;\n}\nfunction hasToString(obj) {\n    return obj != null && typeof obj.toString === 'function';\n}\nexport function isGraphQLError(val) {\n    return val instanceof GraphQLError;\n}\nexport function isOriginalGraphQLError(val) {\n    if (val instanceof GraphQLError) {\n        if (val.originalError != null) {\n            return isOriginalGraphQLError(val.originalError);\n        }\n        return true;\n    }\n    return false;\n}\nexport function isAbortError(error) {\n    return (typeof error === 'object' &&\n        error?.constructor?.name === 'DOMException' &&\n        (error.name === 'AbortError' ||\n            error.name === 'TimeoutError'));\n}\nexport function handleError(error, maskedErrorsOpts, logger) {\n    const errors = new Set();\n    if (isAggregateError(error)) {\n        for (const singleError of error.errors) {\n            const handledErrors = handleError(singleError, maskedErrorsOpts, logger);\n            for (const handledError of handledErrors) {\n                errors.add(handledError);\n            }\n        }\n    }\n    else if (isAbortError(error)) {\n        logger.debug('Request aborted');\n    }\n    else if (maskedErrorsOpts) {\n        const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);\n        if (maskedError !== error) {\n            logger.error(error);\n        }\n        errors.add(isGraphQLError(maskedError)\n            ? maskedError\n            : createGraphQLError(maskedError.message, {\n                originalError: maskedError,\n            }));\n    }\n    else if (isGraphQLError(error)) {\n        errors.add(error);\n    }\n    else if (error instanceof Error) {\n        errors.add(createGraphQLError(error.message, {\n            originalError: error,\n        }));\n    }\n    else if (typeof error === 'string') {\n        errors.add(createGraphQLError(error, {\n            extensions: {\n                code: 'INTERNAL_SERVER_ERROR',\n                unexpected: true,\n            },\n        }));\n    }\n    else if (hasToString(error)) {\n        errors.add(createGraphQLError(error.toString(), {\n            extensions: {\n                code: 'INTERNAL_SERVER_ERROR',\n                unexpected: true,\n            },\n        }));\n    }\n    else {\n        logger.error(error);\n        errors.add(createGraphQLError('Unexpected error.', {\n            extensions: {\n                http: {\n                    unexpected: true,\n                },\n            },\n        }));\n    }\n    return Array.from(errors);\n}\nexport function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {\n    let status;\n    let unexpectedErrorExists = false;\n    if ('extensions' in result && result.extensions?.http) {\n        if (result.extensions.http.headers) {\n            Object.assign(headers, result.extensions.http.headers);\n        }\n        if (result.extensions.http.status) {\n            status = result.extensions.http.status;\n        }\n    }\n    if ('errors' in result && result.errors?.length) {\n        for (const error of result.errors) {\n            if (error.extensions?.['http']) {\n                if (error.extensions['http'].headers) {\n                    Object.assign(headers, error.extensions['http'].headers);\n                }\n                if (isApplicationJson && error.extensions['http'].spec) {\n                    continue;\n                }\n                if (error.extensions['http'].status &&\n                    (!status || error.extensions['http'].status > status)) {\n                    status = error.extensions['http'].status;\n                }\n            }\n            else if (!isOriginalGraphQLError(error) || error.extensions?.['unexpected']) {\n                unexpectedErrorExists = true;\n            }\n        }\n    }\n    else {\n        status ||= 200;\n    }\n    if (!status) {\n        if (unexpectedErrorExists && !('data' in result)) {\n            status = 500;\n        }\n        else {\n            status = 200;\n        }\n    }\n    return {\n        status,\n        headers,\n    };\n}\nexport function areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        obj.length > 0 &&\n        // if one item in the array is a GraphQLError, we're good\n        obj.some(isGraphQLError));\n}\n","import { URLSearchParams } from '@whatwg-node/fetch';\nexport function handleURLSearchParams(searchParams) {\n    const operationName = searchParams.get('operationName') || undefined;\n    const query = searchParams.get('query') || undefined;\n    const variablesStr = searchParams.get('variables') || undefined;\n    const extensionsStr = searchParams.get('extensions') || undefined;\n    return {\n        operationName,\n        query,\n        variables: variablesStr ? JSON.parse(variablesStr) : undefined,\n        extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined,\n    };\n}\nexport function parseURLSearchParams(requestBody) {\n    const searchParams = new URLSearchParams(requestBody);\n    return handleURLSearchParams(searchParams);\n}\nexport function isContentTypeMatch(request, expectedContentType) {\n    let contentType = request.headers.get('content-type');\n    // a list of content-types is not valid as per HTTP spec, but some clients dont care\n    contentType = contentType?.split(',')[0] || null;\n    return (contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`));\n}\n","import { URLSearchParams } from '@whatwg-node/fetch';\nimport { handleURLSearchParams } from './utils.js';\nexport function isGETRequest(request) {\n    return request.method === 'GET';\n}\nexport function parseGETRequest(request) {\n    const queryString = request.url.substring(request.url.indexOf('?') + 1);\n    const searchParams = new URLSearchParams(queryString);\n    return handleURLSearchParams(searchParams);\n}\n","import { isContentTypeMatch, parseURLSearchParams } from './utils.js';\nexport function isPOSTFormUrlEncodedRequest(request) {\n    return (request.method === 'POST' && isContentTypeMatch(request, 'application/x-www-form-urlencoded'));\n}\nexport function parsePOSTFormUrlEncodedRequest(request) {\n    return request.text().then(parseURLSearchParams);\n}\n","import { isContentTypeMatch } from './utils.js';\nexport function isPOSTGraphQLStringRequest(request) {\n    return request.method === 'POST' && isContentTypeMatch(request, 'application/graphql');\n}\nexport function parsePOSTGraphQLStringRequest(request) {\n    return request.text().then(query => ({ query }));\n}\n","import { GraphQLError } from 'graphql';\nimport { createGraphQLError } from '@graphql-tools/utils';\nimport { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { isContentTypeMatch } from './utils.js';\nexport function isPOSTJsonRequest(request) {\n    return (request.method === 'POST' &&\n        (isContentTypeMatch(request, 'application/json') ||\n            isContentTypeMatch(request, 'application/graphql+json')));\n}\nexport function parsePOSTJsonRequest(request) {\n    return handleMaybePromise(() => request.json(), (requestBody) => {\n        if (requestBody == null) {\n            throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {\n                extensions: {\n                    http: {\n                        status: 400,\n                    },\n                    code: 'BAD_REQUEST',\n                },\n            });\n        }\n        const requestBodyTypeof = typeof requestBody;\n        if (requestBodyTypeof !== 'object') {\n            throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {\n                extensions: {\n                    http: {\n                        status: 400,\n                    },\n                    code: 'BAD_REQUEST',\n                },\n            });\n        }\n        return requestBody;\n    }, err => {\n        if (err instanceof GraphQLError) {\n            throw err;\n        }\n        const extensions = {\n            http: {\n                spec: true,\n                status: 400,\n            },\n            code: 'BAD_REQUEST',\n        };\n        if (err instanceof Error) {\n            extensions['originalError'] = {\n                name: err.name,\n                message: err.message,\n            };\n        }\n        throw createGraphQLError('POST body sent invalid JSON.', {\n            extensions,\n        });\n    });\n}\n","export function dset(obj, keys, val) {\n\tkeys.split && (keys=keys.split('.'));\n\tvar i=0, l=keys.length, t=obj, x, k;\n\twhile (i < l) {\n\t\tk = ''+keys[i++];\n\t\tif (k === '__proto__' || k === 'constructor' || k === 'prototype') break;\n\t\tt = t[k] = (i === l) ? val : (typeof(x=t[k])===typeof(keys)) ? x : (keys[i]*0 !== 0 || !!~(''+keys[i]).indexOf('.')) ? {} : [];\n\t}\n}\n","import { dset } from 'dset';\nimport { createGraphQLError } from '@graphql-tools/utils';\nimport { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { isContentTypeMatch } from './utils.js';\nexport function isPOSTMultipartRequest(request) {\n    return request.method === 'POST' && isContentTypeMatch(request, 'multipart/form-data');\n}\nexport function parsePOSTMultipartRequest(request) {\n    return handleMaybePromise(() => request.formData(), (requestBody) => {\n        const operationsStr = requestBody.get('operations');\n        if (!operationsStr) {\n            throw createGraphQLError('Missing multipart form field \"operations\"');\n        }\n        if (typeof operationsStr !== 'string') {\n            throw createGraphQLError('Multipart form field \"operations\" must be a string');\n        }\n        let operations;\n        try {\n            operations = JSON.parse(operationsStr);\n        }\n        catch {\n            throw createGraphQLError('Multipart form field \"operations\" must be a valid JSON string');\n        }\n        const mapStr = requestBody.get('map');\n        if (mapStr != null) {\n            if (typeof mapStr !== 'string') {\n                throw createGraphQLError('Multipart form field \"map\" must be a string');\n            }\n            let map;\n            try {\n                map = JSON.parse(mapStr);\n            }\n            catch {\n                throw createGraphQLError('Multipart form field \"map\" must be a valid JSON string');\n            }\n            for (const fileIndex in map) {\n                const file = requestBody.get(fileIndex);\n                const keys = map[fileIndex];\n                for (const key of keys) {\n                    dset(operations, key, file);\n                }\n            }\n        }\n        return operations;\n    }, e => {\n        if (e instanceof Error && e.message.startsWith('File size limit exceeded: ')) {\n            throw createGraphQLError(e.message, {\n                extensions: {\n                    http: {\n                        status: 413,\n                    },\n                },\n            });\n        }\n        throw e;\n    });\n}\n","import { createGraphQLError } from '@graphql-tools/utils';\nconst expectedParameters = new Set(['query', 'variables', 'operationName', 'extensions']);\nexport function assertInvalidParams(params, extraParamNames) {\n    if (params == null || typeof params !== 'object') {\n        throw createGraphQLError('Invalid \"params\" in the request body', {\n            extensions: {\n                http: {\n                    spec: true,\n                    status: 400,\n                },\n                code: 'BAD_REQUEST',\n            },\n        });\n    }\n    for (const paramKey in params) {\n        if (params[paramKey] == null) {\n            continue;\n        }\n        if (!expectedParameters.has(paramKey)) {\n            if (extraParamNames?.includes(paramKey)) {\n                continue;\n            }\n            throw createGraphQLError(`Unexpected parameter \"${paramKey}\" in the request body.`, {\n                extensions: {\n                    http: {\n                        status: 400,\n                    },\n                    code: 'BAD_REQUEST',\n                },\n            });\n        }\n    }\n}\nexport function checkGraphQLQueryParams(params, extraParamNames) {\n    if (!isObject(params)) {\n        throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {\n            extensions: {\n                http: {\n                    status: 400,\n                    headers: {\n                        Allow: 'GET, POST',\n                    },\n                },\n                code: 'BAD_REQUEST',\n            },\n        });\n    }\n    assertInvalidParams(params, extraParamNames);\n    if (params['query'] == null) {\n        throw createGraphQLError('Must provide query string.', {\n            extensions: {\n                http: {\n                    spec: true,\n                    status: 400,\n                    headers: {\n                        Allow: 'GET, POST',\n                    },\n                },\n                code: 'BAD_REQUEST',\n            },\n        });\n    }\n    const queryType = extendedTypeof(params['query']);\n    if (queryType !== 'string') {\n        throw createGraphQLError(`Expected \"query\" param to be a string, but given ${queryType}.`, {\n            extensions: {\n                http: {\n                    status: 400,\n                    headers: {\n                        Allow: 'GET, POST',\n                    },\n                },\n                code: 'BAD_REQUEST',\n            },\n        });\n    }\n    const variablesParamType = extendedTypeof(params['variables']);\n    if (!['object', 'null', 'undefined'].includes(variablesParamType)) {\n        throw createGraphQLError(`Expected \"variables\" param to be empty or an object, but given ${variablesParamType}.`, {\n            extensions: {\n                http: {\n                    status: 400,\n                    headers: {\n                        Allow: 'GET, POST',\n                    },\n                },\n                code: 'BAD_REQUEST',\n            },\n        });\n    }\n    const extensionsParamType = extendedTypeof(params['extensions']);\n    if (!['object', 'null', 'undefined'].includes(extensionsParamType)) {\n        throw createGraphQLError(`Expected \"extensions\" param to be empty or an object, but given ${extensionsParamType}.`, {\n            extensions: {\n                http: {\n                    status: 400,\n                    headers: {\n                        Allow: 'GET, POST',\n                    },\n                },\n                code: 'BAD_REQUEST',\n            },\n        });\n    }\n    return params;\n}\nexport function isValidGraphQLParams(params) {\n    try {\n        checkGraphQLQueryParams(params);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport function useCheckGraphQLQueryParams(extraParamNames) {\n    return {\n        onParams({ params }) {\n            checkGraphQLQueryParams(params, extraParamNames);\n        },\n    };\n}\nfunction extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\nfunction isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n","import { createGraphQLError } from '@graphql-tools/utils';\nexport function isValidMethodForGraphQL(method) {\n    return method === 'GET' || method === 'POST';\n}\nexport function useCheckMethodForGraphQL() {\n    return {\n        onRequestParse({ request }) {\n            if (!isValidMethodForGraphQL(request.method)) {\n                throw createGraphQLError('GraphQL only supports GET and POST requests.', {\n                    extensions: {\n                        http: {\n                            status: 405,\n                            headers: {\n                                Allow: 'GET, POST',\n                            },\n                        },\n                        code: 'BAD_REQUEST',\n                    },\n                });\n            }\n        },\n    };\n}\n","export function useHTTPValidationError() {\n    return {\n        onValidate() {\n            return ({ valid, result }) => {\n                if (!valid) {\n                    for (const error of result) {\n                        error.extensions ||= {};\n                        error.extensions.code ||= 'GRAPHQL_VALIDATION_FAILED';\n                        error.extensions.http ||= {};\n                        error.extensions.http.spec =\n                            error.extensions.http.spec == null ? true : error.extensions.http.spec;\n                        error.extensions.http.status ||= 400;\n                    }\n                }\n            };\n        },\n    };\n}\n","import { createGraphQLError } from '@graphql-tools/utils';\nexport function useLimitBatching(limit) {\n    return {\n        onRequestParse() {\n            return {\n                onRequestParseDone({ requestParserResult }) {\n                    if (Array.isArray(requestParserResult)) {\n                        if (!limit) {\n                            throw createGraphQLError(`Batching is not supported.`, {\n                                extensions: {\n                                    http: {\n                                        status: 400,\n                                    },\n                                    code: 'BAD_REQUEST',\n                                },\n                            });\n                        }\n                        if (requestParserResult.length > limit) {\n                            throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {\n                                extensions: {\n                                    http: {\n                                        status: 413,\n                                    },\n                                    code: 'BAD_REQUEST',\n                                },\n                            });\n                        }\n                    }\n                },\n            };\n        },\n    };\n}\n","import { getOperationAST, GraphQLError, } from 'graphql';\nimport { createGraphQLError } from '@graphql-tools/utils';\nexport function assertMutationViaGet(method, document, operationName) {\n    const operation = document\n        ? (getOperationAST(document, operationName) ?? undefined)\n        : undefined;\n    if (!operation) {\n        throw createGraphQLError('Could not determine what operation to execute.', {\n            extensions: {\n                code: 'OPERATION_RESOLUTION_FAILURE',\n                http: {\n                    status: 400,\n                },\n            },\n        });\n    }\n    if (operation.operation === 'mutation' && method === 'GET') {\n        throw createGraphQLError('Can only perform a mutation operation from a POST request.', {\n            extensions: {\n                http: {\n                    status: 405,\n                    headers: {\n                        Allow: 'POST',\n                    },\n                },\n                code: 'BAD_REQUEST',\n            },\n        });\n    }\n}\nexport function usePreventMutationViaGET() {\n    return {\n        onParse() {\n            // We should improve this by getting Yoga stuff from the hook params directly instead of the context\n            return ({ result, context: { request, \n            // the `params` might be missing in cases where the user provided\n            // malformed context to getEnveloped (like `yoga.getEnveloped({})`)\n            params: { operationName } = {}, }, }) => {\n                // Run only if this is a Yoga request\n                // the `request` might be missing when using graphql-ws for example\n                // in which case throwing an error would abruptly close the socket\n                if (!request) {\n                    return;\n                }\n                if (result instanceof Error) {\n                    if (result instanceof GraphQLError) {\n                        // @ts-expect-error - We are modifying the extensions on purpose\n                        const extensions = (result.extensions ||= {});\n                        extensions['code'] ||= 'GRAPHQL_PARSE_FAILED';\n                        const httpExtensions = (extensions['http'] ||= {});\n                        httpExtensions.spec ||= true;\n                        httpExtensions.status ||= 400;\n                    }\n                }\n                else {\n                    assertMutationViaGet(request.method, result, operationName);\n                }\n            };\n        },\n    };\n}\n","export default \"<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/graphql-hive/graphql-yoga/main/website/public/favicon.ico><link crossorigin rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.3.5/dist/graphiql.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from\\\"https://unpkg.com/@graphql-yoga/graphiql@4.3.5/dist/yoga-graphiql.es.js\\\";renderYogaGraphiQL(root,__OPTS__)</script></body></html>\";\n","import { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport graphiqlHTML from '../graphiql-html.js';\nexport function shouldRenderGraphiQL({ headers, method }) {\n    return method === 'GET' && !!headers?.get('accept')?.includes('text/html');\n}\nexport const renderGraphiQL = (opts) => graphiqlHTML\n    .replace('__TITLE__', opts?.title || 'Yoga GraphiQL')\n    .replace('__OPTS__', JSON.stringify(opts ?? {}));\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useGraphiQL(config) {\n    const logger = config.logger ?? console;\n    let graphiqlOptionsFactory;\n    if (typeof config?.options === 'function') {\n        graphiqlOptionsFactory = config?.options;\n    }\n    else if (typeof config?.options === 'object') {\n        graphiqlOptionsFactory = () => config?.options;\n    }\n    else if (config?.options === false) {\n        graphiqlOptionsFactory = () => false;\n    }\n    else {\n        graphiqlOptionsFactory = () => ({});\n    }\n    const renderer = config?.render ?? renderGraphiQL;\n    let urlPattern;\n    const getUrlPattern = ({ URLPattern }) => {\n        urlPattern ||= new URLPattern({\n            pathname: config.graphqlEndpoint,\n        });\n        return urlPattern;\n    };\n    return {\n        onRequest({ request, serverContext, fetchAPI, endResponse, url }) {\n            if (shouldRenderGraphiQL(request) &&\n                (request.url.endsWith(config.graphqlEndpoint) ||\n                    request.url.endsWith(`${config.graphqlEndpoint}/`) ||\n                    url.pathname === config.graphqlEndpoint ||\n                    url.pathname === `${config.graphqlEndpoint}/` ||\n                    getUrlPattern(fetchAPI).test(url))) {\n                logger.debug(`Rendering GraphiQL`);\n                return handleMaybePromise(() => graphiqlOptionsFactory(request, serverContext), graphiqlOptions => {\n                    if (graphiqlOptions) {\n                        return handleMaybePromise(() => renderer({\n                            ...(graphiqlOptions === true ? {} : graphiqlOptions),\n                        }), graphiqlBody => {\n                            const response = new fetchAPI.Response(graphiqlBody, {\n                                headers: {\n                                    'Content-Type': 'text/html',\n                                },\n                                status: 200,\n                            });\n                            endResponse(response);\n                        });\n                    }\n                });\n            }\n        },\n    };\n}\n","export function useHealthCheck({ id = Date.now().toString(), logger = console, endpoint = '/health', } = {}) {\n    return {\n        onRequest({ endResponse, fetchAPI, request }) {\n            if (request.url.endsWith(endpoint)) {\n                logger.debug('Responding Health Check');\n                const response = new fetchAPI.Response(null, {\n                    status: 200,\n                    headers: {\n                        'x-yoga-id': id,\n                    },\n                });\n                endResponse(response);\n            }\n        },\n    };\n}\n","/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport { LRUCache as LRU } from 'lru-cache';\n/**\n * @deprecated In the next major, `createLRUCache` will be renamed to `_createLRUCache`,\n * and the current `createLRUCache` will be removed.\n */\nexport const createLRUCache = _createLRUCache;\nconst DEFAULT_MAX = 1024;\nconst DEFAULT_TTL = 3_600_000;\n/**\n * @internal This is an internal utility, and you should use it with your own risk.\n * This utility can have breaking changes in the future.\n */\nexport function _createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL, } = {}) {\n    return new LRU({ max, ttl });\n}\n","import { _createLRUCache } from '../utils/create-lru-cache.js';\nexport function useParserAndValidationCache({ documentCache = _createLRUCache(), errorCache = _createLRUCache(), validationCache = true, }) {\n    const validationCacheByRules = _createLRUCache();\n    return {\n        onParse({ params, setParsedDocument }) {\n            const strDocument = params.source.toString();\n            const document = documentCache.get(strDocument);\n            if (document) {\n                setParsedDocument(document);\n                return;\n            }\n            const parserError = errorCache.get(strDocument);\n            if (parserError) {\n                throw parserError;\n            }\n            return ({ result }) => {\n                if (result != null) {\n                    if (result instanceof Error) {\n                        errorCache.set(strDocument, result);\n                    }\n                    else {\n                        documentCache.set(strDocument, result);\n                    }\n                }\n            };\n        },\n        onValidate({ params: { schema, documentAST, rules }, setResult,\n        // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n         }) {\n            /** No schema no cache */\n            if (schema == null) {\n                return;\n            }\n            if (validationCache !== false) {\n                const rulesKey = rules?.map((rule) => rule.name).join(',') || '';\n                let validationCacheBySchema = validationCacheByRules.get(rulesKey);\n                if (!validationCacheBySchema) {\n                    validationCacheBySchema = new WeakMap();\n                    validationCacheByRules.set(rulesKey, validationCacheBySchema);\n                }\n                let validationCacheByDocument = validationCacheBySchema.get(schema);\n                if (!validationCacheByDocument) {\n                    validationCacheByDocument = new WeakMap();\n                    validationCacheBySchema.set(schema, validationCacheByDocument);\n                }\n                const cachedResult = validationCacheByDocument.get(documentAST);\n                if (cachedResult) {\n                    setResult(cachedResult);\n                    return;\n                }\n                return ({ result }) => {\n                    if (result != null) {\n                        validationCacheByDocument?.set(documentAST, result);\n                    }\n                };\n            }\n        },\n    };\n}\n","const DEFAULT_MATCHER = () => true;\nexport function useRequestParser(options) {\n    const matchFn = options.match || DEFAULT_MATCHER;\n    return {\n        onRequestParse({ request, setRequestParser }) {\n            if (matchFn(request)) {\n                setRequestParser(options.parse);\n            }\n        },\n    };\n}\n","export function getMediaTypesForRequestInOrder(request) {\n    const accepts = (request.headers.get('accept') || '*/*')\n        .replace(/\\s/g, '')\n        .toLowerCase()\n        .split(',');\n    const mediaTypes = [];\n    for (const accept of accepts) {\n        const [mediaType, ...params] = accept.split(';');\n        if (mediaType === undefined)\n            continue; // If true, malformed header.\n        const charset = params?.find(param => param.includes('charset=')) || 'charset=utf-8'; // utf-8 is assumed when not specified;\n        if (charset !== 'charset=utf-8') {\n            // only utf-8 is supported\n            continue;\n        }\n        mediaTypes.push(mediaType);\n    }\n    return mediaTypes.reverse();\n}\nexport function isMatchingMediaType(askedMediaType, processorMediaType) {\n    const [askedPre, askedSuf] = askedMediaType.split('/');\n    const [pre, suf] = processorMediaType.split('/');\n    if ((pre === '*' || pre === askedPre) && (suf === '*' || suf === askedSuf)) {\n        return true;\n    }\n    return false;\n}\n","import { createGraphQLError } from '@graphql-tools/utils';\nimport { isGraphQLError } from '../../error.js';\n// JSON stringifier that adjusts the result error extensions while serialising\nexport function jsonStringifyResultWithoutInternals(result) {\n    if (Array.isArray(result)) {\n        return `[${result\n            .map(r => {\n            const sanitizedResult = omitInternalsFromResultErrors(r);\n            const stringifier = r.stringify || JSON.stringify;\n            return stringifier(sanitizedResult);\n        })\n            .join(',')}]`;\n    }\n    const sanitizedResult = omitInternalsFromResultErrors(result);\n    const stringifier = result.stringify || JSON.stringify;\n    return stringifier(sanitizedResult);\n}\nexport function omitInternalsFromResultErrors(result) {\n    if (result.errors?.length || result.extensions?.http) {\n        const newResult = { ...result };\n        newResult.errors &&= newResult.errors.map(omitInternalsFromError);\n        if (newResult.extensions) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TS should check for unused vars instead\n            const { http, ...extensions } = result.extensions;\n            newResult.extensions = Object.keys(extensions).length ? extensions : undefined;\n        }\n        return newResult;\n    }\n    return result;\n}\nfunction omitInternalsFromError(err) {\n    if (isGraphQLError(err)) {\n        const serializedError = 'toJSON' in err && typeof err.toJSON === 'function' ? err.toJSON() : Object(err);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TS should check for unused vars instead\n        const { http, unexpected, ...extensions } = serializedError.extensions || {};\n        return createGraphQLError(err.message, {\n            nodes: err.nodes,\n            source: err.source,\n            positions: err.positions,\n            path: err.path,\n            originalError: omitInternalsFromError(err.originalError || undefined),\n            extensions: Object.keys(extensions).length ? extensions : undefined,\n        });\n    }\n    return err;\n}\n","import { isAsyncIterable } from '@envelop/core';\nimport { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { fakePromise } from '@whatwg-node/server';\nimport { getResponseInitByRespectingErrors } from '../../error.js';\nimport { jsonStringifyResultWithoutInternals } from './stringify.js';\nexport function processMultipartResult(result, fetchAPI) {\n    const headersInit = {\n        Connection: 'keep-alive',\n        'Content-Type': 'multipart/mixed; boundary=\"-\"',\n        'Transfer-Encoding': 'chunked',\n    };\n    const responseInit = getResponseInitByRespectingErrors(result, headersInit);\n    let iterator;\n    const textEncoder = new fetchAPI.TextEncoder();\n    const readableStream = new fetchAPI.ReadableStream({\n        start(controller) {\n            if (isAsyncIterable(result)) {\n                iterator = result[Symbol.asyncIterator]();\n            }\n            else {\n                let finished = false;\n                iterator = {\n                    next: () => {\n                        if (finished) {\n                            return fakePromise({ done: true, value: null });\n                        }\n                        finished = true;\n                        return fakePromise({ done: false, value: result });\n                    },\n                };\n            }\n            controller.enqueue(textEncoder.encode('\\r\\n'));\n            controller.enqueue(textEncoder.encode(`---`));\n        },\n        pull(controller) {\n            return handleMaybePromise(() => iterator.next(), ({ done, value }) => {\n                if (value != null) {\n                    controller.enqueue(textEncoder.encode('\\r\\n'));\n                    controller.enqueue(textEncoder.encode('Content-Type: application/json; charset=utf-8'));\n                    controller.enqueue(textEncoder.encode('\\r\\n'));\n                    const chunk = jsonStringifyResultWithoutInternals(value);\n                    const encodedChunk = textEncoder.encode(chunk);\n                    controller.enqueue(textEncoder.encode('Content-Length: ' + encodedChunk.byteLength));\n                    controller.enqueue(textEncoder.encode('\\r\\n'));\n                    controller.enqueue(textEncoder.encode('\\r\\n'));\n                    controller.enqueue(encodedChunk);\n                    controller.enqueue(textEncoder.encode('\\r\\n'));\n                    controller.enqueue(textEncoder.encode('---'));\n                }\n                if (done) {\n                    controller.enqueue(textEncoder.encode('--\\r\\n'));\n                    controller.close();\n                }\n            }, err => {\n                controller.error(err);\n            });\n        },\n        cancel(e) {\n            if (iterator.return) {\n                return handleMaybePromise(() => iterator.return?.(e), () => { });\n            }\n        },\n    });\n    return new fetchAPI.Response(readableStream, responseInit);\n}\n","import { isAsyncIterable } from '@graphql-tools/utils';\nimport { areGraphQLErrors, getResponseInitByRespectingErrors, isGraphQLError, } from '../../error.js';\nimport { jsonStringifyResultWithoutInternals } from './stringify.js';\nexport function processRegularResult(executionResult, fetchAPI, acceptedHeader) {\n    if (isAsyncIterable(executionResult)) {\n        return new fetchAPI.Response(null, {\n            status: 406,\n            statusText: 'Not Acceptable',\n            headers: {\n                accept: 'application/json; charset=utf-8, application/graphql-response+json; charset=utf-8',\n            },\n        });\n    }\n    const headersInit = {\n        'Content-Type': acceptedHeader + '; charset=utf-8',\n    };\n    const responseInit = getResponseInitByRespectingErrors(executionResult, headersInit, \n    // prefer 200 only if accepting application/json and all errors are exclusively GraphQL errors\n    acceptedHeader === 'application/json' &&\n        !Array.isArray(executionResult) &&\n        areGraphQLErrors(executionResult.errors) &&\n        executionResult.errors.some(err => !err.extensions?.['originalError'] || isGraphQLError(err.extensions['originalError'])));\n    const responseBody = jsonStringifyResultWithoutInternals(executionResult);\n    return new fetchAPI.Response(responseBody, responseInit);\n}\n","import { isAsyncIterable } from '@envelop/core';\nimport { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { fakePromise } from '@whatwg-node/server';\nimport { getResponseInitByRespectingErrors } from '../../error.js';\nimport { jsonStringifyResultWithoutInternals } from './stringify.js';\nexport function getSSEProcessor() {\n    return function processSSEResult(result, fetchAPI) {\n        let pingIntervalMs = 12_000;\n        // for testing the pings, reduce the timeout\n        if (globalThis.process?.env?.['NODE_ENV'] === 'test') {\n            pingIntervalMs = 300;\n        }\n        const headersInit = {\n            'Content-Type': 'text/event-stream',\n            Connection: 'keep-alive',\n            'Cache-Control': 'no-cache',\n            'Content-Encoding': 'none',\n        };\n        const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);\n        let iterator;\n        let pingInterval;\n        const textEncoder = new fetchAPI.TextEncoder();\n        const readableStream = new fetchAPI.ReadableStream({\n            start(controller) {\n                // always start with a ping because some browsers dont accept a header flush\n                // causing the fetch to stall until something is streamed through the response\n                controller.enqueue(textEncoder.encode(':\\n\\n'));\n                // ping client every 12 seconds to keep the connection alive\n                pingInterval = setInterval(() => {\n                    if (!controller.desiredSize) {\n                        clearInterval(pingInterval);\n                        return;\n                    }\n                    controller.enqueue(textEncoder.encode(':\\n\\n'));\n                }, pingIntervalMs);\n                if (isAsyncIterable(result)) {\n                    iterator = result[Symbol.asyncIterator]();\n                }\n                else {\n                    let finished = false;\n                    iterator = {\n                        next: () => {\n                            if (finished) {\n                                return fakePromise({ done: true, value: null });\n                            }\n                            finished = true;\n                            return fakePromise({ done: false, value: result });\n                        },\n                    };\n                }\n            },\n            pull(controller) {\n                return handleMaybePromise(() => iterator.next(), result => {\n                    if (result.value != null) {\n                        controller.enqueue(textEncoder.encode(`event: next\\n`));\n                        const chunk = jsonStringifyResultWithoutInternals(result.value);\n                        controller.enqueue(textEncoder.encode(`data: ${chunk}\\n\\n`));\n                    }\n                    if (result.done) {\n                        controller.enqueue(textEncoder.encode(`event: complete\\n`));\n                        controller.enqueue(textEncoder.encode(`data:\\n\\n`));\n                        clearInterval(pingInterval);\n                        controller.close();\n                    }\n                }, err => {\n                    controller.error(err);\n                });\n            },\n            cancel(e) {\n                clearInterval(pingInterval);\n                if (iterator.return) {\n                    return handleMaybePromise(() => iterator.return?.(e), () => { });\n                }\n            },\n        });\n        return new fetchAPI.Response(readableStream, responseInit);\n    };\n}\n","import { isAsyncIterable } from '@envelop/core';\nimport { getMediaTypesForRequestInOrder, isMatchingMediaType } from './result-processor/accept.js';\nimport { processMultipartResult } from './result-processor/multipart.js';\nimport { processRegularResult } from './result-processor/regular.js';\nimport { getSSEProcessor } from './result-processor/sse.js';\nconst multipart = {\n    mediaTypes: ['multipart/mixed'],\n    asyncIterables: true,\n    processResult: processMultipartResult,\n};\nfunction getSSEProcessorConfig() {\n    return {\n        mediaTypes: ['text/event-stream'],\n        asyncIterables: true,\n        processResult: getSSEProcessor(),\n    };\n}\nconst regular = {\n    mediaTypes: ['application/graphql-response+json', 'application/json'],\n    asyncIterables: false,\n    processResult: processRegularResult,\n};\nexport function useResultProcessors() {\n    const isSubscriptionRequestMap = new WeakMap();\n    const sse = getSSEProcessorConfig();\n    const defaultList = [sse, multipart, regular];\n    const subscriptionList = [sse, regular];\n    return {\n        onSubscribe({ args: { contextValue } }) {\n            if (contextValue.request) {\n                isSubscriptionRequestMap.set(contextValue.request, true);\n            }\n        },\n        onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {\n            const isSubscriptionRequest = isSubscriptionRequestMap.get(request);\n            const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;\n            const requestMediaTypes = getMediaTypesForRequestInOrder(request);\n            const isAsyncIterableResult = isAsyncIterable(result);\n            for (const resultProcessorConfig of processorConfigList) {\n                for (const requestMediaType of requestMediaTypes) {\n                    if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {\n                        continue;\n                    }\n                    for (const processorMediaType of resultProcessorConfig.mediaTypes) {\n                        acceptableMediaTypes.push(processorMediaType);\n                        if (isMatchingMediaType(processorMediaType, requestMediaType)) {\n                            setResultProcessor(resultProcessorConfig.processResult, processorMediaType);\n                        }\n                    }\n                }\n            }\n        },\n    };\n}\n","import { isSchema } from 'graphql';\nimport { handleMaybePromise } from '@whatwg-node/promise-helpers';\nexport const useSchema = (schemaDef) => {\n    if (schemaDef == null) {\n        return {};\n    }\n    if (isSchema(schemaDef)) {\n        return {\n            onPluginInit({ setSchema }) {\n                setSchema(schemaDef);\n            },\n        };\n    }\n    if ('then' in schemaDef) {\n        let schema;\n        return {\n            onRequestParse() {\n                return {\n                    onRequestParseDone() {\n                        if (!schema) {\n                            return handleMaybePromise(() => schemaDef, schemaDef => {\n                                schema = schemaDef;\n                            });\n                        }\n                    },\n                };\n            },\n            onEnveloped({ setSchema }) {\n                if (!schema) {\n                    throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);\n                }\n                setSchema(schema);\n            },\n        };\n    }\n    const schemaByRequest = new WeakMap();\n    return {\n        onRequestParse({ request, serverContext }) {\n            return {\n                onRequestParseDone() {\n                    return handleMaybePromise(() => schemaDef({\n                        ...serverContext,\n                        request,\n                    }), schemaDef => {\n                        schemaByRequest.set(request, schemaDef);\n                    });\n                },\n            };\n        },\n        onEnveloped({ setSchema, context }) {\n            if (context?.request == null) {\n                throw new Error('Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.');\n            }\n            const schema = schemaByRequest.get(context.request);\n            if (schema == null) {\n                throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);\n            }\n            setSchema(schema);\n        },\n    };\n};\n","export default \"<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/graphql-hive/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox=\\\"-0.41 0.445 472.812 499.811\\\" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform=\\\"matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)\\\"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform=\\\"matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)\\\"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform=\\\"matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)\\\"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform=\\\"matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)\\\"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d=\\\"M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z\\\" fill=url(#paint3_linear_1677_11483) /><path d=\\\"M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z\\\" fill=url(#paint4_linear_1677_11483) /><path d=\\\"M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z\\\" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d=\\\"M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z\\\" fill=black /></mask><path d=\\\"M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z\\\" fill=url(#paint0_linear_1677_11483) /><path d=\\\"M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z\\\" fill=url(#paint1_linear_1677_11483) /><path d=\\\"M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z\\\" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform=\\\"matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)\\\"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d=\\\"M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z\\\" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform=\\\"matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)\\\"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1><p>Version: 5.13.5</p></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? </h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>\\n          <code>\\nimport { createYoga } from 'graphql-yoga';\\n\\nconst yoga = createYoga({\\n  landingPage: false\\n})\\n          </code>\\n        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>\\n          <code>\\nimport { createYoga } from 'graphql-yoga';\\n\\nconst yoga = createYoga({\\n  graphqlEndpoint: '__REQUEST_PATH__',\\n})\\n          </code>\\n        </pre></section></main></body></html>\";\n","import { isPromise } from '@graphql-tools/utils';\nimport landingPageBody from '../landing-page-html.js';\nexport const defaultRenderLandingPage = function defaultRenderLandingPage(opts) {\n    return new opts.fetchAPI.Response(landingPageBody\n        .replace(/__GRAPHIQL_LINK__/g, opts.graphqlEndpoint)\n        .replace(/__REQUEST_PATH__/g, opts.url.pathname), {\n        status: 200,\n        statusText: 'OK',\n        headers: {\n            'Content-Type': 'text/html',\n        },\n    });\n};\nexport function useUnhandledRoute(args) {\n    let urlPattern;\n    function getUrlPattern({ URLPattern }) {\n        urlPattern ||= new URLPattern({\n            pathname: args.graphqlEndpoint,\n        });\n        return urlPattern;\n    }\n    const landingPageRenderer = args.landingPageRenderer || defaultRenderLandingPage;\n    return {\n        onRequest({ request, fetchAPI, endResponse, url }) {\n            if (!request.url.endsWith(args.graphqlEndpoint) &&\n                !request.url.endsWith(`${args.graphqlEndpoint}/`) &&\n                url.pathname !== args.graphqlEndpoint &&\n                url.pathname !== `${args.graphqlEndpoint}/` &&\n                !getUrlPattern(fetchAPI).test(url)) {\n                if (args.showLandingPage === true &&\n                    request.method === 'GET' &&\n                    !!request.headers?.get('accept')?.includes('text/html')) {\n                    const landingPage$ = landingPageRenderer({\n                        request,\n                        fetchAPI,\n                        url,\n                        graphqlEndpoint: args.graphqlEndpoint,\n                        get urlPattern() {\n                            return getUrlPattern(fetchAPI);\n                        },\n                    });\n                    if (isPromise(landingPage$)) {\n                        return landingPage$.then(endResponse);\n                    }\n                    endResponse(landingPage$);\n                    return;\n                }\n                endResponse(new fetchAPI.Response('', {\n                    status: 404,\n                    statusText: 'Not Found',\n                }));\n            }\n        },\n    };\n}\n","import { getOperationAST } from 'graphql';\nimport { handleMaybePromise, iterateAsync } from '@whatwg-node/promise-helpers';\nexport function processResult({ request, result, fetchAPI, onResultProcessHooks, serverContext, }) {\n    let resultProcessor;\n    const acceptableMediaTypes = [];\n    let acceptedMediaType = '*/*';\n    return handleMaybePromise(() => iterateAsync(onResultProcessHooks, onResultProcessHook => onResultProcessHook({\n        request,\n        acceptableMediaTypes,\n        result,\n        setResult(newResult) {\n            result = newResult;\n        },\n        resultProcessor,\n        setResultProcessor(newResultProcessor, newAcceptedMimeType) {\n            resultProcessor = newResultProcessor;\n            acceptedMediaType = newAcceptedMimeType;\n        },\n        serverContext,\n    })), () => {\n        // If no result processor found for this result, return an error\n        if (!resultProcessor) {\n            return new fetchAPI.Response(null, {\n                status: 406,\n                statusText: 'Not Acceptable',\n                headers: {\n                    accept: acceptableMediaTypes.join('; charset=utf-8, '),\n                },\n            });\n        }\n        return resultProcessor(result, fetchAPI, acceptedMediaType);\n    });\n}\nexport function processRequest({ params, enveloped, }) {\n    // Parse GraphQLParams\n    const document = enveloped.parse(params.query);\n    // Validate parsed Document Node\n    const errors = enveloped.validate(enveloped.schema, document);\n    if (errors.length > 0) {\n        return { errors };\n    }\n    // Build the context for the execution\n    return handleMaybePromise(() => enveloped.contextFactory(), contextValue => {\n        const executionArgs = {\n            schema: enveloped.schema,\n            document,\n            contextValue,\n            variableValues: params.variables,\n            operationName: params.operationName,\n        };\n        // Get the actual operation\n        const operation = getOperationAST(document, params.operationName);\n        // Choose the right executor\n        const executeFn = operation?.operation === 'subscription' ? enveloped.subscribe : enveloped.execute;\n        // Get the result to be processed\n        return executeFn(executionArgs);\n    });\n}\n","import { createGraphQLError } from '@graphql-tools/utils';\nimport { isGraphQLError, isOriginalGraphQLError } from '../error.js';\nfunction serializeError(error) {\n    if (isGraphQLError(error)) {\n        return error.toJSON();\n    }\n    if (error instanceof Error) {\n        return {\n            message: error.message,\n            stack: error.stack,\n            cause: error.cause,\n        };\n    }\n    return error;\n}\nexport const maskError = (error, message, isDev = globalThis.process?.env?.['NODE_ENV'] === 'development') => {\n    if (isOriginalGraphQLError(error)) {\n        return error;\n    }\n    const errorExtensions = {\n        code: 'INTERNAL_SERVER_ERROR',\n        unexpected: true,\n    };\n    const errorOptions = {\n        extensions: errorExtensions,\n    };\n    if (isGraphQLError(error)) {\n        errorOptions.nodes = error.nodes;\n        errorOptions.source = error.source;\n        errorOptions.positions = error.positions;\n        errorOptions.path = error.path;\n        if (isDev && error.originalError) {\n            errorExtensions['originalError'] = serializeError(error.originalError);\n        }\n        if (error.extensions?.['http']) {\n            errorExtensions['http'] = error.extensions['http'];\n        }\n    }\n    else if (isDev) {\n        errorExtensions['originalError'] = serializeError(error);\n    }\n    return createGraphQLError(message, errorOptions);\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { parse, specifiedRules, validate } from 'graphql';\nimport { envelop, isAsyncIterable, useEngine, useExtendContext, useMaskedErrors, } from '@envelop/core';\nimport { chain, getInstrumented } from '@envelop/instrumentation';\nimport { normalizedExecutor } from '@graphql-tools/executor';\nimport { createLogger } from '@graphql-yoga/logger';\nimport * as defaultFetchAPI from '@whatwg-node/fetch';\nimport { fakePromise, handleMaybePromise, iterateAsync, iterateAsyncVoid, mapAsyncIterator, unfakePromise, } from '@whatwg-node/promise-helpers';\nimport { createServerAdapter, useCORS, } from '@whatwg-node/server';\nimport { handleError, isAbortError } from './error.js';\nimport { isGETRequest, parseGETRequest } from './plugins/request-parser/get.js';\nimport { isPOSTFormUrlEncodedRequest, parsePOSTFormUrlEncodedRequest, } from './plugins/request-parser/post-form-url-encoded.js';\nimport { isPOSTGraphQLStringRequest, parsePOSTGraphQLStringRequest, } from './plugins/request-parser/post-graphql-string.js';\nimport { isPOSTJsonRequest, parsePOSTJsonRequest } from './plugins/request-parser/post-json.js';\nimport { isPOSTMultipartRequest, parsePOSTMultipartRequest, } from './plugins/request-parser/post-multipart.js';\nimport { useCheckGraphQLQueryParams } from './plugins/request-validation/use-check-graphql-query-params.js';\nimport { useCheckMethodForGraphQL } from './plugins/request-validation/use-check-method-for-graphql.js';\nimport { useHTTPValidationError } from './plugins/request-validation/use-http-validation-error.js';\nimport { useLimitBatching } from './plugins/request-validation/use-limit-batching.js';\nimport { usePreventMutationViaGET } from './plugins/request-validation/use-prevent-mutation-via-get.js';\nimport { useGraphiQL } from './plugins/use-graphiql.js';\nimport { useHealthCheck } from './plugins/use-health-check.js';\nimport { useParserAndValidationCache, } from './plugins/use-parser-and-validation-cache.js';\nimport { useRequestParser } from './plugins/use-request-parser.js';\nimport { useResultProcessors } from './plugins/use-result-processor.js';\nimport { useSchema } from './plugins/use-schema.js';\nimport { useUnhandledRoute } from './plugins/use-unhandled-route.js';\nimport { processRequest as processGraphQLParams, processResult } from './process-request.js';\nimport { maskError } from './utils/mask-error.js';\n/**\n * Base class that can be extended to create a GraphQL server with any HTTP server framework.\n * @internal\n */\nexport class YogaServer {\n    /**\n     * Instance of envelop\n     */\n    getEnveloped;\n    logger;\n    graphqlEndpoint;\n    fetchAPI;\n    plugins;\n    instrumentation;\n    onRequestParseHooks;\n    onParamsHooks;\n    onExecutionResultHooks;\n    onResultProcessHooks;\n    maskedErrorsOpts;\n    id;\n    version = '5.13.5';\n    constructor(options) {\n        this.id = options?.id ?? 'yoga';\n        this.fetchAPI = {\n            ...defaultFetchAPI,\n        };\n        if (options?.fetchAPI) {\n            for (const key in options.fetchAPI) {\n                if (options.fetchAPI[key]) {\n                    this.fetchAPI[key] = options.fetchAPI[key];\n                }\n            }\n        }\n        const logger = options?.logging == null ? true : options.logging;\n        this.logger =\n            typeof logger === 'boolean'\n                ? logger === true\n                    ? createLogger()\n                    : createLogger('silent')\n                : typeof logger === 'string'\n                    ? createLogger(logger)\n                    : logger;\n        const maskErrorFn = (typeof options?.maskedErrors === 'object' && options.maskedErrors.maskError) || maskError;\n        const maskedErrorSet = new WeakSet();\n        this.maskedErrorsOpts =\n            options?.maskedErrors === false\n                ? null\n                : {\n                    errorMessage: 'Unexpected error.',\n                    ...(typeof options?.maskedErrors === 'object' ? options.maskedErrors : {}),\n                    maskError: (error, message) => {\n                        if (maskedErrorSet.has(error)) {\n                            return error;\n                        }\n                        const newError = maskErrorFn(error, message, this.maskedErrorsOpts?.isDev);\n                        if (newError !== error) {\n                            this.logger.error(error);\n                        }\n                        maskedErrorSet.add(newError);\n                        return newError;\n                    },\n                };\n        const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;\n        let batchingLimit = 0;\n        if (options?.batching) {\n            if (typeof options.batching === 'boolean') {\n                batchingLimit = 10;\n            }\n            else {\n                batchingLimit = options.batching.limit ?? 10;\n            }\n        }\n        this.graphqlEndpoint = options?.graphqlEndpoint || '/graphql';\n        const graphqlEndpoint = this.graphqlEndpoint;\n        this.plugins = [\n            useEngine({\n                parse,\n                validate,\n                execute: normalizedExecutor,\n                subscribe: normalizedExecutor,\n                specifiedRules,\n            }),\n            // Use the schema provided by the user\n            !!options?.schema && useSchema(options.schema),\n            options?.context != null &&\n                useExtendContext(initialContext => {\n                    if (options?.context) {\n                        if (typeof options.context === 'function') {\n                            return options.context(initialContext);\n                        }\n                        return options.context;\n                    }\n                    return {};\n                }),\n            // Middlewares before processing the incoming HTTP request\n            useHealthCheck({\n                id: this.id,\n                logger: this.logger,\n                endpoint: options?.healthCheckEndpoint,\n            }),\n            options?.cors !== false && useCORS(options?.cors),\n            options?.graphiql !== false &&\n                useGraphiQL({\n                    graphqlEndpoint,\n                    options: options?.graphiql,\n                    render: options?.renderGraphiQL,\n                    logger: this.logger,\n                }),\n            // Middlewares before the GraphQL execution\n            useRequestParser({\n                match: isGETRequest,\n                parse: parseGETRequest,\n            }),\n            useRequestParser({\n                match: isPOSTJsonRequest,\n                parse: parsePOSTJsonRequest,\n            }),\n            options?.multipart !== false &&\n                useRequestParser({\n                    match: isPOSTMultipartRequest,\n                    parse: parsePOSTMultipartRequest,\n                }),\n            useRequestParser({\n                match: isPOSTGraphQLStringRequest,\n                parse: parsePOSTGraphQLStringRequest,\n            }),\n            useRequestParser({\n                match: isPOSTFormUrlEncodedRequest,\n                parse: parsePOSTFormUrlEncodedRequest,\n            }),\n            // Middlewares after the GraphQL execution\n            useResultProcessors(),\n            ...(options?.plugins ?? []),\n            // To make sure those are called at the end\n            {\n                onPluginInit({ addPlugin }) {\n                    if (options?.parserAndValidationCache !== false) {\n                        addPlugin(\n                        // @ts-expect-error Add plugins has context but this hook doesn't care\n                        useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true\n                            ? {}\n                            : options?.parserAndValidationCache));\n                    }\n                    // @ts-expect-error Add plugins has context but this hook doesn't care\n                    addPlugin(useLimitBatching(batchingLimit));\n                    // @ts-expect-error Add plugins has context but this hook doesn't care\n                    addPlugin(useCheckGraphQLQueryParams(options?.extraParamNames));\n                    const showLandingPage = !!(options?.landingPage ?? true);\n                    addPlugin(\n                    // @ts-expect-error Add plugins has context but this hook doesn't care\n                    useUnhandledRoute({\n                        graphqlEndpoint,\n                        showLandingPage,\n                        landingPageRenderer: typeof options?.landingPage === 'function' ? options.landingPage : undefined,\n                    }));\n                    // We check the method after user-land plugins because the plugin might support more methods (like graphql-sse).\n                    // @ts-expect-error Add plugins has context but this hook doesn't care\n                    addPlugin(useCheckMethodForGraphQL());\n                    // We make sure that the user doesn't send a mutation with GET\n                    // @ts-expect-error Add plugins has context but this hook doesn't care\n                    addPlugin(usePreventMutationViaGET());\n                    if (maskedErrors) {\n                        // Make sure we always throw AbortError instead of masking it!\n                        addPlugin({\n                            onSubscribe() {\n                                return {\n                                    onSubscribeError({ error }) {\n                                        if (isAbortError(error)) {\n                                            throw error;\n                                        }\n                                    },\n                                };\n                            },\n                        });\n                        addPlugin(useMaskedErrors(maskedErrors));\n                    }\n                    addPlugin(\n                    // We handle validation errors at the end\n                    useHTTPValidationError());\n                },\n            },\n        ];\n        this.getEnveloped = envelop({\n            plugins: this.plugins,\n        });\n        this.plugins = this.getEnveloped._plugins;\n        this.onRequestParseHooks = [];\n        this.onParamsHooks = [];\n        this.onExecutionResultHooks = [];\n        this.onResultProcessHooks = [];\n        for (const plugin of this.plugins) {\n            if (plugin) {\n                if (plugin.onYogaInit) {\n                    plugin.onYogaInit({\n                        yoga: this,\n                    });\n                }\n                if (plugin.onRequestParse) {\n                    this.onRequestParseHooks.push(plugin.onRequestParse);\n                }\n                if (plugin.onParams) {\n                    this.onParamsHooks.push(plugin.onParams);\n                }\n                if (plugin.onExecutionResult) {\n                    this.onExecutionResultHooks.push(plugin.onExecutionResult);\n                }\n                if (plugin.onResultProcess) {\n                    this.onResultProcessHooks.push(plugin.onResultProcess);\n                }\n                if (plugin.instrumentation) {\n                    this.instrumentation = this.instrumentation\n                        ? chain(this.instrumentation, plugin.instrumentation)\n                        : plugin.instrumentation;\n                }\n            }\n        }\n    }\n    handleParams = ({ request, context, params }) => {\n        const additionalContext = context['request'] === request\n            ? {\n                params,\n            }\n            : {\n                request,\n                params,\n            };\n        Object.assign(context, additionalContext);\n        const enveloped = this.getEnveloped(context);\n        this.logger.debug(`Processing GraphQL Parameters`);\n        return handleMaybePromise(() => handleMaybePromise(() => processGraphQLParams({ params, enveloped }), result => {\n            this.logger.debug(`Processing GraphQL Parameters done.`);\n            return result;\n        }, error => {\n            const errors = handleError(error, this.maskedErrorsOpts, this.logger);\n            return {\n                errors,\n            };\n        }), result => {\n            if (isAsyncIterable(result)) {\n                result = mapAsyncIterator(result, v => v, (error) => {\n                    if (error.name === 'AbortError') {\n                        this.logger.debug(`Request aborted`);\n                        throw error;\n                    }\n                    const errors = handleError(error, this.maskedErrorsOpts, this.logger);\n                    return {\n                        errors,\n                    };\n                });\n            }\n            return result;\n        });\n    };\n    getResultForParams = ({ params, request, }, context) => {\n        let result;\n        let paramsHandler = this.handleParams;\n        return handleMaybePromise(() => iterateAsync(this.onParamsHooks, onParamsHook => onParamsHook({\n            params,\n            request,\n            setParams(newParams) {\n                params = newParams;\n            },\n            paramsHandler,\n            setParamsHandler(newHandler) {\n                paramsHandler = newHandler;\n            },\n            setResult(newResult) {\n                result = newResult;\n            },\n            fetchAPI: this.fetchAPI,\n            context,\n        })), () => handleMaybePromise(() => result ||\n            paramsHandler({\n                request,\n                params,\n                context: context,\n            }), result => handleMaybePromise(() => iterateAsync(this.onExecutionResultHooks, onExecutionResult => onExecutionResult({\n            result,\n            setResult(newResult) {\n                result = newResult;\n            },\n            request,\n            context: context,\n        })), () => result)));\n    };\n    parseRequest = (request, serverContext) => {\n        let url = new Proxy({}, {\n            get: (_target, prop, _receiver) => {\n                url = new this.fetchAPI.URL(request.url, 'http://localhost');\n                return Reflect.get(url, prop, url);\n            },\n        });\n        let requestParser;\n        const onRequestParseDoneList = [];\n        return handleMaybePromise(() => iterateAsync(this.onRequestParseHooks, onRequestParse => handleMaybePromise(() => onRequestParse({\n            request,\n            url,\n            requestParser,\n            serverContext,\n            setRequestParser(parser) {\n                requestParser = parser;\n            },\n        }), requestParseHookResult => requestParseHookResult?.onRequestParseDone), onRequestParseDoneList), () => {\n            this.logger.debug(`Parsing request to extract GraphQL parameters`);\n            if (!requestParser) {\n                return {\n                    response: new this.fetchAPI.Response(null, {\n                        status: 415,\n                        statusText: 'Unsupported Media Type',\n                    }),\n                };\n            }\n            return handleMaybePromise(() => requestParser(request), requestParserResult => {\n                return handleMaybePromise(() => iterateAsyncVoid(onRequestParseDoneList, onRequestParseDone => onRequestParseDone({\n                    requestParserResult,\n                    setRequestParserResult(newParams) {\n                        requestParserResult = newParams;\n                    },\n                })), () => ({\n                    requestParserResult,\n                }));\n            });\n        });\n    };\n    handle = (request, serverContext) => {\n        const instrumented = this.instrumentation && getInstrumented({ request });\n        const parseRequest = this.instrumentation?.requestParse\n            ? instrumented.asyncFn(this.instrumentation?.requestParse, this.parseRequest)\n            : this.parseRequest;\n        return unfakePromise(fakePromise()\n            .then(() => parseRequest(request, serverContext))\n            .then(({ response, requestParserResult }) => {\n            if (response) {\n                return response;\n            }\n            const getResultForParams = this.instrumentation?.operation\n                ? (payload, context) => {\n                    const instrumented = getInstrumented({ context, request: payload.request });\n                    const tracedHandler = instrumented.asyncFn(this.instrumentation?.operation, this.getResultForParams);\n                    return tracedHandler(payload, context);\n                }\n                : this.getResultForParams;\n            return handleMaybePromise(() => (Array.isArray(requestParserResult)\n                ? Promise.all(requestParserResult.map(params => getResultForParams({\n                    params,\n                    request,\n                }, Object.create(serverContext))))\n                : getResultForParams({\n                    params: requestParserResult,\n                    request,\n                }, serverContext)), result => {\n                const tracedProcessResult = this.instrumentation?.resultProcess\n                    ? instrumented.asyncFn(this.instrumentation.resultProcess, (processResult))\n                    : processResult;\n                return tracedProcessResult({\n                    request,\n                    result,\n                    fetchAPI: this.fetchAPI,\n                    onResultProcessHooks: this.onResultProcessHooks,\n                    serverContext,\n                });\n            });\n        })\n            .catch(error => {\n            const errors = handleError(error, this.maskedErrorsOpts, this.logger);\n            const result = {\n                errors,\n            };\n            return processResult({\n                request,\n                result,\n                fetchAPI: this.fetchAPI,\n                onResultProcessHooks: this.onResultProcessHooks,\n                serverContext,\n            });\n        }));\n    };\n}\nexport function createYoga(options) {\n    const server = new YogaServer(options);\n    return createServerAdapter(server, {\n        fetchAPI: server.fetchAPI,\n        plugins: server['plugins'],\n        disposeOnProcessTerminate: options.disposeOnProcessTerminate,\n    });\n}\n","// GraphQL resolvers for Hijraah API\r\n// TODO: Update imports when generated types are available\r\n\r\ntype ResolverContext = {\r\n  user?: any;\r\n  supabase?: any;\r\n};\r\n\r\nexport const resolvers = {\r\n  Query: {\r\n    hello: () => \"Hello from GraphQL API!\",\r\n  },\r\n  Mutation: {\r\n    echo: (_: any, { text }: { text: string }) => text,\r\n  },\r\n};\r\n","import { readFileSync } from \"fs\";\r\nimport { join } from \"path\";\r\n\r\n// Use the standard createClient for manual token handling\r\nimport { createServerClient as _createServerClient } from \"@supabase/ssr\";\r\nimport { createClient as createSupabaseClient } from \"@supabase/supabase-js\";\r\n// Keep ssr client for potential use outside context if needed, but alias it\r\nimport { createYoga, createSchema } from \"graphql-yoga\";\r\n\r\nimport { resolvers } from \"@/graphql/resolvers\";\r\n\r\nimport type { User } from \"@supabase/supabase-js\";\r\n\r\n// TODO: Verify that the @/types/database path is correct and the file exists.\r\n// import type { Database } from '@/types/database';\r\ntype Database = any;\r\n\r\ntype GraphQLContext = {\r\n  user: User | null;\r\n  // Include standard client in context if needed by resolvers\r\n  supabase?: ReturnType<typeof createSupabaseClient<Database>>;\r\n  request: Request;\r\n  params: Promise<{ [key: string]: string | string[] }>;\r\n};\r\n\r\nconst typeDefs = readFileSync(\r\n  join(process.cwd(), \"graphql/schema/schema.graphql\"),\r\n  \"utf-8\"\r\n);\r\n\r\nconst schema = createSchema<GraphQLContext>({\r\n  typeDefs,\r\n  resolvers,\r\n});\r\n\r\nconst { handleRequest } = createYoga<GraphQLContext>({\r\n  schema,\r\n  graphqlEndpoint: \"/api/graphql\",\r\n  fetchAPI: { Request, Response },\r\n  context: async ({ request }) => {\r\n    let user: User | null = null;\r\n    let supabaseClient:\r\n      | ReturnType<typeof createSupabaseClient<Database>>\r\n      | undefined = undefined;\r\n\r\n    try {\r\n      // Create a standard Supabase client\r\n      supabaseClient = createSupabaseClient<Database>(\r\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\r\n      );\r\n\r\n      // Attempt to get user using JWT from Authorization header\r\n      const authHeader = request.headers.get(\"Authorization\");\r\n      let jwt: string | undefined = undefined;\r\n      if (authHeader?.startsWith(\"Bearer \")) {\r\n        jwt = authHeader.split(\" \")[1];\r\n      }\r\n\r\n      if (jwt) {\r\n        const { data: userData, error: userError } =\r\n          await supabaseClient.auth.getUser(jwt);\r\n        if (userError) {\r\n          console.error(\"Auth user error (JWT) in GraphQL context:\", userError);\r\n        } else {\r\n          user = userData.user;\r\n        }\r\n      } else {\r\n        // Optional: Could try getUser() without JWT to rely on cookies,\r\n        // but this is less reliable in API routes without proper cookie handling.\r\n        // const { data: cookieUserData, error: cookieUserError } = await supabaseClient.auth.getUser();\r\n        // if (!cookieUserError) user = cookieUserData.user;\r\n        console.log(\r\n          \"No JWT found in Authorization header for GraphQL request.\"\r\n        );\r\n      }\r\n\r\n      return {\r\n        user,\r\n        supabase: supabaseClient, // Pass client to resolvers if needed\r\n        request,\r\n        params: Promise.resolve({}),\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Context creation error:\", error);\r\n      return {\r\n        user: null,\r\n        supabase: supabaseClient, // Still pass client if initialized\r\n        request,\r\n        params: Promise.resolve({}),\r\n      };\r\n    }\r\n  },\r\n  maskedErrors: {\r\n    maskError: (error: any, message: string) => {\r\n      console.error(\"GraphQL Error:\", {\r\n        message: error.message,\r\n        path: error.path,\r\n        stack: error.stack,\r\n      });\r\n      return new Error(message);\r\n    },\r\n  },\r\n});\r\n\r\nexport { handleRequest as GET, handleRequest as POST };\r\n\r\nexport type RouteHandlerResponse = Response;\r\n","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/graphql',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\graphql\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/graphql/route\",\n        pathname: \"/api/graphql\",\n        filename: \"route\",\n        bundlePath: \"app/api/graphql/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\graphql\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","module.exports = require(\"node:fs\");","module.exports = require(\"node:url\");","module.exports = require(\"worker_threads\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchPonyfill = fetchPonyfill;\nconst node_buffer_1 = require(\"node:buffer\");\nconst node_fs_1 = require(\"node:fs\");\nconst node_url_1 = require(\"node:url\");\nconst fetchCurl_js_1 = require(\"./fetchCurl.js\");\nconst fetchNodeHttp_js_1 = require(\"./fetchNodeHttp.js\");\nconst Request_js_1 = require(\"./Request.js\");\nconst Response_js_1 = require(\"./Response.js\");\nconst URL_js_1 = require(\"./URL.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst BASE64_SUFFIX = ';base64';\nasync function getResponseForFile(url) {\n    const path = (0, node_url_1.fileURLToPath)(url);\n    try {\n        await node_fs_1.promises.access(path, node_fs_1.promises.constants.R_OK);\n        const stats = await node_fs_1.promises.stat(path, {\n            bigint: true,\n        });\n        const readable = (0, node_fs_1.createReadStream)(path);\n        return new Response_js_1.PonyfillResponse(readable, {\n            status: 200,\n            statusText: 'OK',\n            headers: {\n                'content-type': 'application/octet-stream',\n                'last-modified': stats.mtime.toUTCString(),\n            },\n        });\n    }\n    catch (err) {\n        if (err.code === 'ENOENT') {\n            return new Response_js_1.PonyfillResponse(null, {\n                status: 404,\n                statusText: 'Not Found',\n            });\n        }\n        else if (err.code === 'EACCES') {\n            return new Response_js_1.PonyfillResponse(null, {\n                status: 403,\n                statusText: 'Forbidden',\n            });\n        }\n        throw err;\n    }\n}\nfunction getResponseForDataUri(url) {\n    const [mimeType = 'text/plain', ...datas] = url.substring(5).split(',');\n    const data = decodeURIComponent(datas.join(','));\n    if (mimeType.endsWith(BASE64_SUFFIX)) {\n        const buffer = node_buffer_1.Buffer.from(data, 'base64url');\n        const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);\n        return new Response_js_1.PonyfillResponse(buffer, {\n            status: 200,\n            statusText: 'OK',\n            headers: {\n                'content-type': realMimeType,\n            },\n        });\n    }\n    return new Response_js_1.PonyfillResponse(data, {\n        status: 200,\n        statusText: 'OK',\n        headers: {\n            'content-type': mimeType,\n        },\n    });\n}\nfunction getResponseForBlob(url) {\n    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);\n    if (!blob) {\n        throw new TypeError('Invalid Blob URL');\n    }\n    return new Response_js_1.PonyfillResponse(blob, {\n        status: 200,\n        headers: {\n            'content-type': blob.type,\n            'content-length': blob.size.toString(),\n        },\n    });\n}\nfunction isURL(obj) {\n    return obj != null && obj.href != null;\n}\nfunction fetchPonyfill(info, init) {\n    if (typeof info === 'string' || isURL(info)) {\n        const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);\n        return fetchPonyfill(ponyfillRequest);\n    }\n    const fetchRequest = info;\n    if (fetchRequest.url.startsWith('data:')) {\n        const response = getResponseForDataUri(fetchRequest.url);\n        return (0, utils_js_1.fakePromise)(response);\n    }\n    if (fetchRequest.url.startsWith('file:')) {\n        const response = getResponseForFile(fetchRequest.url);\n        return response;\n    }\n    if (fetchRequest.url.startsWith('blob:')) {\n        const response = getResponseForBlob(fetchRequest.url);\n        return (0, utils_js_1.fakePromise)(response);\n    }\n    if (globalThis.libcurl && !fetchRequest.agent) {\n        return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);\n    }\n    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);\n}\n","module.exports = require(\"zlib\");","'use strict'\n\nconst WritableStream = require('node:stream').Writable\nconst inherits = require('node:util').inherits\n\nconst StreamSearch = require('../../streamsearch/sbmh')\n\nconst PartStream = require('./PartStream')\nconst HeaderParser = require('./HeaderParser')\n\nconst DASH = 45\nconst B_ONEDASH = Buffer.from('-')\nconst B_CRLF = Buffer.from('\\r\\n')\nconst EMPTY_FN = function () {}\n\nfunction Dicer (cfg) {\n  if (!(this instanceof Dicer)) { return new Dicer(cfg) }\n  WritableStream.call(this, cfg)\n\n  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) { throw new TypeError('Boundary required') }\n\n  if (typeof cfg.boundary === 'string') { this.setBoundary(cfg.boundary) } else { this._bparser = undefined }\n\n  this._headerFirst = cfg.headerFirst\n\n  this._dashes = 0\n  this._parts = 0\n  this._finished = false\n  this._realFinish = false\n  this._isPreamble = true\n  this._justMatched = false\n  this._firstWrite = true\n  this._inHeader = true\n  this._part = undefined\n  this._cb = undefined\n  this._ignoreData = false\n  this._partOpts = { highWaterMark: cfg.partHwm }\n  this._pause = false\n\n  const self = this\n  this._hparser = new HeaderParser(cfg)\n  this._hparser.on('header', function (header) {\n    self._inHeader = false\n    self._part.emit('header', header)\n  })\n}\ninherits(Dicer, WritableStream)\n\nDicer.prototype.emit = function (ev) {\n  if (ev === 'finish' && !this._realFinish) {\n    if (!this._finished) {\n      const self = this\n      process.nextTick(function () {\n        self.emit('error', new Error('Unexpected end of multipart data'))\n        if (self._part && !self._ignoreData) {\n          const type = (self._isPreamble ? 'Preamble' : 'Part')\n          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'))\n          self._part.push(null)\n          process.nextTick(function () {\n            self._realFinish = true\n            self.emit('finish')\n            self._realFinish = false\n          })\n          return\n        }\n        self._realFinish = true\n        self.emit('finish')\n        self._realFinish = false\n      })\n    }\n  } else { WritableStream.prototype.emit.apply(this, arguments) }\n}\n\nDicer.prototype._write = function (data, encoding, cb) {\n  // ignore unexpected data (e.g. extra trailer data after finished)\n  if (!this._hparser && !this._bparser) { return cb() }\n\n  if (this._headerFirst && this._isPreamble) {\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts)\n      if (this.listenerCount('preamble') !== 0) { this.emit('preamble', this._part) } else { this._ignore() }\n    }\n    const r = this._hparser.push(data)\n    if (!this._inHeader && r !== undefined && r < data.length) { data = data.slice(r) } else { return cb() }\n  }\n\n  // allows for \"easier\" testing\n  if (this._firstWrite) {\n    this._bparser.push(B_CRLF)\n    this._firstWrite = false\n  }\n\n  this._bparser.push(data)\n\n  if (this._pause) { this._cb = cb } else { cb() }\n}\n\nDicer.prototype.reset = function () {\n  this._part = undefined\n  this._bparser = undefined\n  this._hparser = undefined\n}\n\nDicer.prototype.setBoundary = function (boundary) {\n  const self = this\n  this._bparser = new StreamSearch('\\r\\n--' + boundary)\n  this._bparser.on('info', function (isMatch, data, start, end) {\n    self._oninfo(isMatch, data, start, end)\n  })\n}\n\nDicer.prototype._ignore = function () {\n  if (this._part && !this._ignoreData) {\n    this._ignoreData = true\n    this._part.on('error', EMPTY_FN)\n    // we must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n    this._part.resume()\n  }\n}\n\nDicer.prototype._oninfo = function (isMatch, data, start, end) {\n  let buf; const self = this; let i = 0; let r; let shouldWriteMore = true\n\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && (start + i) < end) {\n      if (data[start + i] === DASH) {\n        ++i\n        ++this._dashes\n      } else {\n        if (this._dashes) { buf = B_ONEDASH }\n        this._dashes = 0\n        break\n      }\n    }\n    if (this._dashes === 2) {\n      if ((start + i) < end && this.listenerCount('trailer') !== 0) { this.emit('trailer', data.slice(start + i, end)) }\n      this.reset()\n      this._finished = true\n      // no more parts will be added\n      if (self._parts === 0) {\n        self._realFinish = true\n        self.emit('finish')\n        self._realFinish = false\n      }\n    }\n    if (this._dashes) { return }\n  }\n  if (this._justMatched) { this._justMatched = false }\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts)\n    this._part._read = function (n) {\n      self._unpause()\n    }\n    if (this._isPreamble && this.listenerCount('preamble') !== 0) {\n      this.emit('preamble', this._part)\n    } else if (this._isPreamble !== true && this.listenerCount('part') !== 0) {\n      this.emit('part', this._part)\n    } else {\n      this._ignore()\n    }\n    if (!this._isPreamble) { this._inHeader = true }\n  }\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf) { shouldWriteMore = this._part.push(buf) }\n      shouldWriteMore = this._part.push(data.slice(start, end))\n      if (!shouldWriteMore) { this._pause = true }\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf) { this._hparser.push(buf) }\n      r = this._hparser.push(data.slice(start, end))\n      if (!this._inHeader && r !== undefined && r < end) { this._oninfo(false, data, start + r, end) }\n    }\n  }\n  if (isMatch) {\n    this._hparser.reset()\n    if (this._isPreamble) { this._isPreamble = false } else {\n      if (start !== end) {\n        ++this._parts\n        this._part.on('end', function () {\n          if (--self._parts === 0) {\n            if (self._finished) {\n              self._realFinish = true\n              self.emit('finish')\n              self._realFinish = false\n            } else {\n              self._unpause()\n            }\n          }\n        })\n      }\n    }\n    this._part.push(null)\n    this._part = undefined\n    this._ignoreData = false\n    this._justMatched = true\n    this._dashes = 0\n  }\n}\n\nDicer.prototype._unpause = function () {\n  if (!this._pause) { return }\n\n  this._pause = false\n  if (this._cb) {\n    const cb = this._cb\n    this._cb = undefined\n    cb()\n  }\n}\n\nmodule.exports = Dicer\n","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","\"use strict\";var U=Object.defineProperty;var Re=Object.getOwnPropertyDescriptor;var Ee=Object.getOwnPropertyNames;var Oe=Object.prototype.hasOwnProperty;var a=(e,t)=>U(e,\"name\",{value:t,configurable:!0});var ke=(e,t)=>{for(var r in t)U(e,r,{get:t[r],enumerable:!0})},Te=(e,t,r,n)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of Ee(t))!Oe.call(e,o)&&o!==r&&U(e,o,{get:()=>t[o],enumerable:!(n=Re(t,o))||n.enumerable});return e};var Ae=e=>Te(U({},\"__esModule\",{value:!0}),e);var He={};ke(He,{URLPattern:()=>M});module.exports=Ae(He);var P=class{type=3;name=\"\";prefix=\"\";value=\"\";suffix=\"\";modifier=3;constructor(t,r,n,o,l,f){this.type=t,this.name=r,this.prefix=n,this.value=o,this.suffix=l,this.modifier=f}hasCustomName(){return this.name!==\"\"&&typeof this.name!=\"number\"}};a(P,\"Part\");var ye=/[$_\\p{ID_Start}]/u,we=/[$_\\u200C\\u200D\\p{ID_Continue}]/u,F=\".*\";function Ce(e,t){return(t?/^[\\x00-\\xFF]*$/:/^[\\x00-\\x7F]*$/).test(e)}a(Ce,\"isASCII\");function W(e,t=!1){let r=[],n=0;for(;n<e.length;){let o=e[n],l=a(function(f){if(!t)throw new TypeError(f);r.push({type:\"INVALID_CHAR\",index:n,value:e[n++]})},\"ErrorOrInvalid\");if(o===\"*\"){r.push({type:\"ASTERISK\",index:n,value:e[n++]});continue}if(o===\"+\"||o===\"?\"){r.push({type:\"OTHER_MODIFIER\",index:n,value:e[n++]});continue}if(o===\"\\\\\"){r.push({type:\"ESCAPED_CHAR\",index:n++,value:e[n++]});continue}if(o===\"{\"){r.push({type:\"OPEN\",index:n,value:e[n++]});continue}if(o===\"}\"){r.push({type:\"CLOSE\",index:n,value:e[n++]});continue}if(o===\":\"){let f=\"\",s=n+1;for(;s<e.length;){let i=e.substr(s,1);if(s===n+1&&ye.test(i)||s!==n+1&&we.test(i)){f+=e[s++];continue}break}if(!f){l(`Missing parameter name at ${n}`);continue}r.push({type:\"NAME\",index:n,value:f}),n=s;continue}if(o===\"(\"){let f=1,s=\"\",i=n+1,c=!1;if(e[i]===\"?\"){l(`Pattern cannot start with \"?\" at ${i}`);continue}for(;i<e.length;){if(!Ce(e[i],!1)){l(`Invalid character '${e[i]}' at ${i}.`),c=!0;break}if(e[i]===\"\\\\\"){s+=e[i++]+e[i++];continue}if(e[i]===\")\"){if(f--,f===0){i++;break}}else if(e[i]===\"(\"&&(f++,e[i+1]!==\"?\")){l(`Capturing groups are not allowed at ${i}`),c=!0;break}s+=e[i++]}if(c)continue;if(f){l(`Unbalanced pattern at ${n}`);continue}if(!s){l(`Missing pattern at ${n}`);continue}r.push({type:\"REGEX\",index:n,value:s}),n=i;continue}r.push({type:\"CHAR\",index:n,value:e[n++]})}return r.push({type:\"END\",index:n,value:\"\"}),r}a(W,\"lexer\");function _(e,t={}){let r=W(e);t.delimiter??=\"/#?\",t.prefixes??=\"./\";let n=`[^${x(t.delimiter)}]+?`,o=[],l=0,f=0,s=\"\",i=new Set,c=a(u=>{if(f<r.length&&r[f].type===u)return r[f++].value},\"tryConsume\"),h=a(()=>c(\"OTHER_MODIFIER\")??c(\"ASTERISK\"),\"tryConsumeModifier\"),p=a(u=>{let d=c(u);if(d!==void 0)return d;let{type:g,index:y}=r[f];throw new TypeError(`Unexpected ${g} at ${y}, expected ${u}`)},\"mustConsume\"),A=a(()=>{let u=\"\",d;for(;d=c(\"CHAR\")??c(\"ESCAPED_CHAR\");)u+=d;return u},\"consumeText\"),be=a(u=>u,\"DefaultEncodePart\"),N=t.encodePart||be,H=\"\",v=a(u=>{H+=u},\"appendToPendingFixedValue\"),D=a(()=>{H.length&&(o.push(new P(3,\"\",\"\",N(H),\"\",3)),H=\"\")},\"maybeAddPartFromPendingFixedValue\"),Z=a((u,d,g,y,B)=>{let m=3;switch(B){case\"?\":m=1;break;case\"*\":m=0;break;case\"+\":m=2;break}if(!d&&!g&&m===3){v(u);return}if(D(),!d&&!g){if(!u)return;o.push(new P(3,\"\",\"\",N(u),\"\",m));return}let S;g?g===\"*\"?S=F:S=g:S=n;let k=2;S===n?(k=1,S=\"\"):S===F&&(k=0,S=\"\");let E;if(d?E=d:g&&(E=l++),i.has(E))throw new TypeError(`Duplicate name '${E}'.`);i.add(E),o.push(new P(k,E,N(u),S,N(y),m))},\"addPart\");for(;f<r.length;){let u=c(\"CHAR\"),d=c(\"NAME\"),g=c(\"REGEX\");if(!d&&!g&&(g=c(\"ASTERISK\")),d||g){let m=u??\"\";t.prefixes.indexOf(m)===-1&&(v(m),m=\"\"),D();let S=h();Z(m,d,g,\"\",S);continue}let y=u??c(\"ESCAPED_CHAR\");if(y){v(y);continue}if(c(\"OPEN\")){let m=A(),S=c(\"NAME\"),k=c(\"REGEX\");!S&&!k&&(k=c(\"ASTERISK\"));let E=A();p(\"CLOSE\");let Pe=h();Z(m,S,k,E,Pe);continue}D(),p(\"END\")}return o}a(_,\"parse\");function x(e){return e.replace(/([.+*?^${}()[\\]|/\\\\])/g,\"\\\\$1\")}a(x,\"escapeString\");function q(e){return e&&e.ignoreCase?\"ui\":\"u\"}a(q,\"flags\");function J(e,t,r){return z(_(e,r),t,r)}a(J,\"stringToRegexp\");function T(e){switch(e){case 0:return\"*\";case 1:return\"?\";case 2:return\"+\";case 3:return\"\"}}a(T,\"modifierToString\");function z(e,t,r={}){r.delimiter??=\"/#?\",r.prefixes??=\"./\",r.sensitive??=!1,r.strict??=!1,r.end??=!0,r.start??=!0,r.endsWith=\"\";let n=r.start?\"^\":\"\";for(let s of e){if(s.type===3){s.modifier===3?n+=x(s.value):n+=`(?:${x(s.value)})${T(s.modifier)}`;continue}t&&t.push(s.name);let i=`[^${x(r.delimiter)}]+?`,c=s.value;if(s.type===1?c=i:s.type===0&&(c=F),!s.prefix.length&&!s.suffix.length){s.modifier===3||s.modifier===1?n+=`(${c})${T(s.modifier)}`:n+=`((?:${c})${T(s.modifier)})`;continue}if(s.modifier===3||s.modifier===1){n+=`(?:${x(s.prefix)}(${c})${x(s.suffix)})`,n+=T(s.modifier);continue}n+=`(?:${x(s.prefix)}`,n+=`((?:${c})(?:`,n+=x(s.suffix),n+=x(s.prefix),n+=`(?:${c}))*)${x(s.suffix)})`,s.modifier===0&&(n+=\"?\")}let o=`[${x(r.endsWith)}]|$`,l=`[${x(r.delimiter)}]`;if(r.end)return r.strict||(n+=`${l}?`),r.endsWith.length?n+=`(?=${o})`:n+=\"$\",new RegExp(n,q(r));r.strict||(n+=`(?:${l}(?=${o}))?`);let f=!1;if(e.length){let s=e[e.length-1];s.type===3&&s.modifier===3&&(f=r.delimiter.indexOf(s)>-1)}return f||(n+=`(?=${l}|${o})`),new RegExp(n,q(r))}a(z,\"partsToRegexp\");var b={delimiter:\"\",prefixes:\"\",sensitive:!0,strict:!0},Q={delimiter:\".\",prefixes:\"\",sensitive:!0,strict:!0},ee={delimiter:\"/\",prefixes:\"/\",sensitive:!0,strict:!0};function te(e,t){return e.length?e[0]===\"/\"?!0:!t||e.length<2?!1:(e[0]==\"\\\\\"||e[0]==\"{\")&&e[1]==\"/\":!1}a(te,\"isAbsolutePathname\");function re(e,t){return e.startsWith(t)?e.substring(t.length,e.length):e}a(re,\"maybeStripPrefix\");function Le(e,t){return e.endsWith(t)?e.substr(0,e.length-t.length):e}a(Le,\"maybeStripSuffix\");function j(e){return!e||e.length<2?!1:e[0]===\"[\"||(e[0]===\"\\\\\"||e[0]===\"{\")&&e[1]===\"[\"}a(j,\"treatAsIPv6Hostname\");var ne=[\"ftp\",\"file\",\"http\",\"https\",\"ws\",\"wss\"];function $(e){if(!e)return!0;for(let t of ne)if(e.test(t))return!0;return!1}a($,\"isSpecialScheme\");function se(e,t){if(e=re(e,\"#\"),t||e===\"\")return e;let r=new URL(\"https://example.com\");return r.hash=e,r.hash?r.hash.substring(1,r.hash.length):\"\"}a(se,\"canonicalizeHash\");function ie(e,t){if(e=re(e,\"?\"),t||e===\"\")return e;let r=new URL(\"https://example.com\");return r.search=e,r.search?r.search.substring(1,r.search.length):\"\"}a(ie,\"canonicalizeSearch\");function ae(e,t){return t||e===\"\"?e:j(e)?V(e):G(e)}a(ae,\"canonicalizeHostname\");function oe(e,t){if(t||e===\"\")return e;let r=new URL(\"https://example.com\");return r.password=e,r.password}a(oe,\"canonicalizePassword\");function ce(e,t){if(t||e===\"\")return e;let r=new URL(\"https://example.com\");return r.username=e,r.username}a(ce,\"canonicalizeUsername\");function le(e,t,r){if(r||e===\"\")return e;if(t&&!ne.includes(t))return new URL(`${t}:${e}`).pathname;let n=e[0]==\"/\";return e=new URL(n?e:\"/-\"+e,\"https://example.com\").pathname,n||(e=e.substring(2,e.length)),e}a(le,\"canonicalizePathname\");function fe(e,t,r){return K(t)===e&&(e=\"\"),r||e===\"\"?e:Y(e)}a(fe,\"canonicalizePort\");function he(e,t){return e=Le(e,\":\"),t||e===\"\"?e:w(e)}a(he,\"canonicalizeProtocol\");function K(e){switch(e){case\"ws\":case\"http\":return\"80\";case\"wws\":case\"https\":return\"443\";case\"ftp\":return\"21\";default:return\"\"}}a(K,\"defaultPortForProtocol\");function w(e){if(e===\"\")return e;if(/^[-+.A-Za-z0-9]*$/.test(e))return e.toLowerCase();throw new TypeError(`Invalid protocol '${e}'.`)}a(w,\"protocolEncodeCallback\");function ue(e){if(e===\"\")return e;let t=new URL(\"https://example.com\");return t.username=e,t.username}a(ue,\"usernameEncodeCallback\");function de(e){if(e===\"\")return e;let t=new URL(\"https://example.com\");return t.password=e,t.password}a(de,\"passwordEncodeCallback\");function G(e){if(e===\"\")return e;if(/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(e))throw new TypeError(`Invalid hostname '${e}'`);let t=new URL(\"https://example.com\");return t.hostname=e,t.hostname}a(G,\"hostnameEncodeCallback\");function V(e){if(e===\"\")return e;if(/[^0-9a-fA-F[\\]:]/g.test(e))throw new TypeError(`Invalid IPv6 hostname '${e}'`);return e.toLowerCase()}a(V,\"ipv6HostnameEncodeCallback\");function Y(e){if(e===\"\"||/^[0-9]*$/.test(e)&&parseInt(e)<=65535)return e;throw new TypeError(`Invalid port '${e}'.`)}a(Y,\"portEncodeCallback\");function pe(e){if(e===\"\")return e;let t=new URL(\"https://example.com\");return t.pathname=e[0]!==\"/\"?\"/-\"+e:e,e[0]!==\"/\"?t.pathname.substring(2,t.pathname.length):t.pathname}a(pe,\"standardURLPathnameEncodeCallback\");function ge(e){return e===\"\"?e:new URL(`data:${e}`).pathname}a(ge,\"pathURLPathnameEncodeCallback\");function me(e){if(e===\"\")return e;let t=new URL(\"https://example.com\");return t.search=e,t.search.substring(1,t.search.length)}a(me,\"searchEncodeCallback\");function Se(e){if(e===\"\")return e;let t=new URL(\"https://example.com\");return t.hash=e,t.hash.substring(1,t.hash.length)}a(Se,\"hashEncodeCallback\");var C=class{#i;#n=[];#t={};#e=0;#s=1;#l=0;#o=0;#d=0;#p=0;#g=!1;constructor(t){this.#i=t}get result(){return this.#t}parse(){for(this.#n=W(this.#i,!0);this.#e<this.#n.length;this.#e+=this.#s){if(this.#s=1,this.#n[this.#e].type===\"END\"){if(this.#o===0){this.#b(),this.#f()?this.#r(9,1):this.#h()?this.#r(8,1):this.#r(7,0);continue}else if(this.#o===2){this.#u(5);continue}this.#r(10,0);break}if(this.#d>0)if(this.#A())this.#d-=1;else continue;if(this.#T()){this.#d+=1;continue}switch(this.#o){case 0:this.#P()&&this.#u(1);break;case 1:if(this.#P()){this.#C();let t=7,r=1;this.#E()?(t=2,r=3):this.#g&&(t=2),this.#r(t,r)}break;case 2:this.#S()?this.#u(3):(this.#x()||this.#h()||this.#f())&&this.#u(5);break;case 3:this.#O()?this.#r(4,1):this.#S()&&this.#r(5,1);break;case 4:this.#S()&&this.#r(5,1);break;case 5:this.#y()?this.#p+=1:this.#w()&&(this.#p-=1),this.#k()&&!this.#p?this.#r(6,1):this.#x()?this.#r(7,0):this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 6:this.#x()?this.#r(7,0):this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 7:this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 8:this.#f()&&this.#r(9,1);break;case 9:break;case 10:break}}this.#t.hostname!==void 0&&this.#t.port===void 0&&(this.#t.port=\"\")}#r(t,r){switch(this.#o){case 0:break;case 1:this.#t.protocol=this.#c();break;case 2:break;case 3:this.#t.username=this.#c();break;case 4:this.#t.password=this.#c();break;case 5:this.#t.hostname=this.#c();break;case 6:this.#t.port=this.#c();break;case 7:this.#t.pathname=this.#c();break;case 8:this.#t.search=this.#c();break;case 9:this.#t.hash=this.#c();break;case 10:break}this.#o!==0&&t!==10&&([1,2,3,4].includes(this.#o)&&[6,7,8,9].includes(t)&&(this.#t.hostname??=\"\"),[1,2,3,4,5,6].includes(this.#o)&&[8,9].includes(t)&&(this.#t.pathname??=this.#g?\"/\":\"\"),[1,2,3,4,5,6,7].includes(this.#o)&&t===9&&(this.#t.search??=\"\")),this.#R(t,r)}#R(t,r){this.#o=t,this.#l=this.#e+r,this.#e+=r,this.#s=0}#b(){this.#e=this.#l,this.#s=0}#u(t){this.#b(),this.#o=t}#m(t){return t<0&&(t=this.#n.length-t),t<this.#n.length?this.#n[t]:this.#n[this.#n.length-1]}#a(t,r){let n=this.#m(t);return n.value===r&&(n.type===\"CHAR\"||n.type===\"ESCAPED_CHAR\"||n.type===\"INVALID_CHAR\")}#P(){return this.#a(this.#e,\":\")}#E(){return this.#a(this.#e+1,\"/\")&&this.#a(this.#e+2,\"/\")}#S(){return this.#a(this.#e,\"@\")}#O(){return this.#a(this.#e,\":\")}#k(){return this.#a(this.#e,\":\")}#x(){return this.#a(this.#e,\"/\")}#h(){if(this.#a(this.#e,\"?\"))return!0;if(this.#n[this.#e].value!==\"?\")return!1;let t=this.#m(this.#e-1);return t.type!==\"NAME\"&&t.type!==\"REGEX\"&&t.type!==\"CLOSE\"&&t.type!==\"ASTERISK\"}#f(){return this.#a(this.#e,\"#\")}#T(){return this.#n[this.#e].type==\"OPEN\"}#A(){return this.#n[this.#e].type==\"CLOSE\"}#y(){return this.#a(this.#e,\"[\")}#w(){return this.#a(this.#e,\"]\")}#c(){let t=this.#n[this.#e],r=this.#m(this.#l).index;return this.#i.substring(r,t.index)}#C(){let t={};Object.assign(t,b),t.encodePart=w;let r=J(this.#c(),void 0,t);this.#g=$(r)}};a(C,\"Parser\");var X=[\"protocol\",\"username\",\"password\",\"hostname\",\"port\",\"pathname\",\"search\",\"hash\"],O=\"*\";function xe(e,t){if(typeof e!=\"string\")throw new TypeError(\"parameter 1 is not of type 'string'.\");let r=new URL(e,t);return{protocol:r.protocol.substring(0,r.protocol.length-1),username:r.username,password:r.password,hostname:r.hostname,port:r.port,pathname:r.pathname,search:r.search!==\"\"?r.search.substring(1,r.search.length):void 0,hash:r.hash!==\"\"?r.hash.substring(1,r.hash.length):void 0}}a(xe,\"extractValues\");function R(e,t){return t?I(e):e}a(R,\"processBaseURLString\");function L(e,t,r){let n;if(typeof t.baseURL==\"string\")try{n=new URL(t.baseURL),t.protocol===void 0&&(e.protocol=R(n.protocol.substring(0,n.protocol.length-1),r)),!r&&t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.username===void 0&&(e.username=R(n.username,r)),!r&&t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.username===void 0&&t.password===void 0&&(e.password=R(n.password,r)),t.protocol===void 0&&t.hostname===void 0&&(e.hostname=R(n.hostname,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&(e.port=R(n.port,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&(e.pathname=R(n.pathname,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&t.search===void 0&&(e.search=R(n.search.substring(1,n.search.length),r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&t.search===void 0&&t.hash===void 0&&(e.hash=R(n.hash.substring(1,n.hash.length),r))}catch{throw new TypeError(`invalid baseURL '${t.baseURL}'.`)}if(typeof t.protocol==\"string\"&&(e.protocol=he(t.protocol,r)),typeof t.username==\"string\"&&(e.username=ce(t.username,r)),typeof t.password==\"string\"&&(e.password=oe(t.password,r)),typeof t.hostname==\"string\"&&(e.hostname=ae(t.hostname,r)),typeof t.port==\"string\"&&(e.port=fe(t.port,e.protocol,r)),typeof t.pathname==\"string\"){if(e.pathname=t.pathname,n&&!te(e.pathname,r)){let o=n.pathname.lastIndexOf(\"/\");o>=0&&(e.pathname=R(n.pathname.substring(0,o+1),r)+e.pathname)}e.pathname=le(e.pathname,e.protocol,r)}return typeof t.search==\"string\"&&(e.search=ie(t.search,r)),typeof t.hash==\"string\"&&(e.hash=se(t.hash,r)),e}a(L,\"applyInit\");function I(e){return e.replace(/([+*?:{}()\\\\])/g,\"\\\\$1\")}a(I,\"escapePatternString\");function Ie(e){return e.replace(/([.+*?^${}()[\\]|/\\\\])/g,\"\\\\$1\")}a(Ie,\"escapeRegexpString\");function Ne(e,t){t.delimiter??=\"/#?\",t.prefixes??=\"./\",t.sensitive??=!1,t.strict??=!1,t.end??=!0,t.start??=!0,t.endsWith=\"\";let r=\".*\",n=`[^${Ie(t.delimiter)}]+?`,o=/[$_\\u200C\\u200D\\p{ID_Continue}]/u,l=\"\";for(let f=0;f<e.length;++f){let s=e[f];if(s.type===3){if(s.modifier===3){l+=I(s.value);continue}l+=`{${I(s.value)}}${T(s.modifier)}`;continue}let i=s.hasCustomName(),c=!!s.suffix.length||!!s.prefix.length&&(s.prefix.length!==1||!t.prefixes.includes(s.prefix)),h=f>0?e[f-1]:null,p=f<e.length-1?e[f+1]:null;if(!c&&i&&s.type===1&&s.modifier===3&&p&&!p.prefix.length&&!p.suffix.length)if(p.type===3){let A=p.value.length>0?p.value[0]:\"\";c=o.test(A)}else c=!p.hasCustomName();if(!c&&!s.prefix.length&&h&&h.type===3){let A=h.value[h.value.length-1];c=t.prefixes.includes(A)}c&&(l+=\"{\"),l+=I(s.prefix),i&&(l+=`:${s.name}`),s.type===2?l+=`(${s.value})`:s.type===1?i||(l+=`(${n})`):s.type===0&&(!i&&(!h||h.type===3||h.modifier!==3||c||s.prefix!==\"\")?l+=\"*\":l+=`(${r})`),s.type===1&&i&&s.suffix.length&&o.test(s.suffix[0])&&(l+=\"\\\\\"),l+=I(s.suffix),c&&(l+=\"}\"),s.modifier!==3&&(l+=T(s.modifier))}return l}a(Ne,\"partsToPattern\");var M=class{#i;#n={};#t={};#e={};#s={};#l=!1;constructor(t={},r,n){try{let o;if(typeof r==\"string\"?o=r:n=r,typeof t==\"string\"){let i=new C(t);if(i.parse(),t=i.result,o===void 0&&typeof t.protocol!=\"string\")throw new TypeError(\"A base URL must be provided for a relative constructor string.\");t.baseURL=o}else{if(!t||typeof t!=\"object\")throw new TypeError(\"parameter 1 is not of type 'string' and cannot convert to dictionary.\");if(o)throw new TypeError(\"parameter 1 is not of type 'string'.\")}typeof n>\"u\"&&(n={ignoreCase:!1});let l={ignoreCase:n.ignoreCase===!0},f={pathname:O,protocol:O,username:O,password:O,hostname:O,port:O,search:O,hash:O};this.#i=L(f,t,!0),K(this.#i.protocol)===this.#i.port&&(this.#i.port=\"\");let s;for(s of X){if(!(s in this.#i))continue;let i={},c=this.#i[s];switch(this.#t[s]=[],s){case\"protocol\":Object.assign(i,b),i.encodePart=w;break;case\"username\":Object.assign(i,b),i.encodePart=ue;break;case\"password\":Object.assign(i,b),i.encodePart=de;break;case\"hostname\":Object.assign(i,Q),j(c)?i.encodePart=V:i.encodePart=G;break;case\"port\":Object.assign(i,b),i.encodePart=Y;break;case\"pathname\":$(this.#n.protocol)?(Object.assign(i,ee,l),i.encodePart=pe):(Object.assign(i,b,l),i.encodePart=ge);break;case\"search\":Object.assign(i,b,l),i.encodePart=me;break;case\"hash\":Object.assign(i,b,l),i.encodePart=Se;break}try{this.#s[s]=_(c,i),this.#n[s]=z(this.#s[s],this.#t[s],i),this.#e[s]=Ne(this.#s[s],i),this.#l=this.#l||this.#s[s].some(h=>h.type===2)}catch{throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`)}}}catch(o){throw new TypeError(`Failed to construct 'URLPattern': ${o.message}`)}}get[Symbol.toStringTag](){return\"URLPattern\"}test(t={},r){let n={pathname:\"\",protocol:\"\",username:\"\",password:\"\",hostname:\"\",port:\"\",search:\"\",hash:\"\"};if(typeof t!=\"string\"&&r)throw new TypeError(\"parameter 1 is not of type 'string'.\");if(typeof t>\"u\")return!1;try{typeof t==\"object\"?n=L(n,t,!1):n=L(n,xe(t,r),!1)}catch{return!1}let o;for(o of X)if(!this.#n[o].exec(n[o]))return!1;return!0}exec(t={},r){let n={pathname:\"\",protocol:\"\",username:\"\",password:\"\",hostname:\"\",port:\"\",search:\"\",hash:\"\"};if(typeof t!=\"string\"&&r)throw new TypeError(\"parameter 1 is not of type 'string'.\");if(typeof t>\"u\")return;try{typeof t==\"object\"?n=L(n,t,!1):n=L(n,xe(t,r),!1)}catch{return null}let o={};r?o.inputs=[t,r]:o.inputs=[t];let l;for(l of X){let f=this.#n[l].exec(n[l]);if(!f)return null;let s={};for(let[i,c]of this.#t[l].entries())if(typeof c==\"string\"||typeof c==\"number\"){let h=f[i+1];s[c]=h}o[l]={input:n[l]??\"\",groups:s}}return o}static compareComponent(t,r,n){let o=a((i,c)=>{for(let h of[\"type\",\"modifier\",\"prefix\",\"value\",\"suffix\"]){if(i[h]<c[h])return-1;if(i[h]===c[h])continue;return 1}return 0},\"comparePart\"),l=new P(3,\"\",\"\",\"\",\"\",3),f=new P(0,\"\",\"\",\"\",\"\",3),s=a((i,c)=>{let h=0;for(;h<Math.min(i.length,c.length);++h){let p=o(i[h],c[h]);if(p)return p}return i.length===c.length?0:o(i[h]??l,c[h]??l)},\"comparePartList\");return!r.#e[t]&&!n.#e[t]?0:r.#e[t]&&!n.#e[t]?s(r.#s[t],[f]):!r.#e[t]&&n.#e[t]?s([f],n.#s[t]):s(r.#s[t],n.#s[t])}get protocol(){return this.#e.protocol}get username(){return this.#e.username}get password(){return this.#e.password}get hostname(){return this.#e.hostname}get port(){return this.#e.port}get pathname(){return this.#e.pathname}get search(){return this.#e.search}get hash(){return this.#e.hash}get hasRegExpGroups(){return this.#l}};a(M,\"URLPattern\");\n","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"node:crypto\");","module.exports = require(\"node:events\");","module.exports = require(\"buffer\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPromise = isPromise;\nexports.isActualPromise = isActualPromise;\nexports.handleMaybePromise = handleMaybePromise;\nexports.fakePromise = fakePromise;\nexports.createDeferredPromise = createDeferredPromise;\nexports.iterateAsync = iterateAsync;\nexports.iterateAsyncVoid = iterateAsync;\nexports.fakeRejectPromise = fakeRejectPromise;\nexports.mapMaybePromise = mapMaybePromise;\nexports.mapAsyncIterator = mapAsyncIterator;\nexports.promiseLikeFinally = promiseLikeFinally;\nexports.unfakePromise = unfakePromise;\nconst kFakePromise = Symbol.for('@whatwg-node/promise-helpers/FakePromise');\nfunction isPromise(value) {\n    return value?.then != null;\n}\nfunction isActualPromise(value) {\n    const maybePromise = value;\n    return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n}\nfunction handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n    let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n    if (finallyFactory) {\n        result$ = result$.finally(finallyFactory);\n    }\n    return unfakePromise(result$);\n}\nfunction fakePromise(value) {\n    if (value && isActualPromise(value)) {\n        return value;\n    }\n    if (isPromise(value)) {\n        return {\n            then: (resolve, reject) => fakePromise(value.then(resolve, reject)),\n            catch: reject => fakePromise(value.then(res => res, reject)),\n            finally: cb => fakePromise(cb ? promiseLikeFinally(value, cb) : value),\n            [Symbol.toStringTag]: 'Promise',\n        };\n    }\n    // Write a fake promise to avoid the promise constructor\n    // being called with `new Promise` in the browser.\n    return {\n        then(resolve) {\n            if (resolve) {\n                try {\n                    return fakePromise(resolve(value));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch() {\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    return fakePromise(cb()).then(() => value, () => value);\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        [Symbol.toStringTag]: 'Promise',\n        __fakePromiseValue: value,\n        [kFakePromise]: 'resolved',\n    };\n}\nfunction createDeferredPromise() {\n    if (Promise.withResolvers) {\n        return Promise.withResolvers();\n    }\n    let resolveFn;\n    let rejectFn;\n    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n        resolveFn = resolve;\n        rejectFn = reject;\n    });\n    return {\n        promise,\n        get resolve() {\n            return resolveFn;\n        },\n        get reject() {\n            return rejectFn;\n        },\n    };\n}\nfunction iterateAsync(iterable, callback, results) {\n    if (iterable?.length === 0) {\n        return;\n    }\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n    function iterate() {\n        const { done: endOfIterator, value } = iterator.next();\n        if (endOfIterator) {\n            return;\n        }\n        let endedEarly = false;\n        function endEarly() {\n            endedEarly = true;\n        }\n        return handleMaybePromise(function handleCallback() {\n            return callback(value, endEarly, index++);\n        }, function handleCallbackResult(result) {\n            if (result) {\n                results?.push(result);\n            }\n            if (endedEarly) {\n                return;\n            }\n            return iterate();\n        });\n    }\n    return iterate();\n}\nfunction fakeRejectPromise(error) {\n    return {\n        then(_resolve, reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch(reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    cb();\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        __fakeRejectError: error,\n        [Symbol.toStringTag]: 'Promise',\n        [kFakePromise]: 'rejected',\n    };\n}\nfunction mapMaybePromise(input, onSuccess, onError) {\n    return handleMaybePromise(() => input, onSuccess, onError);\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, onNext, onError, onEnd) {\n    if (Symbol.asyncIterator in iterator) {\n        iterator = iterator[Symbol.asyncIterator]();\n    }\n    let $return;\n    let abruptClose;\n    let onEndWithValue;\n    if (onEnd) {\n        let onEndWithValueResult /** R in onEndWithValue */;\n        onEndWithValue = value => {\n            onEndWithValueResult ||= handleMaybePromise(onEnd, () => value, () => value);\n            return onEndWithValueResult;\n        };\n    }\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => {\n                throw error;\n            };\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        if (result.done) {\n            return onEndWithValue ? onEndWithValue(result) : result;\n        }\n        return handleMaybePromise(() => result.value, value => handleMaybePromise(() => onNext(value), iteratorResult, abruptClose));\n    }\n    let mapReject;\n    if (onError) {\n        let onErrorResult;\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = onError;\n        mapReject = (error) => {\n            onErrorResult ||= handleMaybePromise(() => error, error => handleMaybePromise(() => reject(error), iteratorResult, abruptClose));\n            return onErrorResult;\n        };\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            const res$ = $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : fakePromise({ value: undefined, done: true });\n            return onEndWithValue ? res$.then(onEndWithValue) : res$;\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            if (abruptClose) {\n                return abruptClose(error);\n            }\n            return fakeRejectPromise(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\nfunction isFakePromise(value) {\n    return value?.[kFakePromise] === 'resolved';\n}\nfunction isFakeRejectPromise(value) {\n    return value?.[kFakePromise] === 'rejected';\n}\nfunction promiseLikeFinally(value, onFinally) {\n    if ('finally' in value) {\n        return value.finally(onFinally);\n    }\n    return value.then(res => {\n        const finallyRes = onFinally();\n        return isPromise(finallyRes) ? finallyRes.then(() => res) : res;\n    }, err => {\n        const finallyRes = onFinally();\n        if (isPromise(finallyRes)) {\n            return finallyRes.then(() => {\n                throw err;\n            });\n        }\n        else {\n            throw err;\n        }\n    });\n}\nfunction unfakePromise(promise) {\n    if (isFakePromise(promise)) {\n        return promise.__fakePromiseValue;\n    }\n    if (isFakeRejectPromise(promise)) {\n        throw promise.__fakeRejectError;\n    }\n    return promise;\n}\n","module.exports = require(\"http\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillTextDecoder = exports.PonyfillTextEncoder = void 0;\nexports.PonyfillBtoa = PonyfillBtoa;\nconst node_buffer_1 = require(\"node:buffer\");\nconst utils_js_1 = require(\"./utils.js\");\nclass PonyfillTextEncoder {\n    encoding;\n    constructor(encoding = 'utf-8') {\n        this.encoding = encoding;\n    }\n    encode(input) {\n        return node_buffer_1.Buffer.from(input, this.encoding);\n    }\n    encodeInto(source, destination) {\n        const buffer = this.encode(source);\n        const copied = buffer.copy(destination);\n        return {\n            read: copied,\n            written: copied,\n        };\n    }\n}\nexports.PonyfillTextEncoder = PonyfillTextEncoder;\nclass PonyfillTextDecoder {\n    encoding;\n    fatal = false;\n    ignoreBOM = false;\n    constructor(encoding = 'utf-8', options) {\n        this.encoding = encoding;\n        if (options) {\n            this.fatal = options.fatal || false;\n            this.ignoreBOM = options.ignoreBOM || false;\n        }\n    }\n    decode(input) {\n        if (node_buffer_1.Buffer.isBuffer(input)) {\n            return input.toString(this.encoding);\n        }\n        if ((0, utils_js_1.isArrayBufferView)(input)) {\n            return node_buffer_1.Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);\n        }\n        return node_buffer_1.Buffer.from(input).toString(this.encoding);\n    }\n}\nexports.PonyfillTextDecoder = PonyfillTextDecoder;\nfunction PonyfillBtoa(input) {\n    return node_buffer_1.Buffer.from(input, 'binary').toString('base64');\n}\n","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextEncoderStream = exports.TextDecoderStream = exports.IteratorObject = exports.DecompressionStream = exports.CompressionStream = exports.TransformStream = exports.WritableStream = exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = void 0;\nvar fetch_js_1 = require(\"./fetch.js\");\nObject.defineProperty(exports, \"fetch\", { enumerable: true, get: function () { return fetch_js_1.fetchPonyfill; } });\nvar Headers_js_1 = require(\"./Headers.js\");\nObject.defineProperty(exports, \"Headers\", { enumerable: true, get: function () { return Headers_js_1.PonyfillHeaders; } });\nvar Body_js_1 = require(\"./Body.js\");\nObject.defineProperty(exports, \"Body\", { enumerable: true, get: function () { return Body_js_1.PonyfillBody; } });\nvar Request_js_1 = require(\"./Request.js\");\nObject.defineProperty(exports, \"Request\", { enumerable: true, get: function () { return Request_js_1.PonyfillRequest; } });\nvar Response_js_1 = require(\"./Response.js\");\nObject.defineProperty(exports, \"Response\", { enumerable: true, get: function () { return Response_js_1.PonyfillResponse; } });\nvar ReadableStream_js_1 = require(\"./ReadableStream.js\");\nObject.defineProperty(exports, \"ReadableStream\", { enumerable: true, get: function () { return ReadableStream_js_1.PonyfillReadableStream; } });\nvar File_js_1 = require(\"./File.js\");\nObject.defineProperty(exports, \"File\", { enumerable: true, get: function () { return File_js_1.PonyfillFile; } });\nvar FormData_js_1 = require(\"./FormData.js\");\nObject.defineProperty(exports, \"FormData\", { enumerable: true, get: function () { return FormData_js_1.PonyfillFormData; } });\nvar Blob_js_1 = require(\"./Blob.js\");\nObject.defineProperty(exports, \"Blob\", { enumerable: true, get: function () { return Blob_js_1.PonyfillBlob; } });\nvar TextEncoderDecoder_js_1 = require(\"./TextEncoderDecoder.js\");\nObject.defineProperty(exports, \"TextEncoder\", { enumerable: true, get: function () { return TextEncoderDecoder_js_1.PonyfillTextEncoder; } });\nObject.defineProperty(exports, \"TextDecoder\", { enumerable: true, get: function () { return TextEncoderDecoder_js_1.PonyfillTextDecoder; } });\nObject.defineProperty(exports, \"btoa\", { enumerable: true, get: function () { return TextEncoderDecoder_js_1.PonyfillBtoa; } });\nvar URL_js_1 = require(\"./URL.js\");\nObject.defineProperty(exports, \"URL\", { enumerable: true, get: function () { return URL_js_1.PonyfillURL; } });\nvar URLSearchParams_js_1 = require(\"./URLSearchParams.js\");\nObject.defineProperty(exports, \"URLSearchParams\", { enumerable: true, get: function () { return URLSearchParams_js_1.PonyfillURLSearchParams; } });\nvar WritableStream_js_1 = require(\"./WritableStream.js\");\nObject.defineProperty(exports, \"WritableStream\", { enumerable: true, get: function () { return WritableStream_js_1.PonyfillWritableStream; } });\nvar TransformStream_js_1 = require(\"./TransformStream.js\");\nObject.defineProperty(exports, \"TransformStream\", { enumerable: true, get: function () { return TransformStream_js_1.PonyfillTransformStream; } });\nvar CompressionStream_js_1 = require(\"./CompressionStream.js\");\nObject.defineProperty(exports, \"CompressionStream\", { enumerable: true, get: function () { return CompressionStream_js_1.PonyfillCompressionStream; } });\nvar DecompressionStream_js_1 = require(\"./DecompressionStream.js\");\nObject.defineProperty(exports, \"DecompressionStream\", { enumerable: true, get: function () { return DecompressionStream_js_1.PonyfillDecompressionStream; } });\nvar IteratorObject_js_1 = require(\"./IteratorObject.js\");\nObject.defineProperty(exports, \"IteratorObject\", { enumerable: true, get: function () { return IteratorObject_js_1.PonyfillIteratorObject; } });\nvar TextEncoderDecoderStream_js_1 = require(\"./TextEncoderDecoderStream.js\");\nObject.defineProperty(exports, \"TextDecoderStream\", { enumerable: true, get: function () { return TextEncoderDecoderStream_js_1.PonyfillTextDecoderStream; } });\nObject.defineProperty(exports, \"TextEncoderStream\", { enumerable: true, get: function () { return TextEncoderDecoderStream_js_1.PonyfillTextEncoderStream; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillBody = void 0;\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nconst node_buffer_1 = require(\"node:buffer\");\nconst node_http_1 = require(\"node:http\");\nconst node_stream_1 = require(\"node:stream\");\nconst busboy_1 = require(\"@fastify/busboy\");\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst Blob_js_1 = require(\"./Blob.js\");\nconst File_js_1 = require(\"./File.js\");\nconst FormData_js_1 = require(\"./FormData.js\");\nconst ReadableStream_js_1 = require(\"./ReadableStream.js\");\nconst utils_js_1 = require(\"./utils.js\");\nvar BodyInitType;\n(function (BodyInitType) {\n    BodyInitType[\"ReadableStream\"] = \"ReadableStream\";\n    BodyInitType[\"Blob\"] = \"Blob\";\n    BodyInitType[\"FormData\"] = \"FormData\";\n    BodyInitType[\"String\"] = \"String\";\n    BodyInitType[\"Readable\"] = \"Readable\";\n    BodyInitType[\"Buffer\"] = \"Buffer\";\n    BodyInitType[\"AsyncIterable\"] = \"AsyncIterable\";\n})(BodyInitType || (BodyInitType = {}));\nclass PonyfillBody {\n    bodyInit;\n    options;\n    bodyUsed = false;\n    contentType = null;\n    contentLength = null;\n    _signal = null;\n    constructor(bodyInit, options = {}) {\n        this.bodyInit = bodyInit;\n        this.options = options;\n        this._signal = options.signal || null;\n        const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit, options?.signal);\n        this._bodyFactory = bodyFactory;\n        this.contentType = contentType;\n        this.contentLength = contentLength;\n        this.bodyType = bodyType;\n        this._buffer = buffer;\n    }\n    bodyType;\n    _bodyFactory = () => null;\n    _generatedBody = null;\n    _buffer;\n    generateBody() {\n        if (this._generatedBody?.readable?.destroyed && this._buffer) {\n            this._generatedBody.readable = node_stream_1.Readable.from(this._buffer);\n        }\n        if (this._generatedBody) {\n            return this._generatedBody;\n        }\n        const body = this._bodyFactory();\n        this._generatedBody = body;\n        return body;\n    }\n    handleContentLengthHeader(forceSet = false) {\n        const contentTypeInHeaders = this.headers.get('content-type');\n        if (!contentTypeInHeaders) {\n            if (this.contentType) {\n                this.headers.set('content-type', this.contentType);\n            }\n        }\n        else {\n            this.contentType = contentTypeInHeaders;\n        }\n        const contentLengthInHeaders = this.headers.get('content-length');\n        if (forceSet && this.bodyInit == null && !contentLengthInHeaders) {\n            this.contentLength = 0;\n            this.headers.set('content-length', '0');\n        }\n        if (!contentLengthInHeaders) {\n            if (this.contentLength) {\n                this.headers.set('content-length', this.contentLength.toString());\n            }\n        }\n        else {\n            this.contentLength = parseInt(contentLengthInHeaders, 10);\n        }\n    }\n    get body() {\n        const _body = this.generateBody();\n        if (_body != null) {\n            const ponyfillReadableStream = _body;\n            const readable = _body.readable;\n            return new Proxy(_body.readable, {\n                get(_, prop) {\n                    if (prop in ponyfillReadableStream) {\n                        const ponyfillReadableStreamProp = ponyfillReadableStream[prop];\n                        if (typeof ponyfillReadableStreamProp === 'function') {\n                            return ponyfillReadableStreamProp.bind(ponyfillReadableStream);\n                        }\n                        return ponyfillReadableStreamProp;\n                    }\n                    if (prop in readable) {\n                        const readableProp = readable[prop];\n                        if (typeof readableProp === 'function') {\n                            return readableProp.bind(readable);\n                        }\n                        return readableProp;\n                    }\n                },\n            });\n        }\n        return null;\n    }\n    _chunks = null;\n    _doCollectChunksFromReadableJob() {\n        if (this.bodyType === BodyInitType.AsyncIterable) {\n            if (Array.fromAsync) {\n                return (0, promise_helpers_1.handleMaybePromise)(() => Array.fromAsync(this.bodyInit), chunks => {\n                    this._chunks = chunks;\n                    return this._chunks;\n                });\n            }\n            const iterator = this.bodyInit[Symbol.asyncIterator]();\n            const chunks = [];\n            const collectValue = () => (0, promise_helpers_1.handleMaybePromise)(() => iterator.next(), ({ value, done }) => {\n                if (value) {\n                    chunks.push(value);\n                }\n                if (!done) {\n                    return collectValue();\n                }\n                this._chunks = chunks;\n                return this._chunks;\n            });\n            return collectValue();\n        }\n        const _body = this.generateBody();\n        if (!_body) {\n            this._chunks = [];\n            return (0, utils_js_1.fakePromise)(this._chunks);\n        }\n        return _body.readable.toArray().then(chunks => {\n            this._chunks = chunks;\n            return this._chunks;\n        });\n    }\n    _collectChunksFromReadable() {\n        if (this._chunks) {\n            return (0, utils_js_1.fakePromise)(this._chunks);\n        }\n        this._chunks ||= this._doCollectChunksFromReadableJob();\n        return this._chunks;\n    }\n    _blob = null;\n    blob() {\n        if (this._blob) {\n            return (0, utils_js_1.fakePromise)(this._blob);\n        }\n        if (this.bodyType === BodyInitType.String) {\n            this._text = this.bodyInit;\n            this._blob = new Blob_js_1.PonyfillBlob([this._text], {\n                type: this.contentType || 'text/plain;charset=UTF-8',\n                size: this.contentLength,\n            });\n        }\n        if (this.bodyType === BodyInitType.Blob) {\n            this._blob = this.bodyInit;\n            return (0, utils_js_1.fakePromise)(this._blob);\n        }\n        if (this._buffer) {\n            this._blob = new Blob_js_1.PonyfillBlob([this._buffer], {\n                type: this.contentType || '',\n                size: this.contentLength,\n            });\n            return (0, utils_js_1.fakePromise)(this._blob);\n        }\n        return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(() => this._collectChunksFromReadable(), chunks => {\n            this._blob = new Blob_js_1.PonyfillBlob(chunks, {\n                type: this.contentType || '',\n                size: this.contentLength,\n            });\n            return this._blob;\n        }));\n    }\n    _formData = null;\n    formData(opts) {\n        if (this._formData) {\n            return (0, utils_js_1.fakePromise)(this._formData);\n        }\n        if (this.bodyType === BodyInitType.FormData) {\n            this._formData = this.bodyInit;\n            return (0, utils_js_1.fakePromise)(this._formData);\n        }\n        this._formData = new FormData_js_1.PonyfillFormData();\n        const _body = this.generateBody();\n        if (_body == null) {\n            return (0, utils_js_1.fakePromise)(this._formData);\n        }\n        const formDataLimits = {\n            ...this.options.formDataLimits,\n            ...opts?.formDataLimits,\n        };\n        return new Promise((resolve, reject) => {\n            const stream = this.body?.readable;\n            if (!stream) {\n                return reject(new Error('No stream available'));\n            }\n            // form data file that is currently being processed, it's\n            // important to keep track of it in case the stream ends early\n            let currFile = null;\n            const bb = new busboy_1.Busboy({\n                headers: {\n                    'content-length': typeof this.contentLength === 'number'\n                        ? this.contentLength.toString()\n                        : this.contentLength || '',\n                    'content-type': this.contentType || '',\n                },\n                limits: formDataLimits,\n                defCharset: 'utf-8',\n            });\n            if (this._signal) {\n                (0, node_stream_1.addAbortSignal)(this._signal, bb);\n            }\n            let completed = false;\n            const complete = (err) => {\n                if (completed)\n                    return;\n                completed = true;\n                stream.unpipe(bb);\n                bb.destroy();\n                if (currFile) {\n                    currFile.destroy();\n                    currFile = null;\n                }\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    // no error occured, this is a successful end/complete/finish\n                    resolve(this._formData);\n                }\n            };\n            // we dont need to listen to the stream close event because bb will close or error when necessary\n            // stream.on('close', complete);\n            // stream can be aborted, for example\n            stream.on('error', complete);\n            bb.on('field', (name, value, fieldnameTruncated, valueTruncated) => {\n                if (fieldnameTruncated) {\n                    return complete(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));\n                }\n                if (valueTruncated) {\n                    return complete(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));\n                }\n                this._formData.set(name, value);\n            });\n            bb.on('file', (name, fileStream, filename, _transferEncoding, mimeType) => {\n                currFile = fileStream;\n                const chunks = [];\n                fileStream.on('data', chunk => {\n                    chunks.push(chunk);\n                });\n                fileStream.on('error', complete);\n                fileStream.on('limit', () => {\n                    complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));\n                });\n                fileStream.on('close', () => {\n                    if (fileStream.truncated) {\n                        complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));\n                    }\n                    currFile = null;\n                    const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });\n                    this._formData.set(name, file);\n                });\n            });\n            bb.on('fieldsLimit', () => {\n                complete(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));\n            });\n            bb.on('filesLimit', () => {\n                complete(new Error(`Files limit exceeded: ${formDataLimits?.files}`));\n            });\n            bb.on('partsLimit', () => {\n                complete(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));\n            });\n            bb.on('end', complete);\n            bb.on('finish', complete);\n            bb.on('close', complete);\n            bb.on('error', complete);\n            stream.pipe(bb);\n        });\n    }\n    buffer() {\n        if (this._buffer) {\n            return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (this._text) {\n            this._buffer = node_buffer_1.Buffer.from(this._text, 'utf-8');\n            return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (this.bodyType === BodyInitType.String) {\n            return this.text().then(text => {\n                this._text = text;\n                this._buffer = node_buffer_1.Buffer.from(text, 'utf-8');\n                return this._buffer;\n            });\n        }\n        if (this.bodyType === BodyInitType.Blob) {\n            if ((0, Blob_js_1.hasBufferMethod)(this.bodyInit)) {\n                return this.bodyInit.buffer().then(buf => {\n                    this._buffer = buf;\n                    return this._buffer;\n                });\n            }\n            if ((0, Blob_js_1.hasBytesMethod)(this.bodyInit)) {\n                return this.bodyInit.bytes().then(bytes => {\n                    this._buffer = node_buffer_1.Buffer.from(bytes);\n                    return this._buffer;\n                });\n            }\n            if ((0, Blob_js_1.hasArrayBufferMethod)(this.bodyInit)) {\n                return this.bodyInit.arrayBuffer().then(buf => {\n                    this._buffer = node_buffer_1.Buffer.from(buf, undefined, buf.byteLength);\n                    return this._buffer;\n                });\n            }\n        }\n        return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(() => this._collectChunksFromReadable(), chunks => {\n            if (chunks.length === 1) {\n                this._buffer = chunks[0];\n                return this._buffer;\n            }\n            this._buffer = node_buffer_1.Buffer.concat(chunks);\n            return this._buffer;\n        }));\n    }\n    bytes() {\n        return this.buffer();\n    }\n    arrayBuffer() {\n        // @ts-ignore - Mismatch between Buffer and ArrayBuffer\n        return this.buffer();\n    }\n    _json = null;\n    json() {\n        if (this._json) {\n            return (0, utils_js_1.fakePromise)(this._json);\n        }\n        return this.text().then(text => {\n            try {\n                this._json = JSON.parse(text);\n            }\n            catch (e) {\n                if (e instanceof SyntaxError) {\n                    e.message += `, \"${text}\" is not valid JSON`;\n                }\n                throw e;\n            }\n            return this._json;\n        });\n    }\n    _text = null;\n    text() {\n        if (this._text) {\n            return (0, utils_js_1.fakePromise)(this._text);\n        }\n        if (this.bodyType === BodyInitType.String) {\n            this._text = this.bodyInit;\n            return (0, utils_js_1.fakePromise)(this._text);\n        }\n        return this.buffer().then(buffer => {\n            this._text = buffer.toString('utf-8');\n            return this._text;\n        });\n    }\n}\nexports.PonyfillBody = PonyfillBody;\nfunction processBodyInit(bodyInit, signal) {\n    if (bodyInit == null) {\n        return {\n            bodyFactory: () => null,\n            contentType: null,\n            contentLength: null,\n        };\n    }\n    if (typeof bodyInit === 'string') {\n        const contentLength = node_buffer_1.Buffer.byteLength(bodyInit);\n        return {\n            bodyType: BodyInitType.String,\n            contentType: 'text/plain;charset=UTF-8',\n            contentLength,\n            bodyFactory() {\n                const readable = node_stream_1.Readable.from(node_buffer_1.Buffer.from(bodyInit, 'utf-8'));\n                return new ReadableStream_js_1.PonyfillReadableStream(readable);\n            },\n        };\n    }\n    if (node_buffer_1.Buffer.isBuffer(bodyInit)) {\n        const buffer = bodyInit;\n        return {\n            bodyType: BodyInitType.Buffer,\n            contentType: null,\n            contentLength: bodyInit.length,\n            buffer: bodyInit,\n            bodyFactory() {\n                const readable = node_stream_1.Readable.from(buffer);\n                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n                return body;\n            },\n        };\n    }\n    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {\n        const buffer = node_buffer_1.Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);\n        return {\n            bodyType: BodyInitType.Buffer,\n            contentLength: bodyInit.byteLength,\n            contentType: null,\n            buffer,\n            bodyFactory() {\n                const readable = node_stream_1.Readable.from(buffer);\n                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n                return body;\n            },\n        };\n    }\n    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {\n        const readableStream = bodyInit;\n        return {\n            bodyType: BodyInitType.ReadableStream,\n            bodyFactory: () => readableStream,\n            contentType: null,\n            contentLength: null,\n        };\n    }\n    if (isBlob(bodyInit)) {\n        const blob = bodyInit;\n        return {\n            bodyType: BodyInitType.Blob,\n            contentType: bodyInit.type,\n            contentLength: bodyInit.size,\n            bodyFactory() {\n                return blob.stream();\n            },\n        };\n    }\n    if (bodyInit instanceof ArrayBuffer) {\n        const contentLength = bodyInit.byteLength;\n        const buffer = node_buffer_1.Buffer.from(bodyInit, undefined, bodyInit.byteLength);\n        return {\n            bodyType: BodyInitType.Buffer,\n            contentType: null,\n            contentLength,\n            buffer,\n            bodyFactory() {\n                const readable = node_stream_1.Readable.from(buffer);\n                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n                return body;\n            },\n        };\n    }\n    if (bodyInit instanceof node_http_1.IncomingMessage) {\n        const passThrough = (0, utils_js_1.wrapIncomingMessageWithPassthrough)({\n            incomingMessage: bodyInit,\n            signal,\n        });\n        return {\n            bodyType: BodyInitType.Readable,\n            contentType: null,\n            contentLength: null,\n            bodyFactory() {\n                return new ReadableStream_js_1.PonyfillReadableStream(passThrough);\n            },\n        };\n    }\n    if (bodyInit instanceof node_stream_1.Readable) {\n        return {\n            bodyType: BodyInitType.Readable,\n            contentType: null,\n            contentLength: null,\n            bodyFactory() {\n                const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);\n                return body;\n            },\n        };\n    }\n    if (isURLSearchParams(bodyInit)) {\n        const contentType = 'application/x-www-form-urlencoded;charset=UTF-8';\n        return {\n            bodyType: BodyInitType.String,\n            contentType,\n            contentLength: null,\n            bodyFactory() {\n                const body = new ReadableStream_js_1.PonyfillReadableStream(node_stream_1.Readable.from(bodyInit.toString()));\n                return body;\n            },\n        };\n    }\n    if (isFormData(bodyInit)) {\n        const boundary = Math.random().toString(36).substr(2);\n        const contentType = `multipart/form-data; boundary=${boundary}`;\n        return {\n            bodyType: BodyInitType.FormData,\n            contentType,\n            contentLength: null,\n            bodyFactory() {\n                return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);\n            },\n        };\n    }\n    if (isReadableStream(bodyInit)) {\n        return {\n            contentType: null,\n            contentLength: null,\n            bodyFactory() {\n                return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);\n            },\n        };\n    }\n    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {\n        return {\n            contentType: null,\n            contentLength: null,\n            bodyType: BodyInitType.AsyncIterable,\n            bodyFactory() {\n                const readable = node_stream_1.Readable.from(bodyInit);\n                return new ReadableStream_js_1.PonyfillReadableStream(readable);\n            },\n        };\n    }\n    throw new Error('Unknown body type');\n}\nfunction isFormData(value) {\n    return value?.forEach != null;\n}\nfunction isBlob(value) {\n    return value?.stream != null && typeof value.stream === 'function';\n}\nfunction isURLSearchParams(value) {\n    return value?.sort != null;\n}\nfunction isReadableStream(value) {\n    return value?.getReader != null;\n}\n","module.exports = require(\"node:inspector\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSyncDisposable = isSyncDisposable;\nexports.isAsyncDisposable = isAsyncDisposable;\nconst symbols_js_1 = require(\"./symbols.js\");\nfunction isSyncDisposable(obj) {\n    return obj?.[symbols_js_1.DisposableSymbols.dispose] != null;\n}\nfunction isAsyncDisposable(obj) {\n    return obj?.[symbols_js_1.DisposableSymbols.asyncDispose] != null;\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 88084;\nmodule.exports = webpackEmptyContext;","'use strict'\n\nconst inherits = require('node:util').inherits\nconst ReadableStream = require('node:stream').Readable\n\nfunction PartStream (opts) {\n  ReadableStream.call(this, opts)\n}\ninherits(PartStream, ReadableStream)\n\nPartStream.prototype._read = function (n) {}\n\nmodule.exports = PartStream\n","/* eslint-disable object-property-newline */\n'use strict'\n\nconst decodeText = require('./decodeText')\n\nconst RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g\n\nconst EncodedLookup = {\n  '%00': '\\x00', '%01': '\\x01', '%02': '\\x02', '%03': '\\x03', '%04': '\\x04',\n  '%05': '\\x05', '%06': '\\x06', '%07': '\\x07', '%08': '\\x08', '%09': '\\x09',\n  '%0a': '\\x0a', '%0A': '\\x0a', '%0b': '\\x0b', '%0B': '\\x0b', '%0c': '\\x0c',\n  '%0C': '\\x0c', '%0d': '\\x0d', '%0D': '\\x0d', '%0e': '\\x0e', '%0E': '\\x0e',\n  '%0f': '\\x0f', '%0F': '\\x0f', '%10': '\\x10', '%11': '\\x11', '%12': '\\x12',\n  '%13': '\\x13', '%14': '\\x14', '%15': '\\x15', '%16': '\\x16', '%17': '\\x17',\n  '%18': '\\x18', '%19': '\\x19', '%1a': '\\x1a', '%1A': '\\x1a', '%1b': '\\x1b',\n  '%1B': '\\x1b', '%1c': '\\x1c', '%1C': '\\x1c', '%1d': '\\x1d', '%1D': '\\x1d',\n  '%1e': '\\x1e', '%1E': '\\x1e', '%1f': '\\x1f', '%1F': '\\x1f', '%20': '\\x20',\n  '%21': '\\x21', '%22': '\\x22', '%23': '\\x23', '%24': '\\x24', '%25': '\\x25',\n  '%26': '\\x26', '%27': '\\x27', '%28': '\\x28', '%29': '\\x29', '%2a': '\\x2a',\n  '%2A': '\\x2a', '%2b': '\\x2b', '%2B': '\\x2b', '%2c': '\\x2c', '%2C': '\\x2c',\n  '%2d': '\\x2d', '%2D': '\\x2d', '%2e': '\\x2e', '%2E': '\\x2e', '%2f': '\\x2f',\n  '%2F': '\\x2f', '%30': '\\x30', '%31': '\\x31', '%32': '\\x32', '%33': '\\x33',\n  '%34': '\\x34', '%35': '\\x35', '%36': '\\x36', '%37': '\\x37', '%38': '\\x38',\n  '%39': '\\x39', '%3a': '\\x3a', '%3A': '\\x3a', '%3b': '\\x3b', '%3B': '\\x3b',\n  '%3c': '\\x3c', '%3C': '\\x3c', '%3d': '\\x3d', '%3D': '\\x3d', '%3e': '\\x3e',\n  '%3E': '\\x3e', '%3f': '\\x3f', '%3F': '\\x3f', '%40': '\\x40', '%41': '\\x41',\n  '%42': '\\x42', '%43': '\\x43', '%44': '\\x44', '%45': '\\x45', '%46': '\\x46',\n  '%47': '\\x47', '%48': '\\x48', '%49': '\\x49', '%4a': '\\x4a', '%4A': '\\x4a',\n  '%4b': '\\x4b', '%4B': '\\x4b', '%4c': '\\x4c', '%4C': '\\x4c', '%4d': '\\x4d',\n  '%4D': '\\x4d', '%4e': '\\x4e', '%4E': '\\x4e', '%4f': '\\x4f', '%4F': '\\x4f',\n  '%50': '\\x50', '%51': '\\x51', '%52': '\\x52', '%53': '\\x53', '%54': '\\x54',\n  '%55': '\\x55', '%56': '\\x56', '%57': '\\x57', '%58': '\\x58', '%59': '\\x59',\n  '%5a': '\\x5a', '%5A': '\\x5a', '%5b': '\\x5b', '%5B': '\\x5b', '%5c': '\\x5c',\n  '%5C': '\\x5c', '%5d': '\\x5d', '%5D': '\\x5d', '%5e': '\\x5e', '%5E': '\\x5e',\n  '%5f': '\\x5f', '%5F': '\\x5f', '%60': '\\x60', '%61': '\\x61', '%62': '\\x62',\n  '%63': '\\x63', '%64': '\\x64', '%65': '\\x65', '%66': '\\x66', '%67': '\\x67',\n  '%68': '\\x68', '%69': '\\x69', '%6a': '\\x6a', '%6A': '\\x6a', '%6b': '\\x6b',\n  '%6B': '\\x6b', '%6c': '\\x6c', '%6C': '\\x6c', '%6d': '\\x6d', '%6D': '\\x6d',\n  '%6e': '\\x6e', '%6E': '\\x6e', '%6f': '\\x6f', '%6F': '\\x6f', '%70': '\\x70',\n  '%71': '\\x71', '%72': '\\x72', '%73': '\\x73', '%74': '\\x74', '%75': '\\x75',\n  '%76': '\\x76', '%77': '\\x77', '%78': '\\x78', '%79': '\\x79', '%7a': '\\x7a',\n  '%7A': '\\x7a', '%7b': '\\x7b', '%7B': '\\x7b', '%7c': '\\x7c', '%7C': '\\x7c',\n  '%7d': '\\x7d', '%7D': '\\x7d', '%7e': '\\x7e', '%7E': '\\x7e', '%7f': '\\x7f',\n  '%7F': '\\x7f', '%80': '\\x80', '%81': '\\x81', '%82': '\\x82', '%83': '\\x83',\n  '%84': '\\x84', '%85': '\\x85', '%86': '\\x86', '%87': '\\x87', '%88': '\\x88',\n  '%89': '\\x89', '%8a': '\\x8a', '%8A': '\\x8a', '%8b': '\\x8b', '%8B': '\\x8b',\n  '%8c': '\\x8c', '%8C': '\\x8c', '%8d': '\\x8d', '%8D': '\\x8d', '%8e': '\\x8e',\n  '%8E': '\\x8e', '%8f': '\\x8f', '%8F': '\\x8f', '%90': '\\x90', '%91': '\\x91',\n  '%92': '\\x92', '%93': '\\x93', '%94': '\\x94', '%95': '\\x95', '%96': '\\x96',\n  '%97': '\\x97', '%98': '\\x98', '%99': '\\x99', '%9a': '\\x9a', '%9A': '\\x9a',\n  '%9b': '\\x9b', '%9B': '\\x9b', '%9c': '\\x9c', '%9C': '\\x9c', '%9d': '\\x9d',\n  '%9D': '\\x9d', '%9e': '\\x9e', '%9E': '\\x9e', '%9f': '\\x9f', '%9F': '\\x9f',\n  '%a0': '\\xa0', '%A0': '\\xa0', '%a1': '\\xa1', '%A1': '\\xa1', '%a2': '\\xa2',\n  '%A2': '\\xa2', '%a3': '\\xa3', '%A3': '\\xa3', '%a4': '\\xa4', '%A4': '\\xa4',\n  '%a5': '\\xa5', '%A5': '\\xa5', '%a6': '\\xa6', '%A6': '\\xa6', '%a7': '\\xa7',\n  '%A7': '\\xa7', '%a8': '\\xa8', '%A8': '\\xa8', '%a9': '\\xa9', '%A9': '\\xa9',\n  '%aa': '\\xaa', '%Aa': '\\xaa', '%aA': '\\xaa', '%AA': '\\xaa', '%ab': '\\xab',\n  '%Ab': '\\xab', '%aB': '\\xab', '%AB': '\\xab', '%ac': '\\xac', '%Ac': '\\xac',\n  '%aC': '\\xac', '%AC': '\\xac', '%ad': '\\xad', '%Ad': '\\xad', '%aD': '\\xad',\n  '%AD': '\\xad', '%ae': '\\xae', '%Ae': '\\xae', '%aE': '\\xae', '%AE': '\\xae',\n  '%af': '\\xaf', '%Af': '\\xaf', '%aF': '\\xaf', '%AF': '\\xaf', '%b0': '\\xb0',\n  '%B0': '\\xb0', '%b1': '\\xb1', '%B1': '\\xb1', '%b2': '\\xb2', '%B2': '\\xb2',\n  '%b3': '\\xb3', '%B3': '\\xb3', '%b4': '\\xb4', '%B4': '\\xb4', '%b5': '\\xb5',\n  '%B5': '\\xb5', '%b6': '\\xb6', '%B6': '\\xb6', '%b7': '\\xb7', '%B7': '\\xb7',\n  '%b8': '\\xb8', '%B8': '\\xb8', '%b9': '\\xb9', '%B9': '\\xb9', '%ba': '\\xba',\n  '%Ba': '\\xba', '%bA': '\\xba', '%BA': '\\xba', '%bb': '\\xbb', '%Bb': '\\xbb',\n  '%bB': '\\xbb', '%BB': '\\xbb', '%bc': '\\xbc', '%Bc': '\\xbc', '%bC': '\\xbc',\n  '%BC': '\\xbc', '%bd': '\\xbd', '%Bd': '\\xbd', '%bD': '\\xbd', '%BD': '\\xbd',\n  '%be': '\\xbe', '%Be': '\\xbe', '%bE': '\\xbe', '%BE': '\\xbe', '%bf': '\\xbf',\n  '%Bf': '\\xbf', '%bF': '\\xbf', '%BF': '\\xbf', '%c0': '\\xc0', '%C0': '\\xc0',\n  '%c1': '\\xc1', '%C1': '\\xc1', '%c2': '\\xc2', '%C2': '\\xc2', '%c3': '\\xc3',\n  '%C3': '\\xc3', '%c4': '\\xc4', '%C4': '\\xc4', '%c5': '\\xc5', '%C5': '\\xc5',\n  '%c6': '\\xc6', '%C6': '\\xc6', '%c7': '\\xc7', '%C7': '\\xc7', '%c8': '\\xc8',\n  '%C8': '\\xc8', '%c9': '\\xc9', '%C9': '\\xc9', '%ca': '\\xca', '%Ca': '\\xca',\n  '%cA': '\\xca', '%CA': '\\xca', '%cb': '\\xcb', '%Cb': '\\xcb', '%cB': '\\xcb',\n  '%CB': '\\xcb', '%cc': '\\xcc', '%Cc': '\\xcc', '%cC': '\\xcc', '%CC': '\\xcc',\n  '%cd': '\\xcd', '%Cd': '\\xcd', '%cD': '\\xcd', '%CD': '\\xcd', '%ce': '\\xce',\n  '%Ce': '\\xce', '%cE': '\\xce', '%CE': '\\xce', '%cf': '\\xcf', '%Cf': '\\xcf',\n  '%cF': '\\xcf', '%CF': '\\xcf', '%d0': '\\xd0', '%D0': '\\xd0', '%d1': '\\xd1',\n  '%D1': '\\xd1', '%d2': '\\xd2', '%D2': '\\xd2', '%d3': '\\xd3', '%D3': '\\xd3',\n  '%d4': '\\xd4', '%D4': '\\xd4', '%d5': '\\xd5', '%D5': '\\xd5', '%d6': '\\xd6',\n  '%D6': '\\xd6', '%d7': '\\xd7', '%D7': '\\xd7', '%d8': '\\xd8', '%D8': '\\xd8',\n  '%d9': '\\xd9', '%D9': '\\xd9', '%da': '\\xda', '%Da': '\\xda', '%dA': '\\xda',\n  '%DA': '\\xda', '%db': '\\xdb', '%Db': '\\xdb', '%dB': '\\xdb', '%DB': '\\xdb',\n  '%dc': '\\xdc', '%Dc': '\\xdc', '%dC': '\\xdc', '%DC': '\\xdc', '%dd': '\\xdd',\n  '%Dd': '\\xdd', '%dD': '\\xdd', '%DD': '\\xdd', '%de': '\\xde', '%De': '\\xde',\n  '%dE': '\\xde', '%DE': '\\xde', '%df': '\\xdf', '%Df': '\\xdf', '%dF': '\\xdf',\n  '%DF': '\\xdf', '%e0': '\\xe0', '%E0': '\\xe0', '%e1': '\\xe1', '%E1': '\\xe1',\n  '%e2': '\\xe2', '%E2': '\\xe2', '%e3': '\\xe3', '%E3': '\\xe3', '%e4': '\\xe4',\n  '%E4': '\\xe4', '%e5': '\\xe5', '%E5': '\\xe5', '%e6': '\\xe6', '%E6': '\\xe6',\n  '%e7': '\\xe7', '%E7': '\\xe7', '%e8': '\\xe8', '%E8': '\\xe8', '%e9': '\\xe9',\n  '%E9': '\\xe9', '%ea': '\\xea', '%Ea': '\\xea', '%eA': '\\xea', '%EA': '\\xea',\n  '%eb': '\\xeb', '%Eb': '\\xeb', '%eB': '\\xeb', '%EB': '\\xeb', '%ec': '\\xec',\n  '%Ec': '\\xec', '%eC': '\\xec', '%EC': '\\xec', '%ed': '\\xed', '%Ed': '\\xed',\n  '%eD': '\\xed', '%ED': '\\xed', '%ee': '\\xee', '%Ee': '\\xee', '%eE': '\\xee',\n  '%EE': '\\xee', '%ef': '\\xef', '%Ef': '\\xef', '%eF': '\\xef', '%EF': '\\xef',\n  '%f0': '\\xf0', '%F0': '\\xf0', '%f1': '\\xf1', '%F1': '\\xf1', '%f2': '\\xf2',\n  '%F2': '\\xf2', '%f3': '\\xf3', '%F3': '\\xf3', '%f4': '\\xf4', '%F4': '\\xf4',\n  '%f5': '\\xf5', '%F5': '\\xf5', '%f6': '\\xf6', '%F6': '\\xf6', '%f7': '\\xf7',\n  '%F7': '\\xf7', '%f8': '\\xf8', '%F8': '\\xf8', '%f9': '\\xf9', '%F9': '\\xf9',\n  '%fa': '\\xfa', '%Fa': '\\xfa', '%fA': '\\xfa', '%FA': '\\xfa', '%fb': '\\xfb',\n  '%Fb': '\\xfb', '%fB': '\\xfb', '%FB': '\\xfb', '%fc': '\\xfc', '%Fc': '\\xfc',\n  '%fC': '\\xfc', '%FC': '\\xfc', '%fd': '\\xfd', '%Fd': '\\xfd', '%fD': '\\xfd',\n  '%FD': '\\xfd', '%fe': '\\xfe', '%Fe': '\\xfe', '%fE': '\\xfe', '%FE': '\\xfe',\n  '%ff': '\\xff', '%Ff': '\\xff', '%fF': '\\xff', '%FF': '\\xff'\n}\n\nfunction encodedReplacer (match) {\n  return EncodedLookup[match]\n}\n\nconst STATE_KEY = 0\nconst STATE_VALUE = 1\nconst STATE_CHARSET = 2\nconst STATE_LANG = 3\n\nfunction parseParams (str) {\n  const res = []\n  let state = STATE_KEY\n  let charset = ''\n  let inquote = false\n  let escaping = false\n  let p = 0\n  let tmp = ''\n  const len = str.length\n\n  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var\n    const char = str[i]\n    if (char === '\\\\' && inquote) {\n      if (escaping) { escaping = false } else {\n        escaping = true\n        continue\n      }\n    } else if (char === '\"') {\n      if (!escaping) {\n        if (inquote) {\n          inquote = false\n          state = STATE_KEY\n        } else { inquote = true }\n        continue\n      } else { escaping = false }\n    } else {\n      if (escaping && inquote) { tmp += '\\\\' }\n      escaping = false\n      if ((state === STATE_CHARSET || state === STATE_LANG) && char === \"'\") {\n        if (state === STATE_CHARSET) {\n          state = STATE_LANG\n          charset = tmp.substring(1)\n        } else { state = STATE_VALUE }\n        tmp = ''\n        continue\n      } else if (state === STATE_KEY &&\n        (char === '*' || char === '=') &&\n        res.length) {\n        state = char === '*'\n          ? STATE_CHARSET\n          : STATE_VALUE\n        res[p] = [tmp, undefined]\n        tmp = ''\n        continue\n      } else if (!inquote && char === ';') {\n        state = STATE_KEY\n        if (charset) {\n          if (tmp.length) {\n            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),\n              'binary',\n              charset)\n          }\n          charset = ''\n        } else if (tmp.length) {\n          tmp = decodeText(tmp, 'binary', 'utf8')\n        }\n        if (res[p] === undefined) { res[p] = tmp } else { res[p][1] = tmp }\n        tmp = ''\n        ++p\n        continue\n      } else if (!inquote && (char === ' ' || char === '\\t')) { continue }\n    }\n    tmp += char\n  }\n  if (charset && tmp.length) {\n    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),\n      'binary',\n      charset)\n  } else if (tmp) {\n    tmp = decodeText(tmp, 'binary', 'utf8')\n  }\n\n  if (res[p] === undefined) {\n    if (tmp) { res[p] = tmp }\n  } else { res[p][1] = tmp }\n\n  return res\n}\n\nmodule.exports = parseParams\n","module.exports = require(\"net\");","\"use strict\";\nif (process.env.NEXT_RUNTIME === 'edge') {\n    module.exports = require('next/dist/server/route-modules/app-route/module.js');\n} else {\n    if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n        if (process.env.NODE_ENV === 'development') {\n            module.exports = require('next/dist/compiled/next-server/app-route-experimental.runtime.dev.js');\n        } else if (process.env.TURBOPACK) {\n            module.exports = require('next/dist/compiled/next-server/app-route-turbo-experimental.runtime.prod.js');\n        } else {\n            module.exports = require('next/dist/compiled/next-server/app-route-experimental.runtime.prod.js');\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            module.exports = require('next/dist/compiled/next-server/app-route.runtime.dev.js');\n        } else if (process.env.TURBOPACK) {\n            module.exports = require('next/dist/compiled/next-server/app-route-turbo.runtime.prod.js');\n        } else {\n            module.exports = require('next/dist/compiled/next-server/app-route.runtime.prod.js');\n        }\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillIteratorObject = void 0;\nconst node_util_1 = require(\"node:util\");\nconst disposablestack_1 = require(\"@whatwg-node/disposablestack\");\nconst utils_js_1 = require(\"./utils.js\");\nclass PonyfillIteratorObject {\n    iterableIterator;\n    [Symbol.toStringTag] = 'IteratorObject';\n    constructor(iterableIterator, className) {\n        this.iterableIterator = iterableIterator;\n        this[Symbol.toStringTag] = className;\n    }\n    *map(callbackfn) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            yield callbackfn(value, index++);\n        }\n        return undefined;\n    }\n    *filter(callbackfn) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            if (callbackfn(value, index++)) {\n                yield value;\n            }\n        }\n        return undefined;\n    }\n    reduce(callbackfn, initialValue) {\n        let index = 0;\n        let accumulator = initialValue;\n        for (const value of this.iterableIterator) {\n            accumulator = callbackfn(accumulator, value, index++);\n        }\n        return accumulator;\n    }\n    forEach(callbackfn) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            callbackfn(value, index++);\n        }\n    }\n    *take(limit) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            if (index >= limit) {\n                break;\n            }\n            yield value;\n            index++;\n        }\n        return undefined;\n    }\n    *drop(count) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            if (index >= count) {\n                yield value;\n            }\n            index++;\n        }\n        return undefined;\n    }\n    *flatMap(callback) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            const iteratorOrIterable = callback(value, index++);\n            if ((0, utils_js_1.isIterable)(iteratorOrIterable)) {\n                for (const innerValue of iteratorOrIterable) {\n                    yield innerValue;\n                }\n            }\n            else {\n                for (const innerValue of {\n                    [Symbol.iterator]: () => iteratorOrIterable,\n                }) {\n                    yield innerValue;\n                }\n            }\n        }\n        return undefined;\n    }\n    some(predicate) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            if (predicate(value, index++)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    every(predicate) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            if (!predicate(value, index++)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    find(predicate) {\n        let index = 0;\n        for (const value of this.iterableIterator) {\n            if (predicate(value, index++)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    toArray() {\n        return Array.from(this.iterableIterator);\n    }\n    [disposablestack_1.DisposableSymbols.dispose]() {\n        this.iterableIterator.return?.();\n    }\n    next(...[value]) {\n        return this.iterableIterator.next(value);\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        const record = {};\n        this.forEach((value, key) => {\n            const inspectedValue = (0, node_util_1.inspect)(value);\n            record[key] = inspectedValue.includes(',')\n                ? inspectedValue.split(',').map(el => el.trim())\n                : inspectedValue;\n        });\n        return `${this[Symbol.toStringTag]} ${(0, node_util_1.inspect)(record)}`;\n    }\n}\nexports.PonyfillIteratorObject = PonyfillIteratorObject;\n","module.exports = require(\"events\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillURL = void 0;\nconst tslib_1 = require(\"tslib\");\nconst node_buffer_1 = tslib_1.__importDefault(require(\"node:buffer\"));\nconst node_crypto_1 = require(\"node:crypto\");\nconst NativeURL = globalThis.URL;\nclass URL extends NativeURL {\n    // This part is only needed to handle `PonyfillBlob` objects\n    static blobRegistry = new Map();\n    static createObjectURL(blob) {\n        const blobUrl = `blob:whatwgnode:${(0, node_crypto_1.randomUUID)()}`;\n        this.blobRegistry.set(blobUrl, blob);\n        return blobUrl;\n    }\n    static revokeObjectURL(url) {\n        if (!this.blobRegistry.has(url)) {\n            NativeURL.revokeObjectURL(url);\n        }\n        else {\n            this.blobRegistry.delete(url);\n        }\n    }\n    static getBlobFromURL(url) {\n        return (this.blobRegistry.get(url) || node_buffer_1.default?.resolveObjectURL?.(url));\n    }\n}\nexports.PonyfillURL = URL;\n","'use strict'\n\nmodule.exports = function basename (path) {\n  if (typeof path !== 'string') { return '' }\n  for (var i = path.length - 1; i >= 0; --i) { // eslint-disable-line no-var\n    switch (path.charCodeAt(i)) {\n      case 0x2F: // '/'\n      case 0x5C: // '\\'\n        path = path.slice(i + 1)\n        return (path === '..' || path === '.' ? '' : path)\n    }\n  }\n  return (path === '..' || path === '.' ? '' : path)\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 96708;\nmodule.exports = webpackEmptyContext;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 97108;\nmodule.exports = webpackEmptyContext;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PonyfillResponse = void 0;\nconst node_http_1 = require(\"node:http\");\nconst Body_js_1 = require(\"./Body.js\");\nconst Headers_js_1 = require(\"./Headers.js\");\nconst JSON_CONTENT_TYPE = 'application/json; charset=utf-8';\nclass PonyfillResponse extends Body_js_1.PonyfillBody {\n    headers;\n    constructor(body, init) {\n        super(body || null, init);\n        this.headers =\n            init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers)\n                ? init.headers\n                : new Headers_js_1.PonyfillHeaders(init?.headers);\n        this.status = init?.status || 200;\n        this.statusText = init?.statusText || node_http_1.STATUS_CODES[this.status] || 'OK';\n        this.url = init?.url || '';\n        this.redirected = init?.redirected || false;\n        this.type = init?.type || 'default';\n        this.handleContentLengthHeader();\n    }\n    get ok() {\n        return this.status >= 200 && this.status < 300;\n    }\n    status;\n    statusText;\n    url;\n    redirected;\n    type;\n    clone() {\n        return this;\n    }\n    static error() {\n        return new PonyfillResponse(null, {\n            status: 500,\n            statusText: 'Internal Server Error',\n        });\n    }\n    static redirect(url, status = 302) {\n        if (status < 300 || status > 399) {\n            throw new RangeError('Invalid status code');\n        }\n        return new PonyfillResponse(null, {\n            headers: {\n                location: url,\n            },\n            status,\n        });\n    }\n    static json(data, init) {\n        const bodyInit = JSON.stringify(data);\n        if (!init) {\n            init = {\n                headers: {\n                    'content-type': JSON_CONTENT_TYPE,\n                    'content-length': Buffer.byteLength(bodyInit).toString(),\n                },\n            };\n        }\n        else if (!init.headers) {\n            init.headers = {\n                'content-type': JSON_CONTENT_TYPE,\n                'content-length': Buffer.byteLength(bodyInit).toString(),\n            };\n        }\n        else if ((0, Headers_js_1.isHeadersLike)(init.headers)) {\n            if (!init.headers.has('content-type')) {\n                init.headers.set('content-type', JSON_CONTENT_TYPE);\n            }\n            if (!init.headers.has('content-length')) {\n                init.headers.set('content-length', Buffer.byteLength(bodyInit).toString());\n            }\n        }\n        else if (Array.isArray(init.headers)) {\n            let contentTypeExists = false;\n            let contentLengthExists = false;\n            for (const [key] of init.headers) {\n                if (contentLengthExists && contentTypeExists) {\n                    break;\n                }\n                if (!contentTypeExists && key.toLowerCase() === 'content-type') {\n                    contentTypeExists = true;\n                }\n                else if (!contentLengthExists && key.toLowerCase() === 'content-length') {\n                    contentLengthExists = true;\n                }\n            }\n            if (!contentTypeExists) {\n                init.headers.push(['content-type', JSON_CONTENT_TYPE]);\n            }\n            if (!contentLengthExists) {\n                init.headers.push(['content-length', Buffer.byteLength(bodyInit).toString()]);\n            }\n        }\n        else if (typeof init.headers === 'object') {\n            if (init.headers?.['content-type'] == null) {\n                init.headers['content-type'] = JSON_CONTENT_TYPE;\n            }\n            if (init.headers?.['content-length'] == null) {\n                init.headers['content-length'] = Buffer.byteLength(bodyInit).toString();\n            }\n        }\n        return new PonyfillResponse(bodyInit, init);\n    }\n    [Symbol.toStringTag] = 'Response';\n}\nexports.PonyfillResponse = PonyfillResponse;\n"],"names":["handleRequest","createYoga","schema","typeDefs","readFileSync","join","process","cwd","resolvers","Query","hello","Mutation","echo","_","text","graphqlEndpoint","fetchAPI","Request","Response","context","request","supabaseClient","user","undefined","jwt","createSupabaseClient","authHeader","headers","get","startsWith","split","data","userData","error","userError","auth","getUser","console","supabase","params","Promise","resolve","maskedErrors","maskError","message","path","stack","serverComponentModule.GET","serverComponentModule.POST","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS"],"sourceRoot":""}