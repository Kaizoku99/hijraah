{"version":3,"file":"../app/api/translations/cache/route.js","mappings":"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","sources":["webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+instrumentat_04f370d515cee0be955272f826166073/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/./src/lib/redis.ts","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external node-commonjs \"node:crypto\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/server/route-modules/app-route/module.compiled.js","webpack://@hijraah/web/external commonjs2 \"events\"","webpack://@hijraah/web/../../node_modules/.pnpm/require-in-the-middle@7.5.2/node_modules/require-in-the-middle/ sync","webpack://@hijraah/web/src/app/api/translations/cache/route.ts","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/?15de"],"sourcesContent":["module.exports = require(\"module\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 8963;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","module.exports = require(\"process\");","module.exports = require(\"os\");","module.exports = require(\"util\");","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");","module.exports = require(\"path\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:zlib\");","/**\r\n * Redis Module - Centralized Redis functionality\r\n *\r\n * This module serves as the single source of truth for all Redis operations\r\n * in the application. It provides:\r\n *\r\n * 1. A singleton Redis client instance with connection management\r\n * 2. Cache middleware for Hono API routes\r\n * 3. Translation cache utilities\r\n * 4. Cache invalidation and statistics\r\n * 5. Testing utilities\r\n */\r\n\r\n// Add a mock Cache API for Hono's built-in cache middleware\r\n// This prevents the \"Cache Middleware is not enabled because caches is not defined\" error\r\nif (typeof globalThis.caches === \"undefined\") {\r\n  // Create a minimal mock of the Cache API that Hono expects\r\n  globalThis.caches = {\r\n    open: () => {\r\n      return Promise.resolve({\r\n        match: () => Promise.resolve(null),\r\n        put: () => Promise.resolve(),\r\n        delete: () => Promise.resolve(false),\r\n      });\r\n    },\r\n    has: () => Promise.resolve(false),\r\n    delete: () => Promise.resolve(false),\r\n  } as any;\r\n  console.log(\"Added Cache API mock for Hono middleware\");\r\n}\r\n\r\nimport { Redis } from \"@upstash/redis\";\r\nimport { Context, MiddlewareHandler, Next } from \"hono\";\r\nimport { LRUCache } from \"lru-cache\";\r\n\r\n// Environment variables for Upstash Redis\r\nconst UPSTASH_REDIS_REST_URL = process.env.UPSTASH_REDIS_REST_URL;\r\nconst UPSTASH_REDIS_REST_TOKEN = process.env.UPSTASH_REDIS_REST_TOKEN;\r\n\r\n// Constants for cache stats\r\nconst STATS_KEYS = {\r\n  HITS: \"cache:stats:hits\",\r\n  MISSES: \"cache:stats:misses\",\r\n  KEYS: \"cache:stats:keys\",\r\n};\r\n\r\n// Interface for cache options\r\ninterface CacheOptions {\r\n  ttl?: number; // Time to live in seconds (default: 300 seconds)\r\n  key?: (c: Context<any>) => string; // Custom key generator\r\n  ignoreQuery?: boolean; // Whether to ignore query parameters in the cache key\r\n  varyByAuth?: boolean; // Whether to create different cache entries based on authentication status\r\n  caches?: string[]; // Routes or patterns to cache, if not provided all routes will be cached\r\n}\r\n\r\n// Singleton pattern for Redis client\r\nlet redisClient: Redis | null = null;\r\nlet redisInitializationAttempted = false;\r\n\r\n/**\r\n * Create a new Redis client\r\n */\r\nfunction createRedisClient(): Redis | null {\r\n  console.log(\"[Redis Client] Attempting to use URL:\", UPSTASH_REDIS_REST_URL);\r\n\r\n  if (!UPSTASH_REDIS_REST_URL || !UPSTASH_REDIS_REST_TOKEN) {\r\n    console.warn(\r\n      \"[Redis Client] Missing Redis URL or Token in environment variables. Redis client will not be initialized.\"\r\n    );\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    return new Redis({\r\n      url: UPSTASH_REDIS_REST_URL,\r\n      token: UPSTASH_REDIS_REST_TOKEN,\r\n      retry: {\r\n        retries: 3,\r\n        backoff: (retryCount) => Math.min(retryCount * 50, 1000),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error(\r\n      \"[Redis Client] Error during Redis client instantiation:\",\r\n      error\r\n    );\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get Redis client (singleton pattern)\r\n */\r\nexport function getRedisClient(): Redis | null {\r\n  if (!redisInitializationAttempted) {\r\n    redisClient = createRedisClient();\r\n    if (redisClient) {\r\n      console.log(\"Upstash Redis client initialized successfully.\");\r\n    } else {\r\n      console.warn(\r\n        \"Upstash Redis client could not be initialized. Features requiring Redis may not work.\"\r\n      );\r\n    }\r\n    redisInitializationAttempted = true;\r\n  }\r\n  return redisClient;\r\n}\r\n\r\n/**\r\n * Sets a custom Redis client (for testing)\r\n */\r\nexport function setRedisClient(client: Redis): void {\r\n  redisClient = client;\r\n}\r\n\r\n/**\r\n * Resets the Redis client (for testing)\r\n */\r\nexport function resetRedisClient(): void {\r\n  if (redisClient && typeof (redisClient as any).quit === \"function\") {\r\n    try {\r\n      (redisClient as any).quit();\r\n    } catch (e) {\r\n      console.error(\"Error quitting existing redis client during reset:\", e);\r\n    }\r\n  }\r\n  redisClient = null;\r\n  redisInitializationAttempted = false;\r\n}\r\n\r\n// Export Redis client for direct access\r\nexport const redis: Redis | null = getRedisClient();\r\n\r\n/**\r\n * Health check function for Redis\r\n */\r\nexport async function isRedisHealthy(): Promise<boolean> {\r\n  if (!redis) {\r\n    console.warn(\r\n      \"[isRedisHealthy] Redis client not initialized. Health check returning false.\"\r\n    );\r\n    return false;\r\n  }\r\n  try {\r\n    const result = await redis.ping();\r\n    return result === \"PONG\";\r\n  } catch (error) {\r\n    console.error(\"Redis health check failed:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Translation cache helper functions\r\n */\r\nexport const translationCache = {\r\n  async get(locale: string): Promise<Record<string, any> | null> {\r\n    if (!redis) {\r\n      console.warn(\"[translationCache.get] Redis client not available.\");\r\n      return null;\r\n    }\r\n    try {\r\n      const cached = await redis.get(`i18n:${locale}`);\r\n      return cached ? JSON.parse(cached as string) : null;\r\n    } catch (error) {\r\n      console.error(\"Translation cache get error:\", error);\r\n      return null;\r\n    }\r\n  },\r\n\r\n  async set(\r\n    locale: string,\r\n    translations: Record<string, any>,\r\n    ttl: number = 3600\r\n  ): Promise<void> {\r\n    if (!redis) {\r\n      console.warn(\"[translationCache.set] Redis client not available.\");\r\n      return;\r\n    }\r\n    try {\r\n      await redis.setex(`i18n:${locale}`, ttl, JSON.stringify(translations));\r\n    } catch (error) {\r\n      console.error(\"Translation cache set error:\", error);\r\n    }\r\n  },\r\n\r\n  async invalidate(locale: string): Promise<void> {\r\n    if (!redis) {\r\n      console.warn(\"[translationCache.invalidate] Redis client not available.\");\r\n      return;\r\n    }\r\n    try {\r\n      await redis.del(`i18n:${locale}`);\r\n    } catch (error) {\r\n      console.error(\"Translation cache invalidate error:\", error);\r\n    }\r\n  },\r\n\r\n  async invalidateAll(): Promise<void> {\r\n    if (!redis) {\r\n      console.warn(\r\n        \"[translationCache.invalidateAll] Redis client not available.\"\r\n      );\r\n      return;\r\n    }\r\n    try {\r\n      const keys = await redis.keys(\"i18n:*\");\r\n      if (keys.length > 0) {\r\n        await redis.del(...keys);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Translation cache invalidate all error:\", error);\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Default cache key generator based on URL, path, and user ID\r\n */\r\nfunction defaultKeyGenerator(c: Context<any>): string {\r\n  const url = new URL(c.req.url);\r\n\r\n  // Get user info for personalized caching\r\n  const user = c.get(\"user\");\r\n  const userId = user?.id || \"anonymous\";\r\n\r\n  // Construct path with query parameters\r\n  const pathWithQuery = url.pathname + url.search;\r\n\r\n  return `cache:${userId}:${pathWithQuery}`;\r\n}\r\n\r\n/**\r\n * Middleware for Redis-backed caching with user-specific keys\r\n *\r\n * @deprecated Use redisApiCacheMiddleware instead to avoid conflicts with Hono's built-in cache\r\n * @param options Cache options\r\n * @returns Hono middleware\r\n */\r\nexport function redisCacheMiddleware(\r\n  options: CacheOptions = {}\r\n): MiddlewareHandler<any> {\r\n  // Set default values for options to avoid Hono warnings\r\n  options.caches = options.caches || []; // Always provide a caches array to avoid Hono built-in middleware warnings\r\n\r\n  return async (c: Context<any>, next: Next) => {\r\n    if (!redis) {\r\n      console.warn(\r\n        \"[redisCacheMiddleware] Redis client not available. Skipping cache.\"\r\n      );\r\n      return next();\r\n    }\r\n    // Only cache GET requests\r\n    if (c.req.method !== \"GET\") {\r\n      return next();\r\n    }\r\n\r\n    // Log incoming Cache-Control header\r\n    const requestCacheControl = c.req.header(\"Cache-Control\");\r\n    console.log(\r\n      `[redisCacheMiddleware] Incoming Cache-Control: ${requestCacheControl}`\r\n    );\r\n\r\n    // If caches is not defined, continue with caching\r\n    // This removes the error message and allows the middleware to be used without the caches parameter\r\n    if (options.caches === undefined) {\r\n      // If caches is undefined, we'll cache everything by default\r\n      // No need to log a warning as this is a valid configuration\r\n    }\r\n\r\n    // Generate cache key\r\n    const generateKey = options.key || defaultKeyGenerator;\r\n    const cacheKey = generateKey(c);\r\n\r\n    // Check if cached response exists\r\n    try {\r\n      const cachedData = await redis.get(cacheKey);\r\n\r\n      if (cachedData) {\r\n        // Track cache hit\r\n        await redis.incr(STATS_KEYS.HITS);\r\n\r\n        // Add cache headers\r\n        c.header(\"X-Cache\", \"HIT\");\r\n        c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n        // Use a default TTL of 300 seconds if none is provided\r\n        const maxAge = options.ttl ? options.ttl.toString() : \"300\";\r\n        c.header(\"Cache-Control\", `public, max-age=${maxAge}`);\r\n\r\n        return c.json(JSON.parse(cachedData as string));\r\n      }\r\n\r\n      // Track cache miss\r\n      await redis.incr(STATS_KEYS.MISSES);\r\n    } catch (error) {\r\n      console.error(\"Redis cache read error:\", error);\r\n      // Continue without caching on error\r\n    }\r\n\r\n    // Set header to indicate cache miss\r\n    c.header(\"X-Cache\", \"MISS\");\r\n    c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n    // Continue to the next middleware/handler\r\n    await next();\r\n\r\n    // Store the response in cache only if status is success\r\n    if (c.res && c.res.status >= 200 && c.res.status < 300) {\r\n      try {\r\n        const responseData = await c.res.clone().json();\r\n\r\n        // Store in Redis with TTL\r\n        const ttl = options.ttl || 300; // Default 5 minutes\r\n        await redis.set(cacheKey, JSON.stringify(responseData), { ex: ttl });\r\n\r\n        // Track cache keys\r\n        await redis.sadd(STATS_KEYS.KEYS, cacheKey);\r\n\r\n        // Add cache-related headers to the response\r\n        c.header(\"Cache-Control\", `public, max-age=${ttl}`);\r\n      } catch (error) {\r\n        console.error(\"Redis cache write error:\", error);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Renamed middleware for Redis-backed caching to avoid conflicts with Hono's built-in cache\r\n * Use this version instead of redisCacheMiddleware to prevent \"Cache Middleware is not enabled\" errors\r\n *\r\n * @param options Cache options\r\n * @returns Hono middleware\r\n */\r\nexport function redisApiCacheMiddleware(\r\n  options: CacheOptions = {}\r\n): MiddlewareHandler<any> {\r\n  return async (c: Context<any>, next: Next) => {\r\n    if (!redis) {\r\n      console.warn(\r\n        \"[redisApiCacheMiddleware] Redis client not available. Skipping cache.\"\r\n      );\r\n      return next();\r\n    }\r\n    // Only cache GET requests\r\n    if (c.req.method !== \"GET\") {\r\n      return next();\r\n    }\r\n\r\n    // Log incoming Cache-Control header\r\n    const requestCacheControl = c.req.header(\"Cache-Control\");\r\n    console.log(\r\n      `[redisApiCacheMiddleware] Incoming Cache-Control: ${requestCacheControl}`\r\n    );\r\n\r\n    // Generate cache key\r\n    const generateKey = options.key || defaultKeyGenerator;\r\n    const cacheKey = generateKey(c);\r\n\r\n    // Check if cached response exists\r\n    try {\r\n      const cachedData = await redis.get(cacheKey);\r\n\r\n      if (cachedData) {\r\n        // Track cache hit\r\n        await redis.incr(STATS_KEYS.HITS);\r\n\r\n        // Add cache headers\r\n        c.header(\"X-Cache\", \"HIT\");\r\n        c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n        // Use a default TTL of 300 seconds if none is provided\r\n        const maxAge = options.ttl ? options.ttl.toString() : \"300\";\r\n        c.header(\"Cache-Control\", `public, max-age=${maxAge}`);\r\n\r\n        return c.json(JSON.parse(cachedData as string));\r\n      }\r\n\r\n      // Track cache miss\r\n      await redis.incr(STATS_KEYS.MISSES);\r\n    } catch (error) {\r\n      console.error(\"Redis cache read error:\", error);\r\n      // Continue without caching on error\r\n    }\r\n\r\n    // Set header to indicate cache miss\r\n    c.header(\"X-Cache\", \"MISS\");\r\n    c.header(\"X-Cache-Key\", cacheKey);\r\n\r\n    // Continue to the next middleware/handler\r\n    await next();\r\n\r\n    // Store the response in cache only if status is success\r\n    if (c.res && c.res.status >= 200 && c.res.status < 300) {\r\n      try {\r\n        const responseData = await c.res.clone().json();\r\n\r\n        // Store in Redis with TTL\r\n        const ttl = options.ttl || 300; // Default 5 minutes\r\n        await redis.set(cacheKey, JSON.stringify(responseData), { ex: ttl });\r\n\r\n        // Track cache keys\r\n        await redis.sadd(STATS_KEYS.KEYS, cacheKey);\r\n\r\n        // Add cache-related headers to the response\r\n        c.header(\"Cache-Control\", `public, max-age=${ttl}`);\r\n      } catch (error) {\r\n        console.error(\"Redis cache write error:\", error);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Invalidate cache entries matching a pattern\r\n * @param pattern String pattern to match against cache keys\r\n */\r\nexport async function invalidateRedisCache(pattern: string): Promise<number> {\r\n  if (!redis) {\r\n    console.warn(\"[invalidateRedisCache] Redis client not available.\");\r\n    return 0;\r\n  }\r\n  try {\r\n    // Find all keys matching the pattern\r\n    let cursor = 0;\r\n    const matchingKeys: string[] = [];\r\n\r\n    do {\r\n      // The scan function returns [cursor, keys] where cursor might be a string depending on the implementation\r\n      // Cast it to unknown first then to the type we need\r\n      const scanResult = await redis.scan(cursor, {\r\n        match: pattern,\r\n        count: 100,\r\n      });\r\n      const nextCursor = Number(scanResult[0]);\r\n      const keys = scanResult[1] as string[];\r\n\r\n      cursor = nextCursor;\r\n      matchingKeys.push(...keys);\r\n    } while (cursor !== 0);\r\n\r\n    if (matchingKeys.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Delete all matching keys\r\n    await Promise.all(matchingKeys.map((key) => redis.del(key)));\r\n\r\n    console.log(\r\n      `Invalidated ${matchingKeys.length} cache entries matching \"${pattern}\"`\r\n    );\r\n    return matchingKeys.length;\r\n  } catch (error) {\r\n    console.error(\"Error invalidating cache:\", error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear all cache entries\r\n */\r\nexport async function clearRedisCache(): Promise<number> {\r\n  if (!redis) {\r\n    console.warn(\"[clearRedisCache] Redis client not available.\");\r\n    return 0;\r\n  }\r\n  try {\r\n    // Get all cache keys\r\n    const keys = (await redis.smembers(STATS_KEYS.KEYS)) as string[];\r\n\r\n    if (keys.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Delete all keys and reset stats\r\n    await Promise.all([\r\n      ...keys.map((key) => redis.del(key)),\r\n      redis.del(STATS_KEYS.HITS),\r\n      redis.del(STATS_KEYS.MISSES),\r\n      redis.del(STATS_KEYS.KEYS),\r\n    ]);\r\n\r\n    console.log(`Cleared ${keys.length} cache entries`);\r\n    return keys.length;\r\n  } catch (error) {\r\n    console.error(\"Error clearing cache:\", error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get cache statistics\r\n */\r\nexport async function getRedisStats(): Promise<{\r\n  hits: number;\r\n  misses: number;\r\n  keys: number;\r\n  hitRatio: number;\r\n}> {\r\n  if (!redis) {\r\n    console.warn(\"[getRedisStats] Redis client not available.\");\r\n    return {\r\n      hits: 0,\r\n      misses: 0,\r\n      keys: 0,\r\n      hitRatio: 0,\r\n    };\r\n  }\r\n  try {\r\n    // Get stats from Redis\r\n    const [hits, misses, keys] = (await Promise.all([\r\n      redis.get(STATS_KEYS.HITS),\r\n      redis.get(STATS_KEYS.MISSES),\r\n      redis.scard(STATS_KEYS.KEYS),\r\n    ])) as [string | null, string | null, number];\r\n\r\n    // Parse stats\r\n    const hitCount = hits ? parseInt(hits) : 0;\r\n    const missCount = misses ? parseInt(misses) : 0;\r\n    const total = hitCount + missCount;\r\n\r\n    return {\r\n      hits: hitCount,\r\n      misses: missCount,\r\n      keys: keys || 0,\r\n      hitRatio: total > 0 ? hitCount / total : 0,\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error getting cache stats:\", error);\r\n    return {\r\n      hits: 0,\r\n      misses: 0,\r\n      keys: 0,\r\n      hitRatio: 0,\r\n    };\r\n  }\r\n}\r\n\r\n// --- Start of CacheManager consolidation ---\r\n\r\ninterface CacheManagerOptions {\r\n  ttl?: number; // Default TTL for LRU cache in milliseconds\r\n  maxSize?: number; // Max number of items in LRU cache\r\n  redisKeyPrefix?: string; // Prefix for all keys stored in Redis by this manager\r\n}\r\n\r\nclass CacheManager {\r\n  private redisClientInternal: Redis | null = null;\r\n  private lruCache: LRUCache<string, string>;\r\n  private redisKeyPrefix: string;\r\n\r\n  constructor(options: CacheManagerOptions = {}) {\r\n    this.redisClientInternal = getRedisClient();\r\n    if (!this.redisClientInternal) {\r\n      console.warn(\r\n        \"[CacheManager] Redis client is not available. CacheManager will operate in LRU-only mode.\"\r\n      );\r\n    }\r\n\r\n    this.redisKeyPrefix = options.redisKeyPrefix || \"cacheManager:\";\r\n\r\n    this.lruCache = new LRUCache({\r\n      max: options.maxSize || 500, // Use provided maxSize or default\r\n      ttl: options.ttl || 3600 * 1000, // Use provided ttl (in ms) or default 1 hour\r\n    });\r\n  }\r\n\r\n  private getPrefixedKey(key: string): string {\r\n    return `${this.redisKeyPrefix}${key}`;\r\n  }\r\n\r\n  async get(key: string): Promise<string | null> {\r\n    if (this.redisClientInternal) {\r\n      const prefixedKey = this.getPrefixedKey(key);\r\n      try {\r\n        const value = await this.redisClientInternal.get<string>(prefixedKey);\r\n        if (value !== null && value !== undefined) {\r\n          return value;\r\n        }\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Redis get error for key ${prefixedKey}:`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n    return this.lruCache.get(key) || null;\r\n  }\r\n\r\n  async set(key: string, value: string, ttlInSeconds?: number): Promise<void> {\r\n    if (this.redisClientInternal) {\r\n      const prefixedKey = this.getPrefixedKey(key);\r\n      try {\r\n        await this.redisClientInternal.set(prefixedKey, value, {\r\n          ex: ttlInSeconds || 3600, // Default 1 hour for Redis\r\n        });\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Redis set error for key ${prefixedKey}:`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n    this.lruCache.set(key, value, {\r\n      ttl: ttlInSeconds ? ttlInSeconds * 1000 : undefined,\r\n    });\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    if (this.redisClientInternal) {\r\n      const prefixedKey = this.getPrefixedKey(key);\r\n      try {\r\n        await this.redisClientInternal.del(prefixedKey);\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Redis delete error for key ${prefixedKey}:`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n    this.lruCache.delete(key);\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    // Clear Redis keys matching the prefix\r\n    if (this.redisClientInternal) {\r\n      console.log(\r\n        `CacheManager: Attempting to clear Redis keys with prefix \"${this.redisKeyPrefix}\"...`\r\n      );\r\n      let cursor = 0;\r\n      let keysDeletedCount = 0;\r\n      try {\r\n        do {\r\n          const scanResult = await this.redisClientInternal.scan(cursor, {\r\n            match: `${this.redisKeyPrefix}*`,\r\n            count: 100, // Process in batches\r\n          });\r\n          const nextCursor = Number(scanResult[0]);\r\n          const keys = scanResult[1] as string[];\r\n\r\n          if (keys.length > 0) {\r\n            const deleted = await this.redisClientInternal.del(...keys);\r\n            keysDeletedCount += deleted;\r\n          }\r\n          cursor = nextCursor;\r\n        } while (cursor !== 0);\r\n        console.log(\r\n          `CacheManager: Cleared ${keysDeletedCount} keys from Redis with prefix \"${this.redisKeyPrefix}\".`\r\n        );\r\n      } catch (error) {\r\n        console.error(\r\n          `CacheManager: Error clearing Redis keys with prefix \"${this.redisKeyPrefix}\":`,\r\n          error\r\n        );\r\n      }\r\n    }\r\n\r\n    // Clear LRU cache\r\n    this.lruCache.clear();\r\n    console.log(\"CacheManager: LRU cache cleared.\");\r\n  }\r\n}\r\n\r\n// Export singleton instance of CacheManager\r\n// You can configure the global 'cache' instance here if needed, e.g.:\r\n// export const cache = new CacheManager({\r\n//   redisKeyPrefix: process.env.CACHE_MANAGER_REDIS_PREFIX || 'globalCache:',\r\n//   ttl: process.env.CACHE_MANAGER_LRU_TTL_MS ? parseInt(process.env.CACHE_MANAGER_LRU_TTL_MS) : 3600 * 1000,\r\n//   maxSize: process.env.CACHE_MANAGER_LRU_MAX_SIZE ? parseInt(process.env.CACHE_MANAGER_LRU_MAX_SIZE) : 500,\r\n// });\r\n// For now, using defaults:\r\nexport const cache = new CacheManager();\r\n\r\n// --- End of CacheManager consolidation ---\r\n","module.exports = require(\"node:tls\");","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","module.exports = require(\"node:os\");","module.exports = require(\"node:diagnostics_channel\");","module.exports = require(\"crypto\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"node:crypto\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","module.exports = require(\"node:inspector\");","\"use strict\";\nif (process.env.NEXT_RUNTIME === 'edge') {\n    module.exports = require('next/dist/server/route-modules/app-route/module.js');\n} else {\n    if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n        if (process.env.NODE_ENV === 'development') {\n            module.exports = require('next/dist/compiled/next-server/app-route-experimental.runtime.dev.js');\n        } else if (process.env.TURBOPACK) {\n            module.exports = require('next/dist/compiled/next-server/app-route-turbo-experimental.runtime.prod.js');\n        } else {\n            module.exports = require('next/dist/compiled/next-server/app-route-experimental.runtime.prod.js');\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            module.exports = require('next/dist/compiled/next-server/app-route.runtime.dev.js');\n        } else if (process.env.TURBOPACK) {\n            module.exports = require('next/dist/compiled/next-server/app-route-turbo.runtime.prod.js');\n        } else {\n            module.exports = require('next/dist/compiled/next-server/app-route.runtime.prod.js');\n        }\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map","module.exports = require(\"events\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 96708;\nmodule.exports = webpackEmptyContext;","import { NextRequest } from 'next/server';\r\n\r\nimport { translationCache } from '@/lib/redis';\r\n\r\nexport async function DELETE(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const locale = searchParams.get('locale');\r\n\r\n    if (locale) {\r\n      await translationCache.invalidate(locale);\r\n      return Response.json({ success: true, message: `Cache invalidated for locale: ${locale}` });\r\n    } else {\r\n      await translationCache.invalidateAll();\r\n      return Response.json({ success: true, message: 'All translation caches invalidated' });\r\n    }\r\n  } catch (error) {\r\n    console.error('Cache invalidation error:', error);\r\n    return Response.json(\r\n      { success: false, message: 'Failed to invalidate cache' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const locale = searchParams.get('locale');\r\n\r\n    if (!locale) {\r\n      return Response.json(\r\n        { success: false, message: 'Locale parameter is required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const translations = await translationCache.get(locale);\r\n    return Response.json({\r\n      success: true,\r\n      locale,\r\n      hasCache: !!translations,\r\n      translations\r\n    });\r\n  } catch (error) {\r\n    console.error('Cache check error:', error);\r\n    return Response.json(\r\n      { success: false, message: 'Failed to check cache' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} ","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/translations/cache',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\translations\\\\cache\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/translations/cache/route\",\n        pathname: \"/api/translations/cache\",\n        filename: \"route\",\n        bundlePath: \"app/api/translations/cache/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\translations\\\\cache\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map"],"names":["globalThis","caches","open","Promise","resolve","match","put","delete","has","UPSTASH_REDIS_REST_URL","process","env","UPSTASH_REDIS_REST_TOKEN","STATS_KEYS","HITS","MISSES","KEYS","redisClient","redisInitializationAttempted","getRedisClient","createRedisClient","console","warn","Redis","url","token","retry","retries","backoff","Math","min","retryCount","error","redis","translationCache","get","locale","cached","JSON","parse","set","translations","ttl","setex","stringify","invalidate","del","invalidateAll","keys","length","redisApiCacheMiddleware","options","c","next","req","method","header","cacheKey","generateKey","key","defaultKeyGenerator","URL","user","userId","id","pathWithQuery","pathname","search","cachedData","incr","maxAge","toString","json","res","status","responseData","clone","ex","sadd","CacheManager","constructor","redisClientInternal","redisKeyPrefix","lruCache","LRUCache","max","maxSize","prefixedKey","getPrefixedKey","value","undefined","ttlInSeconds","clear","cursor","scanResult","scan","count","nextCursor","Number","DELETE","request","searchParams","Response","success","message","GET","hasCache","serverComponentModule.GET","serverComponentModule.POST","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS"],"sourceRoot":""}