{"version":3,"file":"4232.js","mappings":"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","sources":["webpack://@hijraah/web/?83b7","webpack://@hijraah/web/./src/lib/supabase/client.ts","webpack://@hijraah/web/./src/types/auth.ts","webpack://@hijraah/web/./src/lib/supabase/server.ts","webpack://@hijraah/web/./src/lib/auth/actions.ts","webpack://@hijraah/web/./src/lib/auth/errors.ts","webpack://@hijraah/web/./src/lib/auth/server.ts","webpack://@hijraah/web/./src/lib/auth/rbac.ts","webpack://@hijraah/web/./src/lib/auth/storage.ts","webpack://@hijraah/web/./src/lib/auth/token.ts","webpack://@hijraah/web/./src/lib/auth/utils.ts","webpack://@hijraah/web/./src/lib/auth/index.ts","webpack://@hijraah/web/../../node_modules/.pnpm/@supabase+realtime-js@2.11.10_bufferutil@4.0.9/node_modules/@supabase/realtime-js/dist/main/ sync"],"sourcesContent":["\nexport { getUser as \"00ba7857acea32aa72b1bc0fcd21663ce535451a40\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\server.ts\"\nexport { isAuthenticated as \"00d88f9d9e78688ae1c02b6ee9e04f9be99f078b7d\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\server.ts\"\nexport { protectAdminRoute as \"40c302fbd5fafb1c6eef85e9f4a8a8fe9c8dbc353f\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\server.ts\"\nexport { protectRoute as \"40c9e439fa61b8f42ac4617276bda6e1e55d7329ed\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\server.ts\"\nexport { protectRoleRoute as \"60802c70b902d4219853bc5bb5a2109b535fbd1a62\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\server.ts\"\nexport { getCurrentUser as \"004ef00139100f75a458518eb8e47b539bb6abdf0f\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { isAuthenticated as \"00b42241dee711bdf5ba266ee343062f1b6983d0f5\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { getSession as \"00e53ec7946e77fe6a32c567fa2272469d994b35ed\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { hasRole as \"4037929defdfc8cd110be3ad6d4131f782cbb0e097\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { protectAdmin as \"4098cf28dca31a4ad4b65f8aa126dcbcdb87114a4d\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { signOut as \"40c7a2d27bf018512e5c3508bc1bd517236d447c19\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { protect as \"40cff310ab1de5540125be6da54450afb3af63b9b6\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { protectRole as \"600e5b9fa4cf6080a9733400e3ad096f770d003bfb\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { updateUserSettings as \"604b6146e8aea40ce223d08163115beec1a7d008af\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { updateUserRole as \"60e8d90a7773bf2ce25719d36403e1499dbe405f78\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\nexport { createUser as \"700548bb8cec088265b3d348b1b94036288494845b\" } from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\actions.ts\"\n","import {\n  createBrowserClient as _createBrowserClient,\n  createServerClient as _createServerClient,\n} from \"@supabase/ssr\";\nimport {\n  createClient as createSupabaseClient,\n  SupabaseClient,\n  type SupabaseClient as CoreSupabaseClient,\n} from \"@supabase/supabase-js\";\nimport fetchPonyfill from \"fetch-ponyfill\";\nimport { useMemo } from \"react\";\n\nimport type { Database } from \"@/types/database.types\";\n\nimport type { ReadonlyRequestCookies } from \"next/dist/server/web/spec-extension/adapters/request-cookies\";\n\n// Get fetch from ponyfill to avoid undici issues like 'Failed to execute 'fetch' on 'Window': Invalid name'\n// See: https://github.com/vercel/next.js/issues/54827\nconst { fetch: ponyfetch } = fetchPonyfill();\n\n// Environment variables for Supabase\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Type alias for clarity\nexport type TypedSupabaseClient = SupabaseClient<Database>;\nexport type TypedSSRSupabaseClient = CoreSupabaseClient<Database>;\n\n// --------------------------------------\n// Shared header builders\n// --------------------------------------\n\n/**\n * Default headers that must accompany every request made via a browser or server client\n * which authenticates with the anonymous public key.  This prevents 401 responses from\n * PostgREST that indicate the `apikey` header is missing.\n */\nconst anonymousHeaders: Record<string, string> | undefined = supabaseAnonKey\n  ? { apikey: supabaseAnonKey }\n  : undefined;\n\n/**\n * Default headers for the service-role client.  These include the service key as both the\n * `apikey` header and (where relevant) the `Authorization` header is still injected by the\n * libraryʼs internal `fetchWithAuth` helper.\n */\nconst serviceHeaders: Record<string, string> | undefined = serviceRoleKey\n  ? { apikey: serviceRoleKey }\n  : undefined;\n\n// Helper function to check essential env vars\nfunction checkPublicEnvVars() {\n  if (process.env.NODE_ENV === \"development\") {\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_URL present?\",\n      !!supabaseUrl\n    );\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_ANON_KEY present?\",\n      !!supabaseAnonKey\n    );\n    console.debug(\n      \"[Supabase Env] SUPABASE_SERVICE_ROLE_KEY present?\",\n      !!serviceRoleKey\n    );\n  }\n  if (!supabaseUrl || !supabaseAnonKey) {\n    console.error(\n      \"Missing environment variables NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY\"\n    );\n    throw new Error(\"Supabase URL or Anon Key is missing.\");\n  }\n}\n\n// --------------------------------------\n// Patch global `fetch` on the **server** to use `ponyfetch`.\n// This avoids the infamous Undici \"Socket closed unexpectedly\" bug on\n// Windows/Node 18-20 without relying on fragile Undici internals.\n// The patch is idempotent and NO-OPs in the browser.\n\nif (typeof window === \"undefined\") {\n  const g = globalThis as any;\n  if (!g.__USING_PONYFETCH__) {\n    g.fetch = ponyfetch as unknown as typeof fetch;\n    g.__USING_PONYFETCH__ = true;\n    console.info(\"[Supabase] Server fetch patched to use ponyfetch ✅\");\n  }\n}\n\n// --- Browser Client (Singleton with Hook) ---\nlet browserClientInstance: TypedSSRSupabaseClient | undefined;\n\nfunction getSupabaseBrowserClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  if (browserClientInstance) {\n    return browserClientInstance;\n  }\n\n  // In the browser we rely on the native `fetch` implementation to ensure that\n  // request headers (apikey/Authorization) are preserved. Injecting a ponyfill\n  // here has proven to strip custom headers in certain edge-cases, leading to\n  // 401 \"No API key found\" responses. Therefore we only attach the required\n  // headers and leave `fetch` undefined so @supabase/ssr uses the global one.\n\n  browserClientInstance = _createBrowserClient<Database>(\n    supabaseUrl!,\n    supabaseAnonKey!,\n    {\n      global: {\n        headers: anonymousHeaders,\n      },\n    }\n  );\n\n  if (typeof window !== \"undefined\") {\n    console.debug(\"[Supabase] anon key present?\", !!supabaseAnonKey);\n  }\n\n  return browserClientInstance;\n}\n\n/**\n * Hook to get a Supabase client instance suitable for Browser/Client Components.\n * Uses a singleton pattern to ensure only one client instance is created.\n * Leverages @supabase/ssr for proper session handling with Next.js App Router.\n * @returns Memoized Supabase client instance for browser usage.\n */\nexport function useSupabaseBrowser(): TypedSSRSupabaseClient {\n  return useMemo(getSupabaseBrowserClient, []);\n}\n\n// This is the primary export for creating a browser client directly\nexport function createClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createBrowserClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    global: {\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Server Client (For Server Components, Route Handlers, Server Actions) ---\n\n/**\n * Creates a Supabase client suitable for use in Server Components, Server Actions,\n * and Route Handlers that require access to cookies.\n * @param cookieStore A ReadonlyRequestCookies instance (e.g., from `next/headers`).\n * @returns Supabase client instance for server-side usage with cookie handling.\n */\nexport function createSupabaseServerClient(\n  cookieStore: ReadonlyRequestCookies\n): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        return cookieStore.get(name)?.value;\n      },\n      set(name: string, value: string, options) {\n        try {\n          cookieStore.set(name, value, options);\n        } catch (error) {\n          console.warn(`Failed to set cookie '${name}':`, error);\n        }\n      },\n      remove(name: string, options) {\n        try {\n          cookieStore.set(name, \"\", options);\n        } catch (error) {\n          console.warn(`Failed to remove cookie '${name}':`, error);\n        }\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Service Role Client (Admin Operations) ---\n\n/**\n * Creates a Supabase client with the service role key for admin operations.\n * WARNING: This client bypasses RLS. Use only in trusted server-side environments\n * with proper authorization checks. NEVER expose the service role key to the browser.\n * @returns Supabase client instance with service_role privileges.\n */\nexport function createSupabaseServiceClient(): TypedSupabaseClient {\n  if (!supabaseUrl || !serviceRoleKey) {\n    console.error(\"Supabase URL or Service Role Key is missing\");\n    throw new Error(\"Supabase service client configuration is incomplete.\");\n  }\n\n  return createSupabaseClient<Database>(supabaseUrl, serviceRoleKey, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: serviceHeaders,\n    },\n  });\n}\n\n// --- Client with Custom Auth Token ---\n\n/**\n * Creates a Supabase client authenticated with a custom JWT token.\n * Useful for scenarios like testing or specific server-to-server interactions.\n * @param authToken JWT token for authentication.\n * @returns Authenticated Supabase client instance.\n */\nexport function createClientWithAuth(authToken: string): TypedSupabaseClient {\n  checkPublicEnvVars();\n  return createSupabaseClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    auth: {\n      persistSession: false,\n      autoRefreshToken: false,\n      detectSessionInUrl: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: {\n        Authorization: `Bearer ${authToken}`,\n        ...(anonymousHeaders ?? {}),\n      },\n    },\n  });\n}\n\n// ======================================\n// EDGE RUNTIME CLIENT\n// ======================================\n\n/**\n * Creates a Supabase client suitable for Edge Runtime environments (e.g., Edge Functions, Middleware).\n * Reads cookies from the Request headers. Requires manual handling for setting/removing cookies\n * via Response headers in the calling Edge function.\n * @param request The Request object from the Edge Function context.\n */\nexport const createEdgeClient = (request: Request): TypedSSRSupabaseClient => {\n  checkPublicEnvVars();\n  const cookieHeader = request.headers.get(\"cookie\") ?? \"\";\n\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        const match = cookieHeader.match(new RegExp(`(^|;)\\s*${name}=([^;]+)`));\n        return match?.[2];\n      },\n      set(name: string, value: string, options) {\n        console.warn(\n          `Attempted to set cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n      remove(name: string, options) {\n        console.warn(\n          `Attempted to remove cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n};\n\n// --- Remove Deprecated Compatibility Exports ---\n\n/**\n * @deprecated Use `useSupabaseBrowser` in Client Components or `createSupabaseServerClient` in Server Components/Actions/Routes.\n */\nexport const getSupabaseClient = getSupabaseBrowserClient;\n\n/**\n * @deprecated Use `createSupabaseServiceClient` for elevated privilege operations.\n */\nexport const createServiceClient = createSupabaseServiceClient;\n\n/**\n * @deprecated Prefer specific client creation (`useSupabaseBrowser`, `createSupabaseServerClient`, `createSupabaseServiceClient`). Avoid direct default export usage.\n */\nexport const supabase = getSupabaseBrowserClient();\n","// This file is the single source of truth for Authentication and RBAC related types\r\n\r\nimport { Session, User, SupabaseClient } from \"@supabase/supabase-js\";\r\n\r\nimport { Database } from \"@/types/database.types\";\r\n\r\n// RBAC Types (from former rbac.ts)\r\nexport type Permission = string;\r\n\r\nexport interface Role {\r\n  name: string;\r\n  description?: string;\r\n  permissions: Permission[];\r\n  inherits?: string[];\r\n}\r\n\r\nexport interface RBACOptions {\r\n  roles?: Record<string, Role>;\r\n  superAdminRole?: string;\r\n  enableCache?: boolean;\r\n  extractRoles?: (user: ExtendedUser) => string[];\r\n}\r\n\r\n// Auth Types (from former src/lib/auth/types.ts)\r\nexport interface UserSettings {\r\n  theme: string;\r\n  language: string;\r\n  emailNotifications: boolean;\r\n  documentReminders: boolean;\r\n  applicationUpdates: boolean;\r\n  twoFactorAuth: boolean;\r\n}\r\n\r\nexport type ExtendedUser = User & {\r\n  fullName: string;\r\n  avatarUrl: string;\r\n  role: Database[\"public\"][\"Enums\"][\"user_role\"]; // Updated to use the enum from database\r\n  isAdmin?: boolean; // Consider deriving from a hasPermission('admin.access') or similar\r\n  settings?: UserSettings;\r\n  hasTwoFactorAuth?: () => boolean;\r\n  updateSettings?: (settings: Partial<UserSettings>) => ExtendedUser;\r\n  toObject?: () => Record<string, any>;\r\n};\r\n\r\nexport type AuthProvider = \"google\" | \"github\" | \"email\" | \"phone\" | \"azure\"; // Added azure from old types.ts\r\n\r\nexport interface AuthContextType {\r\n  user: ExtendedUser | null;\r\n  session: Session | null;\r\n  isLoading: boolean;\r\n  isAuthenticated: boolean;\r\n  error: any | null; // Consider a more specific error type\r\n  signIn: (provider: AuthProvider, options?: any) => Promise<void>;\r\n  signOut: () => Promise<void>;\r\n  refreshSession: () => Promise<void>;\r\n  signUp: (options: {\r\n    email: string;\r\n    password: string;\r\n    fullName?: string;\r\n    redirectTo?: string;\r\n  }) => Promise<any>; // Consider specific result type\r\n  resetPassword: (email: string, redirectTo?: string) => Promise<boolean>;\r\n  updatePassword: (password: string) => Promise<boolean>;\r\n  hasPermission?: (permission: Permission) => boolean; // Added from old types.ts\r\n}\r\n\r\nexport interface AuthMiddlewareContext {\r\n  user: ExtendedUser | null;\r\n  session: Session | null;\r\n  isAuthenticated: boolean;\r\n  supabase: SupabaseClient<Database>; // Use SupabaseClient<Database> here\r\n  hasPermission?: (permission: Permission) => boolean;\r\n}\r\n\r\n// Utility function (can live here or be moved to a helpers file if it grows)\r\nexport function createExtendedUser(user: User | null): ExtendedUser | null {\r\n  if (!user) return null;\r\n\r\n  const role = (user.user_metadata?.role ||\r\n    \"client\") as Database[\"public\"][\"Enums\"][\"user_role\"];\r\n  const isAdmin = role === \"admin\"; // This isAdmin flag should be used cautiously, prefer RBAC checks\r\n\r\n  const settings: UserSettings = {\r\n    theme: user.user_metadata?.settings_theme || \"system\",\r\n    language: user.user_metadata?.settings_language || \"en\",\r\n    emailNotifications:\r\n      user.user_metadata?.settings_emailNotifications || false,\r\n    documentReminders: user.user_metadata?.settings_documentReminders || false,\r\n    applicationUpdates:\r\n      user.user_metadata?.settings_applicationUpdates || false,\r\n    twoFactorAuth: user.user_metadata?.settings_twoFactorAuth || false,\r\n  };\r\n\r\n  const extendedUser: ExtendedUser = {\r\n    ...user,\r\n    fullName:\r\n      user.user_metadata?.full_name || user.email?.split(\"@\")[0] || \"User\",\r\n    avatarUrl: user.user_metadata?.avatar_url || \"\",\r\n    role,\r\n    isAdmin,\r\n    settings,\r\n    hasTwoFactorAuth: () => settings.twoFactorAuth,\r\n    updateSettings: (newSettings: Partial<UserSettings>) => {\r\n      const updatedSettings = { ...settings, ...newSettings };\r\n      return createExtendedUser({\r\n        ...user,\r\n        user_metadata: {\r\n          ...user.user_metadata,\r\n          settings_theme: updatedSettings.theme,\r\n          settings_language: updatedSettings.language,\r\n          settings_emailNotifications: updatedSettings.emailNotifications,\r\n          settings_documentReminders: updatedSettings.documentReminders,\r\n          settings_applicationUpdates: updatedSettings.applicationUpdates,\r\n          settings_twoFactorAuth: updatedSettings.twoFactorAuth,\r\n        },\r\n      }) as ExtendedUser;\r\n    },\r\n    toObject: () => ({\r\n      id: user.id,\r\n      email: user.email,\r\n      fullName:\r\n        user.user_metadata?.full_name || user.email?.split(\"@\")[0] || \"User\",\r\n      avatarUrl: user.user_metadata?.avatar_url || \"\",\r\n      role,\r\n      settings,\r\n    }),\r\n  };\r\n\r\n  return extendedUser;\r\n}\r\n\r\n// Types from the old src/types/types.ts that were not in src/lib/auth/types.ts\r\n// (Excluding duplicates like ExtendedUser, AuthProvider which are merged above)\r\n\r\nexport interface AuthResult {\r\n  session: Session | null;\r\n  user: User | null; // Should this be ExtendedUser?\r\n  error: Error | null;\r\n}\r\n\r\nexport interface AuthState {\r\n  user: ExtendedUser | null;\r\n  session: Session | null;\r\n  isLoading: boolean;\r\n  isAuthenticated: boolean;\r\n  error?: Error | null;\r\n}\r\n\r\nexport interface LoginCredentials {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nexport interface SignUpData {\r\n  email: string;\r\n  password: string;\r\n  fullName?: string;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface AuthOptions {\r\n  redirectTo?: string;\r\n  email?: string;\r\n  metadata?: Record<string, any>;\r\n  provider?: {\r\n    id: string;\r\n    scopes?: string;\r\n  };\r\n}\r\n\r\nexport type AuthChangeCallback = (\r\n  session: Session | null,\r\n  user: User | null // Should this be ExtendedUser?\r\n) => void | Promise<void>;\r\n\r\nexport interface InitOptions {\r\n  refreshSession?: boolean;\r\n  autoRecoverSession?: boolean;\r\n  refreshOptions?: {\r\n    enableAutoRefresh?: boolean;\r\n    refreshThreshold?: number;\r\n  };\r\n}\r\n","/**\r\n * @deprecated This module is deprecated. Please import from '@/_infrastructure/supabase/server' instead.\r\n */\r\n\r\nimport \"server-only\"; // Ensure this module only runs on the server\r\n\r\nimport { cookies } from \"next/headers\";\r\n\r\nimport {\r\n  createSupabaseServerClient as _createServerClient, // Renamed import\r\n  createSupabaseServiceClient, // Direct import\r\n  type TypedSSRSupabaseClient, // Import the type\r\n  type TypedSupabaseClient, // Import the base client type if needed elsewhere\r\n} from \"./client\";\r\n\r\nimport type { ReadonlyRequestCookies } from \"next/dist/server/web/spec-extension/adapters/request-cookies\"; // Import the specific type\r\n\r\n/**\r\n * Get a Supabase client for server-side operations (Server Components, Route Handlers, Server Actions)\r\n * This client uses cookies for authentication.\r\n * @returns Supabase client instance for server-side usage.\r\n */\r\nexport async function getSupabaseServerClient(): Promise<TypedSSRSupabaseClient> {\r\n  const cookieStore = await cookies();\r\n  return _createServerClient(cookieStore);\r\n}\r\n\r\n/**\r\n * Alias for getSupabaseServerClient for convenience.\r\n * @returns Supabase client instance for server-side usage.\r\n */\r\nexport const createClient = getSupabaseServerClient;\r\n\r\n// Export the specific client creation functions as well\r\nexport {\r\n  _createServerClient as createServerSupabaseClient, // Keep original export name if needed elsewhere\r\n  createSupabaseServiceClient, // Export service client\r\n};\r\n\r\n// Optional: Export the type if needed by consumers\r\nexport type { TypedSSRSupabaseClient };\r\n","\"use server\";\r\n\r\nimport { revalidatePath } from \"next/cache\";\r\nimport { redirect } from \"next/navigation\";\r\n\r\nimport { verifyUserIsAdmin } from \"@/lib/actions/admin\";\r\nimport { createSupabaseServiceClient } from \"@/lib/supabase/client\";\r\nimport { createClient } from \"@/lib/supabase/server\";\r\n\r\nimport { ExtendedUser, createExtendedUser } from \"@/types/auth\";\r\nimport { Database } from \"@/types/database.types\";\r\n\r\ntype UserRole = Database[\"public\"][\"Enums\"][\"user_role\"];\r\n\r\n/**\r\n * Get the current authenticated session\r\n * @returns The current session or null if not authenticated\r\n */\r\nexport async function getSession() {\r\n  const supabase = await createClient();\r\n\r\n  // First verify the user exists using getUser (more secure)\r\n  const {\r\n    data: { user },\r\n    error: userError,\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (userError || !user) {\r\n    return null;\r\n  }\r\n\r\n  // Then get the session\r\n  const {\r\n    data: { session },\r\n    error,\r\n  } = await supabase.auth.getSession();\r\n\r\n  if (error) {\r\n    console.error(\"Error getting session:\", error);\r\n    return null;\r\n  }\r\n\r\n  return session;\r\n}\r\n\r\n/**\r\n * Get the current authenticated user\r\n * @returns The current user or null if not authenticated\r\n */\r\nexport async function getCurrentUser(): Promise<ExtendedUser | null> {\r\n  const supabase = await createClient();\r\n\r\n  const {\r\n    data: { user },\r\n    error,\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (error || !user) {\r\n    return null;\r\n  }\r\n\r\n  return createExtendedUser(user);\r\n}\r\n\r\n/**\r\n * Check if the current user is authenticated\r\n * @returns True if authenticated, false otherwise\r\n */\r\nexport async function isAuthenticated() {\r\n  const session = await getSession();\r\n  return !!session;\r\n}\r\n\r\n/**\r\n * Check if the current user has a specific role\r\n * @param role The role to check\r\n * @returns True if user has the role, false otherwise\r\n */\r\nexport async function hasRole(role: UserRole) {\r\n  const user = await getCurrentUser();\r\n  return user?.role === role;\r\n}\r\n\r\n/**\r\n * Sign out the current user\r\n * @param redirectTo Optional path to redirect to after sign out\r\n */\r\nexport async function signOut(redirectTo: string = \"/login\") {\r\n  const supabase = await createClient();\r\n  await supabase.auth.signOut();\r\n\r\n  revalidatePath(\"/\", \"layout\");\r\n\r\n  if (redirectTo) {\r\n    redirect(redirectTo);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new user with email and password (admin only)\r\n * @param email User email\r\n * @param password User password\r\n * @param userData Additional user data\r\n * @returns The created user or null if failed\r\n */\r\nexport async function createUser(\r\n  email: string,\r\n  password: string,\r\n  userData?: {\r\n    fullName?: string;\r\n    role?: string;\r\n    avatarUrl?: string;\r\n    settings?: Record<string, any>;\r\n  }\r\n) {\r\n  const supabase = createSupabaseServiceClient();\r\n\r\n  // Prepare user metadata\r\n  const userMetadata: Record<string, any> = {\r\n    full_name: userData?.fullName,\r\n    role: userData?.role || \"user\",\r\n    avatar_url: userData?.avatarUrl,\r\n  };\r\n\r\n  // Add settings if provided\r\n  if (userData?.settings) {\r\n    Object.entries(userData.settings).forEach(([key, value]) => {\r\n      userMetadata[`settings_${key}`] = value;\r\n    });\r\n  }\r\n\r\n  const { data, error } = await supabase.auth.admin.createUser({\r\n    email,\r\n    password,\r\n    email_confirm: true,\r\n    user_metadata: userMetadata,\r\n  });\r\n\r\n  if (error) {\r\n    console.error(\"Error creating user:\", error);\r\n    return null;\r\n  }\r\n\r\n  return createExtendedUser(data.user);\r\n}\r\n\r\n/**\r\n * Update a user's role (admin only)\r\n * @param userId The user ID to update\r\n * @param role The new role\r\n * @returns True if successful, false otherwise\r\n */\r\nexport async function updateUserRole(userId: string, role: UserRole) {\r\n  const supabase = createSupabaseServiceClient();\r\n\r\n  const { error } = await supabase.auth.admin.updateUserById(userId, {\r\n    user_metadata: {\r\n      role,\r\n    },\r\n  });\r\n\r\n  if (error) {\r\n    console.error(\"Error updating user role:\", error);\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Update a user's settings (admin or self)\r\n * @param userId The user ID to update\r\n * @param settings The settings to update\r\n * @returns True if successful, false otherwise\r\n */\r\nexport async function updateUserSettings(\r\n  userId: string,\r\n  settings: Record<string, any>\r\n) {\r\n  const supabase = createSupabaseServiceClient();\r\n\r\n  // Format settings for metadata storage\r\n  const formattedSettings: Record<string, any> = {};\r\n  Object.entries(settings).forEach(([key, value]) => {\r\n    formattedSettings[`settings_${key}`] = value;\r\n  });\r\n\r\n  const { error } = await supabase.auth.admin.updateUserById(userId, {\r\n    user_metadata: formattedSettings,\r\n  });\r\n\r\n  if (error) {\r\n    console.error(\"Error updating user settings:\", error);\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Protect server components or routes from unauthorized access\r\n * @param redirectTo Path to redirect to if not authenticated\r\n */\r\nexport async function protect(redirectTo = \"/login\") {\r\n  const session = await getSession();\r\n\r\n  if (!session) {\r\n    redirect(redirectTo);\r\n  }\r\n}\r\n\r\n/**\r\n * Protect routes that require specific role\r\n * @param role Required role\r\n * @param redirectTo Path to redirect to if not authorized\r\n */\r\nexport async function protectRole(role: string, redirectTo = \"/unauthorized\") {\r\n  await protect();\r\n\r\n  const hasUserRole = await hasRole(role as UserRole);\r\n\r\n  if (!hasUserRole) {\r\n    redirect(redirectTo);\r\n  }\r\n}\r\n\r\n/**\r\n * Protect routes that require admin access\r\n * @param redirectTo Path to redirect to if not authorized\r\n */\r\nexport async function protectAdmin(redirectTo = \"/unauthorized\") {\r\n  const user = await getCurrentUser();\r\n\r\n  if (!user || !user.isAdmin) {\r\n    redirect(redirectTo);\r\n  }\r\n}\r\n","import { AuthError as SupabaseAuthError } from '@supabase/supabase-js';\r\n\r\n/**\r\n * Base class for all authentication errors\r\n */\r\nexport class AuthError extends Error {\r\n  public code: string;\r\n  public status?: number;\r\n  public originalError?: Error;\r\n\r\n  constructor(message: string, code: string, originalError?: Error, status?: number) {\r\n    super(message);\r\n    this.name = 'AuthError';\r\n    this.code = code;\r\n    this.status = status;\r\n    this.originalError = originalError;\r\n  }\r\n\r\n  /**\r\n   * Create a JSON representation of the error\r\n   */\r\n  toJSON() {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      code: this.code,\r\n      status: this.status\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create error response for API routes\r\n   */\r\n  toResponse() {\r\n    return new Response(\r\n      JSON.stringify({\r\n        error: {\r\n          message: this.message,\r\n          code: this.code\r\n        }\r\n      }),\r\n      {\r\n        status: this.status || 500,\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when user is not authenticated\r\n */\r\nexport class UnauthorizedError extends AuthError {\r\n  constructor(message = 'Authentication required', originalError?: Error) {\r\n    super(message, 'auth/unauthorized', originalError, 401);\r\n    this.name = 'UnauthorizedError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when user doesn't have sufficient permissions\r\n */\r\nexport class ForbiddenError extends AuthError {\r\n  constructor(message = 'Insufficient permissions', originalError?: Error) {\r\n    super(message, 'auth/forbidden', originalError, 403);\r\n    this.name = 'ForbiddenError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when there's an issue with session management\r\n */\r\nexport class SessionError extends AuthError {\r\n  constructor(message = 'Session error', originalError?: Error) {\r\n    super(message, 'auth/session-error', originalError, 400);\r\n    this.name = 'SessionError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when credentials are invalid\r\n */\r\nexport class InvalidCredentialsError extends AuthError {\r\n  constructor(message = 'Invalid credentials', originalError?: Error) {\r\n    super(message, 'auth/invalid-credentials', originalError, 401);\r\n    this.name = 'InvalidCredentialsError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown for user-related operations failures\r\n */\r\nexport class UserOperationError extends AuthError {\r\n  constructor(message = 'User operation failed', originalError?: Error) {\r\n    super(message, 'auth/user-operation-failed', originalError, 400);\r\n    this.name = 'UserOperationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown for configuration issues\r\n */\r\nexport class ConfigurationError extends AuthError {\r\n  constructor(message = 'Authentication configuration error', originalError?: Error) {\r\n    super(message, 'auth/configuration-error', originalError, 500);\r\n    this.name = 'ConfigurationError';\r\n  }\r\n}\r\n\r\n// Interface for any error with status code\r\ninterface ErrorWithStatus extends Error {\r\n  status?: number;\r\n  code?: string | number;\r\n}\r\n\r\n/**\r\n * Converts Supabase errors to our custom error types\r\n */\r\nexport function handleSupabaseError(error: Error | SupabaseAuthError | ErrorWithStatus | null | undefined): AuthError {\r\n  if (!error) {\r\n    return new AuthError('Unknown error', 'auth/unknown');\r\n  }\r\n\r\n  // Errors with status property\r\n  const errorWithStatus = error as ErrorWithStatus;\r\n  if (errorWithStatus.status) {\r\n    switch (errorWithStatus.status) {\r\n      case 401:\r\n        return new UnauthorizedError(error.message, error);\r\n      case 403:\r\n        return new ForbiddenError(error.message, error);\r\n      case 400:\r\n        if (error.message.includes('credentials')) {\r\n          return new InvalidCredentialsError(error.message, error);\r\n        }\r\n        if (error.message.includes('session')) {\r\n          return new SessionError(error.message, error);\r\n        }\r\n        return new UserOperationError(error.message, error);\r\n      default:\r\n        return new AuthError(\r\n          error.message, \r\n          `auth/error-${errorWithStatus.status || 'unknown'}`, \r\n          error, \r\n          errorWithStatus.status\r\n        );\r\n    }\r\n  }\r\n\r\n  // Generic errors\r\n  return new AuthError(error.message || 'Unknown error', 'auth/unknown-error', error);\r\n}\r\n\r\n/**\r\n * Helper to safely handle auth operations with consistent error handling\r\n */\r\nexport async function safeAuthOperation<T>(\r\n  operation: () => Promise<T>,\r\n  errorMessage = 'Authentication operation failed'\r\n): Promise<T> {\r\n  try {\r\n    return await operation();\r\n  } catch (error) {\r\n    throw handleSupabaseError(error as Error);\r\n  }\r\n}\r\n\r\n/**\r\n * Middleware for handling auth errors in API routes\r\n */\r\nexport function createAuthErrorHandler() {\r\n  return (error: unknown) => {\r\n    if (error instanceof AuthError) {\r\n      return error.toResponse();\r\n    }\r\n    \r\n    const authError = handleSupabaseError(error as Error);\r\n    return authError.toResponse();\r\n  };\r\n} ","\"use server\";\r\n\r\nimport { revalidatePath } from \"next/cache\";\r\nimport { redirect } from \"next/navigation\";\r\n\r\nimport { createClient } from \"@/lib/supabase/server\";\r\n\r\nimport { ExtendedUser, createExtendedUser } from \"@/types/auth\";\r\n\r\n/**\r\n * Get the current authenticated user for server components\r\n */\r\nexport async function getUser(): Promise<ExtendedUser | null> {\r\n  const supabase = await createClient();\r\n\r\n  try {\r\n    const {\r\n      data: { user },\r\n      error,\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (error || !user) {\r\n      return null;\r\n    }\r\n\r\n    // Use the shared utility to create an extended user\r\n    return createExtendedUser(user);\r\n  } catch (error) {\r\n    console.error(\"Error getting user in server component:\", error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a user is authenticated in server components\r\n */\r\nexport async function isAuthenticated(): Promise<boolean> {\r\n  const user = await getUser();\r\n  return !!user;\r\n}\r\n\r\n/**\r\n * Protect a route - redirect to login if not authenticated\r\n */\r\nexport async function protectRoute(\r\n  redirectTo: string = \"/login\"\r\n): Promise<ExtendedUser> {\r\n  const user = await getUser();\r\n\r\n  if (!user) {\r\n    redirect(redirectTo);\r\n  }\r\n\r\n  return user;\r\n}\r\n\r\n/**\r\n * Protect a route requiring a specific role\r\n */\r\nexport async function protectRoleRoute(\r\n  role: string,\r\n  redirectTo: string = \"/unauthorized\"\r\n): Promise<ExtendedUser> {\r\n  const user = await protectRoute();\r\n\r\n  if (user.role !== role && user.role !== \"admin\") {\r\n    redirect(redirectTo);\r\n  }\r\n\r\n  return user;\r\n}\r\n\r\n/**\r\n * Protect a route requiring admin role\r\n */\r\nexport async function protectAdminRoute(\r\n  redirectTo: string = \"/unauthorized\"\r\n): Promise<ExtendedUser> {\r\n  const user = await protectRoute();\r\n\r\n  if (!user.isAdmin) {\r\n    redirect(redirectTo);\r\n  }\r\n\r\n  return user;\r\n}\r\n","import { ForbiddenError } from \"./errors\";\r\nimport { ExtendedUser } from \"./types\";\r\n\r\n/**\r\n * Permission string type\r\n */\r\nexport type Permission = string;\r\n\r\n/**\r\n * Role definition with permissions and optional inheritance\r\n */\r\nexport interface Role {\r\n  /**\r\n   * Name of the role\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Description of the role\r\n   */\r\n  description?: string;\r\n\r\n  /**\r\n   * Array of permissions assigned to this role\r\n   */\r\n  permissions: Permission[];\r\n\r\n  /**\r\n   * Optional array of parent role names this role inherits from\r\n   */\r\n  inherits?: string[];\r\n}\r\n\r\n/**\r\n * Configuration options for the RBAC manager\r\n */\r\nexport interface RBACOptions {\r\n  /**\r\n   * Default roles and their permissions\r\n   */\r\n  roles?: Record<string, Role>;\r\n\r\n  /**\r\n   * Name of super admin role that has all permissions\r\n   * @default 'admin'\r\n   */\r\n  superAdminRole?: string;\r\n\r\n  /**\r\n   * Enable permission caching for performance\r\n   * @default true\r\n   */\r\n  enableCache?: boolean;\r\n\r\n  /**\r\n   * Custom function to extract roles from a user\r\n   */\r\n  extractRoles?: (user: ExtendedUser) => string[];\r\n}\r\n\r\n/**\r\n * Default RBAC options\r\n */\r\nconst defaultRBACOptions: RBACOptions = {\r\n  roles: {},\r\n  superAdminRole: \"admin\",\r\n  enableCache: true,\r\n};\r\n\r\n/**\r\n * Role-Based Access Control Manager\r\n * TODO: The current superAdminRole check (userRoles.includes(this.superAdminRole))\r\n * relies on user.role from metadata (via extractRoles default). This may not align with the\r\n * authoritative admin status determined by verifyUserIsAdmin(userId) which checks the\r\n * 'admin_users' table. For true unification, this superAdmin check should eventually be\r\n * reconciled with the authoritative server-side verification. This might involve making RBAC\r\n * methods async, passing a verified admin status, or other architectural changes.\r\n * For now, critical admin checks should use the useIsAdmin() hook or verifyUserIsAdmin() action directly.\r\n */\r\nexport class RBACManager {\r\n  private roles: Record<string, Role>;\r\n  private superAdminRole: string;\r\n  private enableCache: boolean;\r\n  private extractRoles: (user: ExtendedUser) => string[];\r\n  private permissionCache: Map<string, Set<Permission>> = new Map();\r\n\r\n  constructor(options: RBACOptions = {}) {\r\n    const config = { ...defaultRBACOptions, ...options };\r\n    this.roles = config.roles || {};\r\n    this.superAdminRole = config.superAdminRole || \"admin\";\r\n    this.enableCache = config.enableCache ?? true;\r\n    this.extractRoles =\r\n      config.extractRoles ||\r\n      ((user: ExtendedUser) => {\r\n        return [user.role || \"user\"];\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Define a new role with permissions\r\n   */\r\n  defineRole(role: Role): void {\r\n    this.roles[role.name] = role;\r\n\r\n    // Clear cache if caching is enabled\r\n    if (this.enableCache) {\r\n      this.permissionCache.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Define multiple roles at once\r\n   */\r\n  defineRoles(roles: Record<string, Role>): void {\r\n    this.roles = { ...this.roles, ...roles };\r\n\r\n    // Clear cache if caching is enabled\r\n    if (this.enableCache) {\r\n      this.permissionCache.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all permissions for a given role\r\n   */\r\n  private getRolePermissions(\r\n    roleName: string,\r\n    visited: Set<string> = new Set()\r\n  ): Set<Permission> {\r\n    // Avoid circular dependencies\r\n    if (visited.has(roleName)) {\r\n      return new Set();\r\n    }\r\n\r\n    // Mark this role as visited\r\n    visited.add(roleName);\r\n\r\n    // Get the role definition\r\n    const role = this.roles[roleName];\r\n    if (!role) {\r\n      return new Set();\r\n    }\r\n\r\n    // Start with this role's permissions\r\n    const permissions = new Set(role.permissions);\r\n\r\n    // Add inherited permissions\r\n    if (role.inherits && role.inherits.length > 0) {\r\n      for (const parentRole of role.inherits) {\r\n        const parentPermissions = this.getRolePermissions(parentRole, visited);\r\n        parentPermissions.forEach((permission) => permissions.add(permission));\r\n      }\r\n    }\r\n\r\n    return permissions;\r\n  }\r\n\r\n  /**\r\n   * Get all permissions for a user based on their roles\r\n   */\r\n  getUserPermissions(user: ExtendedUser | null): Set<Permission> {\r\n    if (!user) {\r\n      return new Set();\r\n    }\r\n\r\n    // Extract roles from user\r\n    const userRoles = this.extractRoles(user);\r\n\r\n    // Check for super admin role\r\n    if (userRoles.includes(this.superAdminRole)) {\r\n      return new Set([\"*\"]); // Special wildcard permission for super admins\r\n    }\r\n\r\n    // Check the cache first if enabled\r\n    if (this.enableCache) {\r\n      const cacheKey = userRoles.sort().join(\",\");\r\n      const cachedPermissions = this.permissionCache.get(cacheKey);\r\n\r\n      if (cachedPermissions) {\r\n        return cachedPermissions;\r\n      }\r\n    }\r\n\r\n    // Collect all permissions from all roles\r\n    const allPermissions = new Set<Permission>();\r\n    for (const roleName of userRoles) {\r\n      const rolePermissions = this.getRolePermissions(roleName);\r\n      rolePermissions.forEach((permission) => allPermissions.add(permission));\r\n    }\r\n\r\n    // Save to cache if enabled\r\n    if (this.enableCache && userRoles.length > 0) {\r\n      const cacheKey = userRoles.sort().join(\",\");\r\n      this.permissionCache.set(cacheKey, allPermissions);\r\n    }\r\n\r\n    return allPermissions;\r\n  }\r\n\r\n  /**\r\n   * Check if the user has a specific role\r\n   */\r\n  hasRole(user: ExtendedUser | null, roleName: string): boolean {\r\n    if (!user) return false;\r\n\r\n    const userRoles = this.extractRoles(user);\r\n    return (\r\n      userRoles.includes(roleName) || userRoles.includes(this.superAdminRole)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if the user has a specific permission\r\n   */\r\n  hasPermission(user: ExtendedUser | null, permission: Permission): boolean {\r\n    if (!user) return false;\r\n\r\n    // Get all permissions for the user\r\n    const permissions = this.getUserPermissions(user);\r\n\r\n    // Super admin has all permissions\r\n    if (permissions.has(\"*\")) return true;\r\n\r\n    // Check exact permission\r\n    if (permissions.has(permission)) return true;\r\n\r\n    // Check wildcard permissions\r\n    const parts = permission.split(\":\");\r\n    for (let i = 1; i <= parts.length; i++) {\r\n      const wildcardPermission = [...parts.slice(0, i), \"*\"].join(\":\");\r\n      if (permissions.has(wildcardPermission)) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if the user has any of the specified permissions\r\n   */\r\n  hasAnyPermission(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): boolean {\r\n    return permissions.some((permission) =>\r\n      this.hasPermission(user, permission)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if the user has all of the specified permissions\r\n   */\r\n  hasAllPermissions(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): boolean {\r\n    return permissions.every((permission) =>\r\n      this.hasPermission(user, permission)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Enforce a permission requirement, throwing an error if not authorized\r\n   */\r\n  enforcePermission(user: ExtendedUser | null, permission: Permission): void {\r\n    if (!this.hasPermission(user, permission)) {\r\n      throw new ForbiddenError(`Missing required permission: ${permission}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce that user has any of the specified permissions\r\n   */\r\n  enforceAnyPermission(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): void {\r\n    if (!this.hasAnyPermission(user, permissions)) {\r\n      throw new ForbiddenError(\r\n        `Missing at least one of the required permissions: ${permissions.join(\", \")}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce that user has all of the specified permissions\r\n   */\r\n  enforceAllPermissions(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): void {\r\n    if (!this.hasAllPermissions(user, permissions)) {\r\n      throw new ForbiddenError(\r\n        `Missing some of the required permissions: ${permissions.join(\", \")}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a permission string from resource and action\r\n   */\r\n  createPermission(resource: string, action: string): Permission {\r\n    return `${resource}:${action}`;\r\n  }\r\n}\r\n\r\n// Singleton RBAC manager instance\r\nlet rbacManager: RBACManager | null = null;\r\n\r\n/**\r\n * Get the RBAC manager instance, creating it if it doesn't exist\r\n */\r\nexport function getRBACManager(options?: RBACOptions): RBACManager {\r\n  if (!rbacManager) {\r\n    rbacManager = new RBACManager(options);\r\n  }\r\n  return rbacManager;\r\n}\r\n\r\n/**\r\n * Create a permission string from resource and action\r\n */\r\nexport function createPermission(resource: string, action: string): Permission {\r\n  return `${resource}:${action}`;\r\n}\r\n\r\n/**\r\n * Check if the user has a specific permission\r\n */\r\nexport function hasPermission(\r\n  user: ExtendedUser | null,\r\n  permission: Permission\r\n): boolean {\r\n  return getRBACManager().hasPermission(user, permission);\r\n}\r\n\r\n/**\r\n * Enforce a permission requirement, throwing an error if not authorized\r\n */\r\nexport function enforcePermission(\r\n  user: ExtendedUser | null,\r\n  permission: Permission\r\n): void {\r\n  return getRBACManager().enforcePermission(user, permission);\r\n}\r\n","import { Session } from '@supabase/supabase-js';\r\n\r\n/**\r\n * Interface for storage providers\r\n */\r\nexport interface StorageProvider {\r\n  /**\r\n   * Get item from storage\r\n   */\r\n  getItem(key: string): string | null;\r\n  \r\n  /**\r\n   * Set item in storage\r\n   */\r\n  setItem(key: string, value: string): void;\r\n  \r\n  /**\r\n   * Remove item from storage\r\n   */\r\n  removeItem(key: string): void;\r\n}\r\n\r\n/**\r\n * Storage manager options\r\n */\r\nexport interface StorageManagerOptions {\r\n  /**\r\n   * Prefix for storage keys\r\n   */\r\n  keyPrefix?: string;\r\n\r\n  /**\r\n   * Options for cookie storage provider\r\n   */\r\n  cookieOptions?: CookieOptions;\r\n}\r\n\r\n/**\r\n * Cookie storage options\r\n */\r\nexport interface CookieOptions {\r\n  /**\r\n   * Cookie domain\r\n   */\r\n  domain?: string;\r\n\r\n  /**\r\n   * Cookie path\r\n   */\r\n  path?: string;\r\n\r\n  /**\r\n   * Whether cookie should be secure\r\n   */\r\n  secure?: boolean;\r\n\r\n  /**\r\n   * Same site cookie policy\r\n   */\r\n  sameSite?: 'strict' | 'lax' | 'none';\r\n\r\n  /**\r\n   * Max cookie age in seconds\r\n   */\r\n  maxAge?: number;\r\n}\r\n\r\n/**\r\n * Storage provider for in-memory storage\r\n * Data will be lost when the page is reloaded\r\n */\r\nexport class MemoryStorageProvider implements StorageProvider {\r\n  private storage: Map<string, string> = new Map();\r\n  \r\n  getItem(key: string): string | null {\r\n    return this.storage.get(key) || null;\r\n  }\r\n  \r\n  setItem(key: string, value: string): void {\r\n    this.storage.set(key, value);\r\n  }\r\n  \r\n  removeItem(key: string): void {\r\n    this.storage.delete(key);\r\n  }\r\n}\r\n\r\n/**\r\n * Storage provider for local storage\r\n * Data will persist between page reloads and browser sessions\r\n */\r\nexport class LocalStorageProvider implements StorageProvider {\r\n  getItem(key: string): string | null {\r\n    if (typeof localStorage === 'undefined') return null;\r\n    return localStorage.getItem(key);\r\n  }\r\n  \r\n  setItem(key: string, value: string): void {\r\n    if (typeof localStorage === 'undefined') return;\r\n    localStorage.setItem(key, value);\r\n  }\r\n  \r\n  removeItem(key: string): void {\r\n    if (typeof localStorage === 'undefined') return;\r\n    localStorage.removeItem(key);\r\n  }\r\n}\r\n\r\n/**\r\n * Storage provider for session storage\r\n * Data will persist between page reloads but not when the browser is closed\r\n */\r\nexport class SessionStorageProvider implements StorageProvider {\r\n  getItem(key: string): string | null {\r\n    if (typeof sessionStorage === 'undefined') return null;\r\n    return sessionStorage.getItem(key);\r\n  }\r\n  \r\n  setItem(key: string, value: string): void {\r\n    if (typeof sessionStorage === 'undefined') return;\r\n    sessionStorage.setItem(key, value);\r\n  }\r\n  \r\n  removeItem(key: string): void {\r\n    if (typeof sessionStorage === 'undefined') return;\r\n    sessionStorage.removeItem(key);\r\n  }\r\n}\r\n\r\n/**\r\n * Storage provider for cookies\r\n * Useful for SSR and sending auth data with requests\r\n */\r\nexport class CookieStorageProvider implements StorageProvider {\r\n  private options: CookieOptions;\r\n  \r\n  constructor(options: CookieOptions = {}) {\r\n    this.options = {\r\n      path: '/',\r\n      maxAge: 30 * 24 * 60 * 60, // 30 days\r\n      ...options\r\n    };\r\n  }\r\n  \r\n  getItem(key: string): string | null {\r\n    if (typeof document === 'undefined') return null;\r\n    \r\n    const cookies = document.cookie.split(';');\r\n    for (const cookie of cookies) {\r\n      const [name, value] = cookie.trim().split('=');\r\n      if (name === key) {\r\n        return decodeURIComponent(value);\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n  \r\n  setItem(key: string, value: string): void {\r\n    if (typeof document === 'undefined') return;\r\n    \r\n    const { domain, path, secure, sameSite, maxAge } = this.options;\r\n    \r\n    let cookie = `${key}=${encodeURIComponent(value)}`;\r\n    \r\n    if (domain) cookie += `; Domain=${domain}`;\r\n    if (path) cookie += `; Path=${path}`;\r\n    if (secure) cookie += '; Secure';\r\n    if (sameSite) cookie += `; SameSite=${sameSite}`;\r\n    if (maxAge) cookie += `; Max-Age=${maxAge}`;\r\n    \r\n    document.cookie = cookie;\r\n  }\r\n  \r\n  removeItem(key: string): void {\r\n    if (typeof document === 'undefined') return;\r\n    \r\n    const { domain, path } = this.options;\r\n    let cookie = `${key}=; Max-Age=0`;\r\n    \r\n    if (domain) cookie += `; Domain=${domain}`;\r\n    if (path) cookie += `; Path=${path}`;\r\n    \r\n    document.cookie = cookie;\r\n  }\r\n}\r\n\r\n/**\r\n * Default auth storage keys\r\n */\r\nexport const AUTH_STORAGE_KEYS = {\r\n  SESSION: 'supabase.auth.session',\r\n  USER: 'supabase.auth.user',\r\n  TOKENS: 'supabase.auth.tokens',\r\n  PROVIDER: 'supabase.auth.provider',\r\n  REDIRECT: 'supabase.auth.redirect',\r\n  IS_AUTHENTICATED: 'supabase.auth.isAuthenticated',\r\n  REFRESH_TOKEN: 'supabase.auth.refreshToken',\r\n};\r\n\r\n/**\r\n * Auth Storage Manager for handling auth-related storage\r\n */\r\nexport class AuthStorageManager {\r\n  private provider: StorageProvider;\r\n  private keyPrefix: string;\r\n  \r\n  constructor(provider: StorageProvider, options: StorageManagerOptions = {}) {\r\n    this.provider = provider;\r\n    this.keyPrefix = options.keyPrefix || '';\r\n  }\r\n  \r\n  /**\r\n   * Get the full storage key with prefix\r\n   */\r\n  private getFullKey(key: string): string {\r\n    return this.keyPrefix ? `${this.keyPrefix}:${key}` : key;\r\n  }\r\n  \r\n  /**\r\n   * Get a value from storage\r\n   */\r\n  get<T>(key: string, defaultValue?: T): T | null {\r\n    const value = this.provider.getItem(this.getFullKey(key));\r\n    \r\n    if (!value) {\r\n      return defaultValue || null;\r\n    }\r\n    \r\n    try {\r\n      return JSON.parse(value) as T;\r\n    } catch (error) {\r\n      console.error(`Failed to parse value for key ${key}:`, error);\r\n      return defaultValue || null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Set a value in storage\r\n   */\r\n  set<T>(key: string, value: T): void {\r\n    try {\r\n      const serialized = JSON.stringify(value);\r\n      this.provider.setItem(this.getFullKey(key), serialized);\r\n    } catch (error) {\r\n      console.error(`Failed to set value for key ${key}:`, error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Remove a value from storage\r\n   */\r\n  remove(key: string): void {\r\n    this.provider.removeItem(this.getFullKey(key));\r\n  }\r\n  \r\n  /**\r\n   * Store auth session\r\n   */\r\n  setSession(session: any): void {\r\n    this.set(AUTH_STORAGE_KEYS.SESSION, session);\r\n  }\r\n  \r\n  /**\r\n   * Get stored auth session\r\n   */\r\n  getSession<T = any>(): T | null {\r\n    return this.get<T>(AUTH_STORAGE_KEYS.SESSION);\r\n  }\r\n  \r\n  /**\r\n   * Store user data\r\n   */\r\n  setUser(user: any): void {\r\n    this.set(AUTH_STORAGE_KEYS.USER, user);\r\n  }\r\n  \r\n  /**\r\n   * Get stored user data\r\n   */\r\n  getUser<T = any>(): T | null {\r\n    return this.get<T>(AUTH_STORAGE_KEYS.USER);\r\n  }\r\n  \r\n  /**\r\n   * Store authentication state\r\n   */\r\n  setAuthState(state: { user: any; session: any; isAuthenticated: boolean }): void {\r\n    this.setUser(state.user);\r\n    this.setSession(state.session);\r\n    this.set(AUTH_STORAGE_KEYS.IS_AUTHENTICATED, state.isAuthenticated);\r\n  }\r\n  \r\n  /**\r\n   * Get stored authentication state\r\n   */\r\n  getAuthState<U = any, S = any>(): { user: U | null; session: S | null; isAuthenticated: boolean } {\r\n    return {\r\n      user: this.getUser<U>(),\r\n      session: this.getSession<S>(),\r\n      isAuthenticated: this.get<boolean>(AUTH_STORAGE_KEYS.IS_AUTHENTICATED) || false,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Clear all authentication data\r\n   */\r\n  clearAuth(): void {\r\n    this.remove(AUTH_STORAGE_KEYS.USER);\r\n    this.remove(AUTH_STORAGE_KEYS.SESSION);\r\n    this.remove(AUTH_STORAGE_KEYS.IS_AUTHENTICATED);\r\n    this.remove(AUTH_STORAGE_KEYS.REFRESH_TOKEN);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a storage manager with specified provider\r\n */\r\nexport function createStorageManager(\r\n  provider: StorageProvider,\r\n  options?: StorageManagerOptions\r\n): AuthStorageManager {\r\n  return new AuthStorageManager(provider, options);\r\n} ","import { Session } from '@supabase/supabase-js';\r\n\r\nimport { safeAuthOperation } from './errors';\r\nimport { TypedSupabaseClient } from './types';\r\n\r\n/**\r\n * Options for token manager\r\n */\r\nexport interface TokenManagerOptions {\r\n  /**\r\n   * Supabase client instance\r\n   */\r\n  supabase: TypedSupabaseClient;\r\n\r\n  /**\r\n   * Whether to enable automatic token refreshing\r\n   * @default true\r\n   */\r\n  autoRefresh?: boolean;\r\n\r\n  /**\r\n   * Threshold in seconds before token expiry to trigger refresh\r\n   * @default 300 (5 minutes)\r\n   */\r\n  refreshThreshold?: number;\r\n\r\n  /**\r\n   * Callback when refresh succeeds\r\n   */\r\n  onRefreshSuccess?: (session: Session) => void;\r\n\r\n  /**\r\n   * Callback when refresh fails\r\n   */\r\n  onRefreshError?: (error: Error) => void;\r\n}\r\n\r\n/**\r\n * Manages authentication token refreshing\r\n */\r\nexport class TokenManager {\r\n  private supabase: TypedSupabaseClient;\r\n  private autoRefresh: boolean;\r\n  private refreshThreshold: number;\r\n  private onRefreshSuccess?: (session: Session) => void;\r\n  private onRefreshError?: (error: Error) => void;\r\n  private refreshTimeout: NodeJS.Timeout | null = null;\r\n  private refreshing: boolean = false;\r\n\r\n  constructor(options: TokenManagerOptions) {\r\n    this.supabase = options.supabase;\r\n    this.autoRefresh = options.autoRefresh ?? true;\r\n    this.refreshThreshold = options.refreshThreshold ?? 300; // 5 minutes\r\n    this.onRefreshSuccess = options.onRefreshSuccess;\r\n    this.onRefreshError = options.onRefreshError;\r\n\r\n    // Start refresh scheduler if auto-refresh is enabled\r\n    if (this.autoRefresh) {\r\n      this.startRefreshScheduler();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start the refresh scheduler\r\n   */\r\n  async startRefreshScheduler(): Promise<void> {\r\n    // Clear any existing timeout\r\n    this.stopRefreshScheduler();\r\n\r\n    try {\r\n      // Get current session\r\n      const { data, error } = await this.supabase.auth.getSession();\r\n      \r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      if (data.session) {\r\n        this.scheduleNextRefresh(data.session);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to start refresh scheduler:', error);\r\n      if (this.onRefreshError) {\r\n        this.onRefreshError(error as Error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the refresh scheduler\r\n   */\r\n  stopRefreshScheduler(): void {\r\n    if (this.refreshTimeout) {\r\n      clearTimeout(this.refreshTimeout);\r\n      this.refreshTimeout = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate the time until next refresh in milliseconds\r\n   */\r\n  private calculateNextRefreshTime(session: Session): number {\r\n    if (!session?.expires_at) {\r\n      return 0;\r\n    }\r\n\r\n    const expiryTime = session.expires_at * 1000; // Convert to milliseconds\r\n    const currentTime = Date.now();\r\n    const timeUntilExpiry = expiryTime - currentTime;\r\n    \r\n    // Refresh the token 'refreshThreshold' seconds before it expires\r\n    const refreshTime = timeUntilExpiry - (this.refreshThreshold * 1000);\r\n    \r\n    // If token is already near expiry or expired, refresh immediately\r\n    return Math.max(0, refreshTime);\r\n  }\r\n\r\n  /**\r\n   * Schedule the next token refresh\r\n   */\r\n  private scheduleNextRefresh(session: Session): void {\r\n    if (!session) return;\r\n\r\n    const nextRefreshTime = this.calculateNextRefreshTime(session);\r\n    \r\n    // If token is already expired or very close to expiring, refresh immediately\r\n    if (nextRefreshTime <= 0) {\r\n      this.refreshSession();\r\n      return;\r\n    }\r\n\r\n    // Schedule next refresh\r\n    this.refreshTimeout = setTimeout(() => {\r\n      this.refreshSession();\r\n    }, nextRefreshTime);\r\n  }\r\n\r\n  /**\r\n   * Refresh the session\r\n   */\r\n  async refreshSession(): Promise<Session | null> {\r\n    // Prevent multiple simultaneous refresh attempts\r\n    if (this.refreshing) {\r\n      return null;\r\n    }\r\n\r\n    this.refreshing = true;\r\n\r\n    try {\r\n      const { data, error } = await this.supabase.auth.refreshSession();\r\n      \r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      if (data.session) {\r\n        if (this.onRefreshSuccess) {\r\n          this.onRefreshSuccess(data.session);\r\n        }\r\n\r\n        // Schedule the next refresh if auto-refresh is enabled\r\n        if (this.autoRefresh) {\r\n          this.scheduleNextRefresh(data.session);\r\n        }\r\n\r\n        return data.session;\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Session refresh failed:', error);\r\n      if (this.onRefreshError) {\r\n        this.onRefreshError(error as Error);\r\n      }\r\n      return null;\r\n    } finally {\r\n      this.refreshing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the current session, refreshing if it's expired or close to expiry\r\n   */\r\n  async getSession(): Promise<Session | null> {\r\n    try {\r\n      // Get current session\r\n      const { data, error } = await this.supabase.auth.getSession();\r\n      \r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      const session = data.session;\r\n\r\n      // If no session, return null\r\n      if (!session) {\r\n        return null;\r\n      }\r\n\r\n      // Check if session is close to expiry\r\n      const expiryTime = (session.expires_at || 0) * 1000;\r\n      const currentTime = Date.now();\r\n      const timeUntilExpiry = expiryTime - currentTime;\r\n\r\n      // If session is close to expiry, refresh it\r\n      if (timeUntilExpiry < this.refreshThreshold * 1000) {\r\n        return this.refreshSession();\r\n      }\r\n\r\n      return session;\r\n    } catch (error) {\r\n      console.error('Failed to get session:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   */\r\n  destroy(): void {\r\n    this.stopRefreshScheduler();\r\n  }\r\n}\r\n\r\n/**\r\n * Create a token manager\r\n */\r\nexport function createTokenManager(options: TokenManagerOptions): TokenManager {\r\n  return new TokenManager(options);\r\n} ","import { redirect } from \"next/navigation\";\r\n\r\nimport { ExtendedUser, UserSettings, createExtendedUser } from \"@/types/auth\";\r\n\r\n/**\r\n * Base URL for the application\r\n */\r\nexport const BASE_URL =\r\n  typeof window !== \"undefined\"\r\n    ? window.location.origin\r\n    : process.env.NEXT_PUBLIC_BASE_URL || \"http://localhost:3000\";\r\n\r\n/**\r\n * Safe server-side redirect that handles edge cases\r\n */\r\nexport function safeServerRedirect(url: string = \"/\") {\r\n  // Ensure the URL starts with a slash or has http(s)\r\n  if (!url.startsWith(\"/\") && !url.startsWith(\"http\")) {\r\n    url = `/${url}`;\r\n  }\r\n\r\n  // If URL is a relative path, make sure it doesn't start with multiple slashes\r\n  if (url.startsWith(\"//\") && !url.startsWith(\"//www.\")) {\r\n    url = url.replace(/^\\/+/, \"/\");\r\n  }\r\n\r\n  // For security, only allow redirects to same domain or known safe domains\r\n  // if external URL (starts with http)\r\n  if (url.startsWith(\"http\") && !url.startsWith(BASE_URL)) {\r\n    const isSafeDomain = [\r\n      // Add your list of trusted domains here\r\n      \"supabase.com\",\r\n      \"vercel.app\",\r\n      \"github.com\",\r\n    ].some((domain) => url.includes(domain));\r\n\r\n    if (!isSafeDomain) {\r\n      console.warn(`Unsafe redirect prevented to: ${url}`);\r\n      url = \"/\";\r\n    }\r\n  }\r\n\r\n  redirect(url);\r\n}\r\n\r\n/**\r\n * Parse JWT token without library\r\n */\r\nexport function parseJwt(token: string) {\r\n  try {\r\n    const base64Url = token.split(\".\")[1];\r\n    const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\r\n    const jsonPayload = decodeURIComponent(\r\n      atob(base64)\r\n        .split(\"\")\r\n        .map((c) => \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2))\r\n        .join(\"\")\r\n    );\r\n    return JSON.parse(jsonPayload);\r\n  } catch (error) {\r\n    console.error(\"Failed to parse JWT:\", error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get remaining time of a JWT token in seconds\r\n */\r\nexport function getTokenRemainingTime(token: string): number {\r\n  try {\r\n    const decoded = parseJwt(token);\r\n    if (!decoded || !decoded.exp) return 0;\r\n\r\n    const expiryTime = decoded.exp * 1000; // Convert to milliseconds\r\n    const currentTime = Date.now();\r\n    const remainingTime = Math.max(0, expiryTime - currentTime);\r\n\r\n    return Math.floor(remainingTime / 1000); // Convert to seconds\r\n  } catch (error) {\r\n    console.error(\"Failed to get token remaining time:\", error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get user's preferred locale from browser or storage\r\n */\r\nexport function getUserLocale(): string {\r\n  if (typeof navigator === \"undefined\") return \"en\";\r\n\r\n  return navigator.languages?.[0] || navigator.language || \"en\";\r\n}\r\n\r\n/**\r\n * Sleep for a specified duration\r\n */\r\nexport function sleep(ms: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Generate a random string for CSRF protection\r\n */\r\nexport function generateRandomString(length: number = 16): string {\r\n  const charset =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n  let result = \"\";\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    const randomIndex = Math.floor(Math.random() * charset.length);\r\n    result += charset[randomIndex];\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Validate user settings before applying them\r\n * Returns validated settings or throws an error if invalid\r\n */\r\nexport function validateUserSettings(\r\n  settings: Partial<UserSettings>\r\n): Partial<UserSettings> {\r\n  const validatedSettings: Partial<UserSettings> = {};\r\n\r\n  // Validate theme\r\n  if (settings.theme !== undefined) {\r\n    const validThemes = [\"light\", \"dark\", \"system\"];\r\n    if (!validThemes.includes(settings.theme)) {\r\n      throw new Error(\r\n        `Invalid theme: ${settings.theme}. Valid values are: ${validThemes.join(\", \")}`\r\n      );\r\n    }\r\n    validatedSettings.theme = settings.theme;\r\n  }\r\n\r\n  // Validate language\r\n  if (settings.language !== undefined) {\r\n    const validLanguages = [\"en\", \"es\", \"fr\", \"de\", \"ar\"];\r\n    if (!validLanguages.includes(settings.language)) {\r\n      throw new Error(\r\n        `Invalid language: ${settings.language}. Valid values are: ${validLanguages.join(\", \")}`\r\n      );\r\n    }\r\n    validatedSettings.language = settings.language;\r\n  }\r\n\r\n  // Pass through boolean settings\r\n  const booleanSettings: (keyof Pick<\r\n    UserSettings,\r\n    | \"emailNotifications\"\r\n    | \"documentReminders\"\r\n    | \"applicationUpdates\"\r\n    | \"twoFactorAuth\"\r\n  >)[] = [\r\n    \"emailNotifications\",\r\n    \"documentReminders\",\r\n    \"applicationUpdates\",\r\n    \"twoFactorAuth\",\r\n  ];\r\n\r\n  for (const setting of booleanSettings) {\r\n    if (settings[setting] !== undefined) {\r\n      validatedSettings[setting] = settings[setting];\r\n    }\r\n  }\r\n\r\n  return validatedSettings;\r\n}\r\n\r\n/**\r\n * Check if user can enable two-factor authentication\r\n * In a real application, this might check for prerequisites\r\n */\r\nexport function canEnableTwoFactorAuth(user: ExtendedUser): boolean {\r\n  // Check if user has an email (required for 2FA)\r\n  if (!user.email) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Apply default settings to a user\r\n */\r\nexport function applyDefaultSettings(user: ExtendedUser): ExtendedUser | null {\r\n  // Default settings based on business rules\r\n  const defaultSettings: UserSettings = {\r\n    theme: \"system\",\r\n    language: \"en\",\r\n    emailNotifications: true,\r\n    documentReminders: true,\r\n    applicationUpdates: true,\r\n    twoFactorAuth: false,\r\n  };\r\n\r\n  if (user.updateSettings) {\r\n    return user.updateSettings(defaultSettings);\r\n  }\r\n\r\n  // If user doesn't have the updateSettings method (shouldn't happen)\r\n  return createExtendedUser({\r\n    ...user,\r\n    user_metadata: {\r\n      ...user.user_metadata,\r\n      settings_theme: defaultSettings.theme,\r\n      settings_language: defaultSettings.language,\r\n      settings_emailNotifications: defaultSettings.emailNotifications,\r\n      settings_documentReminders: defaultSettings.documentReminders,\r\n      settings_applicationUpdates: defaultSettings.applicationUpdates,\r\n      settings_twoFactorAuth: defaultSettings.twoFactorAuth,\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Sanitize user avatar URL\r\n * This ensures the URL points to a trusted source\r\n */\r\nexport function sanitizeAvatarUrl(url: string): string {\r\n  if (!url) return \"/avatars/default-avatar.png\";\r\n\r\n  // Validate and sanitize URL\r\n  try {\r\n    const parsedUrl = new URL(url);\r\n\r\n    // Only allow certain domains for security\r\n    const allowedDomains = [\r\n      \"storage.googleapis.com\",\r\n      \"githubusercontent.com\",\r\n      \"gravatar.com\",\r\n      \"yourapp.com\",\r\n      \"supabase.co\",\r\n      \"supabase.in\",\r\n    ];\r\n\r\n    if (!allowedDomains.some((domain) => parsedUrl.hostname.includes(domain))) {\r\n      // Return a default avatar if domain is not allowed\r\n      return \"/avatars/default-avatar.png\";\r\n    }\r\n\r\n    // Ensure HTTPS\r\n    if (parsedUrl.protocol !== \"https:\") {\r\n      parsedUrl.protocol = \"https:\";\r\n    }\r\n\r\n    return parsedUrl.toString();\r\n  } catch (e) {\r\n    // If URL is invalid, return a default avatar\r\n    return \"/avatars/default-avatar.png\";\r\n  }\r\n}\r\n","import { createClient } from \"@supabase/supabase-js\";\r\nimport { cookies } from \"next/headers\";\r\nimport { cache } from \"react\";\r\n\r\nimport { TypedSupabaseClient } from \"@/lib/supabase/client\";\r\nimport { AuthOptions, ExtendedUser } from \"@/types/auth\";\r\n\r\nimport {\r\n  AuthError,\r\n  UnauthorizedError,\r\n  ForbiddenError,\r\n  SessionError,\r\n  InvalidCredentialsError,\r\n  UserOperationError,\r\n  ConfigurationError,\r\n  handleSupabaseError,\r\n  safeAuthOperation,\r\n  createAuthErrorHandler,\r\n} from \"./errors\";\r\nimport {\r\n  Permission,\r\n  Role,\r\n  RBACOptions,\r\n  RBACManager,\r\n  getRBACManager,\r\n  hasPermission,\r\n  createPermission,\r\n  enforcePermission,\r\n} from \"./rbac\";\r\nimport {\r\n  StorageProvider,\r\n  MemoryStorageProvider,\r\n  LocalStorageProvider,\r\n  SessionStorageProvider,\r\n  CookieStorageProvider,\r\n  AUTH_STORAGE_KEYS,\r\n  AuthStorageManager,\r\n  createStorageManager,\r\n  StorageManagerOptions,\r\n} from \"./storage\";\r\nimport { TokenManager, createTokenManager, TokenManagerOptions } from \"./token\";\r\nimport { BASE_URL, safeServerRedirect } from \"./utils\";\r\n\r\n// Re-export enhanced modules\r\nexport * from \"./errors\";\r\nexport * from \"./token\";\r\nexport * from \"./storage\";\r\nexport * from \"./rbac\";\r\nexport * from \"./mock\";\r\n\r\n/**\r\n * Configuration for the authentication module\r\n */\r\nexport interface AuthConfig {\r\n  /**\r\n   * Supabase project URL\r\n   */\r\n  supabaseUrl: string;\r\n\r\n  /**\r\n   * Supabase anonymous key\r\n   */\r\n  supabaseKey: string;\r\n\r\n  /**\r\n   * OAuth callback URL\r\n   * @default `${BASE_URL}/auth/callback`\r\n   */\r\n  callbackUrl?: string;\r\n\r\n  /**\r\n   * URL to redirect after logout\r\n   * @default `/login`\r\n   */\r\n  logoutRedirectUrl?: string;\r\n\r\n  /**\r\n   * URL to redirect after login\r\n   * @default `/dashboard`\r\n   */\r\n  loginRedirectUrl?: string;\r\n\r\n  /**\r\n   * Options for the token manager\r\n   */\r\n  tokenOptions?: Omit<TokenManagerOptions, \"supabase\">;\r\n\r\n  /**\r\n   * Storage provider to use for authentication state\r\n   * @default 'local'\r\n   */\r\n  storageType?: \"memory\" | \"local\" | \"session\" | \"cookie\";\r\n\r\n  /**\r\n   * Options for the storage manager\r\n   */\r\n  storageOptions?: StorageManagerOptions;\r\n\r\n  /**\r\n   * Role-based access control options\r\n   */\r\n  rbacOptions?: RBACOptions;\r\n}\r\n\r\n/**\r\n * Default authentication configuration\r\n */\r\nexport const defaultAuthConfig: AuthConfig = {\r\n  supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || \"\",\r\n  supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || \"\",\r\n  callbackUrl: `${BASE_URL}/auth/callback`,\r\n  logoutRedirectUrl: \"/login\",\r\n  loginRedirectUrl: \"/dashboard\",\r\n  storageType: \"local\",\r\n};\r\n\r\n// Initialize auth configuration\r\nlet globalAuthConfig: AuthConfig = { ...defaultAuthConfig };\r\n\r\n/**\r\n * Set the global authentication configuration\r\n */\r\nexport function setAuthConfig(config: Partial<AuthConfig>) {\r\n  globalAuthConfig = {\r\n    ...globalAuthConfig,\r\n    ...config,\r\n  };\r\n}\r\n\r\n/**\r\n * Get the current authentication configuration\r\n */\r\nexport function getAuthConfig(): AuthConfig {\r\n  return globalAuthConfig;\r\n}\r\n\r\n// Singleton instances of sub-managers\r\nlet tokenManager: TokenManager | null = null;\r\nlet storageManager: AuthStorageManager | null = null;\r\n\r\n/**\r\n * Browser-side Supabase client for authentication\r\n */\r\nexport function createBrowserClient(): TypedSupabaseClient {\r\n  try {\r\n    return createClient(\r\n      globalAuthConfig.supabaseUrl,\r\n      globalAuthConfig.supabaseKey,\r\n      {\r\n        auth: {\r\n          persistSession: true,\r\n          autoRefreshToken: true,\r\n        },\r\n      }\r\n    ) as TypedSupabaseClient;\r\n  } catch (error) {\r\n    console.error(\"Failed to create Supabase browser client:\", error);\r\n    throw new ConfigurationError(\"Failed to create Supabase browser client\");\r\n  }\r\n}\r\n\r\n/**\r\n * Get token manager instance, creating it if it doesn't exist\r\n */\r\nexport function getTokenManager(): TokenManager {\r\n  if (!tokenManager) {\r\n    const supabase = createBrowserClient();\r\n    tokenManager = createTokenManager({\r\n      supabase,\r\n      ...(globalAuthConfig.tokenOptions || {}),\r\n    });\r\n  }\r\n  return tokenManager;\r\n}\r\n\r\n/**\r\n * Get storage manager instance, creating it if it doesn't exist\r\n */\r\nexport function getStorageManager(): AuthStorageManager {\r\n  if (!storageManager) {\r\n    let provider: StorageProvider;\r\n\r\n    switch (globalAuthConfig.storageType) {\r\n      case \"memory\":\r\n        provider = new MemoryStorageProvider();\r\n        break;\r\n      case \"session\":\r\n        provider = new SessionStorageProvider();\r\n        break;\r\n      case \"cookie\":\r\n        provider = new CookieStorageProvider(\r\n          globalAuthConfig.storageOptions?.cookieOptions\r\n        );\r\n        break;\r\n      case \"local\":\r\n      default:\r\n        provider = new LocalStorageProvider();\r\n        break;\r\n    }\r\n\r\n    storageManager = createStorageManager(\r\n      provider,\r\n      globalAuthConfig.storageOptions\r\n    );\r\n  }\r\n\r\n  return storageManager;\r\n}\r\n\r\n/**\r\n * Server-side Supabase client for authentication\r\n */\r\nexport function createServerClient(): TypedSupabaseClient {\r\n  // WARNING: This server client uses synchronous cookie access via next/headers.\r\n  // While convenient, this approach has limitations:\r\n  // 1. Reliability: Synchronous access to next/headers cookies() might not work\r\n  //    consistently across all Next.js versions or deployment environments.\r\n  // 2. Session Refresh: The client might not be able to automatically refresh\r\n  //    auth tokens because it cannot reliably *set* cookies on the response\r\n  //    using this synchronous pattern. Consider using @supabase/ssr's\r\n  //    createServerClient for components/pages where response manipulation is possible,\r\n  //    or handle token refresh manually if using this client in API routes/actions.\r\n  try {\r\n    const cookieStore = cookies();\r\n\r\n    // Create basic client options\r\n    const options: any = {\r\n      auth: {\r\n        persistSession: true,\r\n      },\r\n      global: {\r\n        headers: {\r\n          \"X-Client-Info\": \"hijraah-auth-helper\",\r\n        },\r\n      },\r\n    };\r\n\r\n    // Supabase expects a synchronous cookie interface\r\n    // Next.js 13+ uses an asynchronous cookies() API\r\n    // So we need to handle this carefully\r\n    options.cookies = {\r\n      get(name: string) {\r\n        try {\r\n          // @ts-ignore - Next.js cookies() can be used synchronously in some environments\r\n          return cookieStore.get(name)?.value;\r\n        } catch (error) {\r\n          console.warn(\"Error accessing cookie synchronously:\", error);\r\n          return undefined;\r\n        }\r\n      },\r\n      set(name: string, value: string, cookieOptions: any) {\r\n        try {\r\n          // @ts-ignore - Next.js cookies() can be used synchronously in some environments\r\n          cookieStore.set(name, value, cookieOptions);\r\n        } catch (error) {\r\n          console.warn(\"Error setting cookie synchronously:\", error);\r\n        }\r\n      },\r\n      remove(name: string, cookieOptions: any) {\r\n        try {\r\n          // @ts-ignore - Next.js cookies() can be used synchronously in some environments\r\n          cookieStore.set(name, \"\", { ...cookieOptions, maxAge: 0 });\r\n        } catch (error) {\r\n          console.warn(\"Error removing cookie synchronously:\", error);\r\n        }\r\n      },\r\n    };\r\n\r\n    return createClient(\r\n      globalAuthConfig.supabaseUrl,\r\n      globalAuthConfig.supabaseKey,\r\n      options\r\n    ) as TypedSupabaseClient;\r\n  } catch (error) {\r\n    console.error(\"Failed to create Supabase server client:\", error);\r\n    throw new ConfigurationError(\"Failed to create Supabase server client\");\r\n  }\r\n}\r\n\r\n/**\r\n * Check if the user is authenticated\r\n * @server-only\r\n */\r\nexport async function checkAuth() {\r\n  try {\r\n    const supabase = createServerClient();\r\n\r\n    // First, verify the user with the server\r\n    const {\r\n      data: { user },\r\n      error: userError,\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (userError) {\r\n      console.error(\"Error fetching user in checkAuth:\", userError);\r\n      throw handleSupabaseError(userError); // Propagate Supabase error\r\n    }\r\n\r\n    if (!user) {\r\n      throw new UnauthorizedError(\"User not authenticated\");\r\n    }\r\n\r\n    // User is verified, now get the session data\r\n    const {\r\n      data: { session },\r\n      error: sessionError,\r\n    } = await supabase.auth.getSession();\r\n\r\n    if (sessionError) {\r\n      console.error(\"Error fetching session in checkAuth:\", sessionError);\r\n      // Throw a specific error if session fetch fails after user verification\r\n      throw new SessionError(\r\n        \"Failed to retrieve session data after user verification\"\r\n      );\r\n    }\r\n\r\n    if (!session) {\r\n      // This case should ideally not happen if getUser succeeded, but handle defensively\r\n      throw new UnauthorizedError(\r\n        \"No active session found despite verified user\"\r\n      );\r\n    }\r\n\r\n    // Return the verified user and the associated session\r\n    return {\r\n      session: session,\r\n      user: user, // Use the user from getUser()\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Authentication check failed:\", error);\r\n    if (error instanceof AuthError) {\r\n      throw error;\r\n    }\r\n    throw new UnauthorizedError(\"Failed to authenticate user\");\r\n  }\r\n}\r\n\r\n/**\r\n * Get the authenticated user with server components\r\n * @server-only\r\n */\r\nexport const getAuthUser = cache(async () => {\r\n  try {\r\n    const { session, user } = await checkAuth();\r\n\r\n    if (!user) {\r\n      throw new UnauthorizedError(\"No user found in session\");\r\n    }\r\n\r\n    // Create extended user with additional properties\r\n    const extendedUser: ExtendedUser = {\r\n      ...user,\r\n      fullName:\r\n        user.user_metadata?.full_name || user.email?.split(\"@\")[0] || \"User\",\r\n      avatarUrl: user.user_metadata?.avatar_url || \"\",\r\n      role: user.user_metadata?.role || \"user\",\r\n    };\r\n\r\n    return {\r\n      session,\r\n      user: extendedUser,\r\n      isAuthenticated: true,\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Failed to get authenticated user:\", error);\r\n    return {\r\n      session: null,\r\n      user: null,\r\n      isAuthenticated: false,\r\n    };\r\n  }\r\n});\r\n\r\n/**\r\n * Get the authenticated user or redirect to login\r\n * @server-only\r\n */\r\nexport async function getAuthUserOrRedirect(redirectTo?: string) {\r\n  const { user, session, isAuthenticated } = await getAuthUser();\r\n\r\n  if (!isAuthenticated) {\r\n    safeServerRedirect(\r\n      redirectTo || globalAuthConfig.logoutRedirectUrl || \"/login\"\r\n    );\r\n  }\r\n\r\n  return { user, session, isAuthenticated };\r\n}\r\n\r\n/**\r\n * Require the user to have a specific permission, or redirect\r\n * @server-only\r\n */\r\nexport async function requirePermission(\r\n  permission: Permission,\r\n  redirectTo = \"/unauthorized\"\r\n) {\r\n  const { user } = await getAuthUserOrRedirect();\r\n\r\n  try {\r\n    const rbacManager = getRBACManager();\r\n    const hasAccess = rbacManager.hasPermission(user, permission);\r\n\r\n    if (!hasAccess) {\r\n      throw new ForbiddenError(\r\n        `User does not have required permission: ${permission}`\r\n      );\r\n    }\r\n\r\n    return { user };\r\n  } catch (error) {\r\n    console.error(\"Permission check failed:\", error);\r\n    safeServerRedirect(redirectTo);\r\n    // This return is just to satisfy TypeScript, the redirect will end execution\r\n    return { user: null as unknown as ExtendedUser };\r\n  }\r\n}\r\n\r\n/**\r\n * Sign out the user\r\n * @server-only\r\n */\r\nexport async function signOut(redirectTo?: string) {\r\n  try {\r\n    const supabase = createServerClient();\r\n    await supabase.auth.signOut();\r\n\r\n    const storage = getStorageManager();\r\n    // Clear all auth data\r\n    storage.clearAuth();\r\n\r\n    // Clean up token manager\r\n    if (tokenManager) {\r\n      tokenManager.destroy();\r\n      tokenManager = null;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Sign out failed:\", error);\r\n  }\r\n\r\n  // Redirect to login page\r\n  safeServerRedirect(\r\n    redirectTo || globalAuthConfig.logoutRedirectUrl || \"/login\"\r\n  );\r\n}\r\n\r\n/**\r\n * Initialize auth helpers in the application\r\n */\r\nexport function initializeAuth(config: Partial<AuthConfig> = {}) {\r\n  // Set global configuration\r\n  setAuthConfig(config);\r\n\r\n  // Initialize Supabase clients\r\n  const browserClient = createBrowserClient();\r\n\r\n  // Initialize all managers\r\n  if (!tokenManager) {\r\n    tokenManager = createTokenManager({\r\n      supabase: browserClient,\r\n      ...(config.tokenOptions || {}),\r\n    });\r\n  }\r\n\r\n  if (!storageManager) {\r\n    getStorageManager();\r\n  }\r\n\r\n  // Initialize RBAC\r\n  const rbac = getRBACManager(config.rbacOptions);\r\n\r\n  return {\r\n    config: getAuthConfig(),\r\n    tokenManager,\r\n    storageManager: getStorageManager(),\r\n    rbacManager: rbac,\r\n    createServerClient,\r\n    createBrowserClient,\r\n  };\r\n}\r\n\r\n// Default auth helpers instance for direct use\r\nexport const auth = {\r\n  tokenManager: getTokenManager,\r\n  storageManager: getStorageManager,\r\n  rbacManager: getRBACManager,\r\n  createServerClient,\r\n  createBrowserClient,\r\n  getAuthUser,\r\n  getAuthUserOrRedirect,\r\n  requirePermission,\r\n  signOut,\r\n  config: getAuthConfig,\r\n  initialize: initializeAuth,\r\n};\r\n\r\n// Modern export index for the auth system\r\n// Client hooks\r\nexport {\r\n  AuthProvider,\r\n  useAuth,\r\n  useUser,\r\n  useIsAuthenticated,\r\n  useHasRole,\r\n  useHasPermission,\r\n  useSession,\r\n} from \"./hooks\";\r\n\r\n// Types\r\nexport type {\r\n  AuthContextType,\r\n  ExtendedUser,\r\n  UserSettings,\r\n  AuthProvider as AuthProviderType,\r\n} from \"@/types/auth\";\r\n\r\nexport { createExtendedUser } from \"@/types/auth\";\r\n\r\n// Server utilities\r\nexport {\r\n  getUser,\r\n  protectRoute,\r\n  protectRoleRoute,\r\n  protectAdminRoute,\r\n} from \"./server\";\r\n\r\n// Re-export from actions selectively to avoid conflicts\r\nexport { createUser, updateUserRole, updateUserSettings } from \"./actions\";\r\n\r\n// Utils - import selectively to avoid duplicate exports\r\nexport {\r\n  validateUserSettings,\r\n  canEnableTwoFactorAuth,\r\n  applyDefaultSettings,\r\n  sanitizeAvatarUrl,\r\n} from \"./utils\";\r\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 97108;\nmodule.exports = webpackEmptyContext;"],"names":["browserClientInstance","fetch","ponyfetch","fetchPonyfill","supabaseUrl","process","supabaseAnonKey","serviceRoleKey","env","SUPABASE_SERVICE_ROLE_KEY","anonymousHeaders","apikey","undefined","serviceHeaders","checkPublicEnvVars","console","error","g","globalThis","__USING_PONYFETCH__","getSupabaseBrowserClient","_createBrowserClient","global","headers","createClient","createSupabaseServerClient","cookieStore","_createServerClient","cookies","get","name","value","set","options","warn","remove","createSupabaseServiceClient","createSupabaseClient","auth","autoRefreshToken","persistSession","createEdgeClient","cookieHeader","request","match","createServiceClient","supabase","createExtendedUser","user","role","user_metadata","settings","theme","settings_theme","language","settings_language","emailNotifications","settings_emailNotifications","documentReminders","settings_documentReminders","applicationUpdates","settings_applicationUpdates","twoFactorAuth","settings_twoFactorAuth","fullName","full_name","email","split","avatarUrl","avatar_url","isAdmin","hasTwoFactorAuth","updateSettings","updatedSettings","newSettings","toObject","id","getSupabaseServerClient","getSession","data","userError","getUser","session","getCurrentUser","isAuthenticated","hasRole","signOut","redirectTo","revalidatePath","redirect","createUser","password","userData","userMetadata","entries","forEach","key","admin","email_confirm","updateUserRole","userId","updateUserById","updateUserSettings","formattedSettings","Object","protect","protectRole","hasUserRole","protectAdmin","AuthError","Error","constructor","message","code","originalError","status","toJSON","toResponse","Response","JSON","stringify","UnauthorizedError","ForbiddenError","SessionError","InvalidCredentialsError","UserOperationError","ConfigurationError","handleSupabaseError","errorWithStatus","includes","protectRoute","protectRoleRoute","protectAdminRoute","defaultRBACOptions","roles","superAdminRole","enableCache","RBACManager","permissionCache","Map","config","extractRoles","defineRole","clear","defineRoles","roleName","visited","Set","has","add","permissions","inherits","length","parentRole","getRolePermissions","permission","getUserPermissions","userRoles","cacheKey","sort","join","cachedPermissions","allPermissions","hasPermission","parts","i","wildcardPermission","slice","hasAnyPermission","some","hasAllPermissions","every","enforcePermission","enforceAnyPermission","enforceAllPermissions","createPermission","resource","action","rbacManager","MemoryStorageProvider","getItem","storage","setItem","removeItem","delete","LocalStorageProvider","localStorage","SessionStorageProvider","sessionStorage","CookieStorageProvider","path","maxAge","document","cookie","trim","decodeURIComponent","domain","secure","sameSite","encodeURIComponent","AUTH_STORAGE_KEYS","SESSION","USER","IS_AUTHENTICATED","REFRESH_TOKEN","AuthStorageManager","provider","keyPrefix","defaultValue","getFullKey","parse","serialized","setSession","setUser","setAuthState","state","getAuthState","clearAuth","TokenManager","refreshTimeout","refreshing","autoRefresh","refreshThreshold","onRefreshSuccess","onRefreshError","startRefreshScheduler","stopRefreshScheduler","scheduleNextRefresh","clearTimeout","expires_at","expiryTime","Math","max","timeUntilExpiry","refreshTime","Date","now","nextRefreshTime","calculateNextRefreshTime","refreshSession","setTimeout","currentTime","destroy","BASE_URL","NEXT_PUBLIC_BASE_URL","window","globalAuthConfig","supabaseKey","callbackUrl","logoutRedirectUrl","loginRedirectUrl","storageType","storageManager","defaultAuthConfig","checkAuth","createServerClient","cookieOptions","sessionError","getAuthUser","cache","extendedUser"],"sourceRoot":""}