{"version":3,"file":"8305.js","mappings":"6aAAA,iBACA,iBAMA,EASA,EAOA,EApBA,gBACA,8BACA,CAGA,IACA,KACA,CAAE,SAGF,cACA,CAGA,IACA,KACA,CAAE,SACF,cACA,CAGA,IACA,SACA,CAAE,SACF,cACA,CAuBA,sBACA,qBACA,UACA,cACA,yBACA,cAIA,SACA,KAEA,oCAEA,YACA,OAEA,YACA,QAGA,gBAEA,YACA,YAEA,UAKA,mBAJA,SAQA,UACA,aACM,UACN,aACM,UACN,sBACA,mBACA,WACA,CAAS,aACT,WACA,CAAS,CACT,CAAO,OACD,kBACN,UACM,mBACN,4BACA,4CACM,iBACN,6BACM,yBASN,OANA,EAFA,mBAEA,6BAGA,qBAEA,UACA,EACM,WACN,mBAEA,WAEA,gBADA,6BAIA,mBACA,KAIA,MACA,IAjDA,EACA,EAwEA,EAxBA,eAEA,SACA,YAEA,UACA,SACA,CAgBA,aAdA,QACA,wBACA,eACA,WACA,UACA,CAAO,EAEP,QACA,sBACA,eACA,QACA,CAAO,EAGP,EAEA,GACA,yCAGA,gBAGA,mBAGA,gCAEA,QADA,kCACA,IAAsB,WAAoB,KAG1C,WACA,uCACA,wBAGA,iBACA,cACA,2BACA,aACA,CAAW,EAEX,CAGA,KAEA,QADA,gCACA,IAAsB,WAA6B,KACnD,WACA,uCACA,kBAGA,iBACA,2BACA,aACA,CAAS,EACT,CAGA,QACA,EAEA,IACA,CAoBA,cACA,wCACA,CAkBA,cACA,SAIA,OAHA,mBACA,uBACA,sBACA,CACA,CAGA,OAxCA,6BACA,YACA,YAEA,mBAEA,OADA,cACA,KACA,EAOA,eAKA,WAHA,YACA,gDACA,EAMA,YAHA,YACA,iDACA,EAMA,aAHA,YACA,kDACA,EAUA,qBAEA,CACA,CAAC,EAE6B,YAC9B,qCCtPA,YAKA,CAFY,mBAA4C,CAExD,gBAEA,CAAC,mCCPD,YACA,QACA,YACA,gBAAyD,qBAA0C,6DAAqE,CACxK,aAEA,EAAU,EAAQ,IAAO,EAEzB,EAAiB,SAFA,IAEA,SAA8B,EAG/C,oBACA,kBACA,gBAA8B,EAC9B,QAaA,6BAaA,+BAiBA,6BAqBA,+BAiBA,6BAeA,+BAsBA,6BAiBA,mCAeA,+BAmBA,6BAwBA,uCAkBA,uCAmBA,2CASA,iCAKA,2CAIA,mCAIA,iDAIA,iCAIA,iDAIA,mCAIA,6CACA,eACA,mBAEA,aAEA,4BAEA,eAEA,mBACA,oBACA,kBAEA,SAEA,gBAEA,aAEA,kBAEA,yBAEA,UACA,CAAS,eAET,qCACA,8EACA,mEACA,MAEA,UACA,uBACA,UAGA,GAFA,8BAEA,qBASA,iBARA,IACA,UACA,SACA,CAAkB,SAElB,EADA,EAEA,CAIA,CACA,CAAW,GAGX,YACA,OACA,SACA,OACA,QACA,OACA,EAEA,uCAEA,kBACA,MACA,CAEA,OACA,MAGA,GAFA,UAEA,gCACA,eAGA,iDACA,kBACA,iCAKA,mBAGA,CAEA,QACA,cAGA,GAFA,UAEA,kBAEA,MADA,yBAKA,QADA,KACA,WAAuC,IAAS,KAGhD,GAFA,OAEA,gCACA,OAGA,kDACA,kBACA,iCAGA,mBAEA,CAEA,QACA,CAEA,WACA,QAGA,GAFA,UAEA,+DAEA,MADA,0BAYA,GARA,yBAIA,SACA,wBAGA,gCACA,QAmBA,OAhBA,KAEA,eACA,KACA,qEAGA,6BACA,wCAEA,KACA,wCACA,mBAEA,qBAEA,EACA,CAEA,QACA,wBAGA,GAFA,UAEA,wEAEA,MADA,0BAKA,mBAA8C,IAAS,KAIvD,GAHA,OACA,KAAY,eAAe,EAE3B,sBAEA,MADA,wBAIA,mCACA,OAEA,CACA,mBAA+C,IAAU,IACzD,OACA,MAAY,eAAe,GAC3B,gBAEA,QACA,CAEA,OACA,gBAOA,IANA,UAEA,kBACA,QAEA,IACA,eAAuC,IAAS,KAGhD,GAFA,OAEA,gCACA,OAGA,sBAEA,oEACA,wCACA,kBACA,IAEA,eACA,oBAEA,uBAEA,CACA,QACA,CAEA,QACA,MAMA,OALA,UAEA,MADA,iBAEA,YAEA,CACA,CAEA,SACA,MAGA,GAFA,UACA,2BACA,GACA,SAGA,mCACA,cAGA,sDAEA,KACA,6CAEA,YAEA,GAKA,CAEA,UACA,MAEA,GADA,UACA,GAIA,mCACA,eAGA,gDACA,eAIA,OAEA,CAEA,OAIA,OAFA,UACA,sBAEA,CAEA,OAIA,OAFA,UACA,+CAEA,CAEA,WAEA,OADA,UACA,WAGA,eACA,UAIA,aAEA,YACA,OACA,SACA,OACA,QACA,OACA,EAEA,wBACA,mBACA,kBACA,CAEA,aACA,UAEA,YACA,OACA,SACA,OACA,QACA,OACA,EACA,wBACA,CAEA,QACA,UACA,uBACA,CAEA,iBACA,UAIA,SAHA,UACA,YAGA,OACA,iBAEA,gCACA,6EACA,wDACA,0BAGA,CAKA,mBACA,2BACA,sCAEA,CAEA,YACA,MAYA,OAXA,UACA,KAGA,0BACA,8BACA,KACA,aAEA,wCAEA,CACA,CAEA,iBACA,MAEA,GADA,UACA,0CACA,+BACA,aACA,CAAW,CAEX,CAEA,gBACA,eACA,UACA,wBACA,OAGA,aAiBA,CACA,EAdA,MACA,EACU,EACV,QAGA,wBACA,oBAEA,EAXA,IAWA,oBAMA,UACA,CACA,CAKA,gBAIA,GAHA,wBACA,OAEA,UACA,KACA,mBAEA,WAGA,WACA,CAKA,iBACA,0BACA,CAEA,iBAEA,GADA,UACA,mBAEA,gBACU,4BAEV,gCACU,oBAEV,4CACU,sBACV,SACU,6CAGV,0CACU,uEACV,qBACU,+BAEV,+DACU,uBACV,cAGA,QAEA,CAEA,aAA4B,EAC5B,MASA,OARA,UAEA,YACA,OACA,cACA,qDACA,SAEA,CACA,CAEA,cACA,UAIA,SAHA,UACA,eACA,eAEA,OACA,yCAEA,CAEA,sBACA,mBACA,gCACA,CACA,CAEA,CAUA,OARA,qBACA,kCACA,4CACA,mFACA,kDACA,+CACA,EAEA,CAEA,EAAG,YAEH,CAAC,4DChyBD,0BACA,eACA,SACA,wBACA,CACA,EAGA,QACA,QACA,QACA,QACA,kBACA,GACA,cACA,cACA,iBAEA,yCACA,cACA,kCACA,cAEA,sDACA,WACA,aACA,EAAM,CACN,8BACA,8CACA,CACA,CACA,iBACA,OACA,yBACA,cACA,qBACA,4BACA,aACA,4BAEA,OACA,OACA,YAAoB,uBAA0B,IAC9C,IACA,wDACA,KACA,CAAQ,SACR,iCAQA,eAPA,UACA,gBAA6B,6CAAiD,EAC9E,EACA,CACA,WACA,gDACA,GAEA,KACA,CACA,IACA,uBACA,yDAEA,CAEA,MACA,wCAEA,qBACA,SACA,eAAgC,QAAW,GAE3C,OAAa,8BACb,CACA,EAGA,OACA,YACA,EACA,CAAC,MAAyB,EAC1B,OACA,YACA,cACA,EACA,CAAC,MAAuB,EACxB,OACA,kBACA,gBACA,kBACA,EACA,CAAC,MAAiB,EAGlB,QACA,QACA,qBACA,KACA,eACA,eACA,CAIA,cACA,WAAY,WAAgB,iBAC5B,kBACA,qBACK,EACL,KACA,eAEA,cACA,mDAEA,QACA,CACA,EAGA,kBACA,iBACA,cAEA,EADA,kBACA,qBACA,cACA,MAAoB,EAAS,GAAG,aAAkB,EAElD,UACA,CACA,EAGA,kBACA,iBACA,cACA,cACA,oBACM,8BACN,sEAEA,eACA,MAAoB,EAAS,GAAG,YAAkB,GAElD,UACA,CACA,EAGA,kBACA,iBACA,cACA,eACA,MAAoB,EAAS,GAAG,aAAkB,EAElD,uCACA,MACA,CACA,QACS,CACT,GAEM,iBACN,MACA,CACA,KACA,CAAS,CACT,GAEM,oBACN,UAEA,CACA,EAGA,kBACA,iBACA,eAGA,EAFA,iBACA,gBACA,uBAEA,4BAEA,cACA,MAAoB,EAAS,GAAG,aAAe,EAE/C,UACA,CACA,EACA,KACA,iCAIA,kBACA,mBACA,cAKA,GAJA,eACA,KAAoB,EAAS,GAAG,YAAe,EAC/C,oBAEA,iBACA,OAAc,WAAuB,SAC/B,sBACN,OAAc,UAAqB,SAEnC,8BAEA,CACA,EAGA,kBACA,iBACA,aACA,eACA,MAAoB,EAAS,GAAG,aAAkB,EAElD,UACA,CACA,EAGA,kBACA,eACA,cACA,aACA,KAAoB,EAAS,GAAG,YAAkB,EAC5C,QACN,MAAoB,EAAS,OAE7B,WACA,CACA,EAGA,kBACA,cAEA,SADA,OAEA,CACA,EAGA,kBACA,eACA,+BACA,CACA,EAGA,kBACA,iBACA,uBACA,aACA,2BAEA,GACA,MAAoB,EAAS,GAAG,GAAU,EAE1C,UACA,CACA,EAGA,kBACA,eACA,8BACA,CACA,EAGA,QACA,KACA,MACA,UACA,iBACA,OACA,qBACA,4BACA,GAGA,OADA,iBACA,CACA,EACA,mBACA,cACA,YACA,uFAGA,cAAsC,6BAA8B,SACpE,EACA,oBACA,cACA,yEAEA,mBAA2D,eAAiB,UAE5E,OADA,aACA,CACA,CACA,CACA,EAGA,QACA,OACA,sBAcA,KACA,cACA,gBACA,CAuBA,mBAA+C,yBAA2B,oBAsB1E,mBAA+C,yBAA2B,oBAwB1E,eACA,KACA,8BAEA,MAAkB,0BAElB,2BACA,CAwBA,kBAA6C,yBAA2B,oBA2BxE,yBACA,0CACA,kBACA,WAAY,UAAkB,EAC9B,iBAAa,yBACb,EAsBA,mBAA+C,yBAA2B,oBA+B1E,kBAA6C,yBAA2B,oBAYxE,iBAAmC,yBAA2B,qBAI9D,kBACA,iBACA,cACA,eACA,MAAoB,EAAS,GAAG,aAAe,EAE/C,UACA,CACA,EAGA,kBACA,cAEA,SADA,kBAEA,CACA,EAGA,kBACA,eAEA,SADA,oBAAyC,EAAU,EAEnD,CACA,EAGA,QACA,mBAYA,GACA,aACA,CACA,kCAsBA,0CAyBA,2CAkCA,8CA4BA,4BACA,wCACA,kBACA,WAAY,UAAkB,EAC9B,iBAAa,yBACb,EAuBA,0CAwBA,4CAwBA,yCA8BA,oCA+BA,0CAYA,mCAYA,6CAaA,+CCp0BA,kBAAkC,EAClC,GADuC,SACvC,GACA,yCACA,SAGA,yGACA,+FACA,MACA,qDAEA,MACA,kDAEA,wDACA,uFAEA,uDACA,yFAeA,MAPA,IAAuB,EAAU,CACjC,OADiC,CACjC,EACA,eACA,SAAiB,wBAAyB,EAAM,EAJ1C,GALN,iEACA,CACA,6CAAoD,MACpD,CAD2D,CAAC,2BAC5D,mEACA,4BA9BA,kFACA,OAAkB,qBAAqB,EACvC,kDAAkE,gBAAgB,GA6B5E,EAI0C,CAAwB,CACxE,gDACA,gBACA,CAAK,EAEL,CAWA,oBACA,uEACA,uEACA,MACA,8EAEA,MACA,gFAEA,cAAwB,mBAAuB,CAC/C,CACA","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js","webpack://@hijraah/web/../../node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/lib/node_cache.js","webpack://@hijraah/web/../../node_modules/.pnpm/@upstash+vector@1.2.1/node_modules/@upstash/vector/dist/chunk-HESEGT2A.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@upstash+vector@1.2.1/node_modules/@upstash/vector/dist/nodejs.mjs"],"sourcesContent":["var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var exports;\n\n  exports = module.exports = require('./lib/node_cache');\n\n  exports.version = '5.1.2';\n\n}).call(this);\n","/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var EventEmitter, NodeCache, clone,\n    splice = [].splice,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },\n    indexOf = [].indexOf;\n\n  clone = require(\"clone\");\n\n  EventEmitter = require('events').EventEmitter;\n\n  // generate superclass\n  module.exports = NodeCache = (function() {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super();\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this);\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this);\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this);\n        \n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this);\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this);\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this);\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this);\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this);\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this);\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        this.has = this.has.bind(this);\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this);\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this);\n        \n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this);\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        this.close = this.close.bind(this);\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        this._checkData = this._checkData.bind(this);\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        this._check = this._check.bind(this);\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        this._isInvalidKey = this._isInvalidKey.bind(this);\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        this._wrap = this._wrap.bind(this);\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        this._getValLength = this._getValLength.bind(this);\n        // ## _error\n\n        // internal method to handle an error message\n        this._error = this._error.bind(this);\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n        this._initErrors();\n        // container for cached data\n        this.data = {};\n        // module options\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options);\n        // generate functions with callbacks (legacy)\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach((methodKey) => {\n            var oldMethod;\n            // reference real function\n            oldMethod = this[methodKey];\n            this[methodKey] = function(...args) {\n              var cb, err, ref, res;\n              ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        }\n        // statistics container\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        this._checkData();\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n        boundMethodCheck(this, NodeCache);\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // get data and incremet stats\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]);\n          // return data\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n        boundMethodCheck(this, NodeCache);\n        // convert a string to an array of one key\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        }\n        // define return\n        oRet = {};\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and increment stats\n          if ((this.data[key] != null) && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        }\n        // return all found keys\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n        // force the data to string\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        }\n        // set default ttl if not passed\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // internal helper variables\n        existent = false;\n        // remove existing data from stats\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        }\n        // set the value\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value);\n        // only add the keys and key-size if the key is new\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n        this.emit(\"set\", key, value);\n        // return true\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n\n// loop over keyValueSet to validate key and ttl\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          ({key, val, ttl} = keyValuePair);\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          ({key, val, ttl} = keyValuePair);\n          this.set(key, val, ttl);\n        }\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache);\n        // convert keys to an array of itself\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n        delCount = 0;\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // only delete if existent\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++;\n            // delete the value\n            oldVal = this.data[key];\n            delete this.data[key];\n            // return true\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n        if ((_ret != null)) {\n          this.del(key);\n        }\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n        if (!key) {\n          return false;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existent data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n        boundMethodCheck(this, NodeCache);\n        if (!key) {\n          return void 0;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existant data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n        boundMethodCheck(this, NodeCache);\n        _exists = (this.data[key] != null) && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache);\n        // parameter just for testing\n\n        // set data empty\n        this.data = {};\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // reset check period\n        this._killCheckPeriod();\n        this._checkData(_startPeriod);\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache);\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data;\n        // run the housekeeping method\n        for (key in ref) {\n          value = ref[key];\n          this._check(key, value);\n        }\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n          if ((this.checkTimeout != null) && (this.checkTimeout.unref != null)) {\n            this.checkTimeout.unref();\n          }\n        }\n      }\n\n      // ## _killCheckPeriod\n\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n        boundMethodCheck(this, NodeCache);\n        _retval = true;\n        // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        // define the time to live\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000;\n        // use given ttl\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + (ttl * ttlMultiplicator);\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + (this.options.stdTTL * ttlMultiplicator);\n          }\n        }\n        // return the wrapped value\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      }\n\n      // ## _unwrap\n\n      // internal method to extract get the value out of the wrapped value\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n        return null;\n      }\n\n      // ## _getKeyLength\n\n      // internal method the calculate the key length\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if ((value != null) && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache);\n        // generate the error object\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data;\n        // return the error object\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function(args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    };\n\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n\n    return NodeCache;\n\n  }).call(this);\n\n}).call(this);\n","// src/error/index.ts\nvar UpstashError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"UpstashError\";\n  }\n};\n\n// src/http/index.ts\nvar HttpClient = class {\n  baseUrl;\n  headers;\n  options;\n  retry;\n  constructor(config) {\n    this.options = {\n      cache: config.cache,\n      signal: config.signal\n    };\n    this.baseUrl = config.baseUrl.replace(/\\/$/, \"\");\n    this.headers = {\n      \"Content-Type\": \"application/json\",\n      ...config.headers\n    };\n    this.retry = typeof config?.retry === \"boolean\" && config?.retry === false ? {\n      attempts: 1,\n      backoff: () => 0\n    } : {\n      attempts: config?.retry?.retries ?? 5,\n      backoff: config?.retry?.backoff ?? ((retryCount) => Math.exp(retryCount) * 50)\n    };\n  }\n  async request(req) {\n    const requestOptions = {\n      cache: this.options.cache,\n      method: \"POST\",\n      headers: this.headers,\n      body: JSON.stringify(req.body),\n      keepalive: true,\n      signal: this.options.signal\n    };\n    let res = null;\n    let error = null;\n    for (let i = 0; i <= this.retry.attempts; i++) {\n      try {\n        res = await fetch([this.baseUrl, ...req.path ?? []].join(\"/\"), requestOptions);\n        break;\n      } catch (error_) {\n        if (this.options.signal?.aborted) {\n          const myBlob = new Blob([\n            JSON.stringify({ result: this.options.signal.reason ?? \"Aborted\" })\n          ]);\n          const myOptions = {\n            status: 200,\n            statusText: this.options.signal.reason ?? \"Aborted\"\n          };\n          res = new Response(myBlob, myOptions);\n          break;\n        }\n        error = error_;\n        if (i < this.retry.attempts) {\n          await new Promise((r) => setTimeout(r, this.retry.backoff(i)));\n        }\n      }\n    }\n    if (!res) {\n      throw error ?? new Error(\"Exhausted all retries\");\n    }\n    const body = await res.json();\n    if (!res.ok) {\n      throw new UpstashError(`${body.error}`);\n    }\n    return { result: body.result, error: body.error };\n  }\n};\n\n// src/commands/client/query/types.ts\nvar WeightingStrategy = /* @__PURE__ */ ((WeightingStrategy2) => {\n  WeightingStrategy2[\"IDF\"] = \"IDF\";\n  return WeightingStrategy2;\n})(WeightingStrategy || {});\nvar FusionAlgorithm = /* @__PURE__ */ ((FusionAlgorithm2) => {\n  FusionAlgorithm2[\"RRF\"] = \"RRF\";\n  FusionAlgorithm2[\"DBSF\"] = \"DBSF\";\n  return FusionAlgorithm2;\n})(FusionAlgorithm || {});\nvar QueryMode = /* @__PURE__ */ ((QueryMode2) => {\n  QueryMode2[\"HYBRID\"] = \"HYBRID\";\n  QueryMode2[\"DENSE\"] = \"DENSE\";\n  QueryMode2[\"SPARSE\"] = \"SPARSE\";\n  return QueryMode2;\n})(QueryMode || {});\n\n// src/commands/command.ts\nvar Command = class {\n  payload;\n  endpoint;\n  constructor(command, endpoint) {\n    this.payload = command;\n    this.endpoint = endpoint;\n  }\n  /**\n   * Execute the command using a client.\n   */\n  async exec(client) {\n    const { result, error } = await client.request({\n      body: this.payload,\n      path: [this.endpoint]\n    });\n    if (error) {\n      throw new UpstashError(error);\n    }\n    if (result === void 0) {\n      throw new TypeError(\"Request did not return a result\");\n    }\n    return result;\n  }\n};\n\n// src/commands/client/query/query-many/index.ts\nvar QueryManyCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"query\";\n    const hasData = payload.some((p) => p.data);\n    endpoint = hasData ? \"query-data\" : \"query\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/query/query-single/index.ts\nvar QueryCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"query\";\n    if (\"data\" in payload) {\n      endpoint = \"query-data\";\n    } else if (!payload.vector && !payload.sparseVector) {\n      throw new UpstashError(\"Either data, vector or sparseVector should be provided.\");\n    }\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/delete/index.ts\nvar DeleteCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"delete\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    if (typeof payload === \"string\" || typeof payload === \"number\") {\n      super(\n        {\n          ids: [payload]\n        },\n        endpoint\n      );\n    } else if (Array.isArray(payload)) {\n      super(\n        {\n          ids: payload\n        },\n        endpoint\n      );\n    } else if (typeof payload === \"object\") {\n      super(payload, endpoint);\n    }\n  }\n};\n\n// src/commands/client/upsert/index.ts\nvar UpsertCommand = class extends Command {\n  constructor(payload, opts) {\n    let endpoint = \"upsert\";\n    if (Array.isArray(payload)) {\n      const isUpsert = payload.some((p) => isVectorPayload(p));\n      endpoint = isUpsert ? \"upsert\" : \"upsert-data\";\n    } else {\n      endpoint = isVectorPayload(payload) ? \"upsert\" : \"upsert-data\";\n    }\n    if (opts?.namespace) {\n      endpoint = `${endpoint}/${opts.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\nvar isVectorPayload = (payload) => {\n  return \"vector\" in payload || \"sparseVector\" in payload;\n};\n\n// src/commands/client/fetch/index.ts\nvar FetchCommand = class extends Command {\n  constructor([payload, opts]) {\n    let endpoint = \"fetch\";\n    if (opts?.namespace) {\n      endpoint = `${endpoint}/${opts.namespace}`;\n      delete opts.namespace;\n    }\n    if (Array.isArray(payload)) {\n      super({ ids: payload, ...opts }, endpoint);\n    } else if (typeof payload === \"object\") {\n      super({ ...payload, ...opts }, endpoint);\n    } else {\n      throw new Error(\"Invalid payload\");\n    }\n  }\n};\n\n// src/commands/client/range/index.ts\nvar RangeCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"range\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/reset/index.ts\nvar ResetCommand = class extends Command {\n  constructor(options) {\n    let endpoint = \"reset\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    } else if (options?.all) {\n      endpoint = `${endpoint}?all`;\n    }\n    super([], endpoint);\n  }\n};\n\n// src/commands/client/info/index.ts\nvar InfoCommand = class extends Command {\n  constructor() {\n    const endpoint = \"info\";\n    super([], endpoint);\n  }\n};\n\n// src/commands/client/resumable-query/resume.ts\nvar ResumeQueryCommand = class extends Command {\n  constructor(payload) {\n    super(payload, \"resumable-query-next\");\n  }\n};\n\n// src/commands/client/resumable-query/start.ts\nvar StartResumableQueryCommand = class extends Command {\n  constructor(payload, namespace) {\n    let endpoint = \"resumable-query\";\n    if (\"data\" in payload) {\n      endpoint = \"resumable-query-data\";\n    }\n    if (namespace) {\n      endpoint = `${endpoint}/${namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/resumable-query/stop.ts\nvar StopResumableQueryCommand = class extends Command {\n  constructor(payload) {\n    super(payload, \"resumable-query-end\");\n  }\n};\n\n// src/commands/client/resumable-query/index.ts\nvar ResumableQuery = class {\n  uuid;\n  start;\n  fetchNext;\n  stop;\n  constructor(payload, client, namespace) {\n    this.start = async () => {\n      const result = await new StartResumableQueryCommand(payload, namespace).exec(\n        client\n      );\n      this.uuid = result.uuid;\n      return result;\n    };\n    this.fetchNext = (additionalK) => {\n      if (!this.uuid) {\n        throw new Error(\n          \"The resumable query has already been stopped. Please start another resumable query.\"\n        );\n      }\n      return new ResumeQueryCommand({ uuid: this.uuid, additionalK }).exec(client);\n    };\n    this.stop = async () => {\n      if (!this.uuid) {\n        throw new Error(\"Resumable query has not been started. Call start() first.\");\n      }\n      const result = await new StopResumableQueryCommand({ uuid: this.uuid }).exec(client);\n      this.uuid = \"\";\n      return result;\n    };\n  }\n};\n\n// src/commands/client/namespace/index.ts\nvar Namespace = class {\n  client;\n  namespace;\n  /**\n   * Create a new index namespace client\n   *\n   * @example\n   * ```typescript\n   * const index = new Index({\n   *  url: \"<UPSTASH_VECTOR_REST_URL>\",\n   *  token: \"<UPSTASH_VECTOR_REST_TOKEN>\",\n   * });\n   *\n   * const namespace = index.namespace(\"ns\");\n   * ```\n   */\n  constructor(client, namespace) {\n    this.client = client;\n    this.namespace = namespace;\n  }\n  /**\n   * Upserts (Updates and Inserts) specific items into the index namespace.\n   * It's used for adding new items to the index namespace or updating existing ones.\n   *\n   * @example\n   * ```js\n   * const upsertArgs = {\n   *   id: '123',\n   *   vector: [0.42, 0.87, ...],\n   *   metadata: { property1: 'value1', property2: 'value2' }\n   * };\n   * const upsertResult = await index.namespace(\"ns\").upsert(upsertArgs);\n   * console.log(upsertResult); // Outputs the result of the upsert operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpsertCommand>} args - The arguments for the upsert command.\n   * @param {number|string} args.id - The unique identifier for the item being upserted.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Dict} [args.metadata] - Optional metadata to be associated with the item.\n   *\n   * @returns {string} A promise that resolves with the result of the upsert operation after the command is executed.\n   */\n  upsert = (args) => new UpsertCommand(args, { namespace: this.namespace }).exec(this.client);\n  /*\n   * Updates specific items in the index.\n   * It's used for updating existing items in the index.\n   *\n   * @example\n   * ```js\n   * const updateArgs = {\n   *   id: '123',\n   *   metadata: { updatedProperty: 'value1' }\n   * };\n   * const updateResult = await index.update(updateArgs);\n   * console.log(updateResult); // Outputs the result of the update operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpdateCommand>} args - The arguments for the update command.\n   * @param {number|string} args.id - The unique identifier for the item being updated.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.\n   *\n   * @returns {Promise<{updated: number}>} A promise that returns the number of items successfully updated.\n   */\n  update = (args) => new UpdateCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * Fetches specific items from the index by their IDs or by an id prefix.\n   *\n   * Note: While using id prefix, the paginated `range` command is recommended to prevent timeouts on large result sets.\n   *\n   * @example\n   * ```js\n   * // Using ids\n   * await index.namespace(\"ns\").fetch([\"test-1\", \"test-2\"], { includeMetadata: true });\n   *\n   * // Using id prefix\n   * await index.namespace(\"ns\").fetch({ prefix: \"test-\" });\n   * ```\n   *\n   * @param {...CommandArgs<typeof FetchCommand>} args - The arguments for the fetch command.\n   * @param {FetchPayload} args[0] - An array of IDs or the id prefix of the items to be fetched.\n   * @param {FetchCommandOptions} args[1] - Options for the fetch operation.\n   * @param {boolean} [args[1].includeMetadata=false] - Optionally include metadata of the fetched items.\n   * @param {boolean} [args[1].includeVectors=false] - Optionally include feature vectors of the fetched items.\n   * @param {string} [args[1].namespace = \"\"] - The namespace of the index to fetch items from.\n   *\n   * @returns {Promise<FetchReturnResponse<TMetadata>[]>} A promise that resolves with an array of fetched items or null if not found, after the command is executed.\n   */\n  fetch = (...args) => {\n    if (args[1]) {\n      args[1].namespace = this.namespace;\n    } else {\n      args[1] = { namespace: this.namespace };\n    }\n    return new FetchCommand(args).exec(this.client);\n  };\n  /**\n   * Queries an index namespace with specified parameters.\n   * This method creates and executes a query command on an index based on the provided arguments.\n   *\n   * @example\n   * ```js\n   * await index.namespace(\"ns\").query({\n   *  topK: 3,\n   *  vector: [ 0.22, 0.66 ],\n   *  filter: \"age >= 23 and (type = \\'turtle\\' OR type = \\'cat\\')\"\n   * });\n   * ```\n   *\n   * @param {Object} args - The arguments for the query command.\n   * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.\n   *                                This vector is utilized to find the most relevant items in the index.\n   * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.\n   * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.\n   * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.\n   * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.\n   *\n   * @returns A promise that resolves with an array of query result objects when the request to query the index is completed.\n   */\n  query = (args) => new QueryCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * Initializes a resumable query operation on the vector database.\n   * This method allows for querying large result sets in multiple chunks or implementing pagination.\n   *\n   * @template TMetadata\n   * @param {ResumableQueryPayload} args - The arguments for the resumable query.\n   * @param {number} args.maxIdle - The maximum idle time in seconds before the query session expires.\n   * @param {number} args.topK - The number of top results to return in each fetch operation.\n   * @param {number[]} args.vector - The query vector used for similarity search.\n   * @param {boolean} [args.includeMetadata] - Whether to include metadata in the query results.\n   * @param {boolean} [args.includeVectors] - Whether to include vectors in the query results.\n   * @param {Object} [options] - Additional options for the query.\n   * @returns {Promise<ResumableQuery<TMetadata>>} A promise that resolves to a ResumableQuery object.\n   * @example\n   * const { result, fetchNext, stop } = await index.namespace(\"ns\").resumableQuery({\n   *   maxIdle: 3600,\n   *   topK: 50,\n   *   vector: [0.1, 0.2, 0.3, ...],\n   *   includeMetadata: true,\n   *   includeVectors: true\n   * }, { namespace: 'my-namespace' });\n   *\n   * const firstBatch = await fetchNext(10);\n   * const secondBatch = await fetchNext(10);\n   * await stop(); // End the query session\n   */\n  resumableQuery = async (args) => {\n    const resumableQuery = new ResumableQuery(args, this.client, this.namespace);\n    const initialQuery = await resumableQuery.start();\n    const { fetchNext, stop } = resumableQuery;\n    return { fetchNext, stop, result: initialQuery.scores };\n  };\n  /**\n     * Deletes items from the index namespace by id, by id prefix, or by filter.\n     *\n     * @example\n     * ```js\n     * // Delete by id\n     * await index.namespace(\"ns\").delete(\"test-id\");\n  \n     * // Delete by ids\n     * await index.namespace(\"ns\").delete([\"test-id1\", \"test-id2\"]);\n  \n     * // Delete by id prefix\n     * await index.namespace(\"ns\").delete({ prefix: \"test-\" });\n  \n     * // Delete by filter\n     * await index.namespace(\"ns\").delete({ filter: \"age >= 23\" });\n     * ```\n     *\n     * @param args - A single id, an array of ids, a prefix, or a filter to delete items from the index.\n     * @returns Number of deleted vectors in the format `{ deleted: number }`.If no vectors are deleted, returns `{ deleted: 0 }`.\n     */\n  delete = (args) => new DeleteCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * Retrieves a paginated range of items from the index. Optionally filter results by an id prefix.\n   * Returns items in batches with a cursor for pagination.\n   *\n   * @example\n   * ```js\n   * const args = {\n   *   limit: 10,\n   *   includeVectors: true,\n   *   includeMetadata: false\n   * };\n   * await index.namespace(\"ns\").range(args);\n   *\n   * // Use the cursor to get the next page of results\n   * const nextPage = await index.namespace(\"ns\").range({\n   *   // You have to pass the arguments from the first call\n   *   ...args,\n   *   cursor: rangeResult.nextCursor,\n   * });\n   * ```\n   *\n   * @param {CommandArgs<typeof RangeCommand>} args - The arguments for the range command.\n   * @param {string} [args.prefix] - The prefix of the items to be fetched.\n   * @param {number|string} args.cursor - The starting point (cursor) for the range query.\n   * @param {number} args.limit - The maximum number of items to return in this range.\n   * @param {boolean} [args.includeVectors=false] - Optionally include the feature vectors of the items in the response.\n   * @param {boolean} [args.includeMetadata=false] - Optionally include additional metadata of the items in the response.\n   *\n   * @returns {Promise<RangeReturnResponse<TMetadata>>} A promise that resolves with the response containing the next cursor and an array of vectors, after the command is executed.\n   */\n  range = (args) => new RangeCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * It's used for wiping all the vectors in a index namespace.\n   *\n   * @example\n   * ```js\n   * await index.namespace(\"ns\").reset();\n   * console.log('Index namespace has been reset');\n   * ```\n   *\n   * @returns {Promise<string>} A promise that resolves with the result of the reset operation after the command is executed.\n   */\n  reset = () => new ResetCommand({ namespace: this.namespace }).exec(this.client);\n};\n\n// src/commands/client/update/index.ts\nvar UpdateCommand = class extends Command {\n  constructor(payload, opts) {\n    let endpoint = \"update\";\n    if (opts?.namespace) {\n      endpoint = `${endpoint}/${opts.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/management/namespaces/list/index.ts\nvar ListNamespacesCommand = class extends Command {\n  constructor() {\n    const endpoint = \"list-namespaces\";\n    super([], endpoint);\n  }\n};\n\n// src/commands/management/namespaces/delete/index.ts\nvar DeleteNamespaceCommand = class extends Command {\n  constructor(namespace) {\n    const endpoint = `delete-namespace/${namespace}`;\n    super([], endpoint);\n  }\n};\n\n// src/vector.ts\nvar Index = class {\n  client;\n  /**\n   * Create a new vector db client\n   *\n   * @example\n   * ```typescript\n   * const index = new Index({\n   *  url: \"<UPSTASH_VECTOR_REST_URL>\",\n   *  token: \"<UPSTASH_VECTOR_REST_TOKEN>\",\n   * });\n   * ```\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  namespace = (namespace) => new Namespace(this.client, namespace);\n  /**\n     * Deletes items from the index by id, by id prefix, or by filter.\n     *\n     * @example\n     * ```js\n     * // Delete by id\n     * await index.delete(\"test-id\");\n  \n     * // Delete by ids\n     * await index.delete([\"test-id1\", \"test-id2\"]);\n  \n     * // Delete by id prefix\n     * await index.delete({ prefix: \"test-\" });\n  \n     * // Delete by filter\n     * await index.delete({ filter: \"age >= 23\" });\n     * ```\n     *\n     * @param args - A single id, an array of ids, a prefix, or a filter to delete items from the index.\n     * @returns Number of deleted vectors in the format `{ deleted: number }`.If no vectors are deleted, returns `{ deleted: 0 }`.\n     */\n  delete = (args, options) => new DeleteCommand(args, options).exec(this.client);\n  /**\n   * Queries an index with specified parameters.\n   * This method creates and executes a query command on an index based on the provided arguments.\n   *\n   * @example\n   * ```js\n   * await index.query({\n   *  topK: 3,\n   *  vector: [ 0.22, 0.66 ],\n   *  filter: \"age >= 23 and (type = \\'turtle\\' OR type = \\'cat\\')\"\n   * });\n   * ```\n   *\n   * @param {Object} args - The arguments for the query command.\n   * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.\n   *                                This vector is utilized to find the most relevant items in the index.\n   * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.\n   * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.\n   * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.\n   * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.\n   * @param {boolean} [args.includeData=false] - When set to true, includes data - string - of the returned items in the response.\n   *\n   *  A promise that resolves with an array of query result objects when the request to query the index is completed.\n   */\n  query = (args, options) => new QueryCommand(args, options).exec(this.client);\n  /**\n   * Queries an index with specified parameters.\n   * This method creates and executes a query command on an index based on the provided arguments.\n   *\n   * @example\n   * ```js\n   * await index.queryMany([\n   * {\n   *     topK: 3,\n   *     vector: [0.22, 0.66],\n   *     filter: \"age >= 23 and (type = 'turtle' OR type = 'cat')\",\n   * },\n   * {\n   *     topK: 3,\n   *     vector: [0.45, 0.52],\n   *     filter: \"age >= 27 and (type = 'rabbit' OR type = 'dog')\",\n   * },\n   * ]);\n   *\n   * ```\n   *\n   * @param {Object} args - The arguments for the query command.\n   * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.\n   *                                This vector is utilized to find the most relevant items in the index.\n   * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.\n   * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.\n   * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.\n   * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.\n   * @param {boolean} [args.includeData=false] - When set to true, includes data - string - of the returned items in the response.\n   *\n   *  A promise that resolves with an array of arrays of query result objects,\n   *  where each inner array represents a group of results matching a specific query condition.\n   */\n  queryMany = (args, options) => new QueryManyCommand(args, options).exec(this.client);\n  /**\n   * Initializes a resumable query operation on the vector database.\n   * This method allows for querying large result sets in multiple chunks or implementing pagination.\n   *\n   * @template TMetadata\n   * @param {ResumableQueryPayload} args - The arguments for the resumable query.\n   * @param {number} args.maxIdle - The maximum idle time in seconds before the query session expires.\n   * @param {number} args.topK - The number of top results to return in each fetch operation.\n   * @param {number[]} args.vector - The query vector used for similarity search.\n   * @param {boolean} [args.includeMetadata] - Whether to include metadata in the query results.\n   * @param {boolean} [args.includeVectors] - Whether to include vectors in the query results.\n   * @param {Object} [options] - Additional options for the query.\n   * @param {string} [options.namespace] - The namespace to query within.\n   * @returns {Promise<ResumableQuery<TMetadata>>} A promise that resolves to a ResumableQuery object.\n   * @example\n   * const { result, fetchNext, stop } = await index.resumableQuery({\n   *   maxIdle: 3600,\n   *   topK: 50,\n   *   vector: [0.1, 0.2, 0.3, ...],\n   *   includeMetadata: true,\n   *   includeVectors: true\n   * }, { namespace: 'my-namespace' });\n   *\n   * const firstBatch = await fetchNext(10);\n   * const secondBatch = await fetchNext(10);\n   * await stop(); // End the query session\n   */\n  resumableQuery = async (args, options) => {\n    const resumableQuery = new ResumableQuery(args, this.client, options?.namespace);\n    const initialQuery = await resumableQuery.start();\n    const { fetchNext, stop } = resumableQuery;\n    return { fetchNext, stop, result: initialQuery.scores };\n  };\n  /**\n   * Upserts (Updates and Inserts) specific items into the index.\n   * It's used for adding new items to the index or updating existing ones.\n   *\n   * @example\n   * ```js\n   * const upsertArgs = {\n   *   id: '123',\n   *   vector: [0.42, 0.87, ...],\n   *   metadata: { property1: 'value1', property2: 'value2' }\n   * };\n   * const upsertResult = await index.upsert(upsertArgs);\n   * console.log(upsertResult); // Outputs the result of the upsert operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpsertCommand>} args - The arguments for the upsert command.\n   * @param {number|string} args.id - The unique identifier for the item being upserted.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.\n   *\n   * @returns {string} A promise that resolves with the result of the upsert operation after the command is executed.\n   */\n  upsert = (args, options) => new UpsertCommand(args, options).exec(this.client);\n  /*\n   * Updates specific items in the index.\n   * It's used for updating existing items in the index.\n   *\n   * @example\n   * ```js\n   * const updateArgs = {\n   *   id: '123',\n   *   vector: [0.42, 0.87, ...],\n   *   metadata: { property1: 'value1', property2: 'value2' }\n   * };\n   * const updateResult = await index.update(updateArgs);\n   * console.log(updateResult); // Outputs the result of the update operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpdateCommand>} args - The arguments for the update command.\n   * @param {number|string} args.id - The unique identifier for the item being updated.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.\n   * @param {string} [args.namespace] - The namespace to update the item in.\n   *\n   * @returns {Promise<{updated: number}>} A promise that returns the number of items successfully updated.\n   */\n  update = (args, options) => new UpdateCommand(args, options).exec(this.client);\n  /**\n   * Fetches specific items from the index by their IDs or by an id prefix.\n   *\n   * Note: While using id prefix, the paginated `range` command is recommended to prevent timeouts on large result sets.\n   *\n   * @example\n   * ```js\n   * // Using ids\n   * await index.fetch([\"test-1\", \"test-2\"], { includeMetadata: true });\n   *\n   * // Using id prefix\n   * await index.fetch({ prefix: \"test-\" });\n   * ```\n   *\n   * @param {...CommandArgs<typeof FetchCommand>} args - The arguments for the fetch command.\n   * @param {FetchPayload} args[0] - An array of IDs or the id prefix of the items to be fetched.\n   * @param {FetchCommandOptions} args[1] - Options for the fetch operation.\n   * @param {boolean} [args[1].includeMetadata=false] - Optionally include metadata of the fetched items.\n   * @param {boolean} [args[1].includeVectors=false] - Optionally include feature vectors of the fetched items.\n   * @param {string} [args[1].namespace = \"\"] - The namespace of the index to fetch items from.\n   *\n   * @returns {Promise<FetchReturnResponse<TMetadata>[]>} A promise that resolves with an array of fetched items or null if not found, after the command is executed.\n   */\n  fetch = (...args) => new FetchCommand(args).exec(this.client);\n  /**\n   * It's used for wiping the index.\n   *\n   * By default, resets the default namespace:\n   *\n   * @example\n   * ```js\n   * await index.reset();\n   * console.log('Default namespace has been reset');\n   * ```\n   *\n   * To reset a namespace, call reset like:\n   *\n   * @example\n   * ```js\n   * await index.reset({ namespace: \"ns\" });\n   * console.log('Namespace ns has been reset');\n   * ```\n   *\n   * If you want to reset all namespaces, call reset like:\n   *\n   * @example\n   * ```js\n   * await index.reset({ all: true });\n   * console.log('All namespaces have been reset');\n   * ```\n   *\n   * @returns {Promise<string>} A promise that resolves with the result of the reset operation after the command is executed.\n   */\n  reset = (options) => new ResetCommand(options).exec(this.client);\n  /**\n   * Retrieves a paginated range of items from the index. Optionally filter results by an id prefix.\n   * Returns items in batches with a cursor for pagination.\n   *\n   * @example\n   * ```js\n   * const args = {\n   *   limit: 10,\n   *   includeVectors: true,\n   *   includeMetadata: false\n   * };\n   * await index.range(args);\n   *\n   * // Use the cursor to get the next page of results\n   * const nextPage = await index.range({\n   *   // You have to pass the arguments from the first call\n   *   ...args,\n   *   cursor: rangeResult.nextCursor,\n   * });\n   * ```\n   *\n   * @param {CommandArgs<typeof RangeCommand>} args - The arguments for the range command.\n   * @param {string} [args.prefix] - The prefix of the items to be fetched.\n   * @param {number|string} args.cursor - The starting point (cursor) for the range query.\n   * @param {number} args.limit - The maximum number of items to return in this range.\n   * @param {boolean} [args.includeVectors=false] - Optionally include the feature vectors of the items in the response.\n   * @param {boolean} [args.includeMetadata=false] - Optionally include additional metadata of the items in the response.\n   *\n   * @returns {Promise<RangeReturnResponse<TMetadata>>} A promise that resolves with the response containing the next cursor and an array of vectors, after the command is executed.\n   */\n  range = (args, options) => new RangeCommand(args, options).exec(this.client);\n  /**\n   * Retrieves info from the index.\n   *\n   * @example\n   * ```js\n   * const infoResults = await index.info();\n   * console.log(infoResults); // Outputs the result of the info operation\n   * ```\n   *\n   * @returns {Promise<InfoResult>} A promise that resolves with the response containing the vectorCount, pendingVectorCount, indexSize, dimension count and similarity algorithm after the command is executed.\n   */\n  info = () => new InfoCommand().exec(this.client);\n  /**\n   * List all namespaces in the vector database.\n   *\n   * @example\n   * ```js\n   * const namespaces = await index.listNamespaces();\n   * console.log(namespaces); // Outputs the list of namespaces\n   * ```\n   *\n   * @returns {Promise<string[]>} A promise that resolves with an array of namespaces after the command is executed.\n   */\n  listNamespaces = () => new ListNamespacesCommand().exec(this.client);\n  /**\n   * Deletes a namespace from the vector database.\n   *\n   * @example\n   * ```js\n   * await index.deleteNamespace('namespace');\n   * console.log('Namespace has been deleted');\n   * ```\n   *\n   * @param {string} namespace - The name of the namespace to be deleted.\n   * @returns {Promise<string>} A promise that resolves with the result of the delete operation after the command is executed.\n   */\n  deleteNamespace = (namespace) => new DeleteNamespaceCommand(namespace).exec(this.client);\n};\n\n// version.ts\nvar VERSION = \"v1.2.1\";\n\nexport {\n  HttpClient,\n  WeightingStrategy,\n  FusionAlgorithm,\n  QueryMode,\n  Index,\n  VERSION\n};\n","import {\n  FusionAlgorithm,\n  HttpClient,\n  Index,\n  QueryMode,\n  VERSION,\n  WeightingStrategy\n} from \"./chunk-HESEGT2A.mjs\";\n\n// src/utils/get-runtime.ts\nfunction getRuntime() {\n  if (typeof process === \"object\" && typeof process.versions == \"object\" && process.versions.bun)\n    return `bun@${process.versions.bun}`;\n  return typeof EdgeRuntime === \"string\" ? \"edge-light\" : `node@${process.version}`;\n}\n\n// src/platforms/nodejs.ts\nvar Index2 = class _Index extends Index {\n  constructor(configOrRequester) {\n    if (configOrRequester !== void 0 && \"request\" in configOrRequester) {\n      super(configOrRequester);\n      return;\n    }\n    const token = configOrRequester?.token ?? process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_TOKEN ?? process.env.UPSTASH_VECTOR_REST_TOKEN;\n    const url = configOrRequester?.url ?? process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_URL ?? process.env.UPSTASH_VECTOR_REST_URL;\n    if (!token) {\n      throw new Error(\"UPSTASH_VECTOR_REST_TOKEN is missing!\");\n    }\n    if (!url) {\n      throw new Error(\"UPSTASH_VECTOR_REST_URL is missing!\");\n    }\n    if (url.startsWith(\" \") || url.endsWith(\" \") || /\\r|\\n/.test(url)) {\n      console.warn(\"The vector url contains whitespace or newline, which can cause errors!\");\n    }\n    if (token.startsWith(\" \") || token.endsWith(\" \") || /\\r|\\n/.test(token)) {\n      console.warn(\"The vector token contains whitespace or newline, which can cause errors!\");\n    }\n    const enableTelemetry = process.env.UPSTASH_DISABLE_TELEMETRY ? false : configOrRequester?.enableTelemetry ?? true;\n    const telemetryHeaders = enableTelemetry ? {\n      \"Upstash-Telemetry-Sdk\": `upstash-vector-js@${VERSION}`,\n      \"Upstash-Telemetry-Platform\": process.env.VERCEL ? \"vercel\" : process.env.AWS_REGION ? \"aws\" : \"unknown\",\n      \"Upstash-Telemetry-Runtime\": getRuntime()\n    } : {};\n    const client = new HttpClient({\n      baseUrl: url,\n      retry: configOrRequester?.retry,\n      headers: { authorization: `Bearer ${token}`, ...telemetryHeaders },\n      cache: configOrRequester?.cache === false ? void 0 : configOrRequester?.cache || \"no-store\",\n      signal: configOrRequester?.signal\n    });\n    super(client);\n  }\n  /**\n   * Create a new Upstash Vector instance from environment variables.\n   *\n   * Use this to automatically load connection secrets from your environment\n   * variables. For instance when using the Vercel integration.\n   *\n   * When used on the Cloudflare Workers, you can just pass the \"env\" context provided by Cloudflare.\n   * Else, this tries to load `UPSTASH_VECTOR_REST_URL` and `UPSTASH_VECTOR_REST_TOKEN` from\n   * your environment using `process.env`.\n   */\n  static fromEnv(env, config) {\n    const url = env?.UPSTASH_VECTOR_REST_URL || process?.env.UPSTASH_VECTOR_REST_URL;\n    const token = env?.UPSTASH_VECTOR_REST_TOKEN || process?.env.UPSTASH_VECTOR_REST_TOKEN;\n    if (!url) {\n      throw new Error(\"Unable to find environment variable: `UPSTASH_VECTOR_REST_URL`\");\n    }\n    if (!token) {\n      throw new Error(\"Unable to find environment variable: `UPSTASH_VECTOR_REST_TOKEN`\");\n    }\n    return new _Index({ ...config, url, token });\n  }\n};\nexport {\n  FusionAlgorithm,\n  Index2 as Index,\n  QueryMode,\n  WeightingStrategy\n};\n"],"names":[],"sourceRoot":""}