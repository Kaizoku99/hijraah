{"version":3,"file":"../app/api/onboarding/route.js","mappings":"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,wBAAV,+DAAgC,GAGxC,OAAOmK,OAAOnK,EAAMwC,MAAM,CAAClE,KAAK,CAAC,KAAK8L,EAAE,CAAC,CAAC,GAC5C,gPClGA,qDCAA,4DCAA,kDCAA,wDCAA,iECAA,uDCAA,sDCAA,oDCAA,iDCAA,2DCAA,2DCAA,2CCAA,sCAAyN,yBCAzN,iDCAA,4VCiBA,gBACA,SACA,0EACA,YACA,4DACA,8CAA6D,WAAc,IAC3E,uEACA,kBAEA,QACA,CAOA,gBACA,MACA,6DACA,CAKA,gBACA,6BACA,sCACA,sBAEA,OADA,iCACA,CACA,CACA,CAwEA,gBACA,oBACA,aAEA,oCACA,SAEA,sBACA,mBAGA,sBAKA,+CAPA,SAWA,qBACA,mDACA,wBACA,CAnHA,mDAoHA,SACA,cACA,oBACA,CACA,OACA,yBACA,sBACA,kBACA,uBAIA,CADA,mBAEA,SAEA,CACA,YACA,yBACA,4BACA,KAGA,iBACA,CACA,SACA,uCACA,CACA,QACA,QACA,IACA,IACA,mCACA,KACA,YACA,YACA,OAGA,UACA,oBAAiB,iDACjB,CACA,cACA,QACA,qBACA,YAA4B,WAAmB,IAC/C,2BAEA,QACA,CACA,uBACA,YAA4B,WAAmB,IAC/C,qBAEA,QACA,CACA,sBACA,SAEA,sBACA,iCACA,oDAGA,QACA,CACA,CAEA,cACA,iBACA,CACA,gBACA,SAIA,OAHA,oCACA,SACA,CAAK,EACL,CACA,CAUA,gBACA,SAMA,OALA,oCACA,QACA,QAEA,CAAK,EACL,CACA,CACA,cACA,yBACA,CAOA,cACA,wBACA,CAOA,QACA,eACA,eACA,qBAEA,kBACA,QAEA,UADA,4EACA,mBAKA,cACA,gCAEA,OADA,wBAAiC,uBAAyC,EAC1E,CACA,CAIA,uBACA,UACA,gCACA,6CACA,0CAAyF,KAAsB,oCAAqC,0BAA8F,kEAAiM,EAAG,GAKtb,OAJA,wBACA,iBACA,QACA,CAAS,EACT,CACA,CAIA,gBACA,wBACA,aACA,OACA,CAAS,CACT,CAIA,mBACA,wBACA,eACA,SACA,CAAS,CACT,CASA,yBAOA,OANA,wBACA,iBACA,gBACA,OACA,WACA,CAAS,EACT,CACA,OACA,KAAmB,qBAAsB,EAAK,GAAG,EAAK,EAAG,CAEzD,CACA,qBACA,mBACA,CACA,CAEA,QACA,eACA,cACA,CACA,CACA,kBACA,iBACA,SACA,WACA,CACA,CACA,kBACA,eACA,kDAA0D,eAAkB,0FAC5E,WACA,CACA,CACA,gBACA,IACA,UACA,CACA,SACA,kBACA,0CAA8E,YAE9E,QACA,CACA,CACA,kBACA,eACA,2GACA,WACA,CACA,CAEA,QACA,sBACA,MACA,4BACA,iBACA,eACA,eAQA,0CAEA,OACA,qCACA,wBAAsC,cAA6B,2BACnE,CACA,CACA,8BACA,4BACA,iBACA,eACA,eACA,kCAEA,2BACA,QACA,4BACA,iBACA,eACA,eAQA,0CACA,OACA,qCACA,uCAAoD,6BAEpD,qBAAuC,cAA6B,qDAA+H,CACnM,CACA,CAKA,8BACA,SAxMA,cACA,SAMA,OALA,oCACA,kBACA,QAEA,CAAK,EACL,CACA,EAgMA,eACA,CACA,iCACA,aACA,CACA,gCACA,uCAAoD,mCACpD,CACA,mBACA,MACA,4DAEA,wBACA,0BACA,CACA,0BACA,uCACA,2CACA,CACA,+BACA,UACA,EAEA,oBACA,oBACA,kBACA,+BAEA,sCACA,qCAEA,kBACA,kCAEA,mBACA,8BAEA,UACA,CACA,2BACA,qBACA,CACA,CAEA,QACA,iBACA,QACA,kBACA,qCAA6C,cAA+B,iHAA6M,CACzR,CACA,CAEA,QACA,aACA,qCAA6C,eAAgC,eAAkB,CAC/F,CACA,CAEA,QACA,qBACA,8BACA,kBACA,EACA,CACA,YACA,EAEA,CACA,QACA,wDACA,CACA,CACA,wBAEA,qCACA,OAEA,SAqBA,OApBA,cACA,MACA,oBACA,GADkD,KAClD,wBACA,oDAGA,gCACA,YACA,SACA,CAAiB,EAGjB,kCAEA,sBACA,6BAAiD,GAAe,kEAEhE,UACA,CAAS,EACT,CACA,eACA,SACA,CACA,CACA,CAEA,QACA,eAEA,qCAA6C,eAAgC,mBAA6B,CAC1G,CACA,CAEA,QACA,mBAEA,OACA,MAFA,iCAEA,MACA,SACA,EACA,CACA,cACA,EAEA,CACA,CACA,mCACA,uBAKA,IAFA,8CACA,4CACA,CAJA,GAKA,CACA,CAEA,QACA,eACA,qCAA6C,0BAAmD,oBAA8B,CAC9H,CACA,CAqBA,QACA,eACA,IAAgB,iBAdhB,YAEA,aADA,4CACA,aACA,yCACA,QACA,SACA,aACA,UACA,QACA,cAAa,SACb,EAI+B,eAC/B,eASA,iGAEA,qCAA6C,uCAAiE,OAAc,CAC5H,CACA,CAEA,QACA,iBACA,qCAA6C,iDAC7C,CACA,CAEA,QACA,mBACA,MACA,+DACA,yBACA,sBACA,MACA,iEAA6E,0BAAgC,YAAmC,uBAA4B,GAAW,EAAI,0CAE3L,eAEA,KACA,6BACA,qCACA,uDACA,aAEA,8BACA,4DAAqF,eAAgC,uBAAoD,aACzK,CAAgB,YAChB,EAAgB,0CAChB,OACA,OACA,CAAkB,6BAA8B,QAAmB,EAAG,CACtE,EACA,CAEA,CACA,kCACA,yBACA,yBACA,gBACA,aACA,CAAyB,yBAEzB,GAEA,CAAiB,0BACjB,CACA,kBACA,sCACA,wCACA,eACA,CACA,CAEA,QACA,iBACA,uBACA,iBACA,OACA,yCAIA,MADA,gCACA,4CAAyF,KAAU,MAA0B,IAAM,EACnI,qCAAiD,0BAAgC,EAAY,CAC7F,CACA,qCAA6C,eAAgC,uBAAwC,CACrH,CACA,CAEA,QACA,eACA,UACA,wCACA,8DACA,gCACA,+BAEA,gCACA,+BAEA,qCAA6C,eAE7C,iHAA2R,CAC3R,CAKA,0BACA,SACA,OACA,UACA,QACA,QACA,MACA,SACA,OACA,aACA,YACA,SACA,OACA,UACA,QACA,SACA,OACA,OACA,KACA,UACA,cAEA,CACA,uBACA,6BACA,WAEA,CACA,CAEA,QACA,eACA,uBACA,CACA,iBACA,UAAgB,GAAQ,OACxB,WACA,qCAA6C,oDAC7C,CACA,CAEA,QACA,iBAUA,OACA,QAVA,0BACA,OAMA,EADA,yBAKA,CACA,CACA,4BACA,gBAGA,eACA,sCAHA,IAKA,yBACA,mBACA,gCAEA,CACA,CACA,CAEA,QACA,eACA,wBACA,6BACA,6BACA,6BACA,6BACA,8BACA,2BACA,iCACA,4BACA,4BACA,yCACA,mCACA,6BACA,8BACA,CACA,4BACA,eACA,+BAEA,iCACA,gDAEA,iBACA,qCAEA,iDAGA,8BAA6C,CAD7C,6CAC6C,CAAa,UAAuB,CACjF,CACA,uCACA,oCACA,uDAEA,oBACA,yFAEA,oBACA,qIAEA,oBACA,uFAEA,qBACA,0DAEA,qBACA,0FAEA,kBACA,uFAEA,wBACA,6FAEA,mBACA,0FAEA,mBACA,0FAEA,mBACA,6FAEA,gCACA,8GAEA,0BACA,sGAEA,oBACA,2FAEA,kBACA,yDAEA,mBACA,cACA,qBACA,YACA,CAAS,CACT,CACA,CAEA,QACA,iBACA,mBACA,wBACA,mBACA,kBACA,iBACA,sBACA,iCACA,sBACA,CACA,uBAEA,OADA,oDACA,CACA,kCACA,oBAEA,CACA,qBAEA,OADA,oDACA,CACA,iCACA,CACA,CACA,kBACA,QACA,SAMA,OALA,2CAAsC,qBAAgC,IACtE,KACA,sBAAmH,CACnH,SACA,CAAS,EACT,8BAA6C,KAAoB,sCAAuC,yBAAmE,4DAAgE,4BAAsE,kBAAqB,CACtU,CACA,kBACA,OACA,SACA,YACA,YACA,QACA,CACA,6BAEA,WAMA,WAGA,2BACA,2BAHA,EANA,WAGA,GAFA,EAWA,CACA,kBACA,6BACA,8BAGA,eACA,gBACA,2CACA,MACA,cACA,qCACA,MACA,aACA,kCACA,MACA,iBACA,2BACA,MACA,CACA,CACA,+BACA,oBACA,4BAIA,OAHA,GACA,sBAEA,CACA,CACA,qBACA,cACA,yDACA,wDACA,qDACA,OACA,6DAGA,mBACA,mCACA,kDAA0E,OAAiB,GAC3F,SACA,UACA,KACA,oBACA,oBACA,CACA,CAAa,EAEb,uBACA,0DACA,+CACA,WACA,UACA,OACA,sBACA,sBACA,CACA,CAAa,EAEb,OACA,gCAA6C,qCAA8E,GAE3H,CACA,8BACA,MACA,uBACA,qDACA,0BAAkE,KAAc,EAChF,KACA,UAEA,oBA6BA,OA3BA,eADA,gBACA,cACA,QACA,uBACA,0BACA,KACA,MACA,CAAiB,EACjB,KACA,SAEA,yDACA,4BACA,WACA,+CACA,WACA,kBACqB,EAErB,0BACA,SACA,kDAAkF,qBAAwE,GAC1J,SACA,gBACqB,EAErB,yCAA+D,OAAS,aAA2B,EACnG,CAAa,EAGb,mCACA,kDAA0E,OAAuB,GACjG,SACA,gBACa,EAEb,OACA,kCAAuD,OAAS,MAAgB,GAChF,CAEA,2BACA,MACA,4BACA,qDAEA,0CAEA,sBAA+B,OAD/B,8BAEA,WAAsB,iCAAsE,CAC5F,CACA,qBACA,MACA,uBACA,qDACA,wBACA,sBACA,MACA,aAAkD,oBAAsB,EAExE,MACA,aACA,kBACA,WACA,CAAa,EAGb,qCAA6C,CAD7C,iCAC6C,CAAoB,YAAoC,CACrG,CACA,8BACA,MACA,yBACA,mBACA,uBACA,sDACA,CAAgB,qCAChB,yCACA,kCACA,oCACA,MACA,CAIA,oCACA,MACA,uBACA,qBACA,uBACA,uBACA,oDACA,yDAEA,2BACA,CAIA,wBACA,MACA,uBACA,gBACA,2BACA,0CAEA,yBACA,GACA,8BACA,EAEA,kEAAgL,gCAGhL,UACA,OACA,aAIA,oEAh1BA,EAg1BA,SACA,oCACA,wBACA,CACA,WACA,EAEA,CACA,CAQA,yBACA,oBACA,sCACA,gCACA,qBACA,CAAqB,iCAErB,CACA,CACA,qBACA,8BAAuC,EAAM,EAE7C,kBACA,MACA,OAEA,YAAgB,GAAU,qBAC1B,yBACA,qCAA6C,KAAW,UAA6B,CACrF,CACA,iBACA,MACA,SAEA,YAAgB,GAAU,EAC1B,+BACA,gCACA,iCACA,uDAAoI,iBAAmB,EACvJ,sDAAoI,gBAAkB,EACtJ,wDAA0I,kBAAoB,EAU9J,UACA,KACA,KAXA,OACA,oBACA,+DAEA,6BACA,SACA,0CACA,GACS,EAAI,kBAAoB,KAKjC,EACA,CAEA,kBACA,KAGA,yBACA,mCACA,CACA,CACA,gBACA,WAAgB,gCAAmC,iDACnD,SACA,qBAEA,+BAA8F,SAAU,GAAQ,EAAE,EAAK,EAAG,EAC1H,6CAQA,MAPA,CACA,8DAAgF,eAChF,CACA,uCAEA,EAAoB,iBAAqB,GAAc,EAAI,GAAM,YAA+B,CAChG,CAEA,CACA,uBACA,2BAEA,OADA,oDAAkE,2BAClE,CACA,CACA,eACA,6BACA,SAEA,IAAgB,qBAAmB,+BACnC,IACA,CAAgB,gCAChB,GACA,MACA,qCAAiD,OAEjD,uBACA,2BAGA,EACA,mDAA2D,KAAW,UAA0B,IAChG,CACA,qBACA,gBACA,CACA,sBAGA,OADA,EADA,eACA,mCAEA,CACA,kBACA,eACA,QAppCA,UAopCA,QAppCA,EAqpCA,SAEA,IAAoB,UAAuB,oBAE3C,sBAAmC,OADnC,6BACmC,CAAQ,GAC3C,CAAS,CACT,CACA,uBACA,6GACA,CACA,CAEA,QACA,eACA,OAAiB,YACjB,CACA,+BACA,EACA,qBAEA,CACA,CACA,qBACA,qCAA6C,SAAY,GAAO,+BAChE,CACA,iBACA,MAl+BA,YACA,YAEA,OADA,uBACA,eACA,EA89BA,GACA,OACA,mBACA,KACA,CAAoB,QAAsB,CAC1C,kBACA,kBAEA,CACA,mBACA,uBAA+B,cAC/B,eACA,UACA,mBACA,CAA4B,yBAC5B,CAA4B,4CAC5B,WACA,mBACA,CAA4B,yBAC5B,CAA4B,4CAC5B,SACA,QACA,CACA,CAAS,EACT,CACA,CAEA,QACA,eACA,WACA,0BACA,CACA,oBACA,4CACA,qCAA6C,MAC7C,CACA,qBACA,0CACA,CACA,CAEA,QACA,eACA,OAAiB,YACjB,CACA,+BACA,EACA,qBAEA,CACA,CACA,4BACA,EAKA,EACA,CACA,gDAGA,CACA,MACA,EAVA,EAWA,CACA,iBACA,OACA,aACA,CACA,CACA,mBACA,uBAA+B,cAC/B,eACA,UACA,mBACA,CAA4B,yBAC5B,CAA4B,iCAC5B,WACA,mBACA,CAA4B,yBAC5B,CAA4B,iCAC5B,SACA,QACA,CACA,CAAS,EACT,CACA,CAEA,cACA,qCAEA,QACA,eACA,mBACA,oBACA,WACA,yCACA,CACA,oBACA,4CAIA,OAHA,iBACA,UACA,kDACA,4CAA2D,QAA4B,0BAA4B,CACnH,CACA,qBACA,0CACA,CACA,yBACA,qCAEA,OADA,uDAAqE,8BACrE,CACA,CACA,gBCt0CA,aAEE,OAAS,gBACX,QACA,uDAEA,yBADA,qBAEA,6BAEA,qBACA,4CAEA,CACA,8DAEA,0BAEA,MACA,eAAsC,qBAAyC,IAC/E,MACA,yBACA,SAEA,kBACA,kBAGA,QACA,UAGA,OAFA,aAGA,CAAG,mCCvBH,kBAA6C,GAAI,CACjD,gBACA,wBACA,GACA,SACA,yBAA+B,EAC/B,aAD8C,GAC9C,eACA,CAgCA,UAAe,yBAA6C,yBAC5D,GACA,qCAEA,SACA,qBACA,MAAwB,EAAU,2BAClC,SACA,CACA,sBACA,MAAwB,EAAU,4BAClC,SACA,CACA,uBACA,MAAwB,EAAU,8BAClC,SACA,CACA,uBACA,MAAwB,EAAU,8BAClC,SACA,CACA,+BACA,KACA,6BACA,SACA,SAEA,kBACA,gBAAgC,IAAO,EAGvC,SACA,MAA4B,EAAU,YACtC,6BACA,cACY,CACZ,mBACA,iCACA,gCACA,oBAGA,gCAA+C,EAC/C,SACA,EACA,SACA,CACA,CACA,UACA,MAA4B,EAAU,YACtC,6BACA,cACY,CACZ,mBACA,iCACA,iCACA,oBAGA,gCAA+C,EAC/C,SACA,EACA,SACA,CACA,EACA,CAEA,kCAQA,OAPA,QACA,WACA,sBAAgC,MAAM,cACtC,KACA,EACA,GAEA,KACA,CACA,uBAEA,MADA,IAA0B,EAAkB,kCAC5C,oBACA,2CACA,EACA,yBAEA,UAD0B,EAAmB,kCAC7C,oBACA,2CACA,EACA,WACA,eACA,kCACA,IACA,iCACA,gBACA,CAAQ,SACR,oBACA,CACA,CAAK,CAEL,cACA,eACA,kCACA,IACA,mCACA,gBACA,CAAQ,SACR,oBACA,CACA,CAAK,CAEL,YACA,kCAA2D,GAAG,UAC9D,iBACA,gBAGA,0CACA,eACA,gBACA,iFACA,aACA,0CACA,WACA,KAAkB,QAAS,CAC3B,EAEA,sCAAuD,GAAG,GAC1D,aAEA,CAAW,CACX,eACA,6CACA,aACA,KAAkB,QAAS,CAC3B,EAEA,sCAAuD,GAAG,GAC1D,eAEA,CAA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","sources":["webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/after-task-async-storage.external.js\"","webpack://@hijraah/web/./src/types/auth.ts","webpack://@hijraah/web/./src/lib/auth/hooks.tsx","webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+instrumentat_04f370d515cee0be955272f826166073/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/../../../src/client/components/not-found.ts","webpack://@hijraah/web/external commonjs2 \"punycode\"","webpack://@hijraah/web/../../../src/client/components/forbidden.ts","webpack://@hijraah/web/../../node_modules/.pnpm/@supabase+realtime-js@2.11.10_bufferutil@4.0.9/node_modules/@supabase/realtime-js/dist/main/ sync?5147","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/action-async-storage.external.js\"","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/../../../src/client/components/unstable-rethrow.server.ts","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/buffer.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/validator.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/index.js","webpack://@hijraah/web/external commonjs2 \"stream\"","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/api/navigation.react-server.js","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/./src/lib/supabase/client.ts","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"tls\"","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/../../../src/client/components/unstable-rethrow.ts","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/../../../src/client/components/unauthorized.ts","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/http-exception.js","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external commonjs2 \"https\"","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/ignored|E:\\downloads\\Hijraah\\node_modules\\.pnpm\\ws@8.18.2_bufferutil@4.0.9\\node_modules\\ws\\lib|utf-8-validate","webpack://@hijraah/web/./src/lib/auth/errors.ts","webpack://@hijraah/web/./src/lib/auth/rbac.ts","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/cookie.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/helper/cookie/index.js","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/../../../src/client/components/redirect.ts","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/external commonjs2 \"zlib\"","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external commonjs2 \"buffer\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/external commonjs2 \"http\"","webpack://@hijraah/web/?aa2e","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/../../node_modules/.pnpm/@asteasolutions+zod-to-openapi@7.3.4_zod@3.25.67/node_modules/@asteasolutions/zod-to-openapi/dist/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@hono+zod-validator@0.7.0_hono@4.8.2_zod@3.25.67/node_modules/@hono/zod-validator/dist/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@hono+zod-openapi@0.19.8_hono@4.8.2_zod@3.25.67/node_modules/@hono/zod-openapi/dist/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/helper/factory/index.js","webpack://@hijraah/web/src/app/api/onboarding/route.ts","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/?8542","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/../../../src/client/components/navigation.react-server.ts","webpack://@hijraah/web/external commonjs2 \"net\"","webpack://@hijraah/web/external commonjs2 \"events\"","webpack://@hijraah/web/../../node_modules/.pnpm/require-in-the-middle@7.5.2/node_modules/require-in-the-middle/ sync","webpack://@hijraah/web/?45c9"],"sourcesContent":["module.exports = require(\"next/dist/server/app-render/after-task-async-storage.external.js\");","// This file is the single source of truth for Authentication and RBAC related types\r\n\r\nimport { Session, User, SupabaseClient } from \"@supabase/supabase-js\";\r\n\r\nimport { Database } from \"@/types/database.types\";\r\n\r\n// RBAC Types (from former rbac.ts)\r\nexport type Permission = string;\r\n\r\nexport interface Role {\r\n  name: string;\r\n  description?: string;\r\n  permissions: Permission[];\r\n  inherits?: string[];\r\n}\r\n\r\nexport interface RBACOptions {\r\n  roles?: Record<string, Role>;\r\n  superAdminRole?: string;\r\n  enableCache?: boolean;\r\n  extractRoles?: (user: ExtendedUser) => string[];\r\n}\r\n\r\n// Auth Types (from former src/lib/auth/types.ts)\r\nexport interface UserSettings {\r\n  theme: string;\r\n  language: string;\r\n  emailNotifications: boolean;\r\n  documentReminders: boolean;\r\n  applicationUpdates: boolean;\r\n  twoFactorAuth: boolean;\r\n}\r\n\r\nexport type ExtendedUser = User & {\r\n  fullName: string;\r\n  avatarUrl: string;\r\n  role: Database[\"public\"][\"Enums\"][\"user_role\"]; // Updated to use the enum from database\r\n  isAdmin?: boolean; // Consider deriving from a hasPermission('admin.access') or similar\r\n  settings?: UserSettings;\r\n  hasTwoFactorAuth?: () => boolean;\r\n  updateSettings?: (settings: Partial<UserSettings>) => ExtendedUser;\r\n  toObject?: () => Record<string, any>;\r\n};\r\n\r\nexport type AuthProvider = \"google\" | \"github\" | \"email\" | \"phone\" | \"azure\"; // Added azure from old types.ts\r\n\r\nexport interface AuthContextType {\r\n  user: ExtendedUser | null;\r\n  session: Session | null;\r\n  isLoading: boolean;\r\n  isAuthenticated: boolean;\r\n  error: any | null; // Consider a more specific error type\r\n  signIn: (provider: AuthProvider, options?: any) => Promise<void>;\r\n  signOut: () => Promise<void>;\r\n  refreshSession: () => Promise<void>;\r\n  signUp: (options: {\r\n    email: string;\r\n    password: string;\r\n    fullName?: string;\r\n    redirectTo?: string;\r\n  }) => Promise<any>; // Consider specific result type\r\n  resetPassword: (email: string, redirectTo?: string) => Promise<boolean>;\r\n  updatePassword: (password: string) => Promise<boolean>;\r\n  hasPermission?: (permission: Permission) => boolean; // Added from old types.ts\r\n}\r\n\r\nexport interface AuthMiddlewareContext {\r\n  user: ExtendedUser | null;\r\n  session: Session | null;\r\n  isAuthenticated: boolean;\r\n  supabase: SupabaseClient<Database>; // Use SupabaseClient<Database> here\r\n  hasPermission?: (permission: Permission) => boolean;\r\n}\r\n\r\n// Utility function (can live here or be moved to a helpers file if it grows)\r\nexport function createExtendedUser(user: User | null): ExtendedUser | null {\r\n  if (!user) return null;\r\n\r\n  const role = (user.user_metadata?.role ||\r\n    \"client\") as Database[\"public\"][\"Enums\"][\"user_role\"];\r\n  const isAdmin = role === \"admin\"; // This isAdmin flag should be used cautiously, prefer RBAC checks\r\n\r\n  const settings: UserSettings = {\r\n    theme: user.user_metadata?.settings_theme || \"system\",\r\n    language: user.user_metadata?.settings_language || \"en\",\r\n    emailNotifications:\r\n      user.user_metadata?.settings_emailNotifications || false,\r\n    documentReminders: user.user_metadata?.settings_documentReminders || false,\r\n    applicationUpdates:\r\n      user.user_metadata?.settings_applicationUpdates || false,\r\n    twoFactorAuth: user.user_metadata?.settings_twoFactorAuth || false,\r\n  };\r\n\r\n  const extendedUser: ExtendedUser = {\r\n    ...user,\r\n    fullName:\r\n      user.user_metadata?.full_name || user.email?.split(\"@\")[0] || \"User\",\r\n    avatarUrl: user.user_metadata?.avatar_url || \"\",\r\n    role,\r\n    isAdmin,\r\n    settings,\r\n    hasTwoFactorAuth: () => settings.twoFactorAuth,\r\n    updateSettings: (newSettings: Partial<UserSettings>) => {\r\n      const updatedSettings = { ...settings, ...newSettings };\r\n      return createExtendedUser({\r\n        ...user,\r\n        user_metadata: {\r\n          ...user.user_metadata,\r\n          settings_theme: updatedSettings.theme,\r\n          settings_language: updatedSettings.language,\r\n          settings_emailNotifications: updatedSettings.emailNotifications,\r\n          settings_documentReminders: updatedSettings.documentReminders,\r\n          settings_applicationUpdates: updatedSettings.applicationUpdates,\r\n          settings_twoFactorAuth: updatedSettings.twoFactorAuth,\r\n        },\r\n      }) as ExtendedUser;\r\n    },\r\n    toObject: () => ({\r\n      id: user.id,\r\n      email: user.email,\r\n      fullName:\r\n        user.user_metadata?.full_name || user.email?.split(\"@\")[0] || \"User\",\r\n      avatarUrl: user.user_metadata?.avatar_url || \"\",\r\n      role,\r\n      settings,\r\n    }),\r\n  };\r\n\r\n  return extendedUser;\r\n}\r\n\r\n// Types from the old src/types/types.ts that were not in src/lib/auth/types.ts\r\n// (Excluding duplicates like ExtendedUser, AuthProvider which are merged above)\r\n\r\nexport interface AuthResult {\r\n  session: Session | null;\r\n  user: User | null; // Should this be ExtendedUser?\r\n  error: Error | null;\r\n}\r\n\r\nexport interface AuthState {\r\n  user: ExtendedUser | null;\r\n  session: Session | null;\r\n  isLoading: boolean;\r\n  isAuthenticated: boolean;\r\n  error?: Error | null;\r\n}\r\n\r\nexport interface LoginCredentials {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nexport interface SignUpData {\r\n  email: string;\r\n  password: string;\r\n  fullName?: string;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface AuthOptions {\r\n  redirectTo?: string;\r\n  email?: string;\r\n  metadata?: Record<string, any>;\r\n  provider?: {\r\n    id: string;\r\n    scopes?: string;\r\n  };\r\n}\r\n\r\nexport type AuthChangeCallback = (\r\n  session: Session | null,\r\n  user: User | null // Should this be ExtendedUser?\r\n) => void | Promise<void>;\r\n\r\nexport interface InitOptions {\r\n  refreshSession?: boolean;\r\n  autoRecoverSession?: boolean;\r\n  refreshOptions?: {\r\n    enableAutoRefresh?: boolean;\r\n    refreshThreshold?: number;\r\n  };\r\n}\r\n","\"use client\";\r\n\r\nimport { Session, User } from \"@supabase/supabase-js\";\r\nimport {\r\n  useState,\r\n  useEffect,\r\n  createContext,\r\n  useContext,\r\n  useCallback,\r\n  ReactNode,\r\n} from \"react\";\r\n\r\nimport { createClient } from \"@/lib/supabase/client\";\r\n\r\nimport { hasPermission } from \"./rbac\";\r\nimport {\r\n  AuthContextType,\r\n  type AuthProvider,\r\n  ExtendedUser,\r\n  createExtendedUser,\r\n} from \"@/types/auth\";\r\n\r\n// Create Auth Context\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\n/**\r\n * Provider component to wrap your app and provide authentication state\r\n */\r\nexport function AuthProvider({ children }: { children: ReactNode }) {\r\n  const [user, setUser] = useState<ExtendedUser | null>(null);\r\n  const [session, setSession] = useState<Session | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const supabase = createClient();\r\n\r\n  // Refresh session\r\n  const refreshSession = useCallback(async () => {\r\n    try {\r\n      setIsLoading(true);\r\n      const {\r\n        data: { session },\r\n        error: sessionError,\r\n      } = await supabase.auth.getSession();\r\n\r\n      if (sessionError) throw sessionError;\r\n\r\n      if (session) {\r\n        const {\r\n          data: { user },\r\n          error: userError,\r\n        } = await supabase.auth.getUser();\r\n        if (userError) throw userError;\r\n\r\n        setSession(session);\r\n        setUser(createExtendedUser(user));\r\n      } else {\r\n        setSession(null);\r\n        setUser(null);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error refreshing session:\", error);\r\n      setSession(null);\r\n      setUser(null);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [supabase]);\r\n\r\n  // Sign in with provider\r\n  const signIn = useCallback(\r\n    async (provider: AuthProvider, options?: any) => {\r\n      setIsLoading(true);\r\n      try {\r\n        if (provider === \"email\") {\r\n          if (!options?.email || !options?.password) {\r\n            throw new Error(\"Email and password required for email sign in\");\r\n          }\r\n          const { data, error } = await supabase.auth.signInWithPassword({\r\n            email: options.email,\r\n            password: options.password,\r\n          });\r\n\r\n          if (error) throw error;\r\n\r\n          // Email sign-in provides session immediately\r\n          if (data?.session) {\r\n            setSession(data.session);\r\n            setUser(createExtendedUser(data.session.user));\r\n          }\r\n        } else {\r\n          // OAuth provider sign-in redirects to provider\r\n          const { error } = await supabase.auth.signInWithOAuth({\r\n            provider: provider as any,\r\n            options: options?.redirectTo\r\n              ? { redirectTo: options.redirectTo }\r\n              : undefined,\r\n          });\r\n\r\n          if (error) throw error;\r\n          // No session update here as user will be redirected\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error signing in:\", error);\r\n        throw error;\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [supabase]\r\n  );\r\n\r\n  // Sign out\r\n  const signOut = useCallback(async () => {\r\n    setIsLoading(true);\r\n    try {\r\n      const { error } = await supabase.auth.signOut();\r\n      if (error) throw error;\r\n\r\n      setSession(null);\r\n      setUser(null);\r\n    } catch (error) {\r\n      console.error(\"Error signing out:\", error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [supabase]);\r\n\r\n  // Sign up with email/password\r\n  const signUp = useCallback(\r\n    async (options: {\r\n      email: string;\r\n      password: string;\r\n      fullName?: string;\r\n      redirectTo?: string;\r\n    }) => {\r\n      setIsLoading(true);\r\n      try {\r\n        if (!options.email || !options.password) {\r\n          throw new Error(\"Email and password required for sign up\");\r\n        }\r\n\r\n        const { data, error } = await supabase.auth.signUp({\r\n          email: options.email,\r\n          password: options.password,\r\n          options: {\r\n            data: {\r\n              full_name: options.fullName || \"\",\r\n            },\r\n            emailRedirectTo:\r\n              options.redirectTo || `${window.location.origin}/auth/callback`,\r\n          },\r\n        });\r\n\r\n        if (error) throw error;\r\n        return data;\r\n      } catch (error) {\r\n        console.error(\"Error signing up:\", error);\r\n        throw error;\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [supabase]\r\n  );\r\n\r\n  // Reset password\r\n  const resetPassword = useCallback(\r\n    async (email: string, redirectTo?: string) => {\r\n      setIsLoading(true);\r\n      try {\r\n        const { error } = await supabase.auth.resetPasswordForEmail(email, {\r\n          redirectTo:\r\n            redirectTo || `${window.location.origin}/auth/reset-password`,\r\n        });\r\n\r\n        if (error) throw error;\r\n        return true;\r\n      } catch (error) {\r\n        console.error(\"Error resetting password:\", error);\r\n        throw error;\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [supabase]\r\n  );\r\n\r\n  // Update password\r\n  const updatePassword = useCallback(\r\n    async (password: string) => {\r\n      setIsLoading(true);\r\n      try {\r\n        const { error } = await supabase.auth.updateUser({\r\n          password,\r\n        });\r\n\r\n        if (error) throw error;\r\n        return true;\r\n      } catch (error) {\r\n        console.error(\"Error updating password:\", error);\r\n        throw error;\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [supabase]\r\n  );\r\n\r\n  // Set up auth listener\r\n  useEffect(() => {\r\n    const {\r\n      data: { subscription },\r\n    } = supabase.auth.onAuthStateChange(async (_event, session) => {\r\n      setSession(session);\r\n\r\n      // When auth state changes, get authenticated user data\r\n      if (session) {\r\n        const { data: userData, error } = await supabase.auth.getUser();\r\n        if (!error && userData) {\r\n          setUser(createExtendedUser(userData.user));\r\n        } else {\r\n          setUser(null);\r\n        }\r\n      } else {\r\n        setUser(null);\r\n      }\r\n\r\n      setIsLoading(false);\r\n    });\r\n\r\n    // Get initial session\r\n    refreshSession();\r\n\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [supabase, refreshSession]);\r\n\r\n  const value: AuthContextType = {\r\n    user,\r\n    session,\r\n    isLoading,\r\n    isAuthenticated: !!session,\r\n    signIn,\r\n    signOut,\r\n    refreshSession,\r\n    // Add these new functions\r\n    signUp,\r\n    resetPassword,\r\n    updatePassword,\r\n    error: null, // For backwards compatibility\r\n  };\r\n\r\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\r\n}\r\n\r\n/**\r\n * Hook to access authentication state and methods\r\n */\r\nexport function useAuth(): AuthContextType {\r\n  const context = useContext(AuthContext);\r\n\r\n  if (context === undefined) {\r\n    throw new Error(\"useAuth must be used within an AuthProvider\");\r\n  }\r\n\r\n  return context;\r\n}\r\n\r\n/**\r\n * Hook to get the current user\r\n */\r\nexport function useUser(): ExtendedUser | null {\r\n  const { user } = useAuth();\r\n  return user;\r\n}\r\n\r\n/**\r\n * Hook to check if the user is authenticated\r\n */\r\nexport function useIsAuthenticated(): boolean {\r\n  const { isAuthenticated } = useAuth();\r\n  return isAuthenticated;\r\n}\r\n\r\n/**\r\n * Hook to check if the user has a specific role\r\n */\r\nexport function useHasRole(role: string): boolean {\r\n  const user = useUser();\r\n  return user?.role === role;\r\n}\r\n\r\n/**\r\n * Hook to check if the user has a specific permission\r\n */\r\nexport function useHasPermission(permission: string): boolean {\r\n  const user = useUser();\r\n  return hasPermission(user, permission);\r\n}\r\n\r\n/**\r\n * Hook to access the current session - for compatibility with next-auth style\r\n */\r\nexport function useSession() {\r\n  const context = useContext(AuthContext);\r\n  if (context === undefined) {\r\n    throw new Error(\"useSession must be used within an AuthProvider\");\r\n  }\r\n  // Simplified return for direct session access if preferred elsewhere,\r\n  // but useAuth provides more comprehensive state.\r\n  return {\r\n    session: context.session,\r\n    user: context.user,\r\n    isLoading: context.isLoading,\r\n    error: null, // Assuming errors are handled and reported differently, or add context.error\r\n    refreshSession: context.refreshSession, // Expose refreshSession\r\n  };\r\n}\r\n","module.exports = require(\"module\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 8963;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n","module.exports = require(\"punycode\");","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 15668;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/server/app-render/action-async-storage.external.js\");","module.exports = require(\"process\");","module.exports = require(\"os\");","import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport { isDynamicPostpone } from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","// src/utils/buffer.ts\nimport { sha256 } from \"./crypto.js\";\nvar equal = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const va = new DataView(a);\n  const vb = new DataView(b);\n  let i = va.byteLength;\n  while (i--) {\n    if (va.getUint8(i) !== vb.getUint8(i)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar timingSafeEqual = async (a, b, hashFunction) => {\n  if (!hashFunction) {\n    hashFunction = sha256;\n  }\n  const [sa, sb] = await Promise.all([hashFunction(a), hashFunction(b)]);\n  if (!sa || !sb) {\n    return false;\n  }\n  return sa === sb && a === b;\n};\nvar bufferToString = (buffer) => {\n  if (buffer instanceof ArrayBuffer) {\n    const enc = new TextDecoder(\"utf-8\");\n    return enc.decode(buffer);\n  }\n  return buffer;\n};\nvar bufferToFormData = (arrayBuffer, contentType) => {\n  const response = new Response(arrayBuffer, {\n    headers: {\n      \"Content-Type\": contentType\n    }\n  });\n  return response.formData();\n};\nexport {\n  bufferToFormData,\n  bufferToString,\n  equal,\n  timingSafeEqual\n};\n","// src/validator/validator.ts\nimport { getCookie } from \"../helper/cookie/index.js\";\nimport { HTTPException } from \"../http-exception.js\";\nimport { bufferToFormData } from \"../utils/buffer.js\";\nvar jsonRegex = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar multipartRegex = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9'\"()+_,\\-./:=?]+)?$/;\nvar urlencodedRegex = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar validator = (target, validationFunc) => {\n  return async (c, next) => {\n    let value = {};\n    const contentType = c.req.header(\"Content-Type\");\n    switch (target) {\n      case \"json\":\n        if (!contentType || !jsonRegex.test(contentType)) {\n          break;\n        }\n        try {\n          value = await c.req.json();\n        } catch {\n          const message = \"Malformed JSON in request body\";\n          throw new HTTPException(400, { message });\n        }\n        break;\n      case \"form\": {\n        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {\n          break;\n        }\n        let formData;\n        if (c.req.bodyCache.formData) {\n          formData = await c.req.bodyCache.formData;\n        } else {\n          try {\n            const arrayBuffer = await c.req.arrayBuffer();\n            formData = await bufferToFormData(arrayBuffer, contentType);\n            c.req.bodyCache.formData = formData;\n          } catch (e) {\n            let message = \"Malformed FormData request.\";\n            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;\n            throw new HTTPException(400, { message });\n          }\n        }\n        const form = {};\n        formData.forEach((value2, key) => {\n          if (key.endsWith(\"[]\")) {\n            ;\n            (form[key] ??= []).push(value2);\n          } else if (Array.isArray(form[key])) {\n            ;\n            form[key].push(value2);\n          } else if (key in form) {\n            form[key] = [form[key], value2];\n          } else {\n            form[key] = value2;\n          }\n        });\n        value = form;\n        break;\n      }\n      case \"query\":\n        value = Object.fromEntries(\n          Object.entries(c.req.queries()).map(([k, v]) => {\n            return v.length === 1 ? [k, v[0]] : [k, v];\n          })\n        );\n        break;\n      case \"param\":\n        value = c.req.param();\n        break;\n      case \"header\":\n        value = c.req.header();\n        break;\n      case \"cookie\":\n        value = getCookie(c);\n        break;\n    }\n    const res = await validationFunc(value, c);\n    if (res instanceof Response) {\n      return res;\n    }\n    c.req.addValidatedData(target, res);\n    await next();\n  };\n};\nexport {\n  validator\n};\n","// src/validator/index.ts\nimport { validator } from \"./validator.js\";\nexport {\n  validator\n};\n","module.exports = require(\"stream\");","module.exports = require(\"util\");","module.exports = require(\"fs\");","export * from '../client/components/navigation.react-server';\n\n//# sourceMappingURL=navigation.react-server.js.map","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");","import {\n  createBrowserClient as _createBrowserClient,\n  createServerClient as _createServerClient,\n} from \"@supabase/ssr\";\nimport {\n  createClient as createSupabaseClient,\n  SupabaseClient,\n  type SupabaseClient as CoreSupabaseClient,\n} from \"@supabase/supabase-js\";\nimport fetchPonyfill from \"fetch-ponyfill\";\nimport { useMemo } from \"react\";\n\nimport type { Database } from \"@/types/database.types\";\n\nimport type { ReadonlyRequestCookies } from \"next/dist/server/web/spec-extension/adapters/request-cookies\";\n\n// Get fetch from ponyfill to avoid undici issues like 'Failed to execute 'fetch' on 'Window': Invalid name'\n// See: https://github.com/vercel/next.js/issues/54827\nconst { fetch: ponyfetch } = fetchPonyfill();\n\n// Environment variables for Supabase\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Type alias for clarity\nexport type TypedSupabaseClient = SupabaseClient<Database>;\nexport type TypedSSRSupabaseClient = CoreSupabaseClient<Database>;\n\n// --------------------------------------\n// Shared header builders\n// --------------------------------------\n\n/**\n * Default headers that must accompany every request made via a browser or server client\n * which authenticates with the anonymous public key.  This prevents 401 responses from\n * PostgREST that indicate the `apikey` header is missing.\n */\nconst anonymousHeaders: Record<string, string> | undefined = supabaseAnonKey\n  ? { apikey: supabaseAnonKey }\n  : undefined;\n\n/**\n * Default headers for the service-role client.  These include the service key as both the\n * `apikey` header and (where relevant) the `Authorization` header is still injected by the\n * libraryʼs internal `fetchWithAuth` helper.\n */\nconst serviceHeaders: Record<string, string> | undefined = serviceRoleKey\n  ? { apikey: serviceRoleKey }\n  : undefined;\n\n// Helper function to check essential env vars\nfunction checkPublicEnvVars() {\n  if (process.env.NODE_ENV === \"development\") {\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_URL present?\",\n      !!supabaseUrl\n    );\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_ANON_KEY present?\",\n      !!supabaseAnonKey\n    );\n    console.debug(\n      \"[Supabase Env] SUPABASE_SERVICE_ROLE_KEY present?\",\n      !!serviceRoleKey\n    );\n  }\n  if (!supabaseUrl || !supabaseAnonKey) {\n    console.error(\n      \"Missing environment variables NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY\"\n    );\n    throw new Error(\"Supabase URL or Anon Key is missing.\");\n  }\n}\n\n// --------------------------------------\n// Patch global `fetch` on the **server** to use `ponyfetch`.\n// This avoids the infamous Undici \"Socket closed unexpectedly\" bug on\n// Windows/Node 18-20 without relying on fragile Undici internals.\n// The patch is idempotent and NO-OPs in the browser.\n\nif (typeof window === \"undefined\") {\n  const g = globalThis as any;\n  if (!g.__USING_PONYFETCH__) {\n    g.fetch = ponyfetch as unknown as typeof fetch;\n    g.__USING_PONYFETCH__ = true;\n    console.info(\"[Supabase] Server fetch patched to use ponyfetch ✅\");\n  }\n}\n\n// --- Browser Client (Singleton with Hook) ---\nlet browserClientInstance: TypedSSRSupabaseClient | undefined;\n\nfunction getSupabaseBrowserClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  if (browserClientInstance) {\n    return browserClientInstance;\n  }\n\n  // In the browser we rely on the native `fetch` implementation to ensure that\n  // request headers (apikey/Authorization) are preserved. Injecting a ponyfill\n  // here has proven to strip custom headers in certain edge-cases, leading to\n  // 401 \"No API key found\" responses. Therefore we only attach the required\n  // headers and leave `fetch` undefined so @supabase/ssr uses the global one.\n\n  browserClientInstance = _createBrowserClient<Database>(\n    supabaseUrl!,\n    supabaseAnonKey!,\n    {\n      global: {\n        headers: anonymousHeaders,\n      },\n    }\n  );\n\n  if (typeof window !== \"undefined\") {\n    console.debug(\"[Supabase] anon key present?\", !!supabaseAnonKey);\n  }\n\n  return browserClientInstance;\n}\n\n/**\n * Hook to get a Supabase client instance suitable for Browser/Client Components.\n * Uses a singleton pattern to ensure only one client instance is created.\n * Leverages @supabase/ssr for proper session handling with Next.js App Router.\n * @returns Memoized Supabase client instance for browser usage.\n */\nexport function useSupabaseBrowser(): TypedSSRSupabaseClient {\n  return useMemo(getSupabaseBrowserClient, []);\n}\n\n// This is the primary export for creating a browser client directly\nexport function createClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createBrowserClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    global: {\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Server Client (For Server Components, Route Handlers, Server Actions) ---\n\n/**\n * Creates a Supabase client suitable for use in Server Components, Server Actions,\n * and Route Handlers that require access to cookies.\n * @param cookieStore A ReadonlyRequestCookies instance (e.g., from `next/headers`).\n * @returns Supabase client instance for server-side usage with cookie handling.\n */\nexport function createSupabaseServerClient(\n  cookieStore: ReadonlyRequestCookies\n): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        return cookieStore.get(name)?.value;\n      },\n      set(name: string, value: string, options) {\n        try {\n          cookieStore.set(name, value, options);\n        } catch (error) {\n          console.warn(`Failed to set cookie '${name}':`, error);\n        }\n      },\n      remove(name: string, options) {\n        try {\n          cookieStore.set(name, \"\", options);\n        } catch (error) {\n          console.warn(`Failed to remove cookie '${name}':`, error);\n        }\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Service Role Client (Admin Operations) ---\n\n/**\n * Creates a Supabase client with the service role key for admin operations.\n * WARNING: This client bypasses RLS. Use only in trusted server-side environments\n * with proper authorization checks. NEVER expose the service role key to the browser.\n * @returns Supabase client instance with service_role privileges.\n */\nexport function createSupabaseServiceClient(): TypedSupabaseClient {\n  if (!supabaseUrl || !serviceRoleKey) {\n    console.error(\"Supabase URL or Service Role Key is missing\");\n    throw new Error(\"Supabase service client configuration is incomplete.\");\n  }\n\n  return createSupabaseClient<Database>(supabaseUrl, serviceRoleKey, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: serviceHeaders,\n    },\n  });\n}\n\n// --- Client with Custom Auth Token ---\n\n/**\n * Creates a Supabase client authenticated with a custom JWT token.\n * Useful for scenarios like testing or specific server-to-server interactions.\n * @param authToken JWT token for authentication.\n * @returns Authenticated Supabase client instance.\n */\nexport function createClientWithAuth(authToken: string): TypedSupabaseClient {\n  checkPublicEnvVars();\n  return createSupabaseClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    auth: {\n      persistSession: false,\n      autoRefreshToken: false,\n      detectSessionInUrl: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: {\n        Authorization: `Bearer ${authToken}`,\n        ...(anonymousHeaders ?? {}),\n      },\n    },\n  });\n}\n\n// ======================================\n// EDGE RUNTIME CLIENT\n// ======================================\n\n/**\n * Creates a Supabase client suitable for Edge Runtime environments (e.g., Edge Functions, Middleware).\n * Reads cookies from the Request headers. Requires manual handling for setting/removing cookies\n * via Response headers in the calling Edge function.\n * @param request The Request object from the Edge Function context.\n */\nexport const createEdgeClient = (request: Request): TypedSSRSupabaseClient => {\n  checkPublicEnvVars();\n  const cookieHeader = request.headers.get(\"cookie\") ?? \"\";\n\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        const match = cookieHeader.match(new RegExp(`(^|;)\\s*${name}=([^;]+)`));\n        return match?.[2];\n      },\n      set(name: string, value: string, options) {\n        console.warn(\n          `Attempted to set cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n      remove(name: string, options) {\n        console.warn(\n          `Attempted to remove cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n};\n\n// --- Remove Deprecated Compatibility Exports ---\n\n/**\n * @deprecated Use `useSupabaseBrowser` in Client Components or `createSupabaseServerClient` in Server Components/Actions/Routes.\n */\nexport const getSupabaseClient = getSupabaseBrowserClient;\n\n/**\n * @deprecated Use `createSupabaseServiceClient` for elevated privilege operations.\n */\nexport const createServiceClient = createSupabaseServiceClient;\n\n/**\n * @deprecated Prefer specific client creation (`useSupabaseBrowser`, `createSupabaseServerClient`, `createSupabaseServiceClient`). Avoid direct default export usage.\n */\nexport const supabase = getSupabaseBrowserClient();\n","module.exports = require(\"path\");","module.exports = require(\"tls\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:zlib\");","module.exports = require(\"node:tls\");","/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","module.exports = require(\"node:os\");","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","module.exports = require(\"node:diagnostics_channel\");","// src/http-exception.ts\nvar HTTPException = class extends Error {\n  res;\n  status;\n  constructor(status = 500, options) {\n    super(options?.message, { cause: options?.cause });\n    this.res = options?.res;\n    this.status = status;\n  }\n  getResponse() {\n    if (this.res) {\n      const newResponse = new Response(this.res.body, {\n        status: this.status,\n        headers: this.res.headers\n      });\n      return newResponse;\n    }\n    return new Response(this.message, {\n      status: this.status\n    });\n  }\n};\nexport {\n  HTTPException\n};\n","module.exports = require(\"crypto\");","module.exports = require(\"https\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","/* (ignored) */","import { AuthError as SupabaseAuthError } from '@supabase/supabase-js';\r\n\r\n/**\r\n * Base class for all authentication errors\r\n */\r\nexport class AuthError extends Error {\r\n  public code: string;\r\n  public status?: number;\r\n  public originalError?: Error;\r\n\r\n  constructor(message: string, code: string, originalError?: Error, status?: number) {\r\n    super(message);\r\n    this.name = 'AuthError';\r\n    this.code = code;\r\n    this.status = status;\r\n    this.originalError = originalError;\r\n  }\r\n\r\n  /**\r\n   * Create a JSON representation of the error\r\n   */\r\n  toJSON() {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      code: this.code,\r\n      status: this.status\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create error response for API routes\r\n   */\r\n  toResponse() {\r\n    return new Response(\r\n      JSON.stringify({\r\n        error: {\r\n          message: this.message,\r\n          code: this.code\r\n        }\r\n      }),\r\n      {\r\n        status: this.status || 500,\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when user is not authenticated\r\n */\r\nexport class UnauthorizedError extends AuthError {\r\n  constructor(message = 'Authentication required', originalError?: Error) {\r\n    super(message, 'auth/unauthorized', originalError, 401);\r\n    this.name = 'UnauthorizedError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when user doesn't have sufficient permissions\r\n */\r\nexport class ForbiddenError extends AuthError {\r\n  constructor(message = 'Insufficient permissions', originalError?: Error) {\r\n    super(message, 'auth/forbidden', originalError, 403);\r\n    this.name = 'ForbiddenError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when there's an issue with session management\r\n */\r\nexport class SessionError extends AuthError {\r\n  constructor(message = 'Session error', originalError?: Error) {\r\n    super(message, 'auth/session-error', originalError, 400);\r\n    this.name = 'SessionError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when credentials are invalid\r\n */\r\nexport class InvalidCredentialsError extends AuthError {\r\n  constructor(message = 'Invalid credentials', originalError?: Error) {\r\n    super(message, 'auth/invalid-credentials', originalError, 401);\r\n    this.name = 'InvalidCredentialsError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown for user-related operations failures\r\n */\r\nexport class UserOperationError extends AuthError {\r\n  constructor(message = 'User operation failed', originalError?: Error) {\r\n    super(message, 'auth/user-operation-failed', originalError, 400);\r\n    this.name = 'UserOperationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown for configuration issues\r\n */\r\nexport class ConfigurationError extends AuthError {\r\n  constructor(message = 'Authentication configuration error', originalError?: Error) {\r\n    super(message, 'auth/configuration-error', originalError, 500);\r\n    this.name = 'ConfigurationError';\r\n  }\r\n}\r\n\r\n// Interface for any error with status code\r\ninterface ErrorWithStatus extends Error {\r\n  status?: number;\r\n  code?: string | number;\r\n}\r\n\r\n/**\r\n * Converts Supabase errors to our custom error types\r\n */\r\nexport function handleSupabaseError(error: Error | SupabaseAuthError | ErrorWithStatus | null | undefined): AuthError {\r\n  if (!error) {\r\n    return new AuthError('Unknown error', 'auth/unknown');\r\n  }\r\n\r\n  // Errors with status property\r\n  const errorWithStatus = error as ErrorWithStatus;\r\n  if (errorWithStatus.status) {\r\n    switch (errorWithStatus.status) {\r\n      case 401:\r\n        return new UnauthorizedError(error.message, error);\r\n      case 403:\r\n        return new ForbiddenError(error.message, error);\r\n      case 400:\r\n        if (error.message.includes('credentials')) {\r\n          return new InvalidCredentialsError(error.message, error);\r\n        }\r\n        if (error.message.includes('session')) {\r\n          return new SessionError(error.message, error);\r\n        }\r\n        return new UserOperationError(error.message, error);\r\n      default:\r\n        return new AuthError(\r\n          error.message, \r\n          `auth/error-${errorWithStatus.status || 'unknown'}`, \r\n          error, \r\n          errorWithStatus.status\r\n        );\r\n    }\r\n  }\r\n\r\n  // Generic errors\r\n  return new AuthError(error.message || 'Unknown error', 'auth/unknown-error', error);\r\n}\r\n\r\n/**\r\n * Helper to safely handle auth operations with consistent error handling\r\n */\r\nexport async function safeAuthOperation<T>(\r\n  operation: () => Promise<T>,\r\n  errorMessage = 'Authentication operation failed'\r\n): Promise<T> {\r\n  try {\r\n    return await operation();\r\n  } catch (error) {\r\n    throw handleSupabaseError(error as Error);\r\n  }\r\n}\r\n\r\n/**\r\n * Middleware for handling auth errors in API routes\r\n */\r\nexport function createAuthErrorHandler() {\r\n  return (error: unknown) => {\r\n    if (error instanceof AuthError) {\r\n      return error.toResponse();\r\n    }\r\n    \r\n    const authError = handleSupabaseError(error as Error);\r\n    return authError.toResponse();\r\n  };\r\n} ","import { ForbiddenError } from \"./errors\";\r\nimport { ExtendedUser } from \"./types\";\r\n\r\n/**\r\n * Permission string type\r\n */\r\nexport type Permission = string;\r\n\r\n/**\r\n * Role definition with permissions and optional inheritance\r\n */\r\nexport interface Role {\r\n  /**\r\n   * Name of the role\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Description of the role\r\n   */\r\n  description?: string;\r\n\r\n  /**\r\n   * Array of permissions assigned to this role\r\n   */\r\n  permissions: Permission[];\r\n\r\n  /**\r\n   * Optional array of parent role names this role inherits from\r\n   */\r\n  inherits?: string[];\r\n}\r\n\r\n/**\r\n * Configuration options for the RBAC manager\r\n */\r\nexport interface RBACOptions {\r\n  /**\r\n   * Default roles and their permissions\r\n   */\r\n  roles?: Record<string, Role>;\r\n\r\n  /**\r\n   * Name of super admin role that has all permissions\r\n   * @default 'admin'\r\n   */\r\n  superAdminRole?: string;\r\n\r\n  /**\r\n   * Enable permission caching for performance\r\n   * @default true\r\n   */\r\n  enableCache?: boolean;\r\n\r\n  /**\r\n   * Custom function to extract roles from a user\r\n   */\r\n  extractRoles?: (user: ExtendedUser) => string[];\r\n}\r\n\r\n/**\r\n * Default RBAC options\r\n */\r\nconst defaultRBACOptions: RBACOptions = {\r\n  roles: {},\r\n  superAdminRole: \"admin\",\r\n  enableCache: true,\r\n};\r\n\r\n/**\r\n * Role-Based Access Control Manager\r\n * TODO: The current superAdminRole check (userRoles.includes(this.superAdminRole))\r\n * relies on user.role from metadata (via extractRoles default). This may not align with the\r\n * authoritative admin status determined by verifyUserIsAdmin(userId) which checks the\r\n * 'admin_users' table. For true unification, this superAdmin check should eventually be\r\n * reconciled with the authoritative server-side verification. This might involve making RBAC\r\n * methods async, passing a verified admin status, or other architectural changes.\r\n * For now, critical admin checks should use the useIsAdmin() hook or verifyUserIsAdmin() action directly.\r\n */\r\nexport class RBACManager {\r\n  private roles: Record<string, Role>;\r\n  private superAdminRole: string;\r\n  private enableCache: boolean;\r\n  private extractRoles: (user: ExtendedUser) => string[];\r\n  private permissionCache: Map<string, Set<Permission>> = new Map();\r\n\r\n  constructor(options: RBACOptions = {}) {\r\n    const config = { ...defaultRBACOptions, ...options };\r\n    this.roles = config.roles || {};\r\n    this.superAdminRole = config.superAdminRole || \"admin\";\r\n    this.enableCache = config.enableCache ?? true;\r\n    this.extractRoles =\r\n      config.extractRoles ||\r\n      ((user: ExtendedUser) => {\r\n        return [user.role || \"user\"];\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Define a new role with permissions\r\n   */\r\n  defineRole(role: Role): void {\r\n    this.roles[role.name] = role;\r\n\r\n    // Clear cache if caching is enabled\r\n    if (this.enableCache) {\r\n      this.permissionCache.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Define multiple roles at once\r\n   */\r\n  defineRoles(roles: Record<string, Role>): void {\r\n    this.roles = { ...this.roles, ...roles };\r\n\r\n    // Clear cache if caching is enabled\r\n    if (this.enableCache) {\r\n      this.permissionCache.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all permissions for a given role\r\n   */\r\n  private getRolePermissions(\r\n    roleName: string,\r\n    visited: Set<string> = new Set()\r\n  ): Set<Permission> {\r\n    // Avoid circular dependencies\r\n    if (visited.has(roleName)) {\r\n      return new Set();\r\n    }\r\n\r\n    // Mark this role as visited\r\n    visited.add(roleName);\r\n\r\n    // Get the role definition\r\n    const role = this.roles[roleName];\r\n    if (!role) {\r\n      return new Set();\r\n    }\r\n\r\n    // Start with this role's permissions\r\n    const permissions = new Set(role.permissions);\r\n\r\n    // Add inherited permissions\r\n    if (role.inherits && role.inherits.length > 0) {\r\n      for (const parentRole of role.inherits) {\r\n        const parentPermissions = this.getRolePermissions(parentRole, visited);\r\n        parentPermissions.forEach((permission) => permissions.add(permission));\r\n      }\r\n    }\r\n\r\n    return permissions;\r\n  }\r\n\r\n  /**\r\n   * Get all permissions for a user based on their roles\r\n   */\r\n  getUserPermissions(user: ExtendedUser | null): Set<Permission> {\r\n    if (!user) {\r\n      return new Set();\r\n    }\r\n\r\n    // Extract roles from user\r\n    const userRoles = this.extractRoles(user);\r\n\r\n    // Check for super admin role\r\n    if (userRoles.includes(this.superAdminRole)) {\r\n      return new Set([\"*\"]); // Special wildcard permission for super admins\r\n    }\r\n\r\n    // Check the cache first if enabled\r\n    if (this.enableCache) {\r\n      const cacheKey = userRoles.sort().join(\",\");\r\n      const cachedPermissions = this.permissionCache.get(cacheKey);\r\n\r\n      if (cachedPermissions) {\r\n        return cachedPermissions;\r\n      }\r\n    }\r\n\r\n    // Collect all permissions from all roles\r\n    const allPermissions = new Set<Permission>();\r\n    for (const roleName of userRoles) {\r\n      const rolePermissions = this.getRolePermissions(roleName);\r\n      rolePermissions.forEach((permission) => allPermissions.add(permission));\r\n    }\r\n\r\n    // Save to cache if enabled\r\n    if (this.enableCache && userRoles.length > 0) {\r\n      const cacheKey = userRoles.sort().join(\",\");\r\n      this.permissionCache.set(cacheKey, allPermissions);\r\n    }\r\n\r\n    return allPermissions;\r\n  }\r\n\r\n  /**\r\n   * Check if the user has a specific role\r\n   */\r\n  hasRole(user: ExtendedUser | null, roleName: string): boolean {\r\n    if (!user) return false;\r\n\r\n    const userRoles = this.extractRoles(user);\r\n    return (\r\n      userRoles.includes(roleName) || userRoles.includes(this.superAdminRole)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if the user has a specific permission\r\n   */\r\n  hasPermission(user: ExtendedUser | null, permission: Permission): boolean {\r\n    if (!user) return false;\r\n\r\n    // Get all permissions for the user\r\n    const permissions = this.getUserPermissions(user);\r\n\r\n    // Super admin has all permissions\r\n    if (permissions.has(\"*\")) return true;\r\n\r\n    // Check exact permission\r\n    if (permissions.has(permission)) return true;\r\n\r\n    // Check wildcard permissions\r\n    const parts = permission.split(\":\");\r\n    for (let i = 1; i <= parts.length; i++) {\r\n      const wildcardPermission = [...parts.slice(0, i), \"*\"].join(\":\");\r\n      if (permissions.has(wildcardPermission)) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if the user has any of the specified permissions\r\n   */\r\n  hasAnyPermission(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): boolean {\r\n    return permissions.some((permission) =>\r\n      this.hasPermission(user, permission)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if the user has all of the specified permissions\r\n   */\r\n  hasAllPermissions(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): boolean {\r\n    return permissions.every((permission) =>\r\n      this.hasPermission(user, permission)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Enforce a permission requirement, throwing an error if not authorized\r\n   */\r\n  enforcePermission(user: ExtendedUser | null, permission: Permission): void {\r\n    if (!this.hasPermission(user, permission)) {\r\n      throw new ForbiddenError(`Missing required permission: ${permission}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce that user has any of the specified permissions\r\n   */\r\n  enforceAnyPermission(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): void {\r\n    if (!this.hasAnyPermission(user, permissions)) {\r\n      throw new ForbiddenError(\r\n        `Missing at least one of the required permissions: ${permissions.join(\", \")}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce that user has all of the specified permissions\r\n   */\r\n  enforceAllPermissions(\r\n    user: ExtendedUser | null,\r\n    permissions: Permission[]\r\n  ): void {\r\n    if (!this.hasAllPermissions(user, permissions)) {\r\n      throw new ForbiddenError(\r\n        `Missing some of the required permissions: ${permissions.join(\", \")}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a permission string from resource and action\r\n   */\r\n  createPermission(resource: string, action: string): Permission {\r\n    return `${resource}:${action}`;\r\n  }\r\n}\r\n\r\n// Singleton RBAC manager instance\r\nlet rbacManager: RBACManager | null = null;\r\n\r\n/**\r\n * Get the RBAC manager instance, creating it if it doesn't exist\r\n */\r\nexport function getRBACManager(options?: RBACOptions): RBACManager {\r\n  if (!rbacManager) {\r\n    rbacManager = new RBACManager(options);\r\n  }\r\n  return rbacManager;\r\n}\r\n\r\n/**\r\n * Create a permission string from resource and action\r\n */\r\nexport function createPermission(resource: string, action: string): Permission {\r\n  return `${resource}:${action}`;\r\n}\r\n\r\n/**\r\n * Check if the user has a specific permission\r\n */\r\nexport function hasPermission(\r\n  user: ExtendedUser | null,\r\n  permission: Permission\r\n): boolean {\r\n  return getRBACManager().hasPermission(user, permission);\r\n}\r\n\r\n/**\r\n * Enforce a permission requirement, throwing an error if not authorized\r\n */\r\nexport function enforcePermission(\r\n  user: ExtendedUser | null,\r\n  permission: Permission\r\n): void {\r\n  return getRBACManager().enforcePermission(user, permission);\r\n}\r\n","// src/utils/cookie.ts\nimport { decodeURIComponent_ } from \"./url.js\";\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  if (name && cookie.indexOf(name) === -1) {\n    return {};\n  }\n  const pairs = cookie.trim().split(\";\");\n  const parsedCookie = {};\n  for (let pairStr of pairs) {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      continue;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      continue;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);\n      if (name) {\n        break;\n      }\n    }\n  }\n  return parsedCookie;\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    throw new Error(\"__Secure- Cookie must have Secure attributes\");\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      throw new Error(\"__Host- Cookie must have Secure attributes\");\n    }\n    if (opt.path !== \"/\") {\n      throw new Error('__Host- Cookie must have Path attributes with \"/\"');\n    }\n    if (opt.domain) {\n      throw new Error(\"__Host- Cookie must not have Domain attributes\");\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${opt.maxAge | 0}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.priority) {\n    cookie += `; Priority=${opt.priority}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nexport {\n  parse,\n  parseSigned,\n  serialize,\n  serializeSigned\n};\n","// src/helper/cookie/index.ts\nimport { parse, parseSigned, serialize, serializeSigned } from \"../../utils/cookie.js\";\nvar getCookie = (c, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = parse(cookie, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = parse(cookie);\n  return obj;\n};\nvar getSignedCookie = async (c, secret, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = await parseSigned(cookie, secret, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = await parseSigned(cookie, secret);\n  return obj;\n};\nvar setCookie = (c, name, value, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  c.header(\"Set-Cookie\", cookie, { append: true });\n};\nvar setSignedCookie = async (c, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  c.header(\"set-cookie\", cookie, { append: true });\n};\nvar deleteCookie = (c, name, opt) => {\n  const deletedCookie = getCookie(c, name, opt?.prefix);\n  setCookie(c, name, \"\", { ...opt, maxAge: 0 });\n  return deletedCookie;\n};\nexport {\n  deleteCookie,\n  getCookie,\n  getSignedCookie,\n  setCookie,\n  setSignedCookie\n};\n","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"buffer\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","module.exports = require(\"http\");","import(/* webpackMode: \"eager\", webpackExports: [\"AuthProvider\",\"useAuth\",\"useUser\",\"useIsAuthenticated\",\"useHasRole\",\"useHasPermission\",\"useSession\"] */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\hooks.tsx\");\n","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nfunction isZodType(schema, typeName) {\n    var _a;\n    return ((_a = schema === null || schema === void 0 ? void 0 : schema._def) === null || _a === void 0 ? void 0 : _a.typeName) === typeName;\n}\nfunction isAnyZodType(schema) {\n    return '_def' in schema;\n}\n\nfunction preserveMetadataFromModifier(zod, modifier) {\n    const zodModifier = zod.ZodType.prototype[modifier];\n    zod.ZodType.prototype[modifier] = function (...args) {\n        const result = zodModifier.apply(this, args);\n        result._def.openapi = this._def.openapi;\n        return result;\n    };\n}\nfunction extendZodWithOpenApi(zod) {\n    if (typeof zod.ZodType.prototype.openapi !== 'undefined') {\n        // This zod instance is already extended with the required methods,\n        // doing it again will just result in multiple wrapper methods for\n        // `optional` and `nullable`\n        return;\n    }\n    zod.ZodType.prototype.openapi = function (refOrOpenapi, metadata) {\n        var _a, _b, _c, _d, _e, _f;\n        const openapi = typeof refOrOpenapi === 'string' ? metadata : refOrOpenapi;\n        const _g = openapi !== null && openapi !== void 0 ? openapi : {}, { param } = _g, restOfOpenApi = __rest(_g, [\"param\"]);\n        const _internal = Object.assign(Object.assign({}, (_a = this._def.openapi) === null || _a === void 0 ? void 0 : _a._internal), (typeof refOrOpenapi === 'string'\n            ? { refId: refOrOpenapi }\n            : undefined));\n        const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === void 0 ? void 0 : _b.metadata), restOfOpenApi), (((_d = (_c = this._def.openapi) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.param) || param\n            ? {\n                param: Object.assign(Object.assign({}, (_f = (_e = this._def.openapi) === null || _e === void 0 ? void 0 : _e.metadata) === null || _f === void 0 ? void 0 : _f.param), param),\n            }\n            : undefined));\n        const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, (Object.keys(_internal).length > 0 ? { _internal } : undefined)), (Object.keys(resultMetadata).length > 0\n                ? { metadata: resultMetadata }\n                : undefined)) }));\n        if (isZodType(this, 'ZodObject')) {\n            const originalExtend = this.extend;\n            result.extend = function (...args) {\n                var _a, _b, _c, _d, _e, _f, _g;\n                const extendedResult = originalExtend.apply(this, args);\n                extendedResult._def.openapi = {\n                    _internal: {\n                        extendedFrom: ((_b = (_a = this._def.openapi) === null || _a === void 0 ? void 0 : _a._internal) === null || _b === void 0 ? void 0 : _b.refId)\n                            ? { refId: (_d = (_c = this._def.openapi) === null || _c === void 0 ? void 0 : _c._internal) === null || _d === void 0 ? void 0 : _d.refId, schema: this }\n                            : (_f = (_e = this._def.openapi) === null || _e === void 0 ? void 0 : _e._internal) === null || _f === void 0 ? void 0 : _f.extendedFrom,\n                    },\n                    metadata: (_g = extendedResult._def.openapi) === null || _g === void 0 ? void 0 : _g.metadata,\n                };\n                return extendedResult;\n            };\n        }\n        return result;\n    };\n    preserveMetadataFromModifier(zod, 'optional');\n    preserveMetadataFromModifier(zod, 'nullable');\n    preserveMetadataFromModifier(zod, 'default');\n    preserveMetadataFromModifier(zod, 'transform');\n    preserveMetadataFromModifier(zod, 'refine');\n    const zodDeepPartial = zod.ZodObject.prototype.deepPartial;\n    zod.ZodObject.prototype.deepPartial = function () {\n        const initialShape = this._def.shape();\n        const result = zodDeepPartial.apply(this);\n        const resultShape = result._def.shape();\n        Object.entries(resultShape).forEach(([key, value]) => {\n            var _a, _b;\n            value._def.openapi = (_b = (_a = initialShape[key]) === null || _a === void 0 ? void 0 : _a._def) === null || _b === void 0 ? void 0 : _b.openapi;\n        });\n        result._def.openapi = undefined;\n        return result;\n    };\n    const zodPick = zod.ZodObject.prototype.pick;\n    zod.ZodObject.prototype.pick = function (...args) {\n        const result = zodPick.apply(this, args);\n        result._def.openapi = undefined;\n        return result;\n    };\n    const zodOmit = zod.ZodObject.prototype.omit;\n    zod.ZodObject.prototype.omit = function (...args) {\n        const result = zodOmit.apply(this, args);\n        result._def.openapi = undefined;\n        return result;\n    };\n}\n\nfunction isEqual(x, y) {\n    if (x === null || x === undefined || y === null || y === undefined) {\n        return x === y;\n    }\n    if (x === y || x.valueOf() === y.valueOf()) {\n        return true;\n    }\n    if (Array.isArray(x)) {\n        if (!Array.isArray(y)) {\n            return false;\n        }\n        if (x.length !== y.length) {\n            return false;\n        }\n    }\n    // if they are strictly equal, they both need to be object at least\n    if (!(x instanceof Object) || !(y instanceof Object)) {\n        return false;\n    }\n    // recursive object equality check\n    const keysX = Object.keys(x);\n    return (Object.keys(y).every(keyY => keysX.indexOf(keyY) !== -1) &&\n        keysX.every(key => isEqual(x[key], y[key])));\n}\nclass ObjectSet {\n    constructor() {\n        this.buckets = new Map();\n    }\n    put(value) {\n        const hashCode = this.hashCodeOf(value);\n        const itemsByCode = this.buckets.get(hashCode);\n        if (!itemsByCode) {\n            this.buckets.set(hashCode, [value]);\n            return;\n        }\n        const alreadyHasItem = itemsByCode.some(_ => isEqual(_, value));\n        if (!alreadyHasItem) {\n            itemsByCode.push(value);\n        }\n    }\n    contains(value) {\n        const hashCode = this.hashCodeOf(value);\n        const itemsByCode = this.buckets.get(hashCode);\n        if (!itemsByCode) {\n            return false;\n        }\n        return itemsByCode.some(_ => isEqual(_, value));\n    }\n    values() {\n        return [...this.buckets.values()].flat();\n    }\n    stats() {\n        let totalBuckets = 0;\n        let totalValues = 0;\n        let collisions = 0;\n        for (const bucket of this.buckets.values()) {\n            totalBuckets += 1;\n            totalValues += bucket.length;\n            if (bucket.length > 1) {\n                collisions += 1;\n            }\n        }\n        const hashEffectiveness = totalBuckets / totalValues;\n        return { totalBuckets, collisions, totalValues, hashEffectiveness };\n    }\n    hashCodeOf(object) {\n        let hashCode = 0;\n        if (Array.isArray(object)) {\n            for (let i = 0; i < object.length; i++) {\n                hashCode ^= this.hashCodeOf(object[i]) * i;\n            }\n            return hashCode;\n        }\n        if (typeof object === 'string') {\n            for (let i = 0; i < object.length; i++) {\n                hashCode ^= object.charCodeAt(i) * i;\n            }\n            return hashCode;\n        }\n        if (typeof object === 'number') {\n            return object;\n        }\n        if (typeof object === 'object') {\n            for (const [key, value] of Object.entries(object)) {\n                hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== void 0 ? value : '');\n            }\n        }\n        return hashCode;\n    }\n}\n\nfunction isUndefined(value) {\n    return value === undefined;\n}\nfunction mapValues(object, mapper) {\n    const result = {};\n    Object.entries(object).forEach(([key, value]) => {\n        result[key] = mapper(value);\n    });\n    return result;\n}\nfunction omit(object, keys) {\n    const result = {};\n    Object.entries(object).forEach(([key, value]) => {\n        if (!keys.some(keyToOmit => keyToOmit === key)) {\n            result[key] = value;\n        }\n    });\n    return result;\n}\nfunction omitBy(object, predicate) {\n    const result = {};\n    Object.entries(object).forEach(([key, value]) => {\n        if (!predicate(value, key)) {\n            result[key] = value;\n        }\n    });\n    return result;\n}\nfunction compact(arr) {\n    return arr.filter((elem) => !isUndefined(elem));\n}\nconst objectEquals = isEqual;\nfunction uniq(values) {\n    const set = new ObjectSet();\n    values.forEach(value => set.put(value));\n    return [...set.values()];\n}\nfunction isString(val) {\n    return typeof val === 'string';\n}\n\nfunction getOpenApiMetadata(zodSchema) {\n    var _a, _b;\n    return omitBy((_b = (_a = zodSchema._def.openapi) === null || _a === void 0 ? void 0 : _a.metadata) !== null && _b !== void 0 ? _b : {}, isUndefined);\n}\n\nclass OpenAPIRegistry {\n    constructor(parents) {\n        this.parents = parents;\n        this._definitions = [];\n    }\n    get definitions() {\n        var _a, _b;\n        const parentDefinitions = (_b = (_a = this.parents) === null || _a === void 0 ? void 0 : _a.flatMap(par => par.definitions)) !== null && _b !== void 0 ? _b : [];\n        return [...parentDefinitions, ...this._definitions];\n    }\n    /**\n     * Registers a new component schema under /components/schemas/${name}\n     */\n    register(refId, zodSchema) {\n        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);\n        this._definitions.push({ type: 'schema', schema: schemaWithRefId });\n        return schemaWithRefId;\n    }\n    /**\n     * Registers a new parameter schema under /components/parameters/${name}\n     */\n    registerParameter(refId, zodSchema) {\n        var _a, _b, _c;\n        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);\n        const currentMetadata = (_a = schemaWithRefId._def.openapi) === null || _a === void 0 ? void 0 : _a.metadata;\n        const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : refId }) }));\n        this._definitions.push({\n            type: 'parameter',\n            schema: schemaWithMetadata,\n        });\n        return schemaWithMetadata;\n    }\n    /**\n     * Registers a new path that would be generated under paths:\n     */\n    registerPath(route) {\n        this._definitions.push({\n            type: 'route',\n            route,\n        });\n    }\n    /**\n     * Registers a new webhook that would be generated under webhooks:\n     */\n    registerWebhook(webhook) {\n        this._definitions.push({\n            type: 'webhook',\n            webhook,\n        });\n    }\n    /**\n     * Registers a raw OpenAPI component. Use this if you have a simple object instead of a Zod schema.\n     *\n     * @param type The component type, e.g. `schemas`, `responses`, `securitySchemes`, etc.\n     * @param name The name of the object, it is the key under the component\n     *             type in the resulting OpenAPI document\n     * @param component The actual object to put there\n     */\n    registerComponent(type, name, component) {\n        this._definitions.push({\n            type: 'component',\n            componentType: type,\n            name,\n            component,\n        });\n        return {\n            name,\n            ref: { $ref: `#/components/${type}/${name}` },\n        };\n    }\n    schemaWithRefId(refId, zodSchema) {\n        return zodSchema.openapi(refId);\n    }\n}\n\nclass ZodToOpenAPIError {\n    constructor(message) {\n        this.message = message;\n    }\n}\nclass ConflictError extends ZodToOpenAPIError {\n    constructor(message, data) {\n        super(message);\n        this.data = data;\n    }\n}\nclass MissingParameterDataError extends ZodToOpenAPIError {\n    constructor(data) {\n        super(`Missing parameter data, please specify \\`${data.missingField}\\` and other OpenAPI parameter props using the \\`param\\` field of \\`ZodSchema.openapi\\``);\n        this.data = data;\n    }\n}\nfunction enhanceMissingParametersError(action, paramsToAdd) {\n    try {\n        return action();\n    }\n    catch (error) {\n        if (error instanceof MissingParameterDataError) {\n            throw new MissingParameterDataError(Object.assign(Object.assign({}, error.data), paramsToAdd));\n        }\n        throw error;\n    }\n}\nclass UnknownZodTypeError extends ZodToOpenAPIError {\n    constructor(data) {\n        super(`Unknown zod object type, please specify \\`type\\` and other OpenAPI props using \\`ZodSchema.openapi\\`.`);\n        this.data = data;\n    }\n}\n\nclass Metadata {\n    static getMetadata(zodSchema) {\n        var _a;\n        const innerSchema = this.unwrapChained(zodSchema);\n        const metadata = zodSchema._def.openapi\n            ? zodSchema._def.openapi\n            : innerSchema._def.openapi;\n        /**\n         * Every zod schema can receive a `description` by using the .describe method.\n         * That description should be used when generating an OpenApi schema.\n         * The `??` bellow makes sure we can handle both:\n         * - schema.describe('Test').optional()\n         * - schema.optional().describe('Test')\n         */\n        const zodDescription = (_a = zodSchema.description) !== null && _a !== void 0 ? _a : innerSchema.description;\n        // A description provided from .openapi() should be taken with higher precedence\n        return {\n            _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,\n            metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === void 0 ? void 0 : metadata.metadata),\n        };\n    }\n    static getInternalMetadata(zodSchema) {\n        const innerSchema = this.unwrapChained(zodSchema);\n        const openapi = zodSchema._def.openapi\n            ? zodSchema._def.openapi\n            : innerSchema._def.openapi;\n        return openapi === null || openapi === void 0 ? void 0 : openapi._internal;\n    }\n    static getParamMetadata(zodSchema) {\n        var _a, _b;\n        const innerSchema = this.unwrapChained(zodSchema);\n        const metadata = zodSchema._def.openapi\n            ? zodSchema._def.openapi\n            : innerSchema._def.openapi;\n        /**\n         * Every zod schema can receive a `description` by using the .describe method.\n         * That description should be used when generating an OpenApi schema.\n         * The `??` bellow makes sure we can handle both:\n         * - schema.describe('Test').optional()\n         * - schema.optional().describe('Test')\n         */\n        const zodDescription = (_a = zodSchema.description) !== null && _a !== void 0 ? _a : innerSchema.description;\n        return {\n            _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,\n            metadata: Object.assign(Object.assign({}, metadata === null || metadata === void 0 ? void 0 : metadata.metadata), { \n                // A description provided from .openapi() should be taken with higher precedence\n                param: Object.assign({ description: zodDescription }, (_b = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _b === void 0 ? void 0 : _b.param) }),\n        };\n    }\n    /**\n     * A method that omits all custom keys added to the regular OpenAPI\n     * metadata properties\n     */\n    static buildSchemaMetadata(metadata) {\n        return omitBy(omit(metadata, ['param']), isUndefined);\n    }\n    static buildParameterMetadata(metadata) {\n        return omitBy(metadata, isUndefined);\n    }\n    static applySchemaMetadata(initialData, metadata) {\n        return omitBy(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), isUndefined);\n    }\n    static getRefId(zodSchema) {\n        var _a;\n        return (_a = this.getInternalMetadata(zodSchema)) === null || _a === void 0 ? void 0 : _a.refId;\n    }\n    static unwrapChained(schema) {\n        return this.unwrapUntil(schema);\n    }\n    static getDefaultValue(zodSchema) {\n        const unwrapped = this.unwrapUntil(zodSchema, 'ZodDefault');\n        return unwrapped === null || unwrapped === void 0 ? void 0 : unwrapped._def.defaultValue();\n    }\n    static unwrapUntil(schema, typeName) {\n        if (typeName && isZodType(schema, typeName)) {\n            return schema;\n        }\n        if (isZodType(schema, 'ZodOptional') ||\n            isZodType(schema, 'ZodNullable') ||\n            isZodType(schema, 'ZodBranded')) {\n            return this.unwrapUntil(schema.unwrap(), typeName);\n        }\n        if (isZodType(schema, 'ZodDefault') || isZodType(schema, 'ZodReadonly')) {\n            return this.unwrapUntil(schema._def.innerType, typeName);\n        }\n        if (isZodType(schema, 'ZodEffects')) {\n            return this.unwrapUntil(schema._def.schema, typeName);\n        }\n        if (isZodType(schema, 'ZodPipeline')) {\n            return this.unwrapUntil(schema._def.in, typeName);\n        }\n        return typeName ? undefined : schema;\n    }\n    static isOptionalSchema(zodSchema) {\n        return zodSchema.isOptional();\n    }\n}\n\nclass ArrayTransformer {\n    transform(zodSchema, mapNullableType, mapItems) {\n        var _a, _b;\n        const itemType = zodSchema._def.type;\n        return Object.assign(Object.assign({}, mapNullableType('array')), { items: mapItems(itemType), minItems: (_a = zodSchema._def.minLength) === null || _a === void 0 ? void 0 : _a.value, maxItems: (_b = zodSchema._def.maxLength) === null || _b === void 0 ? void 0 : _b.value });\n    }\n}\n\nclass BigIntTransformer {\n    transform(mapNullableType) {\n        return Object.assign(Object.assign({}, mapNullableType('string')), { pattern: `^\\d+$` });\n    }\n}\n\nclass DiscriminatedUnionTransformer {\n    transform(zodSchema, isNullable, mapNullableOfArray, mapItem, generateSchemaRef) {\n        const options = [...zodSchema.options.values()];\n        const optionSchema = options.map(mapItem);\n        if (isNullable) {\n            return {\n                oneOf: mapNullableOfArray(optionSchema, isNullable),\n            };\n        }\n        return {\n            oneOf: optionSchema,\n            discriminator: this.mapDiscriminator(options, zodSchema.discriminator, generateSchemaRef),\n        };\n    }\n    mapDiscriminator(zodObjects, discriminator, generateSchemaRef) {\n        // All schemas must be registered to use a discriminator\n        if (zodObjects.some(obj => Metadata.getRefId(obj) === undefined)) {\n            return undefined;\n        }\n        const mapping = {};\n        zodObjects.forEach(obj => {\n            var _a;\n            const refId = Metadata.getRefId(obj); // type-checked earlier\n            const value = (_a = obj.shape) === null || _a === void 0 ? void 0 : _a[discriminator];\n            if (isZodType(value, 'ZodEnum') || isZodType(value, 'ZodNativeEnum')) {\n                // Native enums have their keys as both number and strings however the number is an\n                // internal representation and the string is the access point for a documentation\n                const keys = Object.values(value.enum).filter(isString);\n                keys.forEach((enumValue) => {\n                    mapping[enumValue] = generateSchemaRef(refId);\n                });\n                return;\n            }\n            const literalValue = value === null || value === void 0 ? void 0 : value._def.value;\n            // This should never happen because Zod checks the disciminator type but to keep the types happy\n            if (typeof literalValue !== 'string') {\n                throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);\n            }\n            mapping[literalValue] = generateSchemaRef(refId);\n        });\n        return {\n            propertyName: discriminator,\n            mapping,\n        };\n    }\n}\n\nclass EnumTransformer {\n    transform(zodSchema, mapNullableType) {\n        // ZodEnum only accepts strings\n        return Object.assign(Object.assign({}, mapNullableType('string')), { enum: zodSchema._def.values });\n    }\n}\n\nclass IntersectionTransformer {\n    transform(zodSchema, isNullable, mapNullableOfArray, mapItem) {\n        const subtypes = this.flattenIntersectionTypes(zodSchema);\n        const allOfSchema = {\n            allOf: subtypes.map(mapItem),\n        };\n        if (isNullable) {\n            return {\n                anyOf: mapNullableOfArray([allOfSchema], isNullable),\n            };\n        }\n        return allOfSchema;\n    }\n    flattenIntersectionTypes(schema) {\n        if (!isZodType(schema, 'ZodIntersection')) {\n            return [schema];\n        }\n        const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);\n        const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);\n        return [...leftSubTypes, ...rightSubTypes];\n    }\n}\n\nclass LiteralTransformer {\n    transform(zodSchema, mapNullableType) {\n        return Object.assign(Object.assign({}, mapNullableType(typeof zodSchema._def.value)), { enum: [zodSchema._def.value] });\n    }\n}\n\n/**\n * Numeric enums have a reverse mapping https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n * whereas string ones don't.\n *\n * This function checks if an enum is fully numeric - i.e all values are numbers or not.\n * And filters out only the actual enum values when a reverse mapping is apparent.\n */\nfunction enumInfo(enumObject) {\n    const keysExceptReverseMappings = Object.keys(enumObject).filter(key => typeof enumObject[enumObject[key]] !== 'number');\n    const values = keysExceptReverseMappings.map(key => enumObject[key]);\n    const numericCount = values.filter(_ => typeof _ === 'number').length;\n    const type = numericCount === 0\n        ? 'string'\n        : numericCount === values.length\n            ? 'numeric'\n            : 'mixed';\n    return { values, type };\n}\n\nclass NativeEnumTransformer {\n    transform(zodSchema, mapNullableType) {\n        const { type, values } = enumInfo(zodSchema._def.values);\n        if (type === 'mixed') {\n            // enum Test {\n            //   A = 42,\n            //   B = 'test',\n            // }\n            //\n            // const result = z.nativeEnum(Test).parse('42');\n            //\n            // This is an error, so we can't just say it's a 'string'\n            throw new ZodToOpenAPIError('Enum has mixed string and number values, please specify the OpenAPI type manually');\n        }\n        return Object.assign(Object.assign({}, mapNullableType(type === 'numeric' ? 'integer' : 'string')), { enum: values });\n    }\n}\n\nclass NumberTransformer {\n    transform(zodSchema, mapNullableType, getNumberChecks) {\n        return Object.assign(Object.assign({}, mapNullableType(zodSchema.isInt ? 'integer' : 'number')), getNumberChecks(zodSchema._def.checks));\n    }\n}\n\nclass ObjectTransformer {\n    transform(zodSchema, defaultValue, mapNullableType, mapItem) {\n        var _a;\n        const extendedFrom = (_a = Metadata.getInternalMetadata(zodSchema)) === null || _a === void 0 ? void 0 : _a.extendedFrom;\n        const required = this.requiredKeysOf(zodSchema);\n        const properties = mapValues(zodSchema._def.shape(), mapItem);\n        if (!extendedFrom) {\n            return Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType('object')), { properties, default: defaultValue }), (required.length > 0 ? { required } : {})), this.generateAdditionalProperties(zodSchema, mapItem));\n        }\n        const parent = extendedFrom.schema;\n        // We want to generate the parent schema so that it can be referenced down the line\n        mapItem(parent);\n        const keysRequiredByParent = this.requiredKeysOf(parent);\n        const propsOfParent = mapValues(parent === null || parent === void 0 ? void 0 : parent._def.shape(), mapItem);\n        const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {\n            return !objectEquals(propsOfParent[key], type);\n        }));\n        const additionallyRequired = required.filter(prop => !keysRequiredByParent.includes(prop));\n        const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType('object')), { default: defaultValue, properties: propertiesToAdd }), (additionallyRequired.length > 0\n            ? { required: additionallyRequired }\n            : {})), this.generateAdditionalProperties(zodSchema, mapItem));\n        return {\n            allOf: [\n                { $ref: `#/components/schemas/${extendedFrom.refId}` },\n                objectData,\n            ],\n        };\n    }\n    generateAdditionalProperties(zodSchema, mapItem) {\n        const unknownKeysOption = zodSchema._def.unknownKeys;\n        const catchallSchema = zodSchema._def.catchall;\n        if (isZodType(catchallSchema, 'ZodNever')) {\n            if (unknownKeysOption === 'strict') {\n                return { additionalProperties: false };\n            }\n            return {};\n        }\n        return { additionalProperties: mapItem(catchallSchema) };\n    }\n    requiredKeysOf(objectSchema) {\n        return Object.entries(objectSchema._def.shape())\n            .filter(([_key, type]) => !Metadata.isOptionalSchema(type))\n            .map(([key, _type]) => key);\n    }\n}\n\nclass RecordTransformer {\n    transform(zodSchema, mapNullableType, mapItem) {\n        const propertiesType = zodSchema._def.valueType;\n        const keyType = zodSchema._def.keyType;\n        const propertiesSchema = mapItem(propertiesType);\n        if (isZodType(keyType, 'ZodEnum') || isZodType(keyType, 'ZodNativeEnum')) {\n            // Native enums have their keys as both number and strings however the number is an\n            // internal representation and the string is the access point for a documentation\n            const keys = Object.values(keyType.enum).filter(isString);\n            const properties = keys.reduce((acc, curr) => (Object.assign(Object.assign({}, acc), { [curr]: propertiesSchema })), {});\n            return Object.assign(Object.assign({}, mapNullableType('object')), { properties });\n        }\n        return Object.assign(Object.assign({}, mapNullableType('object')), { additionalProperties: propertiesSchema });\n    }\n}\n\nclass StringTransformer {\n    transform(zodSchema, mapNullableType) {\n        var _a, _b, _c;\n        const regexCheck = this.getZodStringCheck(zodSchema, 'regex');\n        const length = (_a = this.getZodStringCheck(zodSchema, 'length')) === null || _a === void 0 ? void 0 : _a.value;\n        const maxLength = Number.isFinite(zodSchema.minLength)\n            ? (_b = zodSchema.minLength) !== null && _b !== void 0 ? _b : undefined\n            : undefined;\n        const minLength = Number.isFinite(zodSchema.maxLength)\n            ? (_c = zodSchema.maxLength) !== null && _c !== void 0 ? _c : undefined\n            : undefined;\n        return Object.assign(Object.assign({}, mapNullableType('string')), { \n            // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c\n            minLength: length !== null && length !== void 0 ? length : maxLength, maxLength: length !== null && length !== void 0 ? length : minLength, format: this.mapStringFormat(zodSchema), pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source });\n    }\n    /**\n     * Attempts to map Zod strings to known formats\n     * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats\n     */\n    mapStringFormat(zodString) {\n        if (zodString.isUUID)\n            return 'uuid';\n        if (zodString.isEmail)\n            return 'email';\n        if (zodString.isURL)\n            return 'uri';\n        if (zodString.isDate)\n            return 'date';\n        if (zodString.isDatetime)\n            return 'date-time';\n        if (zodString.isCUID)\n            return 'cuid';\n        if (zodString.isCUID2)\n            return 'cuid2';\n        if (zodString.isULID)\n            return 'ulid';\n        if (zodString.isIP)\n            return 'ip';\n        if (zodString.isEmoji)\n            return 'emoji';\n        return undefined;\n    }\n    getZodStringCheck(zodString, kind) {\n        return zodString._def.checks.find((check) => {\n            return check.kind === kind;\n        });\n    }\n}\n\nclass TupleTransformer {\n    constructor(versionSpecifics) {\n        this.versionSpecifics = versionSpecifics;\n    }\n    transform(zodSchema, mapNullableType, mapItem) {\n        const { items } = zodSchema._def;\n        const schemas = items.map(mapItem);\n        return Object.assign(Object.assign({}, mapNullableType('array')), this.versionSpecifics.mapTupleItems(schemas));\n    }\n}\n\nclass UnionTransformer {\n    transform(zodSchema, mapNullableOfArray, mapItem) {\n        const options = this.flattenUnionTypes(zodSchema);\n        const schemas = options.map(schema => {\n            // If any of the underlying schemas of a union is .nullable then the whole union\n            // would be nullable. `mapNullableOfArray` would place it where it belongs.\n            // Therefor we are stripping the additional nullables from the inner schemas\n            // See https://github.com/asteasolutions/zod-to-openapi/issues/149\n            const optionToGenerate = this.unwrapNullable(schema);\n            return mapItem(optionToGenerate);\n        });\n        return {\n            anyOf: mapNullableOfArray(schemas),\n        };\n    }\n    flattenUnionTypes(schema) {\n        if (!isZodType(schema, 'ZodUnion')) {\n            return [schema];\n        }\n        const options = schema._def.options;\n        return options.flatMap(option => this.flattenUnionTypes(option));\n    }\n    unwrapNullable(schema) {\n        if (isZodType(schema, 'ZodNullable')) {\n            return this.unwrapNullable(schema.unwrap());\n        }\n        return schema;\n    }\n}\n\nclass OpenApiTransformer {\n    constructor(versionSpecifics) {\n        this.versionSpecifics = versionSpecifics;\n        this.objectTransformer = new ObjectTransformer();\n        this.stringTransformer = new StringTransformer();\n        this.numberTransformer = new NumberTransformer();\n        this.bigIntTransformer = new BigIntTransformer();\n        this.literalTransformer = new LiteralTransformer();\n        this.enumTransformer = new EnumTransformer();\n        this.nativeEnumTransformer = new NativeEnumTransformer();\n        this.arrayTransformer = new ArrayTransformer();\n        this.unionTransformer = new UnionTransformer();\n        this.discriminatedUnionTransformer = new DiscriminatedUnionTransformer();\n        this.intersectionTransformer = new IntersectionTransformer();\n        this.recordTransformer = new RecordTransformer();\n        this.tupleTransformer = new TupleTransformer(versionSpecifics);\n    }\n    transform(zodSchema, isNullable, mapItem, generateSchemaRef, defaultValue) {\n        if (isZodType(zodSchema, 'ZodNull')) {\n            return this.versionSpecifics.nullType;\n        }\n        if (isZodType(zodSchema, 'ZodUnknown') || isZodType(zodSchema, 'ZodAny')) {\n            return this.versionSpecifics.mapNullableType(undefined, isNullable);\n        }\n        if (isZodType(zodSchema, 'ZodObject')) {\n            return this.objectTransformer.transform(zodSchema, defaultValue, // verified on TS level from input\n            // verified on TS level from input\n            _ => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);\n        }\n        const schema = this.transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef);\n        return Object.assign(Object.assign({}, schema), { default: defaultValue });\n    }\n    transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef) {\n        if (isZodType(zodSchema, 'ZodUnknown') || isZodType(zodSchema, 'ZodAny')) {\n            return this.versionSpecifics.mapNullableType(undefined, isNullable);\n        }\n        if (isZodType(zodSchema, 'ZodString')) {\n            return this.stringTransformer.transform(zodSchema, schema => this.versionSpecifics.mapNullableType(schema, isNullable));\n        }\n        if (isZodType(zodSchema, 'ZodNumber')) {\n            return this.numberTransformer.transform(zodSchema, schema => this.versionSpecifics.mapNullableType(schema, isNullable), _ => this.versionSpecifics.getNumberChecks(_));\n        }\n        if (isZodType(zodSchema, 'ZodBigInt')) {\n            return this.bigIntTransformer.transform(schema => this.versionSpecifics.mapNullableType(schema, isNullable));\n        }\n        if (isZodType(zodSchema, 'ZodBoolean')) {\n            return this.versionSpecifics.mapNullableType('boolean', isNullable);\n        }\n        if (isZodType(zodSchema, 'ZodLiteral')) {\n            return this.literalTransformer.transform(zodSchema, schema => this.versionSpecifics.mapNullableType(schema, isNullable));\n        }\n        if (isZodType(zodSchema, 'ZodEnum')) {\n            return this.enumTransformer.transform(zodSchema, schema => this.versionSpecifics.mapNullableType(schema, isNullable));\n        }\n        if (isZodType(zodSchema, 'ZodNativeEnum')) {\n            return this.nativeEnumTransformer.transform(zodSchema, schema => this.versionSpecifics.mapNullableType(schema, isNullable));\n        }\n        if (isZodType(zodSchema, 'ZodArray')) {\n            return this.arrayTransformer.transform(zodSchema, _ => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);\n        }\n        if (isZodType(zodSchema, 'ZodTuple')) {\n            return this.tupleTransformer.transform(zodSchema, _ => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);\n        }\n        if (isZodType(zodSchema, 'ZodUnion')) {\n            return this.unionTransformer.transform(zodSchema, _ => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);\n        }\n        if (isZodType(zodSchema, 'ZodDiscriminatedUnion')) {\n            return this.discriminatedUnionTransformer.transform(zodSchema, isNullable, _ => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem, generateSchemaRef);\n        }\n        if (isZodType(zodSchema, 'ZodIntersection')) {\n            return this.intersectionTransformer.transform(zodSchema, isNullable, _ => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);\n        }\n        if (isZodType(zodSchema, 'ZodRecord')) {\n            return this.recordTransformer.transform(zodSchema, _ => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);\n        }\n        if (isZodType(zodSchema, 'ZodDate')) {\n            return this.versionSpecifics.mapNullableType('string', isNullable);\n        }\n        const refId = Metadata.getRefId(zodSchema);\n        throw new UnknownZodTypeError({\n            currentSchema: zodSchema._def,\n            schemaName: refId,\n        });\n    }\n}\n\nclass OpenAPIGenerator {\n    constructor(definitions, versionSpecifics) {\n        this.definitions = definitions;\n        this.versionSpecifics = versionSpecifics;\n        this.schemaRefs = {};\n        this.paramRefs = {};\n        this.pathRefs = {};\n        this.rawComponents = [];\n        this.openApiTransformer = new OpenApiTransformer(versionSpecifics);\n        this.sortDefinitions();\n    }\n    generateDocumentData() {\n        this.definitions.forEach(definition => this.generateSingle(definition));\n        return {\n            components: this.buildComponents(),\n            paths: this.pathRefs,\n        };\n    }\n    generateComponents() {\n        this.definitions.forEach(definition => this.generateSingle(definition));\n        return {\n            components: this.buildComponents(),\n        };\n    }\n    buildComponents() {\n        var _a, _b;\n        const rawComponents = {};\n        this.rawComponents.forEach(({ componentType, name, component }) => {\n            var _a;\n            (_a = rawComponents[componentType]) !== null && _a !== void 0 ? _a : (rawComponents[componentType] = {});\n            rawComponents[componentType][name] = component;\n        });\n        return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, ((_a = rawComponents.schemas) !== null && _a !== void 0 ? _a : {})), this.schemaRefs), parameters: Object.assign(Object.assign({}, ((_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {})), this.paramRefs) });\n    }\n    sortDefinitions() {\n        const generationOrder = [\n            'schema',\n            'parameter',\n            'component',\n            'route',\n        ];\n        this.definitions.sort((left, right) => {\n            // No type means \"plain zod schema\" => it comes as highest priority based on the array above\n            if (!('type' in left)) {\n                if (!('type' in right)) {\n                    return 0;\n                }\n                return -1;\n            }\n            if (!('type' in right)) {\n                return 1;\n            }\n            const leftIndex = generationOrder.findIndex(type => type === left.type);\n            const rightIndex = generationOrder.findIndex(type => type === right.type);\n            return leftIndex - rightIndex;\n        });\n    }\n    generateSingle(definition) {\n        if (!('type' in definition)) {\n            this.generateSchemaWithRef(definition);\n            return;\n        }\n        switch (definition.type) {\n            case 'parameter':\n                this.generateParameterDefinition(definition.schema);\n                return;\n            case 'schema':\n                this.generateSchemaWithRef(definition.schema);\n                return;\n            case 'route':\n                this.generateSingleRoute(definition.route);\n                return;\n            case 'component':\n                this.rawComponents.push(definition);\n                return;\n        }\n    }\n    generateParameterDefinition(zodSchema) {\n        const refId = Metadata.getRefId(zodSchema);\n        const result = this.generateParameter(zodSchema);\n        if (refId) {\n            this.paramRefs[refId] = result;\n        }\n        return result;\n    }\n    getParameterRef(schemaMetadata, external) {\n        var _a, _b, _c, _d, _e;\n        const parameterMetadata = (_a = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a === void 0 ? void 0 : _a.param;\n        const existingRef = ((_b = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b === void 0 ? void 0 : _b.refId)\n            ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === void 0 ? void 0 : _c.refId]\n            : undefined;\n        if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {\n            return undefined;\n        }\n        if ((parameterMetadata && existingRef.in !== parameterMetadata.in) ||\n            ((external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in)) {\n            throw new ConflictError(`Conflicting location for parameter ${existingRef.name}`, {\n                key: 'in',\n                values: compact([\n                    existingRef.in,\n                    external === null || external === void 0 ? void 0 : external.in,\n                    parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in,\n                ]),\n            });\n        }\n        if ((parameterMetadata && existingRef.name !== parameterMetadata.name) ||\n            ((external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name))) {\n            throw new ConflictError(`Conflicting names for parameter`, {\n                key: 'name',\n                values: compact([\n                    existingRef.name,\n                    external === null || external === void 0 ? void 0 : external.name,\n                    parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name,\n                ]),\n            });\n        }\n        return {\n            $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === void 0 ? void 0 : _e.refId}`,\n        };\n    }\n    generateInlineParameters(zodSchema, location) {\n        var _a;\n        const metadata = Metadata.getMetadata(zodSchema);\n        const parameterMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;\n        const referencedSchema = this.getParameterRef(metadata, { in: location });\n        if (referencedSchema) {\n            return [referencedSchema];\n        }\n        if (isZodType(zodSchema, 'ZodObject')) {\n            const propTypes = zodSchema._def.shape();\n            const parameters = Object.entries(propTypes).map(([key, schema]) => {\n                var _a, _b;\n                const innerMetadata = Metadata.getMetadata(schema);\n                const referencedSchema = this.getParameterRef(innerMetadata, {\n                    in: location,\n                    name: key,\n                });\n                if (referencedSchema) {\n                    return referencedSchema;\n                }\n                const innerParameterMetadata = (_a = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a === void 0 ? void 0 : _a.param;\n                if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) &&\n                    innerParameterMetadata.name !== key) {\n                    throw new ConflictError(`Conflicting names for parameter`, {\n                        key: 'name',\n                        values: [key, innerParameterMetadata.name],\n                    });\n                }\n                if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) &&\n                    innerParameterMetadata.in !== location) {\n                    throw new ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== void 0 ? _b : key}`, {\n                        key: 'in',\n                        values: [location, innerParameterMetadata.in],\n                    });\n                }\n                return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));\n            });\n            return parameters;\n        }\n        if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {\n            throw new ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {\n                key: 'in',\n                values: [location, parameterMetadata.in],\n            });\n        }\n        return [\n            this.generateParameter(zodSchema.openapi({ param: { in: location } })),\n        ];\n    }\n    generateSimpleParameter(zodSchema) {\n        var _a;\n        const metadata = Metadata.getParamMetadata(zodSchema);\n        const paramMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;\n        // TODO: Why are we not unwrapping here for isNullable as well?\n        const required = !Metadata.isOptionalSchema(zodSchema) && !zodSchema.isNullable();\n        const schema = this.generateSchemaWithRef(zodSchema);\n        return Object.assign({ schema,\n            required }, (paramMetadata ? Metadata.buildParameterMetadata(paramMetadata) : {}));\n    }\n    generateParameter(zodSchema) {\n        var _a;\n        const metadata = Metadata.getMetadata(zodSchema);\n        const paramMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;\n        const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;\n        const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;\n        if (!paramName) {\n            throw new MissingParameterDataError({ missingField: 'name' });\n        }\n        if (!paramLocation) {\n            throw new MissingParameterDataError({\n                missingField: 'in',\n                paramName,\n            });\n        }\n        const baseParameter = this.generateSimpleParameter(zodSchema);\n        return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });\n    }\n    generateSchemaWithMetadata(zodSchema) {\n        var _a;\n        const innerSchema = Metadata.unwrapChained(zodSchema);\n        const metadata = Metadata.getMetadata(zodSchema);\n        const defaultValue = Metadata.getDefaultValue(zodSchema);\n        const result = ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.type)\n            ? { type: metadata === null || metadata === void 0 ? void 0 : metadata.metadata.type }\n            : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);\n        return (metadata === null || metadata === void 0 ? void 0 : metadata.metadata)\n            ? Metadata.applySchemaMetadata(result, metadata.metadata)\n            : omitBy(result, isUndefined);\n    }\n    /**\n     * Same as above but applies nullable\n     */\n    constructReferencedOpenAPISchema(zodSchema) {\n        var _a;\n        const metadata = Metadata.getMetadata(zodSchema);\n        const innerSchema = Metadata.unwrapChained(zodSchema);\n        const defaultValue = Metadata.getDefaultValue(zodSchema);\n        const isNullableSchema = zodSchema.isNullable();\n        if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.type) {\n            return this.versionSpecifics.mapNullableType(metadata.metadata.type, isNullableSchema);\n        }\n        return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);\n    }\n    /**\n     * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied\n     */\n    generateSimpleSchema(zodSchema) {\n        var _a;\n        const metadata = Metadata.getMetadata(zodSchema);\n        const refId = Metadata.getRefId(zodSchema);\n        if (!refId || !this.schemaRefs[refId]) {\n            return this.generateSchemaWithMetadata(zodSchema);\n        }\n        const schemaRef = this.schemaRefs[refId];\n        const referenceObject = {\n            $ref: this.generateSchemaRef(refId),\n        };\n        // Metadata provided from .openapi() that is new to what we had already registered\n        const newMetadata = omitBy(Metadata.buildSchemaMetadata((_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) !== null && _a !== void 0 ? _a : {}), (value, key) => value === undefined || objectEquals(value, schemaRef[key]));\n        // Do not calculate schema metadata overrides if type is provided in .openapi\n        // https://github.com/asteasolutions/zod-to-openapi/pull/52/files/8ff707fe06e222bc573ed46cf654af8ee0b0786d#r996430801\n        if (newMetadata.type) {\n            return {\n                allOf: [referenceObject, newMetadata],\n            };\n        }\n        // New metadata from ZodSchema properties.\n        const newSchemaMetadata = omitBy(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === undefined || objectEquals(value, schemaRef[key]));\n        const appliedMetadata = Metadata.applySchemaMetadata(newSchemaMetadata, newMetadata);\n        if (Object.keys(appliedMetadata).length > 0) {\n            return {\n                allOf: [referenceObject, appliedMetadata],\n            };\n        }\n        return referenceObject;\n    }\n    /**\n     * Same as `generateSchema` but if the new schema is added into the\n     * referenced schemas, it would return a ReferenceObject and not the\n     * whole result.\n     *\n     * Should be used for nested objects, arrays, etc.\n     */\n    generateSchemaWithRef(zodSchema) {\n        const refId = Metadata.getRefId(zodSchema);\n        const result = this.generateSimpleSchema(zodSchema);\n        if (refId && this.schemaRefs[refId] === undefined) {\n            this.schemaRefs[refId] = result;\n            return { $ref: this.generateSchemaRef(refId) };\n        }\n        return result;\n    }\n    generateSchemaRef(refId) {\n        return `#/components/schemas/${refId}`;\n    }\n    getRequestBody(requestBody) {\n        if (!requestBody) {\n            return;\n        }\n        const { content } = requestBody, rest = __rest(requestBody, [\"content\"]);\n        const requestBodyContent = this.getBodyContent(content);\n        return Object.assign(Object.assign({}, rest), { content: requestBodyContent });\n    }\n    getParameters(request) {\n        if (!request) {\n            return [];\n        }\n        const { headers } = request;\n        const query = this.cleanParameter(request.query);\n        const params = this.cleanParameter(request.params);\n        const cookies = this.cleanParameter(request.cookies);\n        const queryParameters = enhanceMissingParametersError(() => (query ? this.generateInlineParameters(query, 'query') : []), { location: 'query' });\n        const pathParameters = enhanceMissingParametersError(() => (params ? this.generateInlineParameters(params, 'path') : []), { location: 'path' });\n        const cookieParameters = enhanceMissingParametersError(() => (cookies ? this.generateInlineParameters(cookies, 'cookie') : []), { location: 'cookie' });\n        const headerParameters = enhanceMissingParametersError(() => {\n            if (Array.isArray(headers)) {\n                return headers.flatMap(header => this.generateInlineParameters(header, 'header'));\n            }\n            const cleanHeaders = this.cleanParameter(headers);\n            return cleanHeaders\n                ? this.generateInlineParameters(cleanHeaders, 'header')\n                : [];\n        }, { location: 'header' });\n        return [\n            ...pathParameters,\n            ...queryParameters,\n            ...headerParameters,\n            ...cookieParameters,\n        ];\n    }\n    cleanParameter(schema) {\n        if (!schema) {\n            return undefined;\n        }\n        return isZodType(schema, 'ZodEffects')\n            ? this.cleanParameter(schema._def.schema)\n            : schema;\n    }\n    generatePath(route) {\n        const { method, path, request, responses } = route, pathItemConfig = __rest(route, [\"method\", \"path\", \"request\", \"responses\"]);\n        const generatedResponses = mapValues(responses, response => {\n            return this.getResponse(response);\n        });\n        const parameters = enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });\n        const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);\n        const routeDoc = {\n            [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), (parameters.length > 0\n                ? {\n                    parameters: [...(pathItemConfig.parameters || []), ...parameters],\n                }\n                : {})), (requestBody ? { requestBody } : {})), { responses: generatedResponses }),\n        };\n        return routeDoc;\n    }\n    generateSingleRoute(route) {\n        const routeDoc = this.generatePath(route);\n        this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);\n        return routeDoc;\n    }\n    getResponse(response) {\n        if (this.isReferenceObject(response)) {\n            return response;\n        }\n        const { content, headers } = response, rest = __rest(response, [\"content\", \"headers\"]);\n        const responseContent = content\n            ? { content: this.getBodyContent(content) }\n            : {};\n        if (!headers) {\n            return Object.assign(Object.assign({}, rest), responseContent);\n        }\n        const responseHeaders = isZodType(headers, 'ZodObject')\n            ? this.getResponseHeaders(headers)\n            : // This is input data so it is okay to cast in the common generator\n                // since this is the user's responsibility to keep it correct\n                headers;\n        return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);\n    }\n    isReferenceObject(schema) {\n        return '$ref' in schema;\n    }\n    getResponseHeaders(headers) {\n        const schemaShape = headers._def.shape();\n        const responseHeaders = mapValues(schemaShape, _ => this.generateSimpleParameter(_));\n        return responseHeaders;\n    }\n    getBodyContent(content) {\n        return mapValues(content, config => {\n            if (!config || !isAnyZodType(config.schema)) {\n                return config;\n            }\n            const { schema: configSchema } = config, rest = __rest(config, [\"schema\"]);\n            const schema = this.generateSchemaWithRef(configSchema);\n            return Object.assign({ schema }, rest);\n        });\n    }\n    toOpenAPISchema(zodSchema, isNullable, defaultValue) {\n        return this.openApiTransformer.transform(zodSchema, isNullable, _ => this.generateSchemaWithRef(_), _ => this.generateSchemaRef(_), defaultValue);\n    }\n}\n\nclass OpenApiGeneratorV30Specifics {\n    get nullType() {\n        return { nullable: true };\n    }\n    mapNullableOfArray(objects, isNullable) {\n        if (isNullable) {\n            return [...objects, this.nullType];\n        }\n        return objects;\n    }\n    mapNullableType(type, isNullable) {\n        return Object.assign(Object.assign({}, (type ? { type } : undefined)), (isNullable ? this.nullType : undefined));\n    }\n    mapTupleItems(schemas) {\n        const uniqueSchemas = uniq(schemas);\n        return {\n            items: uniqueSchemas.length === 1\n                ? uniqueSchemas[0]\n                : { anyOf: uniqueSchemas },\n            minItems: schemas.length,\n            maxItems: schemas.length,\n        };\n    }\n    getNumberChecks(checks) {\n        return Object.assign({}, ...checks.map(check => {\n            switch (check.kind) {\n                case 'min':\n                    return check.inclusive\n                        ? { minimum: Number(check.value) }\n                        : { minimum: Number(check.value), exclusiveMinimum: true };\n                case 'max':\n                    return check.inclusive\n                        ? { maximum: Number(check.value) }\n                        : { maximum: Number(check.value), exclusiveMaximum: true };\n                default:\n                    return {};\n            }\n        }));\n    }\n}\n\nclass OpenApiGeneratorV3 {\n    constructor(definitions) {\n        const specifics = new OpenApiGeneratorV30Specifics();\n        this.generator = new OpenAPIGenerator(definitions, specifics);\n    }\n    generateDocument(config) {\n        const baseData = this.generator.generateDocumentData();\n        return Object.assign(Object.assign({}, config), baseData);\n    }\n    generateComponents() {\n        return this.generator.generateComponents();\n    }\n}\n\nclass OpenApiGeneratorV31Specifics {\n    get nullType() {\n        return { type: 'null' };\n    }\n    mapNullableOfArray(objects, isNullable) {\n        if (isNullable) {\n            return [...objects, this.nullType];\n        }\n        return objects;\n    }\n    mapNullableType(type, isNullable) {\n        if (!type) {\n            // 'null' is considered a type in Open API 3.1.0 => not providing a type includes null\n            return {};\n        }\n        // Open API 3.1.0 made the `nullable` key invalid and instead you use type arrays\n        if (isNullable) {\n            return {\n                type: Array.isArray(type) ? [...type, 'null'] : [type, 'null'],\n            };\n        }\n        return {\n            type,\n        };\n    }\n    mapTupleItems(schemas) {\n        return {\n            prefixItems: schemas,\n        };\n    }\n    getNumberChecks(checks) {\n        return Object.assign({}, ...checks.map(check => {\n            switch (check.kind) {\n                case 'min':\n                    return check.inclusive\n                        ? { minimum: Number(check.value) }\n                        : { exclusiveMinimum: Number(check.value) };\n                case 'max':\n                    return check.inclusive\n                        ? { maximum: Number(check.value) }\n                        : { exclusiveMaximum: Number(check.value) };\n                default:\n                    return {};\n            }\n        }));\n    }\n}\n\nfunction isWebhookDefinition(definition) {\n    return 'type' in definition && definition.type === 'webhook';\n}\nclass OpenApiGeneratorV31 {\n    constructor(definitions) {\n        this.definitions = definitions;\n        this.webhookRefs = {};\n        const specifics = new OpenApiGeneratorV31Specifics();\n        this.generator = new OpenAPIGenerator(this.definitions, specifics);\n    }\n    generateDocument(config) {\n        const baseDocument = this.generator.generateDocumentData();\n        this.definitions\n            .filter(isWebhookDefinition)\n            .forEach(definition => this.generateSingleWebhook(definition.webhook));\n        return Object.assign(Object.assign(Object.assign({}, config), baseDocument), { webhooks: this.webhookRefs });\n    }\n    generateComponents() {\n        return this.generator.generateComponents();\n    }\n    generateSingleWebhook(route) {\n        const routeDoc = this.generator.generatePath(route);\n        this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);\n        return routeDoc;\n    }\n}\n\nexport { OpenAPIRegistry, OpenApiGeneratorV3, OpenApiGeneratorV31, extendZodWithOpenApi, getOpenApiMetadata };\n","// src/index.ts\nimport { validator } from \"hono/validator\";\nvar zValidator = (target, schema, hook, options) => (\n  // @ts-expect-error not typed well\n  validator(target, async (value, c) => {\n    let validatorValue = value;\n    if (target === \"header\" && \"_def\" in schema || target === \"header\" && \"_zod\" in schema) {\n      const schemaKeys = Object.keys(schema.shape);\n      const caseInsensitiveKeymap = Object.fromEntries(\n        schemaKeys.map((key) => [key.toLowerCase(), key])\n      );\n      validatorValue = Object.fromEntries(\n        Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2])\n      );\n    }\n    const result = options && options.validationFunction ? await options.validationFunction(schema, validatorValue) : (\n      // @ts-expect-error z4.$ZodType has safeParseAsync\n      await schema.safeParseAsync(validatorValue)\n    );\n    if (hook) {\n      const hookResult = await hook({ data: validatorValue, ...result, target }, c);\n      if (hookResult) {\n        if (hookResult instanceof Response) {\n          return hookResult;\n        }\n        if (\"response\" in hookResult) {\n          return hookResult.response;\n        }\n      }\n    }\n    if (!result.success) {\n      return c.json(result, 400);\n    }\n    return result.data;\n  })\n);\nexport {\n  zValidator\n};\n","// src/index.ts\nimport {\n  OpenAPIRegistry,\n  OpenApiGeneratorV3,\n  OpenApiGeneratorV31,\n  extendZodWithOpenApi\n} from \"@asteasolutions/zod-to-openapi\";\nimport { zValidator } from \"@hono/zod-validator\";\nimport { Hono } from \"hono\";\nimport { mergePath } from \"hono/utils/url\";\nimport { ZodType, z } from \"zod\";\nvar OpenAPIHono = class _OpenAPIHono extends Hono {\n  openAPIRegistry;\n  defaultHook;\n  constructor(init) {\n    super(init);\n    this.openAPIRegistry = new OpenAPIRegistry();\n    this.defaultHook = init?.defaultHook;\n  }\n  /**\n   *\n   * @param {RouteConfig} route - The route definition which you create with `createRoute()`.\n   * @param {Handler} handler - The handler. If you want to return a JSON object, you should specify the status code with `c.json()`.\n   * @param {Hook} hook - Optional. The hook method defines what it should do after validation.\n   * @example\n   * app.openapi(\n   *   route,\n   *   (c) => {\n   *     // ...\n   *     return c.json(\n   *       {\n   *         age: 20,\n   *         name: 'Young man',\n   *       },\n   *       200 // You should specify the status code even if it's 200.\n   *     )\n   *   },\n   *  (result, c) => {\n   *    if (!result.success) {\n   *      return c.json(\n   *        {\n   *          code: 400,\n   *          message: 'Custom Message',\n   *        },\n   *        400\n   *      )\n   *    }\n   *  }\n   *)\n   */\n  openapi = ({ middleware: routeMiddleware, hide, ...route }, handler, hook = this.defaultHook) => {\n    if (!hide) {\n      this.openAPIRegistry.registerPath(route);\n    }\n    const validators = [];\n    if (route.request?.query) {\n      const validator = zValidator(\"query\", route.request.query, hook);\n      validators.push(validator);\n    }\n    if (route.request?.params) {\n      const validator = zValidator(\"param\", route.request.params, hook);\n      validators.push(validator);\n    }\n    if (route.request?.headers) {\n      const validator = zValidator(\"header\", route.request.headers, hook);\n      validators.push(validator);\n    }\n    if (route.request?.cookies) {\n      const validator = zValidator(\"cookie\", route.request.cookies, hook);\n      validators.push(validator);\n    }\n    const bodyContent = route.request?.body?.content;\n    if (bodyContent) {\n      for (const mediaType of Object.keys(bodyContent)) {\n        if (!bodyContent[mediaType]) {\n          continue;\n        }\n        const schema = bodyContent[mediaType][\"schema\"];\n        if (!(schema instanceof ZodType)) {\n          continue;\n        }\n        if (isJSONContentType(mediaType)) {\n          const validator = zValidator(\"json\", schema, hook);\n          if (route.request?.body?.required) {\n            validators.push(validator);\n          } else {\n            const mw = async (c, next) => {\n              if (c.req.header(\"content-type\")) {\n                if (isJSONContentType(c.req.header(\"content-type\"))) {\n                  return await validator(c, next);\n                }\n              }\n              c.req.addValidatedData(\"json\", {});\n              await next();\n            };\n            validators.push(mw);\n          }\n        }\n        if (isFormContentType(mediaType)) {\n          const validator = zValidator(\"form\", schema, hook);\n          if (route.request?.body?.required) {\n            validators.push(validator);\n          } else {\n            const mw = async (c, next) => {\n              if (c.req.header(\"content-type\")) {\n                if (isFormContentType(c.req.header(\"content-type\"))) {\n                  return await validator(c, next);\n                }\n              }\n              c.req.addValidatedData(\"form\", {});\n              await next();\n            };\n            validators.push(mw);\n          }\n        }\n      }\n    }\n    const middleware = routeMiddleware ? Array.isArray(routeMiddleware) ? routeMiddleware : [routeMiddleware] : [];\n    this.on(\n      [route.method],\n      route.path.replaceAll(/\\/{(.+?)}/g, \"/:$1\"),\n      ...middleware,\n      ...validators,\n      handler\n    );\n    return this;\n  };\n  getOpenAPIDocument = (config) => {\n    const generator = new OpenApiGeneratorV3(this.openAPIRegistry.definitions);\n    const document = generator.generateDocument(config);\n    return this._basePath ? addBasePathToDocument(document, this._basePath) : document;\n  };\n  getOpenAPI31Document = (config) => {\n    const generator = new OpenApiGeneratorV31(this.openAPIRegistry.definitions);\n    const document = generator.generateDocument(config);\n    return this._basePath ? addBasePathToDocument(document, this._basePath) : document;\n  };\n  doc = (path, configure) => {\n    return this.get(path, (c) => {\n      const config = typeof configure === \"function\" ? configure(c) : configure;\n      try {\n        const document = this.getOpenAPIDocument(config);\n        return c.json(document);\n      } catch (e) {\n        return c.json(e, 500);\n      }\n    });\n  };\n  doc31 = (path, configure) => {\n    return this.get(path, (c) => {\n      const config = typeof configure === \"function\" ? configure(c) : configure;\n      try {\n        const document = this.getOpenAPI31Document(config);\n        return c.json(document);\n      } catch (e) {\n        return c.json(e, 500);\n      }\n    });\n  };\n  route(path, app) {\n    const pathForOpenAPI = path.replaceAll(/:([^\\/]+)/g, \"{$1}\");\n    super.route(path, app);\n    if (!(app instanceof _OpenAPIHono)) {\n      return this;\n    }\n    app.openAPIRegistry.definitions.forEach((def) => {\n      switch (def.type) {\n        case \"component\":\n          return this.openAPIRegistry.registerComponent(def.componentType, def.name, def.component);\n        case \"route\":\n          return this.openAPIRegistry.registerPath({\n            ...def.route,\n            path: mergePath(\n              pathForOpenAPI,\n              // @ts-expect-error _basePath is private\n              app._basePath.replaceAll(/:([^\\/]+)/g, \"{$1}\"),\n              def.route.path\n            )\n          });\n        case \"webhook\":\n          return this.openAPIRegistry.registerWebhook({\n            ...def.webhook,\n            path: mergePath(\n              pathForOpenAPI,\n              // @ts-expect-error _basePath is private\n              app._basePath.replaceAll(/:([^\\/]+)/g, \"{$1}\"),\n              def.webhook.path\n            )\n          });\n        case \"schema\":\n          return this.openAPIRegistry.register(def.schema._def.openapi._internal.refId, def.schema);\n        case \"parameter\":\n          return this.openAPIRegistry.registerParameter(\n            def.schema._def.openapi._internal.refId,\n            def.schema\n          );\n        default: {\n          const errorIfNotExhaustive = def;\n          throw new Error(`Unknown registry type: ${errorIfNotExhaustive}`);\n        }\n      }\n    });\n    return this;\n  }\n  basePath(path) {\n    return new _OpenAPIHono({ ...super.basePath(path), defaultHook: this.defaultHook });\n  }\n};\nvar createRoute = (routeConfig) => {\n  const route = {\n    ...routeConfig,\n    getRoutingPath() {\n      return routeConfig.path.replaceAll(/\\/{(.+?)}/g, \"/:$1\");\n    }\n  };\n  return Object.defineProperty(route, \"getRoutingPath\", { enumerable: false });\n};\nextendZodWithOpenApi(z);\nfunction addBasePathToDocument(document, basePath) {\n  const updatedPaths = {};\n  Object.keys(document.paths).forEach((path) => {\n    updatedPaths[mergePath(basePath.replaceAll(/:([^\\/]+)/g, \"{$1}\"), path)] = document.paths[path];\n  });\n  return {\n    ...document,\n    paths: updatedPaths\n  };\n}\nfunction isJSONContentType(contentType) {\n  return /^application\\/([a-z-\\.]+\\+)?json/.test(contentType);\n}\nfunction isFormContentType(contentType) {\n  return contentType.startsWith(\"multipart/form-data\") || contentType.startsWith(\"application/x-www-form-urlencoded\");\n}\nexport {\n  OpenAPIHono,\n  createRoute,\n  extendZodWithOpenApi,\n  z\n};\n","// src/helper/factory/index.ts\nimport { Hono } from \"../../hono.js\";\nvar Factory = class {\n  initApp;\n  #defaultAppOptions;\n  constructor(init) {\n    this.initApp = init?.initApp;\n    this.#defaultAppOptions = init?.defaultAppOptions;\n  }\n  createApp = (options) => {\n    const app = new Hono(\n      options && this.#defaultAppOptions ? { ...this.#defaultAppOptions, ...options } : options ?? this.#defaultAppOptions\n    );\n    if (this.initApp) {\n      this.initApp(app);\n    }\n    return app;\n  };\n  createMiddleware = (middleware) => middleware;\n  createHandlers = (...handlers) => {\n    return handlers.filter((handler) => handler !== void 0);\n  };\n};\nvar createFactory = (init) => new Factory(init);\nvar createMiddleware = (middleware) => middleware;\nexport {\n  Factory,\n  createFactory,\n  createMiddleware\n};\n","import { createRoute, z, OpenAPIHono } from \"@hono/zod-openapi\";\r\nimport { createServerClient, type CookieOptions } from \"@supabase/ssr\";\r\nimport { Context } from \"hono\";\r\nimport { getCookie, setCookie, deleteCookie } from \"hono/cookie\";\r\nimport { createMiddleware } from \"hono/factory\";\r\n\r\nimport { getAuthUser } from \"@/lib/auth/index\";\r\nimport { Database } from \"@/types/database.types\";\r\n\r\n// Onboarding API Schema\r\nconst OnboardingSchema = z.object({\r\n  currentStep: z.enum([\r\n    \"welcome\",\r\n    \"profile-setup\",\r\n    \"feature-tour\",\r\n    \"first-task\",\r\n    \"resources\",\r\n    \"completed\",\r\n  ]),\r\n  progress: z.number().min(0).max(100),\r\n  isCompleted: z.boolean(),\r\n});\r\n\r\nconst OnboardingActionSchema = z.object({\r\n  actionKey: z.string().min(1),\r\n  isCompleted: z.boolean(),\r\n});\r\n\r\n// Create authenticated middleware\r\nconst authMiddleware = createMiddleware(async (c, next) => {\r\n  const { user } = await getAuthUser();\r\n  if (!user) {\r\n    return c.json({ error: \"Unauthorized\" }, 401);\r\n  }\r\n  c.set(\"user\", user);\r\n  await next();\r\n});\r\n\r\n// Create Hono app\r\nconst onboarding = new OpenAPIHono();\r\nonboarding.use(\"*\", authMiddleware);\r\n\r\n// GET /api/onboarding - Get user's onboarding state\r\nonboarding.openapi(\r\n  createRoute({\r\n    method: \"get\",\r\n    path: \"/\",\r\n    tags: [\"Onboarding\"],\r\n    summary: \"Get user onboarding state\",\r\n    description:\r\n      \"Retrieves the current onboarding state for the authenticated user\",\r\n    responses: {\r\n      200: {\r\n        description: \"User onboarding state\",\r\n        content: {\r\n          \"application/json\": {\r\n            schema: OnboardingSchema,\r\n          },\r\n        },\r\n      },\r\n      401: {\r\n        description: \"Unauthorized\",\r\n      },\r\n    },\r\n  }),\r\n  async (c: Context) => {\r\n    const user = c.get(\"user\")!;\r\n    const supabase = createServerClient<Database>(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          get: (key) => {\r\n            return getCookie(c, key);\r\n          },\r\n          set: (key, value, options) => {\r\n            setCookie(c, key, value, options);\r\n          },\r\n          remove: (key, options) => {\r\n            deleteCookie(c, key, options);\r\n          },\r\n        },\r\n      }\r\n    );\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"user_onboarding\")\r\n      .select(\"*\")\r\n      .eq(\"user_id\", user.id)\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      // Initialize new onboarding state\r\n      const newOnboardingState = {\r\n        currentStep: \"welcome\",\r\n        progress: 0,\r\n        isCompleted: false,\r\n      };\r\n\r\n      // Insert new record\r\n      await supabase.from(\"user_onboarding\").insert({\r\n        user_id: user.id,\r\n        current_step: newOnboardingState.currentStep,\r\n        progress: newOnboardingState.progress,\r\n        is_completed: newOnboardingState.isCompleted,\r\n      });\r\n\r\n      return c.json(newOnboardingState);\r\n    }\r\n\r\n    return c.json({\r\n      currentStep: data.current_step,\r\n      progress: data.progress,\r\n      isCompleted: data.is_completed,\r\n    });\r\n  }\r\n);\r\n\r\n// PATCH /api/onboarding - Update onboarding state\r\nonboarding.openapi(\r\n  createRoute({\r\n    method: \"patch\",\r\n    path: \"/\",\r\n    tags: [\"Onboarding\"],\r\n    summary: \"Update onboarding state\",\r\n    description: \"Updates the onboarding state for the authenticated user\",\r\n    request: {\r\n      body: {\r\n        content: {\r\n          \"application/json\": {\r\n            schema: OnboardingSchema.partial(),\r\n          },\r\n        },\r\n      },\r\n    },\r\n    responses: {\r\n      200: {\r\n        description: \"Onboarding state updated\",\r\n        content: {\r\n          \"application/json\": {\r\n            schema: OnboardingSchema,\r\n          },\r\n        },\r\n      },\r\n      401: {\r\n        description: \"Unauthorized\",\r\n      },\r\n    },\r\n  }),\r\n  async (c: Context) => {\r\n    const user = c.get(\"user\")!;\r\n    const supabase = createServerClient<Database>(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          get: (key) => {\r\n            return getCookie(c, key);\r\n          },\r\n          set: (key, value, options) => {\r\n            setCookie(c, key, value, options);\r\n          },\r\n          remove: (key, options) => {\r\n            deleteCookie(c, key, options);\r\n          },\r\n        },\r\n      }\r\n    );\r\n    const body = await c.req.json();\r\n\r\n    // Validate the input\r\n    const input = OnboardingSchema.partial().parse(body);\r\n\r\n    // Prepare the update\r\n    const update: Record<string, any> = {};\r\n    if (input.currentStep !== undefined)\r\n      update.current_step = input.currentStep;\r\n    if (input.progress !== undefined) update.progress = input.progress;\r\n    if (input.isCompleted !== undefined)\r\n      update.is_completed = input.isCompleted;\r\n    update.updated_at = new Date().toISOString();\r\n\r\n    // Update the record\r\n    const { data, error } = await supabase\r\n      .from(\"user_onboarding\")\r\n      .upsert({\r\n        user_id: user.id,\r\n        ...update,\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      return c.json({ error: error.message }, 500);\r\n    }\r\n\r\n    return c.json({\r\n      currentStep: data.current_step,\r\n      progress: data.progress,\r\n      isCompleted: data.is_completed,\r\n    });\r\n  }\r\n);\r\n\r\n// POST /api/onboarding/actions - Mark onboarding action as completed\r\nonboarding.openapi(\r\n  createRoute({\r\n    method: \"post\",\r\n    path: \"/actions\",\r\n    tags: [\"Onboarding\"],\r\n    summary: \"Mark onboarding action\",\r\n    description: \"Marks a specific onboarding action as completed\",\r\n    request: {\r\n      body: {\r\n        content: {\r\n          \"application/json\": {\r\n            schema: OnboardingActionSchema,\r\n          },\r\n        },\r\n      },\r\n    },\r\n    responses: {\r\n      200: {\r\n        description: \"Action marked\",\r\n        content: {\r\n          \"application/json\": {\r\n            schema: z.object({\r\n              success: z.boolean(),\r\n            }),\r\n          },\r\n        },\r\n      },\r\n      401: {\r\n        description: \"Unauthorized\",\r\n      },\r\n    },\r\n  }),\r\n  async (c: Context) => {\r\n    const user = c.get(\"user\")!;\r\n    const supabase = createServerClient<Database>(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          get: (key) => {\r\n            return getCookie(c, key);\r\n          },\r\n          set: (key, value, options) => {\r\n            setCookie(c, key, value, options);\r\n          },\r\n          remove: (key, options) => {\r\n            deleteCookie(c, key, options);\r\n          },\r\n        },\r\n      }\r\n    );\r\n    const body = await c.req.json();\r\n\r\n    // Validate the input\r\n    const input = OnboardingActionSchema.parse(body);\r\n\r\n    const { error } = await supabase.rpc(\"mark_onboarding_action_completed\", {\r\n      action_key: input.actionKey,\r\n    });\r\n\r\n    if (error) {\r\n      return c.json({ success: false, error: error.message }, 500);\r\n    }\r\n\r\n    return c.json({ success: true });\r\n  }\r\n);\r\n\r\n// GET /api/onboarding/actions - Get all completed onboarding actions\r\nonboarding.openapi(\r\n  createRoute({\r\n    method: \"get\",\r\n    path: \"/actions\",\r\n    tags: [\"Onboarding\"],\r\n    summary: \"Get completed actions\",\r\n    description: \"Get all completed onboarding actions for the user\",\r\n    responses: {\r\n      200: {\r\n        description: \"List of completed actions\",\r\n        content: {\r\n          \"application/json\": {\r\n            schema: z.array(OnboardingActionSchema),\r\n          },\r\n        },\r\n      },\r\n      401: {\r\n        description: \"Unauthorized\",\r\n      },\r\n    },\r\n  }),\r\n  async (c: Context) => {\r\n    const user = c.get(\"user\")!;\r\n    const supabase = createServerClient<Database>(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          get: (key) => {\r\n            return getCookie(c, key);\r\n          },\r\n          set: (key, value, options) => {\r\n            setCookie(c, key, value, options);\r\n          },\r\n          remove: (key, options) => {\r\n            deleteCookie(c, key, options);\r\n          },\r\n        },\r\n      }\r\n    );\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"onboarding_actions\")\r\n      .select(\"action_key, is_completed\")\r\n      .eq(\"user_id\", user.id)\r\n      .eq(\"is_completed\", true);\r\n\r\n    if (error) {\r\n      return c.json({ error: error.message }, 500);\r\n    }\r\n\r\n    return c.json(\r\n      data.map((action) => ({\r\n        actionKey: action.action_key,\r\n        isCompleted: action.is_completed,\r\n      }))\r\n    );\r\n  }\r\n);\r\n\r\n// Reset /api/onboarding/reset - Reset onboarding state\r\nonboarding.openapi(\r\n  createRoute({\r\n    method: \"post\",\r\n    path: \"/reset\",\r\n    tags: [\"Onboarding\"],\r\n    summary: \"Reset onboarding\",\r\n    description: \"Resets the onboarding process for the user\",\r\n    responses: {\r\n      200: {\r\n        description: \"Onboarding reset\",\r\n        content: {\r\n          \"application/json\": {\r\n            schema: z.object({\r\n              success: z.boolean(),\r\n            }),\r\n          },\r\n        },\r\n      },\r\n      401: {\r\n        description: \"Unauthorized\",\r\n      },\r\n    },\r\n  }),\r\n  async (c: Context) => {\r\n    const user = c.get(\"user\")!;\r\n    const supabase = createServerClient<Database>(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          get: (key) => {\r\n            return getCookie(c, key);\r\n          },\r\n          set: (key, value, options) => {\r\n            setCookie(c, key, value, options);\r\n          },\r\n          remove: (key, options) => {\r\n            deleteCookie(c, key, options);\r\n          },\r\n        },\r\n      }\r\n    );\r\n\r\n    // Reset onboarding state\r\n    const { error: stateError } = await supabase\r\n      .from(\"user_onboarding\")\r\n      .upsert({\r\n        user_id: user.id,\r\n        current_step: \"welcome\",\r\n        progress: 0,\r\n        is_completed: false,\r\n        updated_at: new Date().toISOString(),\r\n      });\r\n\r\n    if (stateError) {\r\n      return c.json({ success: false, error: stateError.message }, 500);\r\n    }\r\n\r\n    // Reset all actions\r\n    const { error: actionsError } = await supabase\r\n      .from(\"onboarding_actions\")\r\n      .delete()\r\n      .eq(\"user_id\", user.id);\r\n\r\n    if (actionsError) {\r\n      return c.json({ success: false, error: actionsError.message }, 500);\r\n    }\r\n\r\n    return c.json({ success: true });\r\n  }\r\n);\r\n\r\nexport const GET = onboarding.fetch;\r\nexport const PATCH = onboarding.fetch;\r\nexport const POST = onboarding.fetch;\r\n","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/onboarding',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\onboarding\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/onboarding/route\",\n        pathname: \"/api/onboarding\",\n        filename: \"route\",\n        bundlePath: \"app/api/onboarding/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\onboarding\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","module.exports = require(\"node:inspector\");","/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\nclass ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n","module.exports = require(\"net\");","module.exports = require(\"events\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 96708;\nmodule.exports = webpackEmptyContext;","import(/* webpackMode: \"eager\", webpackExports: [\"AuthProvider\",\"useAuth\",\"useUser\",\"useIsAuthenticated\",\"useHasRole\",\"useHasPermission\",\"useSession\"] */ \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\lib\\\\auth\\\\hooks.tsx\");\n"],"names":["createExtendedUser","user","role","user_metadata","settings","theme","settings_theme","language","settings_language","emailNotifications","settings_emailNotifications","documentReminders","settings_documentReminders","applicationUpdates","settings_applicationUpdates","twoFactorAuth","settings_twoFactorAuth","fullName","full_name","email","split","avatarUrl","avatar_url","isAdmin","hasTwoFactorAuth","updateSettings","updatedSettings","newSettings","toObject","id","AuthContext","createContext","undefined","AuthProvider","children","setUser","useState","session","setSession","isLoading","setIsLoading","supabase","createClient","refreshSession","useCallback","data","error","sessionError","auth","getSession","userError","getUser","console","signIn","provider","options","password","signInWithPassword","signInWithOAuth","redirectTo","signOut","signUp","emailRedirectTo","window","location","origin","resetPassword","resetPasswordForEmail","updatePassword","updateUser","Provider","value","isAuthenticated","useAuth","context","useContext","useUser","useIsAuthenticated","useHasRole","useHasPermission","permission","hasPermission","useSession","notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","digest","forbidden","unstable_rethrow","isNextRouterError","isBailoutToCSRError","isDynamicServerError","isDynamicPostpone","isPostpone","isHangingPromiseRejectionError","Error","browserClientInstance","fetch","ponyfetch","fetchPonyfill","supabaseUrl","process","supabaseAnonKey","serviceRoleKey","env","SUPABASE_SERVICE_ROLE_KEY","anonymousHeaders","apikey","checkPublicEnvVars","g","globalThis","__USING_PONYFETCH__","getSupabaseBrowserClient","_createBrowserClient","global","headers","useSupabaseBrowser","useMemo","getSupabaseClient","require","unauthorized","AuthError","constructor","message","code","originalError","status","name","toJSON","toResponse","Response","JSON","stringify","UnauthorizedError","ForbiddenError","SessionError","InvalidCredentialsError","UserOperationError","defaultRBACOptions","roles","superAdminRole","enableCache","RBACManager","permissionCache","Map","config","extractRoles","defineRole","clear","defineRoles","roleName","visited","Set","has","add","permissions","inherits","length","parentRole","getRolePermissions","forEach","getUserPermissions","userRoles","includes","cacheKey","sort","join","cachedPermissions","get","allPermissions","rolePermissions","set","hasRole","parts","i","wildcardPermission","slice","hasAnyPermission","some","hasAllPermissions","every","enforcePermission","enforceAnyPermission","enforceAllPermissions","createPermission","resource","action","rbacManager","getRBACManager","getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","REDIRECT_ERROR_CODE","getStore","isAction","RedirectType","push","replace","PermanentRedirect","isRedirectError","Number","at","OnboardingSchema","z","currentStep","progress","min","max","isCompleted","OnboardingActionSchema","actionKey","authMiddleware","c","next","createMiddleware","getAuthUser","json","onboarding","OpenAPIHono","use","openapi","createRoute","method","path","tags","summary","description","responses","content","schema","createServerClient","cookies","key","getCookie","setCookie","remove","deleteCookie","from","select","eq","single","newOnboardingState","insert","user_id","current_step","is_completed","request","body","partial","req","input","parse","update","updated_at","Date","toISOString","upsert","success","rpc","action_key","map","stateError","actionsError","delete","GET","PATCH","POST","serverComponentModule.GET","serverComponentModule.POST","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS","ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","URLSearchParams","append"],"sourceRoot":""}