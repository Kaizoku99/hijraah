{"version":3,"file":"3626.js","mappings":"6bACA,qCAA6C,CAC7C,QACA,CAAC,EACD,yCAAiD,CACjD,cACA,eACA,QACA,CACA,CAAC,CACD,CADE,MACF,EACA,kBACA,+BACA,qBACA,UAEA,CACA,CACA,oBACA,2BACA,CACA,gBACA,uBACA,CACA,2BACA,kCACA,CACA,+BC1BA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,kBAA0B,QAC1B,MAAqB,EAAQ,KAAgB,EAgE7C,UAhE4B,UAgEF,CA/D1B,WACA,gBACA,mBACA,gBACA,kBACA,eACA,CAuDA,OAtDA,yBACA,oBACA,WAEA,qBACA,sBACA,2BACA,YAGA,0BACA,oBACA,mCACA,oCACA,oBAGA,oBAIA,WANA,IAOA,EACA,gCACA,sFACA,EACA,mCACA,sDACA,EACA,8BAEA,QADA,KACA,IAAwB,WAAoB,KAC5C,WACA,WACA,uBAEA,kBAEA,aAEA,EADA,oBACA,yBAGA,uCAEA,YAA4B,WAAwB,KACpD,WACA,6EACA,EACA,CACA,QACA,EAEA,+DACA,CACA,CAAC,kEChED,MAAe,WAAoB,iDCDnC,gDACA,mDAA6E,IAAO,KACpF,YACA,yCACA,WAGA,iDACA,EACA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,YAAoB,QACpB,MAAqB,EAAQ,KAAqB,EAClD,EAAqB,EAAQ,KAAqB,CADtB,CAE5B,EAA6B,EAAQ,KAA6B,CADtC,CAyJ5B,UAxJoC,IAwJhB,CAvJpB,WACA,cACA,uBACA,oBACA,2BACA,MACA,CACA,aACA,sBAEA,0BACA,yBAEA,iBACA,CAuIA,OAtIA,0BAEA,iBADA,YACA,gBACA,EACA,0CACA,eACA,wCACA,CAAS,CACT,cACA,eACA,CAAK,EACL,4CACA,qBACA,6BAEA,sCACA,CAAS,CACT,cACA,eACA,CAAK,EACL,4CACA,sBACA,0BACA,KAEA,kCACA,CAAS,CACT,cACA,eACA,CAAK,EACL,mDACA,eACA,8BAEA,iDACS,CACT,cACA,eACA,CAAK,EACL,8BAEA,aADA,gBACA,sBACA,EACA,2CAEA,MADA,gBACA,kBACA,2BAEA,OADA,OACA,QACA,EACA,gCACA,uCAA0D,oBAA8B,WACxF,EACA,0CACA,2BACA,GACA,gCAA0D,uBAAiC,WAC3F,EACA,gCACA,aAAkC,GAAY,iBAC9C,2BACA,uBACA,KAEA,MAEA,8BAGA,GAFA,aAAkC,GAAY,iBAE9C,2BAEA,kEADA,UAGA,SACA,+BACA,UAEA,YAAwB,yBAA4B,IAGpD,UADA,GADA,mBACA,WACA,aACA,SAIA,wBAA+D,mBAA0B,EACzF,kBACA,yBAA4D,gBAAuB,EAGnF,QADA,KACA,IAAwB,WAA6B,KACrD,WACA,GACA,eAEA,gBACA,gBAEA,SACA,CACA,QACA,EACA,8BAEA,IADA,QAA4C,eAAmB,EAC/D,oBACA,aACA,WACA,2BACA,kBAEA,iCACA,CAAS,CACT,EACA,gCACA,YAA4C,eAAmB,EAC/D,oBACA,aACA,WACA,4BACA,oBAEA,oCACA,oBACA,uDAEA,CACA,wCACA,OACA,eACA,WAGA,CAAS,CACT,EACA,CACA,CAAC,qCC0tBD,qBA93BA,YACA,mBAEA,WADA,cAKA,cAHA,YACA,aACA,EAEA,kBACA,SACA,eACA,OAEA,QACA,EACA,yBACA,0DACA,KACA,eACA,UAEA,wBACA,EACA,kBACA,gCACA,YACS,EAET,4CACA,kBACA,IACA,SACA,eACA,2CACA,UAGA,QACA,EACA,eACA,eACA,QACA,QAGA,EACA,gDACA,uBACA,sDAMA,aALA,oBACA,SACA,8BAAyD,EAAI,MAC7D,OACA,EAEA,+BACA,mBACA,aAEA,CAEA,CAAC,YAAoB,EASpB,YAAgC,EANjC,mBACA,EACA,KACA,IACA,GAGA,sBACA,SACA,MACA,SACA,UACA,QACA,UACA,OACA,SACA,SACA,WACA,YACA,OACA,QACA,SACA,UACA,UACA,OACA,QACA,MACA,MACA,EACA,MAEA,OADA,UAEA,gBACA,kBACA,cACA,oBACA,SACA,mCACA,UACA,qBACA,WACA,iBACA,cACA,oBACA,SACA,oBACA,SACA,oBACA,eAEA,YACA,cAEA,WACA,2BACA,SACA,2BACA,iBAEA,6CACA,aAEA,6CACA,aAEA,+CACA,cAEA,wBAEA,iBAEA,EAEA,kBACA,eACA,kBACA,SACA,gBACA,8BACA,qBACA,oBACA,oBACA,sBACA,eACA,iBACA,YACA,UACA,6BACA,kBACA,aACA,CAKA,uBACA,eACA,QACA,eACA,kBACA,gCAEA,wBACA,mCAEA,2BACA,sBAEA,8BAGA,iBAEA,qBACA,aACA,CACA,aACA,mBAEA,UACA,SACA,YACA,kBAEA,GAA8B,YAC9B,MACA,sBACA,4BACA,0BAEA,kCACA,0BAEA,gCACA,yBAEA,qBACA,yBAEA,CACA,QACA,IACA,uBACA,gBACA,qBAYA,YAAqD,YACrD,yBAXA,YAAqD,YAarD,OACA,GACA,CACA,CAEA,EAEA,OADA,QACA,CACA,CACA,iBACA,qBACA,+BAA+C,EAAM,EAErD,CACA,WACA,oBAEA,cACA,6DACA,CACA,cACA,8BAEA,wBACA,SACA,KACA,yBACA,iBACA,8BACA,yBAGA,aAGA,kBAAiB,gBACjB,CACA,iBACA,qBACA,CACA,CACA,YACA,SAIA,cACA,MACA,eACA,oBAEA,EADA,yBACA,WAGA,YAAsC,WAAe,aAAa,WAAe,EAEjF,KACA,wBACA,qCAAyD,oDAA2D,EACpH,KACA,0BACA,oCAAwD,2BAAkC,EAC1F,KACA,sBACA,kBACA,KACA,oCACA,2CAA+D,yBAA+B,EAC9F,KACA,2BACA,kCAAsD,yBAA+B,cAAc,WAAe,GAClH,KACA,0BACA,+BACA,KACA,4BACA,iCACA,KACA,qBACA,iBACA,KACA,uBACA,8BACA,2BACA,kCAA8D,sBAA0B,GACxF,wCACA,MAAqC,GAAS,oDAAoD,uBAA0B,GAG5H,4BACA,qCAAiE,wBAA4B,GAE7F,0BACA,mCAA+D,sBAA0B,GAGzF,6BAIA,EADA,uBACA,WAAqC,aAAiB,EAGtD,UAEA,KACA,kBAEA,EADA,iBACA,sBAAgD,sDAAsE,EAAE,WAAe,YACvI,kBACA,uBAAiD,iDAAiE,EAAE,WAAe,cACnI,kBACA,kBAA4C,QAC5C,oBACA,YACA,4BACA,gBAA0C,EAAE,UAAc,EAC1D,gBACA,gBAA0C,QAC1C,oBACA,YACA,4BACA,gBAA0C,EAAE,4BAAgC,EAE5E,gBACA,KACA,gBAEA,EADA,iBACA,sBAAgD,qDAAqE,EAAE,WAAe,YACtI,kBACA,uBAAiD,iDAAiE,EAAE,WAAe,cACnI,kBACA,kBAA4C,QAC5C,UACA,YACA,wBACA,aAAuC,EAAE,UAAc,EACvD,kBACA,kBAA4C,QAC5C,UACA,YACA,wBACA,aAAuC,EAAE,UAAc,EACvD,gBACA,gBAA0C,QAC1C,UACA,YACA,2BACA,gBAA0C,EAAE,4BAAgC,EAE5E,gBACA,KACA,eACA,kBACA,KACA,mCACA,6CACA,KACA,wBACA,kCAAsD,aAAiB,EACvE,KACA,mBACA,0BACA,KACA,SACA,iBACA,iBACA,CACA,eAAa,EACb,EAEA,IAIA,aACA,QACA,CAEA,UACA,SAAY,kCAAmC,EAC/C,uBACA,GACA,KACA,MACA,EACA,sBACA,OACA,KACA,OACA,mBAGA,SAKA,aAJA,EACA,eACA,QACA,UAEA,YAAwC,iBAAkC,UAE1E,OACA,KACA,OACA,SACA,CACA,EAEA,gBACA,UACA,KACA,YACA,YACA,YACA,WACA,4BACA,iBACA,EACA,eACA,eACA,CAAK,EACL,uBACA,CACA,QACA,cACA,kBACA,CACA,QACA,sBACA,oBACA,CACA,QACA,wBACA,sBACA,CACA,uBACA,SACA,gBACA,wBACA,QACA,qBACA,UACA,eACA,CACA,OAAiB,uBACjB,CACA,mCACA,SACA,gBACA,kBACA,gBACA,QACA,MACA,OACA,CAAa,CACb,CACA,6BACA,CACA,4BACA,SACA,gBACA,QAAoB,WAAa,EACjC,yBAEA,qBADA,QAGA,qBACA,UACA,oBACA,UACA,uBACA,iCACA,oBAEA,CACA,OAAiB,uBACjB,CACA,CACA,qBACA,gBACA,CAAC,EACD,OAA4B,wBAAwB,CACpD,OAAyB,wBAAwB,CACjD,0BACA,wBACA,wBACA,uDAiBA,oBACA,gFACA,wIACA,oDACA,CAEA,sBACA,6DACA,gFACA,uIACA,kDACA,CAEA,oDAMA,YACA,0CAAsE,GAAU,MAChF,4DACC,YAA8B,CAG/B,SACA,qBACA,oBACA,cACA,YACA,aACA,WACA,CACA,WASA,OARA,0BACA,2BACA,kDAGA,gDAGA,iBAEA,CACA,cACA,QACA,OAAiB,yBAGjB,2BACA,yDAEA,OACA,WACA,YACA,eACA,mBACA,6BAEA,OADA,cACA,YAEA,CAEA,EACA,cACA,MACA,SACA,aAAY,uDAA4D,EACxE,aACA,gHAEA,EACA,CAAiB,0BAcjB,CAAa,SAbb,QACA,QACA,YAAgB,GAAU,QAC1B,8BACA,CAAqB,kCAErB,gBACA,CAAqB,gDAErB,wBACA,CAAqB,wBACrB,CAAiB,+CACjB,EACa,cACb,CACA,QACA,eAEA,6BACA,YACA,iCACA,yCACA,2CACA,mDACA,6BACA,mCACA,2CACA,6CACA,uCACA,uCACA,qCACA,iCACA,qCACA,2BACA,6BACA,yCACA,iCACA,qCACA,iCACA,uCACA,+BACA,uCACA,2CACA,0CACA,CACA,kBACA,6BAEA,YACA,gBACA,CACA,qBACA,WACA,uBACA,YACA,qBACA,kCACA,YACA,gBACS,CAET,uBACA,OACA,aACA,KACA,uBACA,YACA,qBACA,kCACA,YACA,gBACa,CAEb,CACA,cACA,qBACA,QACA,sDAEA,QACA,CACA,eAEA,uBADA,eAEA,CACA,WACA,0BACA,aACA,oBACA,OACA,CACA,eACA,MACA,OACA,QACA,UACA,0CACA,6CACa,CACb,iCACA,kCACA,YACA,OACA,eACA,EACA,wBAAyC,uBAAmC,EAC5E,aACA,CACA,sBACA,qCACA,aACA,oBACA,QAEA,0BACA,OACA,QACA,UACA,6CACA,QACA,CAAa,CACb,iCACA,kCACA,YACA,OACA,eACA,EACA,oBAA+C,uBAAmC,EAIlF,WAHA,YACA,EACA,oBAEA,CACA,YACA,SACA,+BACA,SAAyB,GAEzB,qBACA,KAGA,EAGA,gCACA,WACA,kBACA,cACA,QACa,QACb,kDACA,UACA,MACA,IACA,MAOA,KACA,IACA,GAKA,CAAS,CACT,CACA,gBACA,+BACA,SACA,gCACA,OACA,GACA,IAMA,CACA,eACA,eACA,YACA,uBACA,QAAsB,+BAAgC,CAC7C,CACT,CACA,eACA,0BACA,CACA,WACA,gCACA,CACA,WACA,gCACA,CACA,UACA,iCACA,CACA,QACA,+BACA,CACA,UACA,gCACA,CACA,MACA,oCACA,CACA,OACA,kCACA,CACA,aACA,eACA,gBACA,YACA,uBACA,QAAsB,6BAA8B,CAC3C,CACT,CACA,WAEA,eACA,gBACA,eACA,aAJA,6BAKA,uBACS,CACT,CACA,QACA,eACA,uBACA,UACA,gBACS,CACT,CACA,SAEA,eACA,gBACA,eACA,WAJA,6BAKA,qBACS,CACT,CACA,YAEA,WADA,iBACA,CACA,aACA,aACA,CAAS,CACT,CACA,QACA,wBACA,CACA,WACA,sBACA,CACA,aACA,sCAEA,aACA,oCAEA,CACA,gBAA4B,GAAG,IAC/B,gBACA,uBAAuC,GAAG,GAG1C,gBAAgC,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,GAAG,IACvG,eAAiC,GAAG,IACpC,6SAaA,gFAAiG,GAAG,IAOpG,+DAA+E,EAAE,uDACjF,eAA+B,IAAI,GAAG,EAAE,aAAa,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,EAAE,WAAW,IAAI,GAAG,IAAI,WAAW,IAAI,mCAAmC,EAAE,SAAS,IAAI,MAAM,EAAE,iCAAiC,EAAE,SAAS,IAAI,MAE3Y,mBAAqC,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,OAMhF,6FAAmH,EAAE,uGACrH,aAAiC,EAAgB,IACjD,cAEA,2CAOA,OANA,YACA,KAAmB,EAAM,OAAO,EAAE,aAAgB,EAElD,mBACA,MAAmB,EAAM,aAEzB,CACA,CAKA,cACA,SAAmB,EAAgB,GAAG,KAAsB,EAC5D,KAKA,OAJA,yBACA,UACA,iBAA4B,EAAE,MAAM,EAAE,IACtC,KAAe,EAAM,GAAG,YAAe,GACvC,WAA0B,EAAM,GAChC,CAUA,kBACA,cAVA,QAyBA,EAVA,GAJA,kBACA,wBAEA,mBACA,UACA,8BAMA,OALA,KACA,oBACA,kBACA,qBACA,CAAa,EACb,CACA,CACA,YAEA,8BACA,kBACA,wBAEA,EADA,4BACA,CACA,iBACA,gBACA,cACA,aACA,SACA,kBACqB,EACrB,gBAGA,kBACA,wBAEA,EADA,4BACA,CACA,eACA,gBACA,cACA,aACA,SACA,kBACqB,EACrB,gBAGA,sBACA,4BACA,wBACA,SACA,4BACA,EACA,KACA,eACA,gBACA,cACA,aACA,SACA,kBACyB,EAEzB,GACA,KACA,iBACA,gBACA,cACA,aACA,SACA,kBACyB,EAEzB,UAEA,MACA,oBACA,iBAEA,EADA,4BACA,CACA,mBACA,sBACA,kBACqB,EACrB,gBAGA,oBACA,GACA,UAtIA,OAA2B,sBAAsB,KAAK,gBAAgB,KAsItE,MAEA,iBAEA,EADA,4BACA,CACA,mBACA,sBACA,kBACqB,EACrB,gBAGA,mBACA,iBAEA,EADA,4BACA,CACA,kBACA,sBACA,kBACqB,EACrB,gBAGA,qBACA,iBAEA,EADA,4BACA,CACA,oBACA,sBACA,iBACA,CAAqB,EACrB,gBAGA,mBACA,iBAEA,EADA,4BACA,CACA,kBACA,sBACA,kBACqB,EACrB,gBAGA,oBACA,iBAEA,EADA,4BACA,CACA,mBACA,sBACA,kBACqB,EACrB,gBAGA,mBACA,iBAEA,EADA,4BACA,CACA,kBACA,sBACA,kBACqB,EACrB,gBAGA,kBACA,IACA,eACA,CACA,SAEA,EADA,4BACA,CACA,iBACA,sBACA,kBACqB,EACrB,SACA,KAEA,kBACA,oBACA,uBAGA,EADA,4BACA,CACA,mBACA,sBACA,kBACqB,EACrB,YAGA,gBACA,qBAEA,oBACA,sCAEA,EADA,4BACA,CACA,sBACA,YAAsC,qCAAiD,CACvF,kBACqB,EACrB,WAGA,uBACA,4BAEA,uBACA,4BAEA,sBACA,6BAEA,EADA,4BACA,CACA,sBACA,YAAsC,mBAAyB,CAC/D,kBACqB,EACrB,WAGA,oBACA,2BAEA,EADA,4BACA,CACA,sBACA,YAAsC,iBAAuB,CAC7D,kBACqB,EACrB,WAGA,oBACA,KACA,eAEA,EADA,4BACA,CACA,sBACA,sBACA,kBACqB,EACrB,WAGA,gBACA,EACA,eAEA,EADA,4BACA,CACA,sBACA,kBACA,kBACqB,EACrB,WAGA,gBA5QA,WAA0B,EA6Q1B,GA7QgD,IA8QhD,eAEA,EADA,4BACA,CACA,sBACA,kBACA,kBACqB,EACrB,WAGA,oBACA,iBAEA,EADA,4BACA,CACA,sBACA,sBACA,kBACqB,EACrB,WAGA,eAvRA,EAwRA,SAvRA,SADA,EAwRA,YAvRA,gBAGA,gCAsRA,EADA,4BACA,CACA,gBACA,sBACA,kBACqB,EACrB,YAGA,kBACA,iBAEA,EADA,4BACA,CACA,oBACA,sBACA,kBACqB,EACrB,WAIA,kBAGA,OAAiB,4BACjB,CACA,cACA,qCACA,aACA,sBACA,iBACA,CAAS,CACT,CACA,aACA,cACA,aACA,+BACS,CACT,CACA,SACA,uBAAgC,+BAA+C,CAC/E,CACA,OACA,uBAAgC,6BAA6C,CAC7E,CACA,SACA,uBAAgC,+BAA+C,CAC/E,CACA,QACA,uBAAgC,8BAA8C,CAC9E,CACA,UACA,uBAAgC,gCAAgD,CAChF,CACA,QACA,uBAAgC,8BAA8C,CAC9E,CACA,SACA,uBAAgC,+BAA+C,CAC/E,CACA,QACA,uBAAgC,8BAA8C,CAC9E,CACA,UACA,uBAAgC,gCAAgD,CAChF,CACA,MACA,uBAAgC,4BAA4C,CAC5E,CACA,YACA,cACA,mBACA,gBACA,gBACA,eACA,UACA,SACA,SACA,CAAa,EAEb,gBACA,gBACA,gFACA,4CACA,0CACA,yCACS,CACT,CACA,QACA,uBAAgC,sBAAuB,CACvD,CACA,cACA,mBACA,gBACA,YACA,eACA,SACA,CAAa,EAEb,gBACA,YACA,gFACA,yCACS,CACT,CACA,YACA,uBAAgC,kCAAkD,CAClF,CACA,WACA,uBACA,aACA,QACA,kBACS,CACT,CACA,cACA,uBACA,gBACA,QACA,mCACA,yCACS,CACT,CACA,gBACA,uBACA,kBACA,QACA,kBACS,CACT,CACA,cACA,uBACA,gBACA,QACA,kBACS,CACT,CACA,SACA,uBACA,WACA,QACA,kBACS,CACT,CACA,SACA,uBACA,WACA,QACA,kBACS,CACT,CACA,YACA,uBACA,cACA,QACA,kBACS,CACT,CAKA,YACA,iCACA,CACA,OACA,cACA,aACA,6BAA4C,YAAc,CAC1D,CAAS,CACT,CACA,cACA,cACA,aACA,6BAA4C,mBAAqB,EACxD,CACT,CACA,cACA,cACA,aACA,6BAA4C,mBAAqB,EACxD,CACT,CACA,iBACA,qDACA,CACA,aACA,iDACA,CACA,aACA,iDACA,CACA,iBACA,qDACA,CACA,cACA,kDACA,CACA,YACA,gDACA,CACA,cACA,kDACA,CACA,aACA,iDACA,CACA,eACA,mDACA,CACA,aACA,iDACA,CACA,cACA,kDACA,CACA,aACA,iDACA,CACA,WACA,+CACA,CACA,eACA,mDACA,CACA,gBACA,WACA,8BACA,gBACA,uBACA,YAGA,QACA,CACA,gBACA,WACA,8BACA,gBACA,uBACA,YAGA,QACA,CACA,CACA,aACA,MACA,cACA,UACA,sBACA,4CACA,QACK,CACL,CAUA,mBACA,cACA,oBACA,kBACA,kBACA,0BAEA,cAcA,EATA,GAJA,kBACA,wBAGA,IADA,eACA,UACA,8BAMA,OALA,KACA,oBACA,kBACA,qBACA,CAAa,EACb,CACA,CAEA,YACA,8BACA,eACA,uBAEA,EADA,4BACA,CACA,oBACA,mBACA,iBACA,kBACqB,EACrB,WAGA,eACA,aACA,eACA,mBAGA,EADA,4BACA,CACA,iBACA,gBACA,cACA,sBACA,SACA,kBACqB,EACrB,WAGA,eACA,aACA,eACA,mBAGA,EADA,4BACA,CACA,eACA,gBACA,cACA,sBACA,SACA,iBACA,CAAqB,EACrB,WAGA,sBACA,IA/EA,cACA,8CACA,0CACA,UAGA,gBAFA,8BACA,uCACA,cACA,EAwEA,kBAEA,EADA,4BACA,CACA,uBACA,mBACA,kBACqB,EACrB,WAGA,kBACA,0BAEA,EADA,4BACA,CACA,kBACA,kBACqB,EACrB,WAIA,kBAGA,OAAiB,4BACjB,CACA,SACA,+CACA,CACA,QACA,+CACA,CACA,SACA,+CACA,CACA,QACA,+CACA,CACA,kBACA,cACA,aACA,WACA,iBACA,CACA,OACA,QACA,YACA,sBACA,CAAiB,CAEjB,CAAS,CACT,CACA,aACA,cACA,aACA,+BACS,CACT,CACA,OACA,uBACA,WACA,sBACA,CAAS,CACT,CACA,YACA,uBACA,WACA,QACA,aACA,sBACA,CAAS,CACT,CACA,YACA,uBACA,WACA,QACA,aACA,sBACA,CAAS,CACT,CACA,eACA,uBACA,WACA,QACA,aACA,sBACA,CAAS,CACT,CACA,eACA,uBACA,WACA,QACA,aACA,sBACA,CAAS,CACT,CACA,gBACA,uBACA,kBACA,QACA,sBACA,CAAS,CACT,CACA,UACA,uBACA,cACA,sBACA,CAAS,CACT,CACA,QACA,uBACA,WACA,aACA,8BACA,sBACA,CAAS,aACT,WACA,aACA,8BACA,sBACA,CAAS,CACT,CACA,eACA,WACA,8BACA,gBACA,uBACA,YAGA,QACA,CACA,eACA,WACA,8BACA,gBACA,uBACA,YAGA,QACA,CACA,YACA,iDACA,6CACA,CACA,eACA,kBACA,8BACA,sBACA,gBACA,sBACA,aAEA,eACA,uBACA,YAEA,gBACA,uBACA,YAGA,6CACA,CACA,CACA,YACA,OACA,UACA,sBACA,qCACA,OACA,CAAK,CAEL,mBACA,cACA,oBACA,kBACA,kBAEA,cAcA,EATA,GAJA,kBACA,wBAGA,IADA,eACA,UACA,8BAMA,OALA,KACA,oBACA,kBACA,sBACa,EACb,CACA,CAEA,YACA,8BACA,eACA,aACA,eACA,mBAGA,EADA,4BACA,CACA,iBACA,cACA,gBACA,sBACA,kBACqB,EACrB,WAGA,eACA,aACA,eACA,mBAGA,EADA,4BACA,CACA,eACA,cACA,gBACA,sBACA,iBACA,CAAqB,EACrB,WAGA,sBACA,6BAEA,EADA,4BACA,CACA,uBACA,mBACA,kBACqB,EACrB,WAIA,kBAGA,OAAiB,4BACjB,CACA,SACA,+CACA,CACA,QACA,+CACA,CACA,SACA,+CACA,CACA,QACA,+CACA,CACA,kBACA,cACA,aACA,WACA,iBACA,CACA,OACA,QACA,YACA,sBACA,CAAiB,CAEjB,CAAS,CACT,CACA,aACA,cACA,aACA,+BACS,CACT,CACA,YACA,uBACA,WACA,gBACA,aACA,sBACA,CAAS,CACT,CACA,YACA,uBACA,WACA,gBACA,aACA,sBACA,CAAS,CACT,CACA,eACA,uBACA,WACA,gBACA,aACA,sBACA,CAAS,CACT,CACA,eACA,uBACA,WACA,gBACA,aACA,sBACA,CAAS,CACT,CACA,gBACA,uBACA,kBACA,QACA,sBACA,CAAS,CACT,CACA,eACA,WACA,8BACA,gBACA,uBACA,YAGA,QACA,CACA,eACA,WACA,8BACA,gBACA,uBACA,YAGA,QACA,CACA,CACA,aACA,MACA,cACA,UACA,sBACA,4CACA,QACK,CACL,CACA,mBACA,UAKA,GAJA,kBACA,kBAEA,mBACA,WACA,8BAMA,OALA,KACA,oBACA,mBACA,qBACA,CAAa,EACb,CACA,CACA,gBACA,CACA,CACA,YACA,OACA,uBACA,qCACA,QACK,CAEL,mBACA,cAsBA,EAjBA,GAJA,kBACA,0BAEA,mBACA,QACA,8BAMA,OALA,KACA,oBACA,gBACA,sBACa,EACb,CACA,CACA,2BAKA,OAHA,EADA,wBACA,CACA,mBACA,CAAa,EACb,EAEA,YAEA,8BACA,eACA,2BAEA,EADA,4BACA,CACA,iBACA,kBACA,aACA,SACA,gBACA,WACA,CAAqB,EACrB,WAGA,eACA,2BAEA,EADA,4BACA,CACA,eACA,kBACA,aACA,SACA,gBACA,WACA,CAAqB,EACrB,WAIA,kBAGA,OACA,eACA,gCACA,CACA,CACA,aACA,cACA,aACA,+BACS,CACT,CACA,SACA,uBACA,WACA,kBACA,sBACA,CAAS,CACT,CACA,SACA,uBACA,WACA,kBACA,sBACA,CAAS,CACT,CACA,cACA,WACA,8BACA,gBACA,uBACA,YAGA,+BACA,CACA,cACA,WACA,8BACA,gBACA,uBACA,YAGA,+BACA,CACA,CACA,YACA,OACA,UACA,qCACA,oBACA,QACK,CAEL,mBACA,UAEA,GADA,mBACA,UACA,8BAMA,OALA,KACA,oBACA,kBACA,qBACA,CAAa,EACb,CACA,CACA,gBACA,CACA,CACA,YACA,OACA,sBACA,QACK,CAEL,mBACA,UAEA,GADA,mBACA,aACA,8BAMA,OALA,KACA,oBACA,qBACA,sBACa,EACb,CACA,CACA,gBACA,CACA,CACA,YACA,OACA,yBACA,QACK,CAEL,mBACA,UAEA,GADA,mBACA,QACA,8BAMA,OALA,KACA,oBACA,gBACA,qBACA,CAAa,EACb,CACA,CACA,gBACA,CACA,CACA,YACA,OACA,oBACA,QACK,CAEL,mBACA,cACA,oBAEA,YACA,CACA,UACA,gBACA,CACA,CACA,YACA,OACA,mBACA,QACK,CAEL,mBACA,cACA,oBAEA,gBACA,CACA,UACA,gBACA,CACA,CACA,YACA,OACA,uBACA,QACK,CAEL,mBACA,UACA,8BAMA,OALA,KACA,oBACA,iBACA,sBACS,EACT,CACA,CACA,CACA,YACA,OACA,qBACA,QACK,CAEL,mBACA,UAEA,OADA,eACA,aACA,8BAMA,OALA,KACA,oBACA,gBACA,qBACA,CAAa,EACb,CACA,CACA,gBACA,CACA,CACA,YACA,OACA,oBACA,QACK,CAEL,mBACA,UACA,QAAgB,YAAc,4BAC9B,YACA,0BAMA,OALA,KACA,oBACA,iBACA,sBACa,EACb,EAEA,yBACA,wCACA,oCACA,SACA,KACA,6BACA,qCACA,qCACA,aACA,aACA,SACA,8BACiB,EACjB,UAEA,CA2BA,GA1BA,oBACA,kCACA,KACA,iBACA,0BACA,aACA,aACA,SACA,4BACiB,EACjB,WAGA,oBACA,kCACA,KACA,eACA,0BACA,aACA,aACA,SACA,4BACiB,EACjB,WAGA,eACA,0CACA,0CACa,QACb,mBAGA,6BACA,wCAEA,wBACA,CACA,cACA,sBAEA,SACA,cACA,aACA,WAAyB,+BAAwD,CACxE,CACT,CACA,SACA,cACA,aACA,WAAyB,+BAAwD,CACxE,CACT,CACA,YACA,cACA,aACA,aAA2B,+BAAkD,CACpE,CACT,CACA,YACA,oBACA,CACA,CACA,gBACA,OACA,OACA,eACA,eACA,iBACA,qBACA,QACK,CAiCL,oBACA,cACA,oBACA,kBAKA,gCAqCA,yBAEA,aACA,uBACA,oBACA,wBACA,mBACA,qBAAiC,eAAa,CAE9C,UAEA,OADA,eACA,UACA,8BAMA,OALA,KACA,oBACA,kBACA,sBACa,EACb,CACA,CACA,WAAgB,SAAc,4BAC9B,OAAgB,UAAyB,kBACzC,KACA,sCACA,iCACA,oBACA,eACA,UAIA,SACA,gBACA,WACA,YACA,QACA,KAAuB,uBAA6B,CACpD,oCACA,sBACa,CACb,CACA,oCACA,4BACA,qBACA,eACA,QACA,KAA+B,uBAA6B,CAC5D,OAAiC,+BAAuC,CACnD,OAGrB,gBACA,aACA,KACA,yBACA,MACA,CAAqB,EACrB,gBAGA,qBAEA,mEAEA,KACA,CAEA,yBACA,gBACA,gBACA,QACA,KAA2B,uBAA6B,CACxD,oCAEA,sBACiB,CACjB,CACA,QACA,eACA,kBACA,eACA,SACA,gBACA,kBACA,gBACA,QACA,MACA,QACA,sBACqB,CACrB,CACA,QACA,CAAa,EACb,QACA,wBAIA,sBAEA,CACA,YACA,wBACA,CACA,UAEA,OADA,YACA,QACA,aACA,qBACA,cACA,CACA,iBACA,YACA,qGACA,6BACA,CACA,4CACA,EACA,CACA,SACA,CACA,CAAqB,EAErB,EAAoB,CACX,CACT,CACA,QACA,eACA,aACA,mBACA,CAAS,CACT,CACA,cACA,eACA,aACA,yBACA,CAAS,CACT,CAkBA,UACA,eACA,aACA,YACA,qBACA,KACA,CAAa,CACJ,CACT,CAMA,SAUA,OATA,QACA,+BACA,yBACA,YACA,qBACA,kBACA,CAAa,CACb,sBACS,CAET,CAoCA,YACA,qBAA8B,MAAe,CAC7C,CAsBA,YACA,eACA,aACA,UACA,CAAS,CACT,CACA,QACA,SAMA,OALA,6BACA,qBACA,oBAEA,CAAS,EACT,QACA,aACA,WACA,CAAS,CACT,CACA,QACA,SAMA,OALA,sCACA,MACA,oBAEA,CAAS,EACT,QACA,aACA,WACA,CAAS,CACT,CAIA,cACA,OA9VA,cACA,oBACA,SACA,sBACA,gBACA,qBACA,CACA,eACA,UACA,WACA,CAAS,CACT,CACA,kBACA,cACA,UACA,iBACA,CAAS,EAET,mBACA,gCAEA,mBACA,gCAEA,mBACA,4CAGA,QAEA,EAgUA,KACA,CACA,WACA,SAUA,OATA,sCACA,oBACA,SACA,OAGA,iBAEA,CAAS,EACT,QACA,aACA,WACA,CAAS,CACT,CACA,YACA,SAcA,OAbA,sCACA,YACA,uBAEA,CAEA,MADA,cAEA,sBACA,mBAEA,MACA,CACA,CAAS,EACT,QACA,aACA,WACA,CAAS,CACT,CACA,QACA,oCACA,CACA,CACA,iBACA,QACA,YACA,oBACA,oBACA,sBACA,QACK,EAEL,uBACA,QACA,YACA,qBACA,oBACA,sBACA,QACK,EAEL,qBACA,QACA,QACA,oBACA,oBACA,sBACA,QACK,CAEL,oBACA,UACA,QAAgB,GAAM,4BACtB,oBAuBA,kBACA,mCACA,OACA,KACA,QACA,YACA,UACqB,CACrB,WACA,EACA,OACA,4BACA,YACA,YACA,QACA,CAAqB,EACrB,KACA,CACA,CAAa,QAxCb,YAEA,eACA,6BACA,gBAGA,eACA,6BAGA,OADA,6CACA,SAIA,2CAKA,OAJA,KACA,qBACA,aACA,CAAa,EACb,CACA,EAqBA,EAEA,IADA,EACA,KACA,gBACA,OACA,KACA,QACA,YACA,UACqB,CACrB,WACA,EACA,gBACA,YACA,YACA,QACA,CAAiB,EACjB,sBACA,QAEA,wBACA,IAA8B,iBAE9B,wBACA,uBAEA,CACA,KAEA,OADA,6CACA,SAEA,yBAKA,OAJA,KACA,qBACA,aACA,CAAa,EACb,CACA,CACA,CACA,cACA,yBAEA,CACA,iBACA,QACA,UACA,qBACA,OACA,CAAK,EASL,WACA,mBACA,oBAEA,mBACA,yBAEA,mBACA,gBAEA,mBACA,iBAEA,mBAEA,oCAEA,mBACA,iCAEA,kBACA,oBAEA,kBACA,kBAEA,mBACA,sCAEA,mBACA,oCAEA,mBACA,2BAEA,mBACA,2BAEA,mBACA,iCAGA,SAGA,oBACA,UACA,QAAgB,GAAM,4BACtB,2BAMA,OALA,KACA,oBACA,kBACA,sBACa,EACb,EAEA,yBACA,YACA,gCACA,EAQA,eACA,eACA,YACA,YACA,QACA,CAAa,EAGb,cACA,YACA,YACA,QACA,CAAa,GAnBb,KACA,mCACA,2CACA,SACa,EACb,EAgBA,CACA,oBACA,+BAEA,cACA,yBAEA,iBACA,4BAUA,qBAEA,cAEA,gBACA,qBACA,aACA,+CAAmE,EAAc,oDAEjF,gBACA,YACA,sCAA8D,WAAuB,sBAAsB,UAAc,GAEzH,UACA,CACA,CACA,eACA,kCACA,gBACA,UACA,aACA,QACS,CACT,CACA,CA+CA,mBACA,UACA,WAAgB,SAAc,4BAC9B,UACA,cACA,SAEA,MArDA,gBACA,WACA,OACA,SACA,OAAiB,iBAEjB,+BACA,uBACA,KACA,cACA,6BACA,GAAyB,WACzB,gBACA,mBACA,YACA,OAAyB,SAEzB,aAEA,OAAiB,gBACjB,CACA,6BACA,uBACA,OAAqB,UAErB,SACA,YAA4B,WAAkB,KAC9C,IAEA,IAFA,KACA,MAEA,YACA,OAAyB,UAEzB,cACA,CACA,OAAiB,gBACjB,CACA,eACA,YACA,OACA,OAAiB,iBAGjB,OAAiB,SAEjB,EAQA,wBACA,SAMA,cACA,UAEA,CAAqB,+BARrB,KACA,kCACiB,EACjB,EAMA,SACA,eACA,aACA,4BACA,YACA,YACA,QACA,CAAiB,EACjB,6BACA,YACA,YACA,QACA,CAAiB,EACjB,wBAGA,6BACA,YACA,YACA,QACA,CAAa,8BACb,YACA,YACA,QACA,CAAa,EAEb,CACA,CACA,mBACA,QACA,OACA,QACA,4BACA,QACK,CAEL,oBACA,UACA,WAAgB,SAAc,4BAC9B,0BAMA,OALA,KACA,oBACA,iBACA,sBACa,EACb,EAEA,wCAQA,OAPA,KACA,iBACA,+BACA,aACA,SACA,YACA,CAAa,EACb,CAGA,EADA,gBACA,uCACA,KACA,eACA,+BACA,aACA,SACA,YACA,CAAa,EACb,WAEA,kBACA,YACA,gDACA,EAEA,8BADA,IAEA,CAAS,EACT,gBAAiC,MACjC,eACA,uBACA,mBAIA,iBAEA,CACA,YACA,uBAEA,QACA,eACA,aACA,MACA,CAAS,CACT,CACA,CACA,kBACA,qBACA,qEAEA,eACA,QACA,qBACA,UACA,OACA,CAAK,CACL,CACA,oBACA,gBACA,yBAEA,kBACA,2BAEA,UACA,WAAgB,SAAc,4BAC9B,2BAMA,OALA,KACA,oBACA,kBACA,sBACa,EACb,EAEA,SACA,oBACA,sBACA,oBACA,QACA,kCACA,4CACA,sBACa,SAEb,eACA,wBAGA,sBAEA,CACA,cACA,0BACA,CACA,gCAEA,GADA,eACA,CACA,UACA,YACA,sBACA,QACa,CAEb,CACA,mBACA,YACA,sBACA,OACA,CAAS,CACT,CACA,CACA,mBACA,gBACA,yBAEA,kBACA,2BAEA,UACA,WAAgB,SAAc,4BAC9B,wBAMA,OALA,KACA,oBACA,eACA,sBACa,EACb,EAEA,wBACA,sBACA,uCACA,EACA,0CACA,6CACA,IAEA,mBACA,cACA,wCACA,gBACA,kBACA,gBACA,8CACA,QAEA,2CACA,UAEA,sBACA,CACA,OAAyB,uBACzB,CAAa,CACb,CACA,CACA,cACA,gBACA,YACA,UACA,8CACA,QAEA,2CACA,UAEA,sBACA,CACA,OAAqB,uBACrB,CACA,CACA,CACA,mBACA,QACA,YACA,UACA,mBACA,QACK,CAEL,oBACA,UACA,WAAgB,SAAc,4BAC9B,wBAMA,OALA,KACA,oBACA,eACA,sBACa,EACb,EAEA,uBACA,WACA,8BACA,KACA,iBACA,wBACA,WACA,aACA,SACA,0BACiB,EACjB,WAGA,kBACA,8BACA,KACA,eACA,wBACA,WACA,aACA,SACA,yBACA,CAAiB,EACjB,WAGA,0BACA,cACA,cACA,gBACA,wBACA,QACA,qBACA,UACA,cACA,CACA,OAAqB,uBACrB,CACA,4EACA,eACA,6BAGA,IAEA,CACA,SACA,eACA,aACA,SAAuB,+BACvB,CAAS,CACT,CACA,SACA,eACA,aACA,SAAuB,+BACvB,CAAS,CACT,CACA,UACA,6BACA,CACA,YACA,oBACA,CACA,CACA,iBACA,QACA,YACA,aACA,aACA,mBACA,OACA,CAAK,CAEL,oBACA,cACA,oBACA,6BAEA,UACA,QAAgB,GAAM,4BACtB,6BAMA,OALA,KACA,oBACA,oBACA,sBACa,EACb,EAEA,gBACA,UACA,OACA,YACA,WACA,4BACA,iBACA,IACA,EACA,gBACA,WACA,yBACA,gBACA,CAAiB,CACJ,CACb,CACA,gBACA,UACA,OACA,YACA,WACA,4BACA,iBACA,IACA,EACA,gBACA,WACA,2BACA,iBACA,CAAiB,CACJ,CACb,CACA,OAAyB,sCACzB,SACA,oCAIA,WACA,8BACA,gBACA,oBACA,gBACA,UAEA,MADA,mBACA,CACA,CAAiB,EACjB,gCAOA,OANA,+BACA,gBACA,UAEA,MADA,mBACA,CACA,CAAiB,CAEjB,CAAa,CACb,CACA,CAIA,WACA,wBACA,iCACA,cACA,4BAEA,mCACA,gCACA,cACA,4BAEA,aACA,CAAa,CACb,CACA,CACA,aACA,sBAEA,aACA,wBACA,CACA,WACA,eACA,aACA,kCACA,CAAS,CACT,CACA,WACA,eACA,aACA,SACA,CAAS,CACT,CACA,aAEA,OADA,aAEA,CACA,mBAEA,OADA,aAEA,CACA,qBACA,eACA,QAEA,+BACA,sBACA,wBACA,QACS,CACT,CACA,CACA,mBACA,aACA,yBACA,CACA,UACA,QAAgB,GAAM,4BAEtB,OADA,mBACA,QAAmC,iCAA6C,CAChF,CACA,CACA,iBACA,QACA,SACA,oBACA,OACA,CAAK,CAEL,oBACA,UACA,6BACA,8BAMA,OALA,KACA,gBACA,uBACA,wBACA,CAAa,EACb,CACA,CACA,OAAiB,4BACjB,CACA,YACA,uBAEA,CAQA,iBACA,eACA,SACA,oBACA,QACK,CACL,CAbA,iBACA,QACA,QACA,uBACA,QACK,CASL,oBACA,cACA,oBACA,mBACA,CACA,UACA,4BACA,8BACA,mBAMA,OALA,KACA,0BACA,sBACA,oBACa,EACb,CACA,CAIA,GAHA,gBACA,yCAEA,6BACA,8BACA,mBAMA,OALA,KACA,gBACA,0BACA,SACA,CAAa,EACb,CACA,CACA,gBACA,CACA,cACA,wBAEA,WACA,SACA,8BACA,OAEA,QACA,CACA,aACA,SACA,8BACA,OAEA,QACA,CACA,WACA,SACA,8BACA,OAEA,QACA,CACA,uBACA,oBACA,aACA,KACS,CACT,CACA,uBACA,yDACA,aACA,KACS,CACT,CACA,CACA,eACA,YACA,oBACA,cACA,oBACA,mBACA,CACA,UACA,8CACA,0BACA,4BACA,yBACA,yBAMA,OALA,KACA,0BACA,sBACA,oBACa,EACb,CACA,CAIA,GAHA,gBACA,gEAEA,6BACA,yBAMA,OALA,KACA,gBACA,0BACA,SACA,CAAa,EACb,CACA,CACA,gBACA,CACA,WACA,wBAEA,CACA,eACA,iBACA,QACA,SACA,0BACA,QACK,CAEL,oBACA,SACA,sBAEA,UACA,QAAgB,GAAM,mCACtB,0BACA,qBACA,KACA,oBACA,mBACA,sBACa,EACb,GAKA,EAHA,0BACA,OACA,yBACA,QACA,6BACA,YACA,qCACa,GAEb,CACA,CACA,iBACA,QACA,OACA,uBACA,QACK,CAEL,oBACA,YACA,wBAEA,aACA,sDACA,8BACA,iBAEA,UACA,WAAgB,SAAc,4BAC9B,yBACA,GACA,aACA,OACA,QACA,UAGA,SAEA,CAAa,CACb,WACA,cAEA,EAEA,GADA,8BACA,uBACA,4BACA,kBACA,yCACA,uBACA,SACA,0CACA,OACA,YACA,QACA,CAAqB,QACrB,qBACA,EACA,oBAEA,kBADA,WAGA,CACA,CAAiB,CAEjB,EACA,uBACA,SACA,mCACA,OACA,YACA,QACA,CAAiB,QACjB,qBACA,EACA,oBAEA,kBADA,WAGA,CACA,CACA,CACA,0BACA,UACA,wBACA,kBACA,0BAEA,wBACA,yGAEA,QACA,EACA,uBAeA,wBACA,aAAmC,iCAA6C,EAChF,QACA,qBACA,GACA,oBACA,UACA,oBACA,EAAiC,iCAvBjC,EACA,mCACA,YACA,YACA,QACA,CAAiB,QACjB,qBACA,GACA,oBACA,UAEA,WACA,CAAyB,8BACzB,CAcA,CACA,wBACA,uBAeA,wBACA,aAAmC,iCAA6C,EAChF,QACA,KAEA,kDAAuG,uBAAqC,GAD5I,OAnBA,CACA,mCACA,YACA,YACA,QACA,CAAiB,EACjB,SACA,SACA,6BACA,wBACA,+GAEA,OAAyB,uBACzB,CAWA,iBACA,CACA,CACA,mBACA,QACA,SACA,uBACA,SACA,QACK,EAEL,iCACA,QACA,SACA,QAAkB,8BAA2C,CAC7D,uBACA,QACK,CAEL,oBACA,iBACA,mBACA,YACA,UAEA,6BACA,CACA,SACA,2BAEA,CACA,iBACA,QACA,YACA,wBACA,QACK,CAEL,oBACA,iBACA,mBACA,OACA,QAEA,6BACA,CACA,SACA,2BAEA,CACA,iBACA,QACA,YACA,wBACA,QACK,CAEL,oBACA,UACA,QAAgB,GAAM,4BACtB,SAIA,OAHA,4BACA,6BAEA,4BACA,OACA,YACA,QACA,CAAS,CACT,CACA,gBACA,2BAEA,CACA,iBACA,QACA,YACA,uBACA,0CACA,UACA,cACA,QACK,CAEL,oBACA,UACA,QAAgB,GAAM,4BAEtB,GACA,KACA,QACA,YACA,UACa,EAEb,8BACA,YACA,YACA,QACA,KACa,CACJ,SACT,KACA,UACA,EACA,eACA,yBACA,QACA,sBACA,YACA,6BACA,CAA6B,CAC7B,aACyB,CACzB,IAIA,CACA,eACA,yBACA,QACA,sBACA,YACA,6BACA,CAAyB,CACzB,aACqB,CACrB,CAEA,CACA,cACA,2BAEA,CACA,iBACA,QACA,YACA,qBACA,0DACA,QACK,CAEL,oBACA,UAEA,GADA,mBACA,OACA,8BAMA,OALA,KACA,oBACA,eACA,sBACa,EACb,CACA,CACA,OAAiB,4BACjB,CACA,CACA,aACA,QACA,mBACA,QACK,EAEL,0BACA,oBACA,UACA,QAAgB,GAAM,4BACtB,SACA,8BACA,OACA,YACA,QACA,CAAS,CACT,CACA,SACA,sBAEA,CACA,mBACA,UACA,WAAgB,SAAc,4BAC9B,kBAqBA,MApBA,WACA,sCACA,YACA,YACA,QACA,CAAiB,QACjB,qBACA,EACA,oBACA,UACA,YAGA,2BACA,aACA,YACA,QACA,CAAqB,CAErB,IAGA,EACA,+BACA,YACA,YACA,QACA,CAAa,QACb,qBACA,EACA,oBACA,UACA,CACA,eACA,gBAIA,0BACA,aACA,YACA,QACA,CAAiB,CAEjB,CACA,CACA,mBACA,eACA,KACA,MACA,wBACS,CACT,CACA,CACA,mBACA,UACA,oCACA,MACA,MACA,iCAEA,GAEA,YACA,gBACA,IACA,CACA,SACA,2BAEA,CAQA,kBAAkC,CAWlC,UACA,EACA,+BACA,QACA,UACA,2BACA,KACA,mBACA,CAA4B,WAC5B,EACA,qCACA,sBAAqD,WAAa,EAClE,YAA+B,2BAAsC,CACrE,CACA,CAAS,EACT,UACA,CAlCA,iBACA,QACA,YACA,wBACA,QACK,EA8BL,QACA,uBAGA,YACA,wBACA,wBACA,kBACA,wBACA,0BACA,oBACA,wBACA,8BACA,oBACA,kBACA,0BACA,sBACA,oBACA,sBACA,wBACA,sBACA,gDACA,oCACA,sBACA,wBACA,kBACA,kBACA,4BACA,oBACA,0BACA,oBACA,0BACA,gCACA,4BACA,4BACA,0BACA,sBACA,0BACA,0BACA,4BACA,2BACA,CAAC,YAAsD,EAMvD,gBACA,YACA,aACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,aACA,mBACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,2BACA,aAgBA,IA5hIA,GA+DA,GAmeA,GAMA,MAu5GA,GsD/jHA,qBAsGA,mDAkRA,kBtDoyGI,GAAC,eACL,eACA,kBACA,YAlpHA,YACA,GACA,EAipHA,cACA,YACA,WAlnHA,GAmnHA,oBACA,cACA,UACA,QACA,KACA,YACA,UACA,UACA,UACA,WAAkB,UAAc,CAChC,iBAAwB,UAAoB,CAC5C,gBACA,gBACA,UACA,gBACA,YACA,YACA,YACA,aACA,UACA,YACA,eACA,UACA,SACA,aACA,WACA,UACA,WACA,aACA,YACA,yBACA,mBACA,YACA,aACA,UACA,UACA,eACA,WACA,cACA,WACA,iBACA,cACA,cACA,kBACA,eACA,eACA,cACA,YACA,UACA,SACA,cACA,eACA,eACA,UACA,SACA,YACA,QACA,4BAAmC,UAA+B,CAClE,OA7EA,CACA,oBAAyC,eAAsB,EAC/D,oBAAyC,eAAsB,EAC/D,qBACA,KACA,SACA,CAAK,EACL,oBAAyC,eAAsB,EAC/D,kBAAqC,eAAsB,CAC3D,EAqEA,OACA,SACA,UACA,WACA,QACA,sBACA,UACA,QACA,YACA,WAjIA,CAEA,KACA,iCAAsC,OAAS,EAC9C,2BA8HD,gBACA,QACA,WACA,OACA,OACA,cACA,SACA,QACA,YACA,UACA,UACA,SApGA,oBAqGA,QAtGA,oBAuGA,YACA,QAzGA,oBA0GA,YACA,cACA,WACA,UACA,OACA,gBACA,UACA,UACA,eACA,SACA,aACA,SACA,WACA,QACA,MA3GA,EA4GA,eACA,cA1+HA,GACA,yBACA,6BAy+HA,UACA,CAAC,ECzoIM,gBCGA,qBACP,IAAY,WAAU,MAAQ,+BAAc,CAC5C,wCACA,wBACA,UANO,0BAOP,YANO,2BAOP,oBAA8B,IATvB,OASuB,CAAoB,EAClD,cACA,2CACA,OACA,CCZqD,GAAC,QACtD,IAAS,GAAC,eACV,kBAAuB,GAAC,QACxB,CAAC,EACkD,GAAC,QACpD,kBAAuB,GAAC,QACxB,CAAC,EACmD,GAAC,QACrD,MAAW,GACX,EADY,IACZ,EACA,MAAe,GAAC,SAChB,gBAAyB,GAAC,QAC1B,CAAK,EACL,UACA,CAAC,ECdD,OAAsB,GAAC,OAAQ,GAAC,SAAW,GAAC,SAAW,GAAC,UAAY,GAAC,SAC9D,GAA+B,GAAC,SAAY,GAAC,UAAuB,GAAC,UAAgC,GAAC,c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ACA,kCACA,CAAS,CACT,CACA,kBACA,2BACA,0CAEA,yBACA,kCACA,CAAS,CACT,CACA,mBAEA,WAEA,IADA,QACA,iBACA,wBACA,OAEA,CACA,gCACA,oCACA,mCACA,OAGA,CACA,CCxFO,IAAM,GAAmB,CAChC,cACA,MAFgC,CAEhC,EACA,mBACA,mBACA,YACA,EAIA,IACA,QACA,EAOO,SAAS,GAAQ,SACxB,CADwB,MACxB,mBACA,CACO,uBACP,kCACA,UACA,oCAEA,SACA,6BAEA,UACA,+BAEA,MAA6B,GAAC,QAC9B,KAAc,GAAC,SACf,WAAoB,GAAC,QACrB,KAAkB,GAAC,oBACnB,SAAsB,GAAC,mBACvB,CAAS,CACT,CAAK,EACL,aAGA,OAFA,sBAEA,OADA,iBACA,UACA,CACO,uBACP,kCACA,UACA,iCAEA,QACA,6BAEA,MAAkC,GAAC,QACnC,KAAc,GAAC,SACf,WAAoB,GAAC,QACrB,YAAyB,GAAC,gBAC1B,WAAwB,GAAC,gBACzB,MAAmB,GAAC,eACpB,CAAS,CACT,CAAK,EACL,aAGA,OAFA,sBAEA,OADA,iBACA,UACA,CACA,uBACA,sBACA,WAEA,qBACA,+BACA,qBAA2C,GAAQ,EAAE,WAAa,EAClE,yDACA,WACK,CACL,YACA,CAAa,GAA0B,mCACvC,eADuC,QACvC,CAEA,CAAK,CACL,CACA,2BACA,cACA,eAA2B,0BAAyC,WACpE,WA6SA,GACA,8BACA,sCACA,SAEA,sCAEA,OADI,IAAW,QAAQ,IAAO,aAC9B,CACA,KACA,sBACA,CACA,EAxTA,GACA,wBAOA,OANA,sBACA,2BAEA,gBACA,qCAEA,CACA,CAAK,CACL,CACA,+BACA,QAiHA,EAhHA,oBA0HA,YACA,IACA,OACA,KACA,gBACA,EAEA,OADA,kCACA,CACA,CACA,SACA,YACA,CACA,EAtIA,IACA,GA+GA,EA/GA,UAgHA,6BAEA,cACA,SACA,mBACA,gCACS,CACJ,GAtHL,UACA,eAwDA,OACA,aAEA,MAAsB,GADtB,CAAwB,GAAG,EAAmB,OACD,UAC7C,EACA,CAAqB,kBAGrB,CAAqB,SAErB,CAEA,sCAEA,cACA,WACA,eACA,OAAiB,UAEjB,mBAGA,eAFA,WAKA,mBACA,yDACA,OAAqB,UAGrB,yCACA,MAEA,MADA,eACA,yCACA,OACA,OAAyB,iBAEzB,CACA,UACA,QAEA,cACA,IACA,CAAa,SACb,EApGA,cACA,WAEA,OADA,8BACA,qBAEA,EACA,8BAAmE,GAAW,YAC9E,CAD8E,CAC9E,MACA,YACA,OAAsB,GAAQ,wBAC9B,CACA,CACA,kBACA,iBACA,aACA,OAAqB,wBAErB,MAAgC,SPhEzB,GOgEqC,CPhErC,EAA4C,MAlBnD,MAmBA,uBAAY,EA7DZ,EA6DY,kBA5DZ,GAA2B,CA4Df,kBA3DZ,OA2DY,mBAzDZ,IAyDY,cAAuK,EAMnL,eAzBA,EAoBA,SACA,WACA,QA/CA,kBACA,4BACA,qBACA,eACA,eACA,iBACA,QAIA,OAHA,eACA,UAEA,CACA,CAAS,KACT,QAEA,GDjCA,CCiCQ,GAAe,ODjCvB,KCiCuB,CDjCvB,CCiCuB,KFjChB,EEkCP,sBACA,gBACA,sBACA,SAA0B,WAAe,WAAW,EAAW,EAG/D,SAAkB,WAAe,MFvCjC,KADO,EEwCwC,QFvC/C,OACA,gBAEA,iBACA,sBACA,8BAEA,mBACA,gBAUA,oBAVA,KAEA,eACA,qBAEA,0BACA,YACA,CAAK,KEwBuD,GAE5D,iBACA,EAuBA,QACA,QAvBA,EAwBA,EAxBA,EAwBA,EAvBA,SACA,WACA,cAEA,EAEA,WACA,EAEA,IAeA,SACA,EOwD4C,QAC5C,WAAkB,GAAwB,CAC1C,gBACA,IAF0C,EAE1C,EACA,kBACA,UACA,SACA,CAAS,CACT,CACA,SACA,gBAA6B,GAC7B,KADqC,CACrC,EAIA,GAFA,aAA6B,GAE7B,UAEA,EAJ4C,EAI5C,EAA0B,GAD1B,CAA4B,GAAG,EAAmB,aACD,GACjD,KAEA,OADA,sBACA,qBAEA,CACA,UAAkB,GAAkB,CAAG,MAAO,GAAW,GAAS,CAClE,CADoC,CAGpC,OAHyD,QAGzD,MACA,IACA,6BACA,CACA,SACA,MACA,CACA,CACA,SAAS,GAAW,UACpB,GADoB,UACpB,MACA,EACA,QACA,CA8CA,eACA,IACA,oBACA,CACA,SACA,MACA,CACA,CA4BO,yBACP,4BACA,GACA,UAIA,OACA,CAAS,EACT,sBACA,CAQA,aACA,+CACA,CAOA,qBACA,6DACA,YAAiB,aACjB,CACA,QACA,2CACA,CACA,UACA,6BACA,CACA,SACA,4BACA,CACA,WACA,8BACA,CACA,CACO,oBACP,OACA,IACA,OACA,YACA,oBACA,aACA,kBACA,SAAsB,GAAU,kDAChC,oBACA,CAAS,GACT,cACA,WACA,cACA,mBACA,cACA,CACA,MACA,gCAA2D,oBAA2B,+BACtF,CAQA,gCAEA,kBADA,aAEA,OAEA,CACA,CACO,oBACP,OACA,IACA,OACA,YACA,oBACA,aACA,kBACA,SAAsB,GAAe,kDACrC,oBACA,CAAS,GACT,cACA,WACA,cACA,mBACA,cACA,CACA,MACA,gCAAgE,oBAA2B,+BAC3F,CAQA,gCAEA,kBADA,aAEA,OAEA,CACA,CACA,+BACA,cACA,uBACA,gDAAuE,SAAgB,+BACvF,qCACA,CAAS,EACT,YACA,CAAiB,GAA0B,mBAC3C,GAAmB,GAAmB,CACtC,OACA,CACA,gBAJ2C,CAIG,MAHR,GAGQ,iBAAuC,KAAK,EAAM,IAChG,gBACA,CAAyB,CACzB,CACA,gBACA,CAAiB,EAEjB,CAAS,CACT,CACA,qCACA,CC3XA,uBACA,iBACA,wGAEA,CACA,eACA,CCJA,iCACA,qBAAgB,yBAA8B,EAAI,EAClD,MACA,OACA,SACA,EAAiB,SDAjB,GCA6B,GDC7B,qBACA,gBACA,uEAA6E,YAAY,KAEzF,YAAU,4CAA4D,EACtE,sBAOA,cACA,qBAgDA,gBACA,KACA,gBAGA;AACA,kBACA,CAAK,sBAnDL,sBACA,sCACA,MACA,CACA,qBACA,WACA,sCACA,IADA,aACA,GACA,MACA,CACA,SACA,CACA,kBACA,UACA,YACA,IACA,KACA,YACA,KAAkB,EAAK,EAAE;AACzB,EACA,KACA,UACA,4BACA,KACA,aACA,oCACA,oCAAsD,EAAM,IAC5D,qBACA,QACA,MACA,CAAW,GAEX,KACA,SACA,EACA,OACA,kBAA8B,eAAuB,cAAmB,UAAgB,GACxF,CAAc,8CAId,CACA,CAcA,OAAW,KAnEX,YACA,8CAoEA,YACA,SACA,SACA,KAAS,YAA4B,CACrC;AACA,KACA,KACA,mEACA,aACA,KACA,CAAM,KACN,cACA;AACA,MACA,CACA,CACA,WACA,EArFA,GAA0H,EAAe,EAAE,EAAM,GACjJ,eACA,IACA,SACA,EA8DW,MAHX,aAA6B,EAC7B,+CACA,CACW,CACX,EC3E6B,CAC7B,YACA,YACA,CAAW,CACX,WACA,qDACA,CAAW,CACX,UACA,WACA,CAAS,CACT,CAAO,CACP,aACA,SACA,CACA,CAAK,CACL,CACA,CCvBO,QACP,MACA,QACA,mDACA,oFACA,oEACA,2DACA,CAAS,CACT,UACA,2CACA,CAAS,CACT,SACA,8CACA,CAAS,CACT,iBACA,2FACA,CAAS,CACT,aACA,sGACA,CAAS,CACJ,CACL,MACA,2BACA,qCACA,CAAK,ECgVL,IACA,yBACA,8HACA,MACA,gBACA,KAAkB,GAAK,mBACd,CACJ,CACL,+BACA,oIACA,MACA,gBACA,KAAkB,GAAK,mBACd,CACJ,CACL,sBACA,oMACA,MACA,kBACA,KAAkB,GAAK,aACvB,oBACA,CAAS,CACJ,CACL,sBACA,8IACA,MACA,kBACA,KAAkB,GAAK,aACvB,oBACA,CAAS,CACJ,CACL,sBACA,mGACA,MACA,0BACA,KAAkB,GAAK,iBACvB,CAAS,CACJ,CACL,0BACA,gGACA,MACA,mCACA,KAAkB,GAAK,qCACd,CACJ,CACL,yBACA,gIACA,MACA,yBACA,KAAkB,GAAK,mCACd,CACJ,EAEL,MACA,EACA,sBACA,OACA,SACA,EAQA,eACA,MACA,OAEA,8BACA,sBACA,UAEA,sBACA,UAEA,sBACA,UAGA,MAEA,EC3bO,SAAS,GAAS,WAEzB,EAFyB,WAEzB,iEACA,kBAEA,CACA,CCHA,IAAM,GAAQ,YACP,UADO,QACP,MACP,eACA,SACA,iCACA,CACA,CACO,SACP,8BACA,EACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,UACQ,GAAiB,GACzB,CACA,SAFwB,IAExB,CACA,OAHiC,GAGjC,MACA,mBAAkC,GAAS,6CAC3C,CACA,kBACA,gBACA,qBACA,gBACY,GAAS,uBACT,GAAS,uBACrB,CACA,aACA,kCAGA,WAAmB,GAAS,8BAC5B,CACA,gBACA,oCACA,2CAEA,WAAmB,GAAS,8BAC5B,CACA,mBACA,gBAGA,OADQ,GAAe,GADvB,CAA0B,OACJ,CADI,GACK,IAC/B,MAD+B,KAC/B,MACY,GAAe,GAAQ,KACnC,CAAS,CACT,CAF0B,cAAS,kBAGnC,GACA,OAAe,GAAe,GAAQ,EACtC,CACA,KAF6B,OAGd,GAAU,GACzB,CACA,EAFwB,mBAAS,EAEjC,CACA,qBACA,4BACA,KAGA,EAGA,EAGA,gBAFA,+HAHA,4HAHA,mJASA,CACA,CCrEO,IAAM,GAAmB,GAAmB,cEE5C,EFF4C,aEE5C,EFFsB,CEEtB,KACP,UAGA,mBACA,uBACA,yBA2QA,YACA,KAGA,qBAEA,iCAGA,QACA,CACA,EAtRA,GACA,8BACA,UAAoB,GAAQ,WAC5B,gBACA,kBAIA,QAHA,kBACA,oBACA,yDAAyE,OAAW,gCAGpF,CACA,CACO,uBACP,2BACA,kBACA,CACO,qBACP,cACA,OAAiB,6BAEjB,sBACA,OAAiB,8BAEjB,IACA,cAAgB,GAAY,WAE5B,OAAiB,KADjB,KACiB,kCACjB,CACA,MACA,OAAiB,mCACjB,CACA,CAoCA,QACA,mBACA,mBACA,cACA,SACA,YACA,EAsBO,+BACP,iCACA,EAEA,EAIA,yDACA,gBACS,CACT,YACA,CAAiB,GAA0B,4BAC3C,CAAa,CACJ,GACT,EAVA,eAO2C,CAP3C,IAYA,CACO,uBACP,IACA,qBACA,SACA,OAEA,qBACA,oDAKA,gBAJA,CACA,OACA,UACA,EAEA,CACA,SACA,MACA,CACA,CACA,yBACA,WACA,SAEA,SAA8B,GAAgB,OAC9C,MACA,SAEA,YAJ8C,EAI9C,sBACA,QAA2B,GAAS,GAAC,OAAF,CAAE,qBACrC,QACA,CAAK,eACL,SACA,uCAAmD,eAA+B,IAAI,aAAoB,GAE1G,qBAEA,OADA,oDACA,CACA,OACA,0DACA,CACA,CA2IA,oBACA,YAA4B,+BAAmB,CAM/C,OALA,kBACA,8DACA,oBACA,6BACA,CAAK,WACL,CACA,CCvTA,6BACA,2BACA,oCACA,gCACA,mCACA,yCACA,OACA,kBACA,EACA,2BAA8E,kDAA6D,SAC3I,WACA,sBAA+B,CAC/B,cACA,aACA,MACA,mBACA,cACA,aAEA,QACA,EACA,sBACA,WACA,SACA,eACA,8BACA,YACA,eACA,mBACA,8BACA,YAEA,QACA,EACA,sCACA,qEACA,sHACA,4EACA,gDACA,YACA,oBACA,UACA,IACA,YACA,CAAQ,SACR,IACA,CACA,EACA,MACA,IACA,aACA,CAAQ,SACR,IACA,CACA,EACA,0DACA,0BACA,CAAG,EAIH,yBACA,yBACA,MACA,iBAA+B,GAAQ,KAAK,EAAI,IAAI,4BAA2C,GAE/F,WACA,uBACA,cACA,YACA,YACA,cACA,CACA,yBACA,gCACA,IAEA,EACA,EAHA,WACA,+CAGA,gCAMA,OALA,kCACA,iBAEA,iBAEA,gBACA,CAAK,CACL,CACA,EACA,uBACA,cACA,oCACA,kCACA,CACA,EACA,uBACA,cACA,+DACA,gCACA,CACA,EACA,uBACA,cACA,uEACA,8BACA,CACA,EACA,uBACA,cACA,MACA,6EAEA,mCACA,CACA,EACA,uBACA,eACA,MACA,kEAAwE,aAA0B,GAElG,8BACA,CACA,EACA,uBACA,eACA,iBAAqB,oBAA4C,+BACjE,gCACA,CACA,EACA,uBACA,iBACA,+CAAuD,GAAK;AAC5D,EACA,cACA,QAAkB;AAClB,EACK,EAKL,MAFA,GAFA;AAGA;AACA,kGADA,CAFA,CAIA,CACA,EAGA,gBAGA,oBACA,QACA,IACA,QACA,QACA,KANA,aAOA,KARA,uBASA,UACA,UACA,QACA,QACA,EA4CA,SACA,eACA,oBAAkD,OAClD,CACA,WACA,4BACA,2CAEA,YADA,GACA,YACA,qBAFA,CAEA,MACA,CAAS,EAET,GAEA,CAEA,gBACA,MACA,WACA,MACA,SAEA,IAA6B,eAA8B,OAA3D,EAA2D,iBAE3D,KADA,8BACA,YACA,OACA,GACA,YArEA,EACA,EACA,EACA,EACA,EACA,SALA,IACA,OACA,KACA,KACA,IAoCA,SAlCA,KACA,SACA,KAAW,WAAc,KAEzB,GADA,OACA,EACA,SACA,UACU,SACV,iBACA,KACA,eACA,OAEA,UAEQ,WACR,UACQ,KAAoB,IAApB,EACR,MACA,kBACQ,KAAoB,IAApB,EAAoB,CAC5B,KACA,4CACA,MACA,KACA,EAAQ,cAAiC,IAAjC,GAAiC,UACzC,OAqCA,IArCA,4BACA,OAEA,GACA,CAEA,OADA,cAgCA,EAhCA,gCACA,CACA,EA8BA,EA7BA,KA8BA,EACA,GAEA,GAEA,MACA,CACA,EACA,mBACA,MACA,iCACA,eAUA,EATA,GAUA,QADA,EATA,IAUA,WAVA,CACA,MACA,kCAEA,WACA,CACA,aACA,CACA,CAMA,eACA,eACA,CAUA,yBACA,qBAIA,YACA,YACA,UACA,YAMA,SACA,IACA,iBACA,aACA,cACA,EAsCA,IACA,qBACA,EAyBA,IACA,kBACA,kBACA,CACA,uBACA,uBA0BA,SACA,mBAOA,EANA,YACA,YACA,YACA,oBACA,YACA,YAEA,0DACA,oCACA,6BACA,wBACA,6CACA,CACA,QACA,uCACA,CACA,cACA,MACA,sBACA,2CACA,sBAUA,OATA,sBACA,WACA,cACA,cACA,4CACA,0CAEA,CAAK,aACL,CAAK,EACL,CACA,CACA,EA+BA,iBACA,wBACA,oBACA,gBApLA,uBAqLA,oBACA,iBACA,2BAIA,OAHA,yBACA,yBACA,sBACA,YACA,CAzCA,eACA,eACA,eACA,eACA,eACA,eACA,sBACA,IAmCA,IAlCA,sBACA,wCACA,0BACA,IACA,sCAAoG,oBAAkC,GACtI,QA6BA,EA7BA,GA6BA,EA7BA,kCA+BA,oBAEA,0CACA,OACA,CAAK,GALL,SA7BA,CAAK,GACL,yBACA,WACA,kCACA,qBACA,UAIA,cACA,uCAJA,kBAKA,CAAK,aACL,CAAK,CACL,CAAI,SACJ,CACA,EAwBA,gBACA,GACA,GACA,GACA,GACA,EASA,SACA,mBAgBA,MAfA,YACA,iBACA,YACA,YACA,oBACA,YACA,YAEA,YAEA,eACA,eACA,YACA,YACA,YAEA,iBAAoC,aAAiB,IACrD,SAwOA,GACA,UACA,aAEA,gDACA,aAEA,iDACA,aAEA,aACA,mCACA,cAEA,cACA,eAEA,CAEA,EA3PA,cACA,iDACA,eACA,gCACA,6BACA,iCAEA,eA/NA,QACA,IACA,eACA,WACA,aACA,WACA,kBACA,CAAI,EACJ,uCACA,MACA,WACA,OACA,IACA,IACA,OACA,IACA,oBACA,gBACA,4CACA,CAAQ,SAER,GADA,aACA,mDACA,aACU,wEACV,OAEA,uCACA,kBACA,IACA,IACA,8BAA0C,GAAS,QAAQ,EAAM,KAGjE,CAEA,CAAG,CACH,EA0LA,8CACA,QAA0G,mCAC1G,qBACA,QACA,eACA,wEACA,CACA,CAAK,GACL,WAhKA,YACA,uCACA,oBACA,SACA,gBACA,KACA,uCACA,MAEA,OADA,IACA,WACA,aAOA,GANA,iCACA,MAEA,0DACA,MAEA,WACA,iBAEA,CACA,QACA,CAAG,CACH,EA0IA,SA/LA,QACA,IACA,EADA,CAAU,uBAAsB,EAqBhC,MAnBA,iCACA,sBACA,iCACA,KACA,QAEA,oBACA,oBACA,UASA,OARA,GACA,WACA,cACA,wBACA,MACA,gBACA,EAAO,EAEP,CACA,CAAG,CAEH,EAwKA,KAEA,yBACA,CACA,kBACA,kBACA,CACA,YACA,kBACA,CACA,iBACA,kBACA,CACA,iBACA,kBACA,CACA,mBACA,CAAG,EACH,oBAEA,OADA,yBACA,KACA,qBACA,CACA,CACA,iBACA,mBACA,CAEA,eACA,kBACA,CAEA,oBACA,yBACA,sBACA,CAEA,cACA,kBACA,CAEA,YACA,kBACA,CACA,ECxiBO,mBACP,2BACA,eAEA,MADA,sCACA,YAOA,IANA,gCACA,oBACA,WACA,SACA,CAAiB,CACjB,CAAa,IACb,CACA,IAAwB,gBAAc,eACtC,MACA,UACA,KACA,CACA,YACA,CACA,CAAS,CACJ,CACL,CDohBA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,cACA,oCACA,IA7TA,EA8TA,IACA,+FACA,IA4CA,EA5CA,KAAgB,YAAc,aAC9B,aACA,wBACA,8CACA,cAEA,cACA,YACA,kEAAgF,aAA0B,GAG1G,MApHA,YACA,SACA,iCACA,oCAEA,QACA,EA8GA,oBACA,UACA,mBA9TA,QA8TA,SACA,SACA,mBA/TA,QA+TA,SACA,WACA,mBAvUA,UAuUA,WACA,WACA,mBAlUA,UAkUA,WACA,WAAgD,IAKhD,eAJA,eACA,eACA,iBACA,iBACA,mBACA,uBAEA,CACA,mCACA,cACA,8BACA,mBACA,GACA,cAGA,aACA,mBACA,GACA,aAGA,sBAEA,IACA,4CACA,SACA,6BACW,EACX,cACA,CAAU,SACV,yBACA,8BACA,kBACA,oBACA,4BACA,uCACA,QACA,CAAY,+BAEZ,MADA,4BACA,CAEA,CACA,YAAgB,YAAkB,EAClC,WACA,IACA,cAEA,eACA,IACA,cAEA,YApYA,kBAqYA,IACA,cAEA,WACA,YAtYA,mBAuYA,yBACA,EACA,wCACA,iCACA,UACA,uBAEA,uCACA,eAvZA,EAwZA,cA1ZA,GAGA,uCAyZA,uBACA,gBAEA,iCACA,CACA,CACA,CAAM,SAEN,GADA,cACA,aACA,oCACA,sBACA,0BACA,cACA,+BAEA,eACA,iCAEA,2BAEA,MACA,CACA,OACA,EAAM,OACN,cACA,CACA,CAAG,CACH,EACA,eACA,gCACA,kBACA,qEACA,IACA,UACA,CAAU,SACV,oBACA,OACA,CAAW,CACX,CACA,CAAO,GAEP,CAAG,CACH,EACA,eACA,8BACA,aACA,CAAG,CACH,EAKA,eACA,iBACA,eACA,cACA,eACA,eACA,kBACA,EACA,YACA,YACA,iBACA,EAqGA,eACA,eACA,eACA,eACA,eAmDA,cACA,wBACA,GAAe,8CAAkD,CACjE,CAAG,CACH,CEl1BA,UACA,IACA,WACA,GACA,MACA,CACA,QACA,WACA,CACA,eACA,UAEA,0BACA,UACA,6DACA,CAAa,CACJ,CAET,SDjEO,cACP,WCgEsD,QDhEtD,yBAUA,OATA,6BACA,oBACA,OACA,aACA,SAAwB,WAAc,eACtC,UAAgC,sBAA+B,CAAI,gBACnE,CACA,CACA,EACA,CACA,ECqDsD,GACtD,kBACA,cACA,eACA,GAAwB,GAAe,IACvC,YACA,4BACA,aAEA,uBACA,SACA,KAEA,eAEA,qBACA,IACA,CAAwC,iBACxC,QACA,iBACA,QAEA,CACA,CACA,MAC6B,GAAgB,IAC7C,SAD6C,QAC7C,oBACA,gBACA,YAKA,gBACA,oBACA,IACA,YAEA,CACA,CAAa,CACJ,CACT,CACA,aACA,eAEA,iBACA,0BAEA,iBACA,yBACA,CACA,aACA,2BAEA,YACA,eAEA,eACA,6BACA,CACA,aACA,2BACA,CACA,YACA,0BACA,CACA,cACA,4BACA,CACA,MACA,aAAyB,IACzB,MADmC,CACnC,IAEA,CACA,CCnIO,iBACP,0BACA,SAA2D,GAAS,qBAAuB,GAAS,gDACpG,mBACA,gBACK,EAEL,yCACA,kBACA,SAEA,CAAK,EAAI,QAAY,EACrB,MDlBO,SAAS,CAAc,MAC9B,KCiB4C,CDjB5C,QAD8B,YA6B9B,OA3BA,yCACA,SACA,CAAK,EAAI,QAAY,EAyBrB,CACA,OAbA,OAZA,IAA4B,GAAW,CACvC,MACA,CAFuC,OAEvC,CACA,cACA,2CACA,CAAS,CACT,2BACA,gBACA,YACA,eACA,CAAS,CACJ,GAEL,wCACA,qBACA,oBACA,WACA,kBAGA,wCAAqE,gBAAqB,GAE1F,CAAS,CACJ,GAGL,SACA,EACA,gBACA,kBAEA,SACA,CAAiB,IAGjB,SAEA,CACA,CACA,EC1B6C,GAAoB,GACjE,KACA,gBACA,YACA,oBACA,CAAS,CACJ,EAQL,cAPA,CACA,wBACA,mCACA,gBACA,kBACA,MAGA,CDyGgC,eCvGzB,UACP,IACA,oBACA,KACA,WACA,cACA,CACA,kBACA,uBACA,SACA,2BACA,wBACa,CACb,2BACS,WACT,SACA,MAAsB,GAAQ,oBAA6B,gEAE3D,WACA,gCAEA,cACA,mCACA,gBAAiC,IACjC,mBADwD,aACxD,CACA,eACA,mBA0OA,GACA,IACA,oBACA,CACA,SACA,QACA,CACA,EAjPA,QACA,CAAiB,CACJ,EACb,CAAS,CACT,CACA,CACO,SACP,QACA,OACA,kBACA,eACA,cACA,CACA,0BACA,UACA,gDAGA,cADA,GAAuB,gBAAwB,uBAAuB,EAAM,GAAG,EAAU,EACzF,aACA,CACA,CA0BO,SACP,QACA,OACA,oBACA,iBACA,8BACA,GACA,eACA,sBACA,8CACA,YAAsB,GAA2B,6BACjD,uBACA,sCACA,aAEA,mCACA,uBACA,qBACA,8CACA,iCAEA,CAAa,CACJ,qCACT,CACA,cACA,6CACA,qCAEA,iCACA,CACA,yBACA,0CACA,CACA,YACA,8BACA,CACA,cAEA,cACA,OAAe,GAA2B,aAC1C,WAD0C,KAC1C,OAMA,GALA,WACA,WACA,KACA,CAAiB,EAEjB,YACA,0BACA,oCACA,kCACA,qBAGA,WACA,SAGA,IAFA,+EAGA,YACA,SACA,EACA,iCACA,eACA,WACA,OACA,QACA,KACA,CAAyC,CACzC,CACA,CAAiC,GACjC,2BACA,SACA,YACA,CAAqC,CACJ,GACjC,UACA,iCAAqE,EAAU,KAC/E,CAAiC,CACjC,CAA6B,EAC7B,UACA,6CAA6E,EAAU,KACvF,CAA6B,GAI7B,CAAa,CACJ,qCACT,CACA,2BACA,oBACA,CAAgB,+CAChB,OACA,eACA,CAAgB,6CAChB,OACA,yBACA,CAAc,uBAAuC,CACrD,CAAc,sBAAqC,CACnD,mBAAuB,QAAa,IACpC,MACA,OAEA,8BAAyD,aAAe,GAAG,EAAI,GAC/E,cACA,SAEA,YAAiC,GAAiC,uBAElE,OADA,wBAAoC,aAAe,GAAG,EAAI,KAC1D,CACA,CAAS,GACT,6BACA,MAAoB,GAAW,CAAG,OAAH,QAAG,yBAAgD,EAClF,OACA,OACA,gBACA,UACA,SACA,sBACA,sBACA,gCACA,gBACA,gBAiBA,GACA,UACA,cACA,eAEA,0BACA,0BAEA,eACA,cAEA,cACA,wBACA,cAEA,8BACA,oBAEA,iBACA,iBAEA,gBACA,gBAEA,8BACA,iBAEA,sBACA,sBAEA,mBACA,mBAEA,eACA,eAEA,6BACA,cAEA,eACA,eAEA,iBACA,iBAEA,SACA,+BAA+C,EAAO,EAEtD,CACA,EAlEA,UACA,6BACA,0BACA,kCACA,mBACA,wCACA,8BACA,iCACA,8BACA,kCACA,4BACA,cAA+B,ST5HxB,GACP,MAsUO,GS3M6C,MT2M7C,GACP,eACA,qBACA,mCACA,qDAEA,OADA,kBAEA,cACA,OACA,8BAEA,eACA,OACA,8BAEA,eACA,OACA,uCAEA,SACA,OACA,gDACA,kBACA,wBAEA,CAGA,qBACA,qDA9aA,mBAobA,EApbA,MAobA,EAnbA,SAbA,0BAgcA,EAnbA,QA8aA,OACA,gCACA,EAQA,KAEA,oBAGA,mBAFA,KAKA,sBACA,YAA+B,GAAiB,uCAEhD,OADA,eAEA,cACA,OACA,8BAEA,eACA,OACA,6BACA,CACA,eACA,OACA,uCAEA,SACA,OACA,gDACA,kBACA,wBAGA,CAEA,OACA,KACA,cAGA,CACA,QACA,EAtZA,GACA,eACA,qBACA,OACA,YACA,kBACA,wBAGA,oBAKA,mBAJA,OACA,cAQA,sBACA,OACA,uCAAwD,OAAmB,EAC3E,CAEA,CACA,ESkGoD,gBACpD,gBACA,UACA,CACA,CACA,CA6DA,4BACA,+BACA,sCACA,6DACA,gDAmBA,0DAAoD,MAAwB,EAAI,EAChF,uBACA,OACA,aACA,IACA,qBAIA,OAHA,QACA,gBAEA,CACA,CACA,SAEA,MADA,gBACA,CACA,CACA,CAAa,CACb,gBACA,KAMA,oBANA,CACA,kBACA,gBACA,OACA,CAIA,OAAyB,gBACzB,CAAa,CACb,yBACA,YACa,CAEb,EAEA,kFCnWA,QACA,OACA,cACA,mBACA,mBACA,WACA,YACA,CAAK,CAME,UACP,QACA,YACA,kCACA,QAAyD,EACzD,mBACA,iCACA,2BAAqC,GAAmB,KACxD,CACA,kBACA,EAHwD,EAGxD,cAWA,MAVA,OAQA,QAPA,CACA,KACA,SACA,cACA,IACA,CAAiB,EAKjB,CACA,aACA,kBACA,CACA,wBACA,IACA,aAAyB,GAAS,GAAsB,GAAK,IAA5B,CAA4B,QAAa,GAAlB,UAAkB,EAAe,EAAM,UAC/F,aACA,mBACA,CAAa,CAAE,GAAmB,8BAClC,CACA,SACA,gBAAiC,IACjC,IADyC,EACzC,SACA,MAGA,QACA,CACA,CACA,2BACA,aAAqB,GAAS,GAA2B,GAAK,aAAa,QAAlB,QAAkB,EAAkB,EAAQ,WACrG,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,qBACA,4BACA,OAAe,GAAS,GAAmB,GAAK,IAAzB,CAAyB,QAAa,gBAAgB,EAAc,WAC3F,cACA,yCACA,sBACA,CAAS,CAAE,GAAmB,+BAC9B,eACA,YAA2B,kBAAgB,IAC3C,qCACA,sBACA,OACA,KACA,mBACA,EAEA,4CACA,yBACA,QAA8B,GAAW,CACzC,OADyC,GACzC,iBACA,SACA,KACA,qBAA0C,KAAQ,GACjC,CACjB,yDACA,CAAa,EACb,OACA,KACA,mBACA,CACA,CAAS,CACT,CACA,sBACA,OAAe,GAAS,GAA0B,GAAK,IAAhC,CAAgC,QAAa,OAAlB,YAAkB,GACpE,cACA,yCACA,oCACA,2CACA,iDACA,CAAa,EACb,sBACA,CAAS,CAAE,GAAmB,+BAC9B,eACA,qBAA2B,SAAgB,IAC3C,4CACA,yBACA,QAA8B,GAAW,CACzC,OADyC,GACzC,iBACA,SACA,KACA,sBAA2C,KAAQ,GAClC,CACjB,yDACA,CAAa,EACb,OACA,KACA,mBACA,CACA,CAAS,CACT,CACA,4BACA,OAAe,GAAS,GAAkC,GAAK,IAAxC,CAAwC,QAAa,eAAlB,CAAkB,EAAkB,EAAS,GACvG,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,mBACA,OAAe,GAAS,GAAkC,GAAK,IAAxC,CAAwC,QAAa,eAAlB,CAAkB,EAAkB,EAAS,GACvG,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,iBACA,OAAe,GAAS,GAAmB,GAAK,aAAa,eAAe,EAAM,GAClF,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,cACA,YACA,OAAe,GAAmB,GAAmB,GAAK,SAAzB,GAAyB,CAAa,eACvE,QACA,eACA,eACA,gBACA,CAAS,EACT,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,uBACA,YAIA,OAHA,QACA,mEAEe,GAAmB,GAAmB,GAAK,SAAzB,GAAyB,CAAa,mBAAmB,EAAW,QACrG,QACA,eACA,eACA,gBACA,CAAS,EACT,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,eACA,OAAe,GAAS,GAAiB,GAAK,IAAvB,CAAuB,MAAL,CAAK,CAAa,eAAe,EAAM,UAChF,cACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,eACA,OAAe,GAAS,GAAmB,GAAK,IAAzB,CAAyB,QAAL,aAAkB,EAAe,EAAM,UAClF,cACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,qBACA,OAAe,GAAS,GAAmB,GAAK,aAAa,eAAe,EAAM,cAClF,cACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,eACA,OAAe,GAAS,GAAC,QAAU,QAAS,GAAC,SAAW,KAAM,aAAa,eAAe,EAAM,QAChG,cACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,oBACA,OAAe,GAAS,GAAc,GAAK,IAApB,CAAoB,GAAL,IAAK,CAAa,oBACxD,cACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,mBACA,0BAOA,OANA,SACA,mCAEA,YACA,yCAEe,GAAwB,GAAc,GAAK,QAAL,IAAK,CAAa,CAAjC,gBAAiC,GACvE,aACA,gBACA,CAAS,EACT,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,sBACA,OAAe,GAAS,GAAc,GAAK,IAApB,CAAoB,GAAL,IAAK,CAAa,oBAAoB,EAAW,GACvF,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,sBACA,OAAe,GAAS,GAAc,GAAK,IAApB,CAAoB,GAAL,IAAK,CAAa,oBAAoB,EAAW,GACvF,aACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,wBACA,OAAe,GAAS,GAAc,GAAK,QAAL,IAAK,CAAa,oBAAoB,EAAW,cACvF,cACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,sBACA,OAAe,GAAS,GAAc,GAAK,IAApB,CAAoB,GAAL,IAAK,CAAa,oBAAoB,EAAW,YACvF,cACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,oBACA,OAAe,GAAS,GAAqB,GAAK,IAA3B,CAA2B,QAAa,EAAlB,gBAAkB,EAAoB,EAAW,GAC9F,gBACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,mBACA,OAAe,GAAS,GAAoB,GAAK,IAA1B,CAA0B,QAAa,CAAlB,gBAAkB,EAAmB,EAAW,WAAW,EAAK,GAC5G,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,uBACA,OAAe,GAAS,GAA+B,GAAK,IAArC,CAAqC,QAAa,YAAlB,KAAkB,EAAmB,EAAW,WAAW,EAAK,UACvH,cACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,wBACA,OAAe,GAAS,GAAwB,GAAK,IAA9B,CAA8B,QAAa,KAAlB,YAAkB,EAAmB,EAAW,WAAW,EAAK,GAAG,EAAI,GACvH,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,sBACA,OAAe,GAAS,GAA+B,GAAK,aAAa,YAAlB,KAAkB,EAAmB,EAAW,WAAW,EAAK,GACvH,cACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,wBACA,OAAe,GAAS,GAA+B,GAAK,aAAa,YAAlB,KAAkB,EAAmB,EAAW,WAAW,EAAK,GAAG,EAAI,GAC9H,aACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,sBACA,OAAe,GAAS,GAA+B,GAAK,IAArC,CAAqC,QAAa,YAAlB,KAAkB,EAAmB,EAAW,WAAW,EAAK,GAAG,EAAI,GAC9H,gBACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,yBACA,OAAe,GAAS,GAA0B,GAAK,IAAhC,CAAgC,QAAa,OAAlB,MAAkB,EAAe,EAAM,YACzF,aACA,oBACA,sBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,oBACA,OAAe,GAAS,GAA0B,GAAK,IAAhC,CAAgC,QAAa,OAAlB,MAAkB,EAAe,EAAM,YACzF,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,oBACA,OAAe,GAAc,GAAI,QAAJ,IAAI,CAAa,oBAAoB,EAAM,GACxE,wEACA,kBACA,YACA,iBACA,4BACA,CAAS,CACT,CACA,4BACA,eAyEA,GACA,0BASA,OARA,IACA,SACA,mEAEA,QACA,gEAGA,CACA,EApFA,CACA,MACA,CAAS,EACT,OAAe,GAAc,GAAI,QAAJ,IAAI,CAAa,mBAAmB,MAAmB,EAAa,KAAO,GACxG,mBACA,kBACA,YACA,iBACA,4BACA,CAAS,CACT,CACA,sBACA,OAAe,GAAc,GAAI,QAAJ,IAAI,CAAa,uBAAuB,EAAQ,GAC7E,mBACA,kBACA,YACA,iBACA,4BACA,CAAS,CACT,CACA,yBAKA,UAJkC,GAA4B,0BAC9D,0BACA,gBACA,CAAS,EACT,wBAEA,OADA,mBAEA,CACA,2BACA,OAAe,GAAS,GAAC,OAAF,GAAW,UAAY,aAAa,0BAC3D,cACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,mBACA,OAAe,GAAS,GAAqB,GAAK,aAAa,EAAlB,cAAkB,EAAkB,EAAQ,GACzF,aACA,mBACA,CAAS,CAAE,GAAmB,8BAC9B,CACA,QACA,OACA,kCACA,wBAAqC,iBAAiB,EACtD,kBAA+B,GAC/B,IADsC,MACtC,aAAqD,qBACrD,YACA,SAEA,GACa,EAAI,CACjB,EAWA,OATY,GAAW,eACvB,UADuB,WACvB,QACA,GACA,0CAGA,sDACA,kCAEA,CACA,CACA,KAKA,MAJA,CACA,wBAAqC,iBAAiB,EACtD,kBAA+B,EAC/B,CAEA,CACA,CAaA,EAjBsC,OAiBtC,MACA,0BAoCA,OAnCA,IACA,UACA,+EAEA,kBACA,+GAEA,WACA,mFAEA,cACA,4CAEA,OACA,mEAEA,YACA,wCAEA,4BACA,4CAEA,QACA,yGAEA,MACA,iGAEA,UACA,+CAEA,SACA,mCAGA,CACA,CACO,SAAS,GAAmB,YACnC,EAGA,CACA,KACA,KACA,CAPmC,KAOnC,CACA,WACA,WACS,EART,CAUA,gBCncO,UACP,aAEA,UADwB,IAAW,GACnC,WACA,0BAEA,QAEA,CACA,CCVA,IAAM,GAAQ,QAGd,GAHc,IAGW,EAClB,SAD6B,CAEpC,8BACA,EACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,kBACA,OAAe,GAAe,GAAQ,EACtC,CACA,KAF6B,GAAS,IAEtC,CACA,6BACA,CACA,QACA,iBACA,CACA,KACA,OAAe,GAAU,KAAQ,CAAT,CACxB,CACA,CCrBO,IAAM,CDmBoB,ECnBZ,GAAQ,SAAX,EAAW,EC0DtB,UACP,SACA,OACA,QACA,QACA,SACA,WACA,WAAoB,CACpB,CACA,YACA,QACA,CACA,CCxEA,IAAM,GAAQ,SACd,GADc,IACe,EACtB,UACP,EAF2C,KAE3C,uBACA,EACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,UACQ,GAAiB,GACzB,CACA,SAFwB,EAAS,SAEjC,GACA,OAAe,GAAe,GAAQ,EACtC,CACA,KAF6B,CAE7B,GAFsC,CAEtC,CACA,oBACA,CACA,SACA,kBACA,CACA,UACA,mBACA,CACA,UACA,mBACA,CACA,WACA,oBACA,CACA,aACA,6BACA,CACA,eACA,+BACA,CACA,KACA,OAAe,GAAU,KAAQ,CAAT,CACxB,CACA,CCvCsB,GAAS,GDqCE,GCrCF,OCHxB,UACP,UAEA,CACA,mBACA,wBACA,CACA,aACA,wBACA,CACA,eACA,wBACA,MACA,QACA,OACA,sBACA,KAAsB,GAAiB,uBAC1B,CACJ,CACT,CACA,gBACA,wBACA,QACA,SACS,CACT,CACA,CC3BO,SACP,UAEA,CACA,QACA,OACA,aAA6B,sBAAyB,CAEtD,CACA,QACA,iBACA,CACA,cACA,UACA,CACA,SAEA,CACA,CClBA,IAAM,GAAQ,QAGd,CAHc,EAGd,IAA+B,EACxB,UACP,IAF+C,GAE/C,uBACA,EACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,yBACA,OAAe,GAAe,GAAQ,EACtC,CACA,KAF6B,CAAS,GAEtC,CACA,oBACQ,GAAiB,GACzB,CACA,QAFiC,CAAT,MAGxB,iBACA,CACA,QACA,wBACA,CACA,cACA,8BACA,CACA,SACA,yBACA,CACA,KACA,OAAe,GAAU,KAAQ,CAAT,CACxB,CACA,CC/BO,GD6B0B,CC7B1B,GAAc,GAAQ,cCJvB,GAAQ,UAId,GAJc,IAImB,EAK1B,UACP,MANmD,CAMnD,uBACA,EACA,qBAIA,OAHA,gBACA,wBAEA,cACA,CACA,mBACA,OAAe,GAAK,4CACpB,CACA,aACA,OAAe,GAAK,sCACpB,CACA,eACA,OAAe,GAAK,wCACpB,CACA,gBACA,OAAe,GAAK,yCACpB,CACA,2BACA,OAAe,GAAe,GAAQ,EACtC,CACA,KAF6B,IAE7B,CAFsC,IAGtC,gBACQ,GAAiB,GACzB,CACA,KACA,IAHwB,GAAS,GAGR,KAAQ,CAAT,CACxB,CACA,CCpCO,ODkC0B,GClCA,aCJ1B,UACP,YACA,sCACA,CACA,YACA,sCACA,CACA,eACA,sCACA,CACA,eACA,sCACA,CACA,YACA,sCACA,CACA,iBACA,sCACA,CACA,SACA,sCACA,CACA,WACA,sCACA,CACA,sBACA,UACA,sCACA,CACA,UACA,sCACA,CACA,SACA,sCACA,CACA,OACA,sCACA,CACA,UACA,sCACA,CACA,aACA,OACA,uBACA,oBACA,oBACA,0BACA,0BACA,uBACA,4BACA,6BACA,0BAAkD,qBAA8B,CAChF,EAAiB,CACJ,EACb,uBAEA,CACA,WACA,OACA,qBACA,kBACA,kBACA,wBACA,wBACA,qBACA,4BACA,6BACA,0BAAkD,qBAA8B,CAChF,EAAiB,CACJ,EACb,qBAEA,CACA,CCvEA,IAAM,GAAQ,eACd,EADc,CACd,IAAyB,EAClB,UACP,UAF+C,MAG/C,gBACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,oBACA,OAAe,GAAe,GAAQ,EACtC,CACA,KACA,OAAe,EAHuB,CAGb,KAAQ,CAAT,CACxB,CACA,YAFiC,MAEjC,GACA,8BACA,CACA,UACA,0BACA,CACA,UACA,0BACA,CACA,SAEA,OADA,mBACA,KAEA,OAEA,OADA,iBACA,KAEA,eAEA,OADA,yBACA,KAEA,eAEA,OADA,yBACA,KAEA,YAEA,OADA,sBACA,KAEA,YAEA,OADA,sBACA,KAEA,UAEA,OADA,oBACA,KAEA,cACA,8BACA,CACA,iBACA,iCACA,CACA,SACA,yBACA,CACA,WACA,2BACA,CACA,aACA,wBAEA,WACA,sBAEA,UC1EA,uCEGO,OAAoB,GAAc,cCFnC,GAAQ,YACd,GADc,IACd,GACA,YAEA,CACA,qBACA,wBACA,CACA,oBACA,QACA,CACA,CACA,IAAM,GAAY,MACX,UACP,GAFkB,IAElB,uBACA,EACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,oBACA,OAAe,GAAe,GAAQ,EACtC,CACA,KAF6B,OAAS,GAGb,KAAa,CAAd,CACxB,CACA,UAFiC,CAEjC,CACA,OAHkD,IAGlD,iBACA,CACA,qBACA,qCACA,CACA,oBACA,oCACA,CACA,CCnCyB,GAAY,cCFrC,IAAM,GAAQ,SACd,QADc,EAEd,qBACA,oCAEA,CACA,aACO,UACP,gBACA,gBACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,aACA,wBAEA,qBACA,qCACA,CACA,oBACA,OAAe,GAAe,GAAQ,EACtC,CACA,KAF6B,IAE7B,CACQ,GAAiB,CAHa,EAItC,CACA,KACA,IAHwB,GAGT,GAAU,CAHQ,IAGA,CAAT,CACxB,CACA,CC5BO,OAAgB,GAAU,CD0BA,MC1BA,MCkC1B,UACP,kBAEA,CACA,aACA,SAEA,CCzCA,IAAM,GAAQ,uBACR,CADQ,EACI,IAAO,EAClB,UACP,YAFkB,IAElB,CAFsD,aAGtD,EACA,qBAIA,OAHA,gBACA,wBAEA,eAEA,kBACA,2BACA,CACA,aACA,6BACA,CASA,6BAEA,IACA,EADA,KAEA,wBACA,QAEA,CAEA,GADA,QACA,GACA,0EAEA,GACA,CAEA,iBACA,IAEA,gBAEA,eAWA,OATA,qBACA,OACA,QACA,YACA,KACA,UACA,CAAiB,CACjB,WACA,CAAa,EACb,CACA,CACA,SAEA,kBAaA,OAZA,qBACA,OACA,QACA,YACA,KACA,WACA,6CACA,eACA,CAAiB,CACjB,WACA,CAAa,EAEb,CACA,CACA,CACA,6BAYA,OAXA,kBACA,OACA,EACA,YACA,sBACA,YACA,gBACA,cAEA,GAGA,CACA,iCACA,wBACA,gBACA,SAGA,uBACA,WACA,eAEA,kBACA,GACS,EAAI,EAEb,mBACA,YACA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GA,CACA,6BACA,iBACA,QAEA,2DACA,CACA,mBAA2B,2BAA8C,yBAAyB,WAAmB,CACrH,CCPO,MDM8G,SCN9G,YACP,iDACA,CAsDO,2BACP,6DACA,CAgBO,2BACP,wBACA,OAAW,GAAI,WACf,CACO,2BACP,sDACA,CAuiBA,+BACA,MAAsB,GAAgB,gBACtC,iBACA,CAFsC,CAEtC,MAAgC,GAAW,GAmC3C,KAnC2C,EAC3C,uBACA,eACA,SACA,eACA,iCACA,KAAkB,GAAW,gBAC7B,SAD6B,GAC7B,WACA,qBAAkC,GAAkB,mBACpD,uCACA,eACA,WACA,aACA,2BACA,cAA2B,GAAW,gBACtC,qBACA,2BACA,mBACA,0BAA+C,GAAS,kBACxD,CAAS,CACJ,EACL,mBACA,CAAK,EACL,OACA,MAAc,IACd,eACA,uBACA,0CACA,iCACA,4BAGA,CAAS,CACT,KACK,CAEL,CACA,iCACA,MAAsB,GAAgB,gBACtC,kBADsC,MACtC,EACA,wCACA,qCACA,QAAwC,GAAW,GACnD,KADmD,CACnD,CACA,OACA,eACA,SACA,0BACA,yCACA,KAA0B,GAAW,gBACrC,SADqC,GACrC,WACA,qBAA0C,GAAkB,2BAC5D,+CACA,uBACA,mBACA,qBACA,mCACA,cAAmC,GAAW,gBAC9C,6BACA,mCACA,2BACA,kCAA4D,GAAS,kBACrE,CAAiB,CAEjB,CAAS,EACT,CAAK,EACL,oBACA,qBAA8B,GAAkB,mBAChD,uCACA,6DACA,CAAK,EACL,OACA,MAAc,IACd,eACA,oBACA,2CACA,iCACA,+BAEA,mCACA,yCAEA,+CACA,YACA,gFAEA,uCAEA,yDACA,kDAGA,CAAS,CACT,KACK,EAQL,MAPA,CACA,aACA,oBACA,gCACA,YACA,sCAGA,CACA,+BACA,MAAgB,GAAW,IAC3B,MACA,eAF2B,yDAI3B,MAAsB,GAAgB,gBACtC,iBACA,CAFsC,CAEtC,MAAgC,GAAW,GAC3C,KAD2C,EAC3C,MAAiB,GAAM,4BACvB,6BACA,eACA,SACA,8BACA,cAA+B,GAAW,gBAC1C,eACA,iCACA,KAAsB,GAAW,gBACjC,SADiC,GACjC,WACA,eACA,WACA,aACA,2BACA,qBACA,2BACA,kBACA,CAAa,CACJ,GAAI,IACb,6BACA,YAA6B,GAAO,aACpC,QACA,KACA,CAAS,EACT,oBACA,CAAK,EACL,KAAc,IAAQ,UACtB,YACA,CAAa,GAA0B,sBACvC,GAAe,GAAmB,CAClC,OACA,CACA,OACA,MALuC,EAKvC,QAJkC,CAKb,CACrB,CACA,gBACA,CAAa,CACb,CAAS,CACJ,CACL,CACA,iCACA,MAAgB,GAAW,IAC3B,MACA,eAF2B,8DAI3B,MAAsB,GAAgB,gBACtC,aAAiB,GAAM,EADe,QACf,kBACvB,8BACA,wCACA,qCACA,QAA4C,GAAW,GACvD,KADuD,CACvD,CACA,OACA,eACA,SACA,cAAuC,GAAW,gBAClD,SADkD,MAClD,WACA,yCACA,KAA8B,GAAW,gBACzC,SADyC,GACzC,WACA,uBACA,mBACA,qBACA,mCACA,6BACA,mCACA,0BACA,CAAqB,CAErB,CAAa,GACb,6BACA,CAAS,EACT,6DACA,CAAS,IACT,+BACA,yCACA,sCACA,YACA,gFAEA,kBACA,kDAEA,YAA6B,GAAO,cACpC,QACA,yBACA,KACA,CAAS,EACT,sBACA,OACA,QACA,MACA,CACA,CAAK,EACL,KAAc,IAAQ,UACtB,YACA,CAAa,GAA0B,sBACvC,GAAe,GAAmB,CAClC,OACA,CACA,OACA,MALuC,EAKvC,QAJkC,CAKb,CACrB,CACA,gBACA,CAAa,EACJ,CACJ,CACL,CACA,8BACA,oDAOA,MAAiB,GAAM,kDACvB,iCACA,gBAGK,CACL,KAAc,IAAQ,UACtB,CAAS,GAA0B,4BACnC,CAAK,EAbL,mBAYmC,CAZnC,aACA,eAaA,CAmBA,uBACA,SAWA,OACA,MACA,QACA,mCACA,MAAmB,S3Dx+BZ,GACP,Q2Du+BuC,C3Dv+BvC,MACA,sBACA,uBAGA,OAFA,cACA,qBACA,CACA,CACA,mBACA,iBAEA,eACA,wBAEA,uBACA,0CAAoE,OAAW,IAG/E,OAFA,cACA,qBACA,CACA,CACA,CACA,E2Dm9BuC,QACvC,CAhBA,EACA,OAA+B,qCAC/B,QAAqC,GAAyB,EAAe,IAC7E,OACA,EAFmF,CAEnF,GACA,GAH8D,EAG9D,GACA,mCACA,aAA0B,GAAW,EACrC,CACA,CASA,CCnjCO,GDwiC8B,CCxiC9B,IACP,OAAW,IACX,cAAkB,IAClB,YAAgB,IAChB,cAAkB,CDqLX,kBACP,WAAe,GAAc,QAC7B,SAD6B,mBAC7B,gBACA,SACA,IACA,CAAS,EACT,UACA,IACA,CAAS,CACT,CAAK,GACL,EC9LA,mBAAuB,GACvB,EO3B8B,GAAW,OACb,CADa,EACF,KAUvC,GAVuC,CAUvC,IACA,IAyDA,cAEA,OADI,GAAW,SACf,EACA,EA3DA,IAoEA,YAEA,OADI,GAAW,OACf,CADe,CAEf,EAtEA,OAoIA,cAEA,OADI,GAAW,YACf,EACA,EAtIA,OAkJA,cAEA,OADI,GAAW,YACf,EACA,EApJA,UAmGA,gBAEA,OADI,GAAW,eACf,EACA,EArGA,UAiHA,gBAEA,OADI,GAAW,eACf,EACA,EAnHA,QACA,EAwJA,qBACA,MAA4B,GAAmB,CAC/C,MAAc,IACd,eAF+C,SAG/C,gBACA,CAAK,GACL,OAAU,GAAW,SA7Jd,EAUP,MACA,EC/BoB,GAEE,MACtB,gBCAO,wBACP,eACA,SACA,wBACA,CACA,CGmMA,eACA,SACA,iCACA,KACA,2BACA,eAEA,sBACA,iCACA,oBACA,eACA,UAAyD,EAAO,GAAG,EAAS,GAAG,EAAK,OAGpF,mBACA,UAAqD,EAAO,GAAG,EAAS,GAAG,EAAM,GAEjF,wBACA,UAAqD,EAAO,GAAG,EAAS,EAGxE,CAGA,QACA,mBEtOA,OAqEA,WAEA,MACA,eAEA,YAEA,QADA,EACA,IAAsB,mBAAsB,IAE5C,aADA,eAEA,QACA,YAIA,QACA,EAGA,EACA,eACA,YACA,0DACA,EAMA,IACA,YACA,8BACA,CAAK,CACL,YACA,4BACA,CAAK,CACL,YACA,mCACA,CAAK,CACL,YACA,2BACA,CAAK,CACL,YACA,yBACA,CAAK,CACL,YACA,4BACA,CAAK,CACL,YACA,0CACA,CAAK,CACL,YACA,wDACA,CAAK,CACL,KAOA,GACA,KACA,OACA,YACA,4BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,wBACA,CAAO,CACP,YACA,wBACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,yDACA,KACA,EACA,YACA,oCACS,CACT,YACA,mCACS,CACT,YACA,yCACS,CACT,YACA,mCACS,CACT,YACA,sCACS,CACT,YACA,wCACS,CACT,YACA,uCACA,CAAS,CACT,YACA,8DACA,KACA,CACS,CACT,KAEA,CACA,gBACA,iBACA,+DAGA,KACA,YACA,yCACO,CACP,YACA,wCACO,CACP,YACA,4CACO,CACP,YACA,gCACO,CACP,YACA,kCACO,CACP,YACA,yCACO,CACP,YACA,4CACO,CACP,YACA,wDACO,CACP,KAEA,KACA,MACA,MACA,SACA,MACA,QACA,QACA,UACA,eAEA,KACA,YACA,0BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,+BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,gCACA,CAAO,CACP,KAEA,MACA,MACA,OACA,QACA,MACA,QACA,QACA,OACA,YACA,KAEA,KACA,YACA,wCACO,CACP,YACA,6DACO,CACP,YACA,0DACO,CACP,YACA,wCACA,CAAO,CACP,YACA,gDACA,CAAO,CACP,YACA,iDACO,CACP,YACA,+CACA,KACA,CACO,CACP,YACA,+DACA,KACA,CACO,CACP,KAEA,KACA,WACA,MACA,UACA,UACA,MACA,QACA,SACA,cAEA,KACA,QACA,YACA,gCACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,KACA,YACA,2BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,KACA,KACA,YACA,2BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,kCACA,GAEA,KACA,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,kCACA,CAAO,CACP,KAEA,KACA,YACA,6BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,kCACA,CAAO,CACP,KAEA,KACA,YACA,4BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,gCACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,KACA,OACA,WACA,OACA,OACA,OACA,SACA,UACA,cACA,KAEA,KACA,MACA,MACA,OACA,MACA,OACA,QACA,QACA,cAEA,KACA,YACA,6BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,qCACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,+BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,KACA,QACA,YACA,4CACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,iCACA,CAAO,CACP,YACA,kCACA,CAAO,CACP,SACA,cACA,KAEA,KACA,YACA,wBACA,CAAO,CACP,OACA,YACA,6BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,kCACA,CAAO,CACP,KAEA,KACA,KACA,YACA,yBACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,yBACA,CAAO,CACP,YACA,yBACA,CAAO,CACP,YACA,yBACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,oCACA,GAEA,KACA,mBACA,0BACA,SAEA,QACA,CAAO,CACP,mBACA,MACA,SACU,oBACV,UAEA,SACA,CAAO,CACP,mBACA,gBACA,SAEA,QACA,CAAO,CACP,YACA,yBACA,CAAO,CACP,mBACA,MACA,MACU,oBACV,OAEA,MACA,CAAO,CACP,YACA,iBACA,oCACA,SAEA,QACA,CAAO,CACP,YACA,WACA,gDAEU,SACV,qBACU,uBACV,gBAEA,eACA,CAAO,CACP,mBACA,MACA,cACU,0BACV,cAEA,aACA,CAAO,CACP,KAEA,KACA,MACA,YACA,4BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,MACA,YACA,0BACA,CAAO,CACP,OACA,QACA,aAEA,KACA,QACA,WACA,SACA,MACA,SACA,OACA,eACA,oBACA,KAEA,KACA,QACA,QACA,SACA,OACA,MACA,QACA,QACA,aAEA,KACA,QACA,YACA,qCACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,qCACA,CAAO,CACP,YACA,oCACA,CAAO,CACP,YACA,kCACA,CAAO,CACP,YACA,uCACA,GAEA,KACA,YACA,2BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,gCACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,2CACA,KACA,QACA,KACA,UACA,OACA,OACA,OACA,SACA,gBAEA,KACA,YACA,6BACA,CAAO,CACP,YACA,iCACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,+BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,YACA,2CACA,GAEA,4CACA,KACA,MACA,MACA,QACA,MACA,OACA,OACA,SACA,oBACA,KAEA,KACA,KACA,QACA,QACA,MACA,UACA,OACA,SACA,cACA,KAEA,KACA,YACA,qCACA,OACA,OACA,CAAO,CACP,YACA,2CACO,CACP,YACA,6CACA,CAAO,CACP,YACA,uCACO,CACP,YACA,6CACO,CACP,YACA,2CACO,CACP,YACA,+CACO,CACP,YACA,qDACA,KACA,CACO,CACP,KAEA,KACA,YACA,yBACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,gCACA,CAAO,CACP,YACA,wCACA,CAAO,CACP,KAEA,KACA,YACA,8BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,yBACA,CAAO,CACP,YACA,yBACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,gCACA,CAAO,CACP,YACA,wCACA,CAAO,CACP,KAEA,KACA,MACA,MACA,cACA,OACA,MACA,QACA,SACA,eAEA,KACA,YACA,2BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,OACA,MACA,YACA,6BACA,CAAO,CACP,QACA,aAEA,KACA,QACA,QACA,SACA,OACA,MACA,QACA,OACA,YAEA,KACA,OACA,YACA,8BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,MACA,YACA,+BACA,CAAO,CACP,YACA,iCACA,CAAO,CACP,YACA,2CACA,CAAO,CACP,KAEA,KACA,QACA,YACA,gCACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,KACA,YACA,wCACO,CACP,YACA,mDACA,KACA,CACO,CACP,YACA,wDACO,CACP,YACA,yCACO,CACP,YACA,qDACO,CACP,YACA,iDACO,CACP,YACA,qDACO,CACP,YACA,+DACA,KACA,CACO,CACP,KAEA,KACA,YACA,0BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,KACA,YACA,uBACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,0CACA,CAAO,CACP,YACA,wBACA,CAAO,CACP,YACA,wBACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,gCACA,CAAO,CACP,YACA,wCACA,CAAO,CACP,KAEA,KACA,YACA,gCACA,CAAO,CACP,YACA,yCACO,CACP,YACA,yCACO,CACP,YACA,kCACO,CACP,YACA,mCACO,CACP,YACA,wCACO,CACP,YACA,2CACO,CACP,YACA,oDACA,KACA,CACO,CACP,KAEA,KACA,YACA,yBACA,CAAO,CACP,OACA,UACA,UACA,SACA,YACA,gCACA,CAAO,CACP,YACA,iCACA,CAAO,CACP,YACA,qCACA,CAAO,CACP,KAEA,KACA,YACA,yCACO,CACP,YACA,wCACO,CACP,YACA,yCACO,CACP,YACA,kCACO,CACP,YACA,kCACO,CACP,YACA,wCACO,CACP,YACA,4CACO,CACP,YACA,wDACO,CACP,KAEA,UACA,YACA,yCACO,CACP,YACA,wCACO,CACP,YACA,4CACO,CACP,YACA,kCACO,CACP,YACA,kCACO,CACP,YACA,wCACO,CACP,YACA,4CACO,CACP,YACA,wDACO,CACP,KAEA,KACA,YACA,gCACA,CAAO,CACP,YACA,+BACA,CAAO,CACP,YACA,+BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,kCACA,CAAO,CACP,YACA,+BACA,CAAO,CACP,YACA,sCACA,GAEA,KACA,YACA,iCACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,4BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,gCACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,0CACA,GAEA,KACA,YACA,mCACO,CACP,YACA,0CACO,CACP,YACA,yCACO,CACP,YACA,kCACO,CACP,YACA,wCACO,CACP,YACA,2CACO,CACP,YACA,2CACO,CACP,YACA,uDACO,CACP,KAEA,KACA,MACA,YACA,4BACA,CAAO,CACP,YACA,0BACA,CAAO,CACP,KACA,YACA,4BACA,CAAO,CACP,MACA,QACA,aAEA,KACA,YACA,yCACA,CAAO,CACP,YACA,gDACA,KACA,CACO,CACP,YACA,yDACA,KACA,CACO,CACP,YACA,yCACO,CACP,YACA,oDACO,CACP,YACA,6DACO,CACP,YACA,kDACA,KACA,CACO,CACP,YACA,kEACA,KACA,CACO,CACP,KAEA,KACA,mBACA,QACA,OACU,SACV,OAEA,UACA,UACA,4BAEA,OAEA,KAEA,CAAO,CACP,mBACA,QACA,QACU,sCACV,SACU,iBACV,SAEA,SAEA,CAAO,CACP,mBACA,QACA,QACU,qCACV,QACU,iBACV,QAEA,QAEA,CAAO,CACP,YACA,2BACA,CAAO,CACP,mBACA,QACA,MACU,SACV,MACU,oCACV,MAEA,IAEA,CAAO,CACP,mBACA,QACA,SACU,QACV,SAEA,SACA,SACA,4BAEA,SAEA,OAEA,CAAO,CACP,mBACA,QACA,UACU,SACV,UACU,sCACV,UAEA,QAEA,CAAO,CACP,mBACA,QACA,cACU,SACV,cACU,sCACV,cAEA,YAEA,CAAO,CACP,KAEA,KACA,QACA,YACA,gCACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,2BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,6BACA,CAAO,CACP,YACA,8BACA,CAAO,CACP,YACA,mCACA,CAAO,CACP,KAEA,KACA,EACA,YACA,4BACA,CAAS,CACT,YACA,4BACA,CAAS,CACT,OACA,YACA,4BACA,CAAS,CACT,YACA,0BACA,CAAS,CACT,SACA,UACA,eAEA,CAAQ,kBAER,KACA,MACA,KACA,QACA,SACA,OACA,SACA,SACA,aACA,KAEA,KACA,KACA,QACA,UACA,MACA,UACA,OACA,SACA,eAEA,KACA,MACA,KACA,QACA,MACA,OACA,QACA,SACA,eAEA,SACA,MACA,KACA,QACA,MACA,OACA,QACA,SACA,eAEA,KACA,MACA,WACA,OACA,UACA,MACA,UACA,UACA,eACA,KAEA,6CACA,4CACA,EAiBA,8BAEA,OAAmB,mCAInB,OAHA,YACA,cAEA,CACA,CASA,qBACA,MACA,EAGA,EADA,WAIA,CASA,qBACA,MACA,EAEA,kBACA,EAEA,wCACA,EAEA,CACA,CASA,qBACA,kBACA,EAGA,qBACA,kBACA,QAEA,EAEA,QACA,EAGA,EADA,KAIA,CASA,qBACA,MACA,EAEA,kBACA,EAEA,2BACA,EAEA,CACA,CASA,qBACA,yBACA,EAGA,mBACA,mBACA,kBAEA,EAEA,CACA,CASA,cACA,yBACA,CASA,gBACA,gDACA,CAsCA,kBACA,IAOA,EAUA,EAQA,EAiCA,EA1DA,aACA,cAEA,WACA,qBAKA,EADA,eACA,UACM,eACN,UAEA,IAKA,wBACA,sBACM,0BACN,yBAUA,MAJA,YACA,EACA,6BACA,gBACA,WAEA,0BACA,KACA,UAEA,MACA,KACA,YAAwB,WAAqB,KAC7C,UACA,SACA,KAEA,GACA,EAEA,EAEA,CAGA,EAAQ,IACR,mBAIA,iBAQA,CALA,EADA,qBACA,KAEA,EAGA,gBACA,MAEA,KACA,CAoLA,cAMA,oBAKA,cAEA,UAA6B,QAAgC,EAI7D,OArEA,cACA,IAeA,EAfA,EArOA,YACA,mBAEA,oBACA,sCACA,6BAEA,oEAIA,YAAoB,WAA8B,KAClD,WACA,oBACA,sBAEA,UACA,YAIA,iCACA,EA+MA,GAEA,cACA,cAEA,SACA,CAAU,SAFV,cAEU,YAA0C,CACpD,EACA,EAEA,CAEA,oBACA,gBAIA,EADA,iBACA,YACM,iBACN,YAEA,KAKA,QADA,KACA,IAAoB,WAAmB,IACvC,2BAGA,gBAIA,aACA,UAIA,sBACA,WACA,EACA,YAXA,SAaA,EAsBA,SApLA,KAaA,IAXA,EAGA,EAGA,EAGA,EAEA,UACA,iBACA,8BAEA,sBAKA,SAEA,QADA,IACgB,WAAkB,KAElC,QADA,OACA,CAGA,EADA,eAEA,IACA,gBACA,OAEA,MACA,CAEA,YAIA,QACA,QAAkB,WAAkB,IAIpC,OAFA,KADA,OACA,GAOA,QACA,cAA8B,WAAkB,KAChD,WACA,OACA,MACA,OACA,KACA,MACA,CACA,KACA,CASA,iBAAiC,KAAQ,IAIzC,OAFA,KADA,OACA,GAIA,oBAGA,GAFA,OAEA,YAEA,aACA,OACA,aACA,UAEA,KACA,QACA,YAEA,MAGA,CAGA,SACA,QAAgB,uBAA6C,IAE7D,KADA,OACA,GAEA,QAAsB,uBAA0C,EAGhE,QACA,EA2EA,KAEA,EACA,EAEA,SACA,EACA,CACA,cACA,WACA,eACA,eACA,qCACA,YAAqB,CACrB,SACA,cACA,WACA,WACA,SACA,QACA,OACA,MACA,MACA,IACA,CACA,CAAO,CACP,EAEA,CAOA,YAA4C,GAC5C,iCACA,SACA,eACA,kBACA,UAGA,QACA,CAAK,CACL,WACA,CAAG,CAKC,MAEC,IAFD,IAAO,WACX,QACA,EAAK,8BAML,CAAC,CANK,kCC56DN,EAHA,GAAmB,QACnB,UAAyB,EAAE,4CAA4C,IAAI,GAC3E,uFAEA,YACA,4BACA,2BACA,kBACA,CAAC,UAAoB,CAwDrB,sBACA,eAIA,GAHA,QACA,eACA,cACA,wDACA,iCAIA,4BAEA,cADA,cAEA,yBACA,yBACA,0BACA,wBACA,sBACA,CAmBA,cACA,6BACA,eAEA,uCACA,CAaA,oBACA,yBACA,mBAIA,OAHA,8BACA,UAEA,GAA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A,eACA,CAiBA,OAhBA,+BACA,QACA,MAEA,IACA,EACA,gCACA,mBACA,EACA,mCACA,QACA,EACA,8BAEA,QACA,EACA,CACA,CAAC,+BCvBD,qCAA6C,CAAE,SAAa,EAAC,EAiB7D,OAAe,CAhBf,WACA,kBACA,aACA,aACA,YACA,aACA,CAQA,OAPA,+BACA,kBAIA,MAHA,wEACA,iCAEA,oBACA,EACA,CACA,CAAC,iCChBD,qCAA6C,CAC7C,QACA,CAAC,EAAC,CAOF,cACA,0CACA,cACA,QACA,CAAK,CACL,EACA,GACA,2CACA,QACA,CAAK,CACL,gDACA,QACA,CAAK,CACL,iDACA,QACA,CAAK,CACL,iEACA,QACA,CACA,CAAC,EACD,MAAiC,EAAQ,KAAmD,EAC5F,EAAuC,EAAQ,IAAiD,EAChG,gBACA,iEAA4F,GAAO,kDAAkD,EAAW,kJAChK,aACA,cACA,eACA,CAAK,CACL,CACA,gBACA,iEAA4F,GAAO,6EAA6E,EAAW,kJAC3L,aACA,cACA,eACA,CAAK,CACL,CACA,cACA,2CAAmD,GAAO,2WAC1D,aACA,cACA,eACA,CAAK,CACL,CACA,aACA,yCACA,sDACA","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js","webpack://@hijraah/web/../../node_modules/.pnpm/@jsonhero+path@1.0.21/node_modules/@jsonhero/path/lib/path/slice-path-component.js","webpack://@hijraah/web/../../node_modules/.pnpm/uncrypto@0.1.3/node_modules/uncrypto/dist/crypto.node.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@jsonhero+path@1.0.21/node_modules/@jsonhero/path/lib/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/version.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/jwt.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/tokens.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/json.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/common.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/schemas.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/resources.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/config.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/build.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/messages.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/style.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/eventFilter.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/fetch.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/openTelemetry.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/addMissingVersionField.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/errors.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/eventFilter.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/integrations.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/properties.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/schedules.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/tasks.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/triggers.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/statuses.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/runs.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/requestFilter.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/schemas/api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/webhooks.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/schemas/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/semanticInternalAttributes.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/platform.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/globals.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/taskContext/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/task-context-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.23.8/node_modules/zod-validation-error/dist/esm/utils/joinPath.js","webpack://@hijraah/web/../../node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.23.8/node_modules/zod-validation-error/dist/esm/utils/NonEmptyArray.js","webpack://@hijraah/web/../../node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.23.8/node_modules/zod-validation-error/dist/esm/ValidationError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/retry.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/retries.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClient/errors.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/flattenAttributes.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/styleAttributes.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClient/pagination.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClient/core.js","webpack://@hijraah/web/../../node_modules/.pnpm/eventsource-parser@3.0.2/node_modules/eventsource-parser/dist/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/eventsource-parser@3.0.2/node_modules/eventsource-parser/dist/stream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/links.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/errors.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/getEnv.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClientManager/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClientManager-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/zodfetch.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/ioSerialization.js","webpack://@hijraah/web/../../node_modules/.pnpm/@electric-sql+client@1.0.0-beta.1/node_modules/@electric-sql/client/dist/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/streams/asyncIterableStream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClient/stream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClient/runStream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/apiClient/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/clock/simpleClock.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/clock/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/clock-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/logger/taskLogger.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/logger/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/logger-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runtime/noopRuntimeManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/usage/noopUsageManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/usage/api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/usage-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runtime/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runtime-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/noopManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runMetadata/operations.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/run-metadata-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/waitUntil/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/wait-until-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/timeout/api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/timeout-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runTimelineMetrics/runTimelineMetricsManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/runTimelineMetrics/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/run-timeline-metrics-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/task-catalog/noopTaskCatalog.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/task-catalog/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/task-catalog-api.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/types/tasks.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/types/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/idempotencyKeys.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/utils/durations.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/eventFilterMatches.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+api-logs@0.52.1/node_modules/@opentelemetry/api-logs/build/esm/platform/node/globalThis.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+api-logs@0.52.1/node_modules/@opentelemetry/api-logs/build/esm/internal/global-utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+api-logs@0.52.1/node_modules/@opentelemetry/api-logs/build/esm/NoopLogger.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+api-logs@0.52.1/node_modules/@opentelemetry/api-logs/build/esm/NoopLoggerProvider.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+api-logs@0.52.1/node_modules/@opentelemetry/api-logs/build/esm/api/logs.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+api-logs@0.52.1/node_modules/@opentelemetry/api-logs/build/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/otel/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+core@3.3.17_bufferutil@4.0.9/node_modules/@trigger.dev/core/dist/esm/v3/tracer.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/version.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/tracer.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/cache.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.25.1/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.25.1/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/retry.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/runs.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/shared.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/tasks.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/batch.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/wait.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/waitUntil.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/usage.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/idempotencyKeys.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/tags.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/metadata.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/timeout.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/webhooks.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/schedules/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/envvars.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/auth.js","webpack://@hijraah/web/../../node_modules/.pnpm/@trigger.dev+sdk@3.3.17_bufferutil@4.0.9_zod@3.25.72/node_modules/@trigger.dev/sdk/dist/esm/v3/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/humanize-duration@3.33.0/node_modules/humanize-duration/humanize-duration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@google-cloud+precise-date@4.0.0/node_modules/@google-cloud/precise-date/build/src/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@jsonhero+path@1.0.21/node_modules/@jsonhero/path/lib/path/path-builder.js","webpack://@hijraah/web/../../node_modules/.pnpm/@jsonhero+path@1.0.21/node_modules/@jsonhero/path/lib/path/simple-key-path-component.js","webpack://@hijraah/web/../../node_modules/.pnpm/@jsonhero+path@1.0.21/node_modules/@jsonhero/path/lib/path/wildcard-path-component.js","webpack://@hijraah/web/../../node_modules/.pnpm/@jsonhero+path@1.0.21/node_modules/@jsonhero/path/lib/path/start-path-component.js","webpack://@hijraah/web/../../node_modules/.pnpm/@jsonhero+path@1.0.21/node_modules/@jsonhero/path/lib/path/query-result.js","webpack://@hijraah/web/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/server/request/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ReflectAdapter\", {\n    enumerable: true,\n    get: function() {\n        return ReflectAdapter;\n    }\n});\nclass ReflectAdapter {\n    static get(target, prop, receiver) {\n        const value = Reflect.get(target, prop, receiver);\n        if (typeof value === 'function') {\n            return value.bind(target);\n        }\n        return value;\n    }\n    static set(target, prop, value, receiver) {\n        return Reflect.set(target, prop, value, receiver);\n    }\n    static has(target, prop) {\n        return Reflect.has(target, prop);\n    }\n    static deleteProperty(target, prop) {\n        return Reflect.deleteProperty(target, prop);\n    }\n}\n\n//# sourceMappingURL=reflect.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SlicePathComponent = void 0;\nvar query_result_1 = require(\"./query-result\");\nvar SlicePathComponent = /** @class */ (function () {\n    function SlicePathComponent(startIndex, endIndex) {\n        this.endIndex = null;\n        this.isArray = true;\n        this.startIndex = startIndex;\n        this.endIndex = endIndex;\n    }\n    SlicePathComponent.fromString = function (string) {\n        if (!SlicePathComponent.regex.test(string)) {\n            return null;\n        }\n        SlicePathComponent.regex.lastIndex = 0;\n        var result = SlicePathComponent.regex.exec(string);\n        if (result == null || result.groups == null) {\n            return null;\n        }\n        // try and extract the numbers from the Regex\n        var startResult = result.groups.startIndex;\n        var endResult = result.groups.endIndex;\n        var startIndex = startResult == null || startResult === '' ? 0 : parseInt(startResult, 10);\n        var endIndex = endResult == null ? null : parseInt(endResult, 10);\n        if (startIndex == null && endIndex == null) {\n            return null;\n        }\n        var isStartInteger = Number.isInteger(startIndex);\n        if (!isStartInteger) {\n            return null;\n        }\n        return new SlicePathComponent(startIndex, endIndex);\n    };\n    SlicePathComponent.prototype.toString = function () {\n        return \"[\".concat(this.startIndex).concat(this.endIndex == null ? '' : ':' + this.endIndex, \"]\");\n    };\n    SlicePathComponent.prototype.jsonPointer = function () {\n        throw Error(\"JSON Pointers don't work with wildcards\");\n    };\n    SlicePathComponent.prototype.query = function (results) {\n        var newResults = [];\n        for (var i = 0; i < results.length; i++) {\n            var result = results[i];\n            var object = result.object;\n            if (typeof object !== 'object')\n                continue;\n            if (!Array.isArray(object))\n                continue;\n            var slicedItems = void 0;\n            if (this.endIndex == null) {\n                slicedItems = object.slice(this.startIndex);\n            }\n            else {\n                slicedItems = object.slice(this.startIndex, this.endIndex);\n            }\n            for (var j = 0; j < slicedItems.length; j++) {\n                var slicedItem = slicedItems[j];\n                newResults.push(new query_result_1.default(result.depth + 1, result.path.child(\"\".concat(j + this.startIndex)), slicedItem));\n            }\n        }\n        return newResults;\n    };\n    //pattern that matches [startIndex?:endIndex?]\n    SlicePathComponent.regex = /^\\[(?<startIndex>[0-9]*):(?<endIndex>\\-?[0-9]*)?\\]$/g;\n    return SlicePathComponent;\n}());\nexports.SlicePathComponent = SlicePathComponent;\n","import nodeCrypto from 'node:crypto';\n\nconst subtle = nodeCrypto.webcrypto?.subtle || {};\nconst randomUUID = () => {\n  return nodeCrypto.randomUUID();\n};\nconst getRandomValues = (array) => {\n  return nodeCrypto.webcrypto.getRandomValues(array);\n};\nconst _crypto = {\n  randomUUID,\n  getRandomValues,\n  subtle\n};\n\nexport { _crypto as default, getRandomValues, randomUUID, subtle };\n","\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONHeroPath = void 0;\nvar path_builder_1 = require(\"./path/path-builder\");\nvar query_result_1 = require(\"./path/query-result\");\nvar start_path_component_1 = require(\"./path/start-path-component\");\nvar JSONHeroPath = /** @class */ (function () {\n    function JSONHeroPath(components) {\n        if (typeof components == 'string') {\n            var pathBuilder = new path_builder_1.default();\n            this.components = pathBuilder.parse(components);\n            return;\n        }\n        if (components.length == 0) {\n            components.push(new start_path_component_1.default());\n        }\n        if (!(components[0] instanceof start_path_component_1.default)) {\n            components.unshift(new start_path_component_1.default());\n        }\n        this.components = components;\n    }\n    JSONHeroPath.fromPointer = function (pointer) {\n        var pathBuilder = new path_builder_1.default();\n        return new JSONHeroPath(pathBuilder.parsePointer(pointer));\n    };\n    Object.defineProperty(JSONHeroPath.prototype, \"root\", {\n        get: function () {\n            return new JSONHeroPath(this.components.slice(0, 1));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JSONHeroPath.prototype, \"isRoot\", {\n        get: function () {\n            if (this.components.length > 1)\n                return false;\n            return this.components[0] instanceof start_path_component_1.default;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JSONHeroPath.prototype, \"parent\", {\n        get: function () {\n            if (this.components.length == 1) {\n                return null;\n            }\n            return new JSONHeroPath(this.components.slice(0, -1));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JSONHeroPath.prototype, \"lastComponent\", {\n        get: function () {\n            if (this.components.length === 0)\n                return;\n            return this.components[this.components.length - 1];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    JSONHeroPath.prototype.child = function (key) {\n        var string = this.toString();\n        return new JSONHeroPath(string.concat(\".\".concat(key)));\n    };\n    JSONHeroPath.prototype.replaceComponent = function (index, newKey) {\n        var pathBuilder = new path_builder_1.default();\n        var newComponent = pathBuilder.parseComponent(newKey);\n        var newComponents = __spreadArray([], this.components, true);\n        newComponents[index] = newComponent;\n        return new JSONHeroPath(newComponents);\n    };\n    JSONHeroPath.prototype.toString = function () {\n        return this.components.map(function (component) { return component.toString(); }).join('.');\n    };\n    JSONHeroPath.prototype.jsonPointer = function () {\n        if (this.components.length === 1)\n            return '';\n        return this.components.map(function (component) { return component.jsonPointer(); }).join('/');\n    };\n    JSONHeroPath.prototype.first = function (object, options) {\n        if (options === void 0) { options = { includePath: false }; }\n        var results = this.all(object, options);\n        if (results === null || results.length === 0) {\n            return null;\n        }\n        return results[0];\n    };\n    JSONHeroPath.prototype.all = function (object, options) {\n        if (options === void 0) { options = { includePath: false }; }\n        //if the path is just a wildcard then return the original object\n        if (this.components.length == 0)\n            return [object];\n        if (this.components.length == 1 && this.components[0] instanceof start_path_component_1.default)\n            return [object];\n        var results = [];\n        var firstResult = new query_result_1.default(0, this.root, object);\n        results.push(firstResult);\n        //use the path to traverse the object\n        for (var i = 0; i < this.components.length; i++) {\n            var component = this.components[i];\n            results = component.query(results);\n            if (results === null || results.length === 0) {\n                return [];\n            }\n        }\n        //flatten the result\n        var flattenedResults = results.map(function (result) { return result.flatten(); });\n        if (!options.includePath) {\n            return flattenedResults.map(function (result) { return result.object; });\n        }\n        var all = [];\n        for (var i = 0; i < flattenedResults.length; i++) {\n            var flattenedResult = flattenedResults[i];\n            var object_1 = {\n                value: flattenedResult.object,\n            };\n            if (options.includePath) {\n                object_1.path = flattenedResult.path;\n            }\n            all.push(object_1);\n        }\n        return all;\n    };\n    JSONHeroPath.prototype.set = function (object, newValue) {\n        var allResults = this.all(object, { includePath: true });\n        allResults.forEach(function (_a) {\n            var path = _a.path;\n            var parentPath = path.parent;\n            var parentObject = parentPath === null || parentPath === void 0 ? void 0 : parentPath.first(object);\n            if (!path.lastComponent)\n                return;\n            parentObject[path.lastComponent.toString()] = newValue;\n        });\n    };\n    JSONHeroPath.prototype.merge = function (object, mergeValue) {\n        var allResults = this.all(object, { includePath: true });\n        allResults.forEach(function (_a) {\n            var path = _a.path;\n            var parentPath = path.parent;\n            var parentObject = parentPath === null || parentPath === void 0 ? void 0 : parentPath.first(object);\n            if (!path.lastComponent)\n                return;\n            var existingValue = parentObject[path.lastComponent.toString()];\n            if (Array.isArray(existingValue)) {\n                parentObject[path.lastComponent.toString()] = existingValue.concat([mergeValue].flat());\n            }\n            else {\n                if (typeof mergeValue != 'object' || Array.isArray(mergeValue))\n                    return;\n                for (var key in mergeValue) {\n                    existingValue[key] = mergeValue[key];\n                }\n            }\n        });\n    };\n    return JSONHeroPath;\n}());\nexports.JSONHeroPath = JSONHeroPath;\n","var util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            overrideMap,\n            overrideMap === errorMap ? undefined : errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nvar _ZodEnum_cache, _ZodNativeEnum_cache;\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        var _a, _b;\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    // let regex = `\\\\d{2}:\\\\d{2}:\\\\d{2}`;\n    let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\n    if (args.precision) {\n        regex = `${regex}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        regex = `${regex}(\\\\.\\\\d+)?`;\n    }\n    return regex;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a, _b;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * @deprecated Use z.string().min(1) instead.\n     * @see {@link ZodString.min}\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    constructor() {\n        super(...arguments);\n        _ZodEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\n_ZodEnum_cache = new WeakMap();\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    constructor() {\n        super(...arguments);\n        _ZodNativeEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\n_ZodNativeEnum_cache = new WeakMap();\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result)\n            ? result.then((data) => freeze(data))\n            : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\nfunction custom(check, params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n}\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    datetimeRegex: datetimeRegex,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\nexport { BRAND, DIRTY, EMPTY_PATH, INVALID, NEVER, OK, ParseStatus, ZodType as Schema, ZodAny, ZodArray, ZodBigInt, ZodBoolean, ZodBranded, ZodCatch, ZodDate, ZodDefault, ZodDiscriminatedUnion, ZodEffects, ZodEnum, ZodError, ZodFirstPartyTypeKind, ZodFunction, ZodIntersection, ZodIssueCode, ZodLazy, ZodLiteral, ZodMap, ZodNaN, ZodNativeEnum, ZodNever, ZodNull, ZodNullable, ZodNumber, ZodObject, ZodOptional, ZodParsedType, ZodPipeline, ZodPromise, ZodReadonly, ZodRecord, ZodType as ZodSchema, ZodSet, ZodString, ZodSymbol, ZodEffects as ZodTransformer, ZodTuple, ZodType, ZodUndefined, ZodUnion, ZodUnknown, ZodVoid, addIssueToContext, anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, coerce, custom, dateType as date, datetimeRegex, z as default, errorMap as defaultErrorMap, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, getErrorMap, getParsedType, instanceOfType as instanceof, intersectionType as intersection, isAborted, isAsync, isDirty, isValid, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, objectUtil, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, quotelessJson, recordType as record, setType as set, setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, util, voidType as void, z };\n","export const VERSION = \"3.3.17\";\n//# sourceMappingURL=version.js.map","export const JWT_ALGORITHM = \"HS256\";\nexport const JWT_ISSUER = \"https://id.trigger.dev\";\nexport const JWT_AUDIENCE = \"https://api.trigger.dev\";\nexport async function generateJWT(options) {\n    const { SignJWT } = await import(\"jose\");\n    const secret = new TextEncoder().encode(options.secretKey);\n    return new SignJWT(options.payload)\n        .setIssuer(JWT_ISSUER)\n        .setAudience(JWT_AUDIENCE)\n        .setProtectedHeader({ alg: JWT_ALGORITHM })\n        .setIssuedAt()\n        .setExpirationTime(options.expirationTime ?? \"15m\")\n        .sign(secret);\n}\nexport async function validateJWT(token, apiKey) {\n    const { jwtVerify, errors } = await import(\"jose\");\n    const secret = new TextEncoder().encode(apiKey);\n    try {\n        const { payload } = await jwtVerify(token, secret, {\n            issuer: JWT_ISSUER,\n            audience: JWT_AUDIENCE,\n        });\n        return { ok: true, payload };\n    }\n    catch (error) {\n        if (error instanceof errors.JOSEError) {\n            return {\n                ok: false,\n                error: error.message,\n                code: error.code,\n            };\n        }\n        else {\n            return {\n                ok: false,\n                error: error instanceof Error ? error.message : \"Unknown error\",\n                code: \"ERR_UNKNOWN\",\n            };\n        }\n    }\n}\n//# sourceMappingURL=jwt.js.map","import { z } from \"zod\";\nexport const CreateAuthorizationCodeResponseSchema = z.object({\n    url: z.string().url(),\n    authorizationCode: z.string(),\n});\nexport const GetPersonalAccessTokenRequestSchema = z.object({\n    authorizationCode: z.string(),\n});\nexport const GetPersonalAccessTokenResponseSchema = z.object({\n    token: z\n        .object({\n        token: z.string(),\n        obfuscatedToken: z.string(),\n    })\n        .nullable(),\n});\n//# sourceMappingURL=tokens.js.map","import { z } from \"zod\";\nconst LiteralSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\nexport const DeserializedJsonSchema = z.lazy(() => z.union([LiteralSchema, z.array(DeserializedJsonSchema), z.record(DeserializedJsonSchema)]));\nconst SerializableSchema = z.union([\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.null(),\n    z.date(),\n    z.undefined(),\n    z.symbol(),\n]);\nexport const SerializableJsonSchema = z.lazy(() => z.union([SerializableSchema, z.array(SerializableJsonSchema), z.record(SerializableJsonSchema)]));\n//# sourceMappingURL=json.js.map","import { z } from \"zod\";\nimport { DeserializedJsonSchema } from \"../../schemas/json.js\";\nexport const RunMetadataUpdateOperation = z.object({\n    type: z.literal(\"update\"),\n    value: z.record(z.unknown()),\n});\nexport const RunMetadataSetKeyOperation = z.object({\n    type: z.literal(\"set\"),\n    key: z.string(),\n    value: DeserializedJsonSchema,\n});\nexport const RunMetadataDeleteKeyOperation = z.object({\n    type: z.literal(\"delete\"),\n    key: z.string(),\n});\nexport const RunMetadataAppendKeyOperation = z.object({\n    type: z.literal(\"append\"),\n    key: z.string(),\n    value: DeserializedJsonSchema,\n});\nexport const RunMetadataRemoveFromKeyOperation = z.object({\n    type: z.literal(\"remove\"),\n    key: z.string(),\n    value: DeserializedJsonSchema,\n});\nexport const RunMetadataIncrementKeyOperation = z.object({\n    type: z.literal(\"increment\"),\n    key: z.string(),\n    value: z.number(),\n});\nexport const RunMetadataChangeOperation = z.discriminatedUnion(\"type\", [\n    RunMetadataUpdateOperation,\n    RunMetadataSetKeyOperation,\n    RunMetadataDeleteKeyOperation,\n    RunMetadataAppendKeyOperation,\n    RunMetadataRemoveFromKeyOperation,\n    RunMetadataIncrementKeyOperation,\n]);\nexport const FlushedRunMetadata = z.object({\n    metadata: z.record(DeserializedJsonSchema).optional(),\n    operations: z.array(RunMetadataChangeOperation).optional(),\n    parentOperations: z.array(RunMetadataChangeOperation).optional(),\n    rootOperations: z.array(RunMetadataChangeOperation).optional(),\n});\n// Defaults to 0.5\nexport const MachineCpu = z.union([\n    z.literal(0.25),\n    z.literal(0.5),\n    z.literal(1),\n    z.literal(2),\n    z.literal(4),\n]);\n// Defaults to 1\nexport const MachineMemory = z.union([\n    z.literal(0.25),\n    z.literal(0.5),\n    z.literal(1),\n    z.literal(2),\n    z.literal(4),\n    z.literal(8),\n]);\n// Default is small-1x\nexport const MachinePresetName = z.enum([\n    \"micro\",\n    \"small-1x\",\n    \"small-2x\",\n    \"medium-1x\",\n    \"medium-2x\",\n    \"large-1x\",\n    \"large-2x\",\n]);\nexport const MachineConfig = z.object({\n    cpu: MachineCpu.optional(),\n    memory: MachineMemory.optional(),\n    preset: MachinePresetName.optional(),\n});\nexport const MachinePreset = z.object({\n    name: MachinePresetName,\n    cpu: z.number(),\n    memory: z.number(),\n    centsPerMs: z.number(),\n});\nexport const TaskRunBuiltInError = z.object({\n    type: z.literal(\"BUILT_IN_ERROR\"),\n    name: z.string(),\n    message: z.string(),\n    stackTrace: z.string(),\n});\nexport const TaskRunCustomErrorObject = z.object({\n    type: z.literal(\"CUSTOM_ERROR\"),\n    raw: z.string(),\n});\nexport const TaskRunStringError = z.object({\n    type: z.literal(\"STRING_ERROR\"),\n    raw: z.string(),\n});\nexport const TaskRunInternalError = z.object({\n    type: z.literal(\"INTERNAL_ERROR\"),\n    code: z.enum([\n        \"COULD_NOT_FIND_EXECUTOR\",\n        \"COULD_NOT_FIND_TASK\",\n        \"COULD_NOT_IMPORT_TASK\",\n        \"CONFIGURED_INCORRECTLY\",\n        \"TASK_ALREADY_RUNNING\",\n        \"TASK_EXECUTION_FAILED\",\n        \"TASK_EXECUTION_ABORTED\",\n        \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n        \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n        \"TASK_PROCESS_SIGSEGV\",\n        \"TASK_PROCESS_SIGTERM\",\n        \"TASK_PROCESS_OOM_KILLED\",\n        \"TASK_PROCESS_MAYBE_OOM_KILLED\",\n        \"TASK_RUN_CANCELLED\",\n        \"TASK_INPUT_ERROR\",\n        \"TASK_OUTPUT_ERROR\",\n        \"HANDLE_ERROR_ERROR\",\n        \"GRACEFUL_EXIT_TIMEOUT\",\n        \"TASK_RUN_HEARTBEAT_TIMEOUT\",\n        \"TASK_RUN_CRASHED\",\n        \"MAX_DURATION_EXCEEDED\",\n        \"DISK_SPACE_EXCEEDED\",\n        \"POD_EVICTED\",\n        \"POD_UNKNOWN_ERROR\",\n        \"OUTDATED_SDK_VERSION\",\n        \"TASK_DID_CONCURRENT_WAIT\",\n        \"RECURSIVE_WAIT_DEADLOCK\",\n    ]),\n    message: z.string().optional(),\n    stackTrace: z.string().optional(),\n});\nexport const TaskRunErrorCodes = TaskRunInternalError.shape.code.enum;\nexport const TaskRunError = z.discriminatedUnion(\"type\", [\n    TaskRunBuiltInError,\n    TaskRunCustomErrorObject,\n    TaskRunStringError,\n    TaskRunInternalError,\n]);\nexport const TaskRun = z.object({\n    id: z.string(),\n    payload: z.string(),\n    payloadType: z.string(),\n    context: z.any(),\n    tags: z.array(z.string()),\n    isTest: z.boolean().default(false),\n    createdAt: z.coerce.date(),\n    startedAt: z.coerce.date().default(() => new Date()),\n    idempotencyKey: z.string().optional(),\n    maxAttempts: z.number().optional(),\n    durationMs: z.number().default(0),\n    costInCents: z.number().default(0),\n    baseCostInCents: z.number().default(0),\n    version: z.string().optional(),\n    metadata: z.record(DeserializedJsonSchema).optional(),\n    maxDuration: z.number().optional(),\n});\nexport const TaskRunExecutionTask = z.object({\n    id: z.string(),\n    filePath: z.string(),\n    exportName: z.string(),\n});\nexport const TaskRunExecutionAttempt = z.object({\n    id: z.string(),\n    number: z.number(),\n    startedAt: z.coerce.date(),\n    backgroundWorkerId: z.string(),\n    backgroundWorkerTaskId: z.string(),\n    status: z.string(),\n});\nexport const TaskRunExecutionEnvironment = z.object({\n    id: z.string(),\n    slug: z.string(),\n    type: z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]),\n});\nexport const TaskRunExecutionOrganization = z.object({\n    id: z.string(),\n    slug: z.string(),\n    name: z.string(),\n});\nexport const TaskRunExecutionProject = z.object({\n    id: z.string(),\n    ref: z.string(),\n    slug: z.string(),\n    name: z.string(),\n});\nexport const TaskRunExecutionQueue = z.object({\n    id: z.string(),\n    name: z.string(),\n});\nexport const TaskRunExecutionBatch = z.object({\n    id: z.string(),\n});\nexport const TaskRunExecution = z.object({\n    task: TaskRunExecutionTask,\n    attempt: TaskRunExecutionAttempt,\n    run: TaskRun,\n    queue: TaskRunExecutionQueue,\n    environment: TaskRunExecutionEnvironment,\n    organization: TaskRunExecutionOrganization,\n    project: TaskRunExecutionProject,\n    batch: TaskRunExecutionBatch.optional(),\n    machine: MachinePreset.optional(),\n});\nexport const TaskRunContext = z.object({\n    task: TaskRunExecutionTask,\n    attempt: TaskRunExecutionAttempt.omit({\n        backgroundWorkerId: true,\n        backgroundWorkerTaskId: true,\n    }),\n    run: TaskRun.omit({ payload: true, payloadType: true, metadata: true }),\n    queue: TaskRunExecutionQueue,\n    environment: TaskRunExecutionEnvironment,\n    organization: TaskRunExecutionOrganization,\n    project: TaskRunExecutionProject,\n    batch: TaskRunExecutionBatch.optional(),\n    machine: MachinePreset.optional(),\n});\nexport const TaskRunExecutionRetry = z.object({\n    timestamp: z.number(),\n    delay: z.number(),\n    error: z.unknown().optional(),\n});\nexport const TaskRunExecutionUsage = z.object({\n    durationMs: z.number(),\n});\nexport const TaskRunFailedExecutionResult = z.object({\n    ok: z.literal(false),\n    id: z.string(),\n    error: TaskRunError,\n    retry: TaskRunExecutionRetry.optional(),\n    skippedRetrying: z.boolean().optional(),\n    usage: TaskRunExecutionUsage.optional(),\n    // Optional for now for backwards compatibility\n    taskIdentifier: z.string().optional(),\n    metadata: FlushedRunMetadata.optional(),\n});\nexport const TaskRunSuccessfulExecutionResult = z.object({\n    ok: z.literal(true),\n    id: z.string(),\n    output: z.string().optional(),\n    outputType: z.string(),\n    usage: TaskRunExecutionUsage.optional(),\n    // Optional for now for backwards compatibility\n    taskIdentifier: z.string().optional(),\n    metadata: FlushedRunMetadata.optional(),\n});\nexport const TaskRunExecutionResult = z.discriminatedUnion(\"ok\", [\n    TaskRunSuccessfulExecutionResult,\n    TaskRunFailedExecutionResult,\n]);\nexport const BatchTaskRunExecutionResult = z.object({\n    id: z.string(),\n    items: TaskRunExecutionResult.array(),\n});\nexport const SerializedError = z.object({\n    message: z.string(),\n    name: z.string().optional(),\n    stackTrace: z.string().optional(),\n});\n//# sourceMappingURL=common.js.map","import { z } from \"zod\";\nimport { MachineConfig, MachinePreset, MachinePresetName, TaskRunExecution } from \"./common.js\";\n/*\n    WARNING: Never import anything from ./messages here. If it's needed in both, put it here instead.\n*/\nexport const EnvironmentType = z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]);\nexport const TaskRunExecutionMetric = z.object({\n    name: z.string(),\n    event: z.string(),\n    timestamp: z.number(),\n    duration: z.number(),\n});\nexport const TaskRunExecutionMetrics = z.array(TaskRunExecutionMetric);\nexport const TaskRunExecutionPayload = z.object({\n    execution: TaskRunExecution,\n    traceContext: z.record(z.unknown()),\n    environment: z.record(z.string()).optional(),\n    metrics: TaskRunExecutionMetrics.optional(),\n});\n// **IMPORTANT NOTE**: If you change this schema, make sure it is backwards compatible with the previous version as this also used when a worker signals to the coordinator that a TaskRun is complete.\n// Strategies for not breaking backwards compatibility:\n// 1. Add new fields as optional\n// 2. If a field is required, add a default value\nexport const ProdTaskRunExecution = TaskRunExecution.extend({\n    worker: z.object({\n        id: z.string(),\n        contentHash: z.string(),\n        version: z.string(),\n    }),\n    machine: MachinePreset.default({ name: \"small-1x\", cpu: 1, memory: 1, centsPerMs: 0 }),\n});\nexport const ProdTaskRunExecutionPayload = z.object({\n    execution: ProdTaskRunExecution,\n    traceContext: z.record(z.unknown()),\n    environment: z.record(z.string()).optional(),\n    metrics: TaskRunExecutionMetrics.optional(),\n});\nexport const FixedWindowRateLimit = z.object({\n    type: z.literal(\"fixed-window\"),\n    limit: z.number(),\n    window: z.union([\n        z.object({\n            seconds: z.number(),\n        }),\n        z.object({\n            minutes: z.number(),\n        }),\n        z.object({\n            hours: z.number(),\n        }),\n    ]),\n});\nexport const SlidingWindowRateLimit = z.object({\n    type: z.literal(\"sliding-window\"),\n    limit: z.number(),\n    window: z.union([\n        z.object({\n            seconds: z.number(),\n        }),\n        z.object({\n            minutes: z.number(),\n        }),\n        z.object({\n            hours: z.number(),\n        }),\n    ]),\n});\nexport const RateLimitOptions = z.discriminatedUnion(\"type\", [\n    FixedWindowRateLimit,\n    SlidingWindowRateLimit,\n]);\nexport const RetryOptions = z.object({\n    /** The number of attempts before giving up */\n    maxAttempts: z.number().int().optional(),\n    /** The exponential factor to use when calculating the next retry time.\n     *\n     * Each subsequent retry will be calculated as `previousTimeout * factor`\n     */\n    factor: z.number().optional(),\n    /** The minimum time to wait before retrying */\n    minTimeoutInMs: z.number().int().optional(),\n    /** The maximum time to wait before retrying */\n    maxTimeoutInMs: z.number().int().optional(),\n    /** Randomize the timeout between retries.\n     *\n     * This can be useful to prevent the thundering herd problem where all retries happen at the same time.\n     */\n    randomize: z.boolean().optional(),\n    /** If a run fails with an Out Of Memory (OOM) error and you have this set, it will retry with the machine you specify.\n     * Note: it will not default to this [machine](https://trigger.dev/docs/machines) for new runs, only for failures caused by OOM errors.\n     * So if you frequently have attempts failing with OOM errors, you should set the [default machine](https://trigger.dev/docs/machines) to be higher.\n     */\n    outOfMemory: z\n        .object({\n        machine: MachinePresetName.optional(),\n    })\n        .optional(),\n});\nexport const QueueOptions = z.object({\n    /** You can define a shared queue and then pass the name in to your task.\n     *\n     * @example\n     *\n     * ```ts\n     * const myQueue = queue({\n        name: \"my-queue\",\n        concurrencyLimit: 1,\n      });\n  \n      export const task1 = task({\n        id: \"task-1\",\n        queue: {\n          name: \"my-queue\",\n        },\n        run: async (payload: { message: string }) => {\n          // ...\n        },\n      });\n  \n      export const task2 = task({\n        id: \"task-2\",\n        queue: {\n          name: \"my-queue\",\n        },\n        run: async (payload: { message: string }) => {\n          // ...\n        },\n      });\n     * ```\n     */\n    name: z.string().optional(),\n    /** An optional property that specifies the maximum number of concurrent run executions.\n     *\n     * If this property is omitted, the task can potentially use up the full concurrency of an environment */\n    concurrencyLimit: z.number().int().min(0).max(1000).optional().nullable(),\n});\nexport const ScheduleMetadata = z.object({\n    cron: z.string(),\n    timezone: z.string(),\n});\nconst taskMetadata = {\n    id: z.string(),\n    description: z.string().optional(),\n    queue: QueueOptions.optional(),\n    retry: RetryOptions.optional(),\n    machine: MachineConfig.optional(),\n    triggerSource: z.string().optional(),\n    schedule: ScheduleMetadata.optional(),\n    maxDuration: z.number().optional(),\n};\nexport const TaskMetadata = z.object(taskMetadata);\nexport const TaskFile = z.object({\n    entry: z.string(),\n    out: z.string(),\n});\nconst taskFileMetadata = {\n    filePath: z.string(),\n    exportName: z.string(),\n    entryPoint: z.string(),\n};\nexport const TaskFileMetadata = z.object(taskFileMetadata);\nexport const TaskManifest = z.object({\n    ...taskMetadata,\n    ...taskFileMetadata,\n});\nexport const PostStartCauses = z.enum([\"index\", \"create\", \"restore\"]);\nexport const PreStopCauses = z.enum([\"terminate\"]);\nconst RegexSchema = z.custom((val) => {\n    try {\n        // Check to see if val is a regex\n        return typeof val.test === \"function\";\n    }\n    catch {\n        return false;\n    }\n});\nexport const Config = z.object({\n    project: z.string(),\n    triggerDirectories: z.string().array().optional(),\n    triggerUrl: z.string().optional(),\n    projectDir: z.string().optional(),\n    tsconfigPath: z.string().optional(),\n    retries: z\n        .object({\n        enabledInDev: z.boolean().default(true),\n        default: RetryOptions.optional(),\n    })\n        .optional(),\n    additionalPackages: z.string().array().optional(),\n    additionalFiles: z.string().array().optional(),\n    dependenciesToBundle: z.array(z.union([z.string(), RegexSchema])).optional(),\n    logLevel: z.string().optional(),\n    enableConsoleLogging: z.boolean().optional(),\n    postInstall: z.string().optional(),\n    extraCACerts: z.string().optional(),\n});\nexport const WaitReason = z.enum([\"WAIT_FOR_DURATION\", \"WAIT_FOR_TASK\", \"WAIT_FOR_BATCH\"]);\nexport const TaskRunExecutionLazyAttemptPayload = z.object({\n    runId: z.string(),\n    attemptCount: z.number().optional(),\n    messageId: z.string(),\n    isTest: z.boolean(),\n    traceContext: z.record(z.unknown()),\n    environment: z.record(z.string()).optional(),\n    metrics: TaskRunExecutionMetrics.optional(),\n});\nexport const ManualCheckpointMetadata = z.object({\n    /** NOT a friendly ID */\n    attemptId: z.string(),\n    previousRunStatus: z.string(),\n    previousAttemptStatus: z.string(),\n});\n//# sourceMappingURL=schemas.js.map","import { z } from \"zod\";\nimport { QueueOptions, RetryOptions, ScheduleMetadata } from \"./schemas.js\";\nimport { MachineConfig } from \"./common.js\";\nexport const TaskResource = z.object({\n    id: z.string(),\n    description: z.string().optional(),\n    filePath: z.string(),\n    exportName: z.string(),\n    queue: QueueOptions.optional(),\n    retry: RetryOptions.optional(),\n    machine: MachineConfig.optional(),\n    triggerSource: z.string().optional(),\n    schedule: ScheduleMetadata.optional(),\n    maxDuration: z.number().optional(),\n});\nexport const BackgroundWorkerSourceFileMetadata = z.object({\n    filePath: z.string(),\n    contents: z.string(),\n    contentHash: z.string(),\n    taskIds: z.array(z.string()),\n});\nexport const BackgroundWorkerMetadata = z.object({\n    packageVersion: z.string(),\n    contentHash: z.string(),\n    cliPackageVersion: z.string().optional(),\n    tasks: z.array(TaskResource),\n    sourceFiles: z.array(BackgroundWorkerSourceFileMetadata).optional(),\n});\nexport const ImageDetailsMetadata = z.object({\n    contentHash: z.string(),\n    imageTag: z.string(),\n});\n//# sourceMappingURL=resources.js.map","import { z } from \"zod\";\nimport { DeserializedJsonSchema } from \"../../schemas/json.js\";\nimport { FlushedRunMetadata, MachinePresetName, SerializedError, TaskRunError, } from \"./common.js\";\nimport { BackgroundWorkerMetadata } from \"./resources.js\";\nimport { QueueOptions } from \"./schemas.js\";\nexport const WhoAmIResponseSchema = z.object({\n    userId: z.string(),\n    email: z.string().email(),\n    dashboardUrl: z.string(),\n});\nexport const GetProjectResponseBody = z.object({\n    id: z.string(),\n    externalRef: z.string(),\n    name: z.string(),\n    slug: z.string(),\n    createdAt: z.coerce.date(),\n    organization: z.object({\n        id: z.string(),\n        title: z.string(),\n        slug: z.string(),\n        createdAt: z.coerce.date(),\n    }),\n});\nexport const GetProjectsResponseBody = z.array(GetProjectResponseBody);\nexport const GetProjectEnvResponse = z.object({\n    apiKey: z.string(),\n    name: z.string(),\n    apiUrl: z.string(),\n    projectId: z.string(),\n});\nexport const CreateBackgroundWorkerRequestBody = z.object({\n    localOnly: z.boolean(),\n    metadata: BackgroundWorkerMetadata,\n    supportsLazyAttempts: z.boolean().optional(),\n});\nexport const CreateBackgroundWorkerResponse = z.object({\n    id: z.string(),\n    version: z.string(),\n    contentHash: z.string(),\n});\n//an array of 1, 2, or 3 strings\nconst RunTag = z.string().max(128, \"Tags must be less than 128 characters\");\nexport const RunTags = z.union([RunTag, RunTag.array()]);\nexport const TriggerTaskRequestBody = z.object({\n    payload: z.any(),\n    context: z.any(),\n    options: z\n        .object({\n        concurrencyKey: z.string().optional(),\n        delay: z.string().or(z.coerce.date()).optional(),\n        dependentAttempt: z.string().optional(),\n        dependentBatch: z.string().optional(),\n        idempotencyKey: z.string().optional(),\n        idempotencyKeyTTL: z.string().optional(),\n        lockToVersion: z.string().optional(),\n        machine: MachinePresetName.optional(),\n        maxAttempts: z.number().int().optional(),\n        maxDuration: z.number().optional(),\n        metadata: z.any(),\n        metadataType: z.string().optional(),\n        parentAttempt: z.string().optional(),\n        parentBatch: z.string().optional(),\n        payloadType: z.string().optional(),\n        queue: QueueOptions.optional(),\n        tags: RunTags.optional(),\n        test: z.boolean().optional(),\n        ttl: z.string().or(z.number().nonnegative().int()).optional(),\n    })\n        .optional(),\n});\nexport const TriggerTaskResponse = z.object({\n    id: z.string(),\n});\nexport const BatchTriggerTaskRequestBody = z.object({\n    items: TriggerTaskRequestBody.array(),\n    dependentAttempt: z.string().optional(),\n});\nexport const BatchTriggerTaskItem = z.object({\n    task: z.string(),\n    payload: z.any(),\n    context: z.any(),\n    options: z\n        .object({\n        concurrencyKey: z.string().optional(),\n        delay: z.string().or(z.coerce.date()).optional(),\n        idempotencyKey: z.string().optional(),\n        idempotencyKeyTTL: z.string().optional(),\n        lockToVersion: z.string().optional(),\n        machine: MachinePresetName.optional(),\n        maxAttempts: z.number().int().optional(),\n        maxDuration: z.number().optional(),\n        metadata: z.any(),\n        metadataType: z.string().optional(),\n        parentAttempt: z.string().optional(),\n        payloadType: z.string().optional(),\n        queue: QueueOptions.optional(),\n        tags: RunTags.optional(),\n        test: z.boolean().optional(),\n        ttl: z.string().or(z.number().nonnegative().int()).optional(),\n    })\n        .optional(),\n});\nexport const BatchTriggerTaskV2RequestBody = z.object({\n    items: BatchTriggerTaskItem.array(),\n    dependentAttempt: z.string().optional(),\n});\nexport const BatchTriggerTaskV2Response = z.object({\n    id: z.string(),\n    isCached: z.boolean(),\n    idempotencyKey: z.string().optional(),\n    runs: z.array(z.object({\n        id: z.string(),\n        taskIdentifier: z.string(),\n        isCached: z.boolean(),\n        idempotencyKey: z.string().optional(),\n    })),\n});\nexport const BatchTriggerTaskResponse = z.object({\n    batchId: z.string(),\n    runs: z.string().array(),\n});\nexport const GetBatchResponseBody = z.object({\n    id: z.string(),\n    items: z.array(z.object({\n        id: z.string(),\n        taskRunId: z.string(),\n        status: z.enum([\"PENDING\", \"CANCELED\", \"COMPLETED\", \"FAILED\"]),\n    })),\n});\nexport const AddTagsRequestBody = z.object({\n    tags: RunTags,\n});\nexport const RescheduleRunRequestBody = z.object({\n    delay: z.string().or(z.coerce.date()),\n});\nexport const GetEnvironmentVariablesResponseBody = z.object({\n    variables: z.record(z.string()),\n});\nexport const StartDeploymentIndexingRequestBody = z.object({\n    imageReference: z.string(),\n    selfHosted: z.boolean().optional(),\n});\nexport const StartDeploymentIndexingResponseBody = z.object({\n    id: z.string(),\n    contentHash: z.string(),\n});\nexport const FinalizeDeploymentRequestBody = z.object({\n    imageReference: z.string(),\n    selfHosted: z.boolean().optional(),\n    skipRegistryProxy: z.boolean().optional(),\n    skipPromotion: z.boolean().optional(),\n});\nexport const ExternalBuildData = z.object({\n    buildId: z.string(),\n    buildToken: z.string(),\n    projectId: z.string(),\n});\nexport const InitializeDeploymentResponseBody = z.object({\n    id: z.string(),\n    contentHash: z.string(),\n    shortCode: z.string(),\n    version: z.string(),\n    imageTag: z.string(),\n    externalBuildData: ExternalBuildData.optional().nullable(),\n    registryHost: z.string().optional(),\n});\nexport const InitializeDeploymentRequestBody = z.object({\n    contentHash: z.string(),\n    userId: z.string().optional(),\n    registryHost: z.string().optional(),\n    selfHosted: z.boolean().optional(),\n    namespace: z.string().optional(),\n});\nexport const DeploymentErrorData = z.object({\n    name: z.string(),\n    message: z.string(),\n    stack: z.string().optional(),\n    stderr: z.string().optional(),\n});\nexport const FailDeploymentRequestBody = z.object({\n    error: DeploymentErrorData,\n});\nexport const FailDeploymentResponseBody = z.object({\n    id: z.string(),\n});\nexport const PromoteDeploymentResponseBody = z.object({\n    id: z.string(),\n    version: z.string(),\n    shortCode: z.string(),\n});\nexport const GetDeploymentResponseBody = z.object({\n    id: z.string(),\n    status: z.enum([\n        \"PENDING\",\n        \"BUILDING\",\n        \"DEPLOYING\",\n        \"DEPLOYED\",\n        \"FAILED\",\n        \"CANCELED\",\n        \"TIMED_OUT\",\n    ]),\n    contentHash: z.string(),\n    shortCode: z.string(),\n    version: z.string(),\n    imageReference: z.string().nullish(),\n    errorData: DeploymentErrorData.nullish(),\n    worker: z\n        .object({\n        id: z.string(),\n        version: z.string(),\n        tasks: z.array(z.object({\n            id: z.string(),\n            slug: z.string(),\n            filePath: z.string(),\n            exportName: z.string(),\n        })),\n    })\n        .optional(),\n});\nexport const CreateUploadPayloadUrlResponseBody = z.object({\n    presignedUrl: z.string(),\n});\nexport const ReplayRunResponse = z.object({\n    id: z.string(),\n});\nexport const CanceledRunResponse = z.object({\n    id: z.string(),\n});\nexport const ScheduleType = z.union([z.literal(\"DECLARATIVE\"), z.literal(\"IMPERATIVE\")]);\nexport const ScheduledTaskPayload = z.object({\n    /** The schedule id associated with this run (you can have many schedules for the same task).\n      You can use this to remove the schedule, update it, etc */\n    scheduleId: z.string(),\n    /** The type of schedule  `\"DECLARATIVE\"` or `\"IMPERATIVE\"`.\n     *\n     * **DECLARATIVE**  defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.\n     *\n     * **IMPERATIVE**  created using the `schedules.create` functions or in the dashboard.\n     */\n    type: ScheduleType,\n    /** When the task was scheduled to run.\n     * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.\n     *\n     * This date is UTC. To output it as a string with a timezone you would do this:\n     * ```ts\n     * const formatted = payload.timestamp.toLocaleString(\"en-US\", {\n          timeZone: payload.timezone,\n      });\n      ```  */\n    timestamp: z.date(),\n    /** When the task was last run (it has been).\n      This can be undefined if it's never been run. This date is UTC. */\n    lastTimestamp: z.date().optional(),\n    /** You can optionally provide an external id when creating the schedule.\n      Usually you would use a userId or some other unique identifier.\n      This defaults to undefined if you didn't provide one. */\n    externalId: z.string().optional(),\n    /** The IANA timezone the schedule is set to. The default is UTC.\n     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n     */\n    timezone: z.string(),\n    /** The next 5 dates this task is scheduled to run */\n    upcoming: z.array(z.date()),\n});\nexport const CreateScheduleOptions = z.object({\n    /** The id of the task you want to attach to. */\n    task: z.string(),\n    /**  The schedule in CRON format.\n     *\n     * ```txt\n  *    *    *    *    *    *\n                  \n                  |\n                   day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)\n               month (1 - 12)\n           day of month (1 - 31, L)\n       hour (0 - 23)\n   minute (0 - 59)\n     * ```\n  \n  \"L\" means the last. In the \"day of week\" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.\n  \n     */\n    cron: z.string(),\n    /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.\n     *\n     * This is required to prevent you from creating duplicate schedules. */\n    deduplicationKey: z.string(),\n    /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.\n     *\n     * This allows you to have per-user CRON tasks.\n     */\n    externalId: z.string().optional(),\n    /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.\n     * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.\n     *\n     * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.\n     *\n     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n     *\n     * @example \"America/New_York\", \"Europe/London\", \"Asia/Tokyo\", \"Africa/Cairo\"\n     *\n     */\n    timezone: z.string().optional(),\n});\nexport const UpdateScheduleOptions = CreateScheduleOptions.omit({ deduplicationKey: true });\nexport const ScheduleGenerator = z.object({\n    type: z.literal(\"CRON\"),\n    expression: z.string(),\n    description: z.string(),\n});\nexport const ScheduleObject = z.object({\n    id: z.string(),\n    type: ScheduleType,\n    task: z.string(),\n    active: z.boolean(),\n    deduplicationKey: z.string().nullish(),\n    externalId: z.string().nullish(),\n    generator: ScheduleGenerator,\n    timezone: z.string(),\n    nextRun: z.coerce.date().nullish(),\n    environments: z.array(z.object({\n        id: z.string(),\n        type: z.string(),\n        userName: z.string().nullish(),\n    })),\n});\nexport const DeletedScheduleObject = z.object({\n    id: z.string(),\n});\nexport const ListSchedulesResult = z.object({\n    data: z.array(ScheduleObject),\n    pagination: z.object({\n        currentPage: z.number(),\n        totalPages: z.number(),\n        count: z.number(),\n    }),\n});\nexport const ListScheduleOptions = z.object({\n    page: z.number().optional(),\n    perPage: z.number().optional(),\n});\nexport const TimezonesResult = z.object({\n    timezones: z.array(z.string()),\n});\nexport const RunStatus = z.enum([\n    /// Task hasn't been deployed yet but is waiting to be executed\n    \"WAITING_FOR_DEPLOY\",\n    /// Task is waiting to be executed by a worker\n    \"QUEUED\",\n    /// Task is currently being executed by a worker\n    \"EXECUTING\",\n    /// Task has failed and is waiting to be retried\n    \"REATTEMPTING\",\n    /// Task has been paused by the system, and will be resumed by the system\n    \"FROZEN\",\n    /// Task has been completed successfully\n    \"COMPLETED\",\n    /// Task has been canceled by the user\n    \"CANCELED\",\n    /// Task has been completed with errors\n    \"FAILED\",\n    /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage\n    \"CRASHED\",\n    /// Task was interrupted during execution, mostly this happens in development environments\n    \"INTERRUPTED\",\n    /// Task has failed to complete, due to an error in the system\n    \"SYSTEM_FAILURE\",\n    /// Task has been scheduled to run at a specific time\n    \"DELAYED\",\n    /// Task has expired and won't be executed\n    \"EXPIRED\",\n    /// Task has reached it's maxDuration and has been stopped\n    \"TIMED_OUT\",\n]);\nexport const AttemptStatus = z.enum([\n    \"PENDING\",\n    \"EXECUTING\",\n    \"PAUSED\",\n    \"COMPLETED\",\n    \"FAILED\",\n    \"CANCELED\",\n]);\nexport const RunEnvironmentDetails = z.object({\n    id: z.string(),\n    name: z.string(),\n    user: z.string().optional(),\n});\nexport const RunScheduleDetails = z.object({\n    id: z.string(),\n    externalId: z.string().optional(),\n    deduplicationKey: z.string().optional(),\n    generator: ScheduleGenerator,\n});\nexport const TriggerFunction = z.enum([\n    \"triggerAndWait\",\n    \"trigger\",\n    \"batchTriggerAndWait\",\n    \"batchTrigger\",\n]);\nconst CommonRunFields = {\n    id: z.string(),\n    status: RunStatus,\n    taskIdentifier: z.string(),\n    idempotencyKey: z.string().optional(),\n    version: z.string().optional(),\n    isQueued: z.boolean(),\n    isExecuting: z.boolean(),\n    isCompleted: z.boolean(),\n    isSuccess: z.boolean(),\n    isFailed: z.boolean(),\n    isCancelled: z.boolean(),\n    isTest: z.boolean(),\n    createdAt: z.coerce.date(),\n    updatedAt: z.coerce.date(),\n    startedAt: z.coerce.date().optional(),\n    finishedAt: z.coerce.date().optional(),\n    delayedUntil: z.coerce.date().optional(),\n    ttl: z.string().optional(),\n    expiredAt: z.coerce.date().optional(),\n    tags: z.string().array(),\n    costInCents: z.number(),\n    baseCostInCents: z.number(),\n    durationMs: z.number(),\n    metadata: z.record(z.any()).optional(),\n};\nconst RetrieveRunCommandFields = {\n    ...CommonRunFields,\n    depth: z.number(),\n    triggerFunction: z.enum([\"triggerAndWait\", \"trigger\", \"batchTriggerAndWait\", \"batchTrigger\"]),\n    batchId: z.string().optional(),\n};\nexport const RelatedRunDetails = z.object(RetrieveRunCommandFields);\nexport const RetrieveRunResponse = z.object({\n    ...RetrieveRunCommandFields,\n    payload: z.any().optional(),\n    payloadPresignedUrl: z.string().optional(),\n    output: z.any().optional(),\n    outputPresignedUrl: z.string().optional(),\n    error: SerializedError.optional(),\n    schedule: RunScheduleDetails.optional(),\n    relatedRuns: z.object({\n        root: RelatedRunDetails.optional(),\n        parent: RelatedRunDetails.optional(),\n        children: z.array(RelatedRunDetails).optional(),\n    }),\n    attempts: z.array(z\n        .object({\n        id: z.string(),\n        status: AttemptStatus,\n        createdAt: z.coerce.date(),\n        updatedAt: z.coerce.date(),\n        startedAt: z.coerce.date().optional(),\n        completedAt: z.coerce.date().optional(),\n        error: SerializedError.optional(),\n    })\n        .optional()),\n    attemptCount: z.number().default(0),\n});\nexport const ListRunResponseItem = z.object({\n    ...CommonRunFields,\n    env: RunEnvironmentDetails,\n});\nexport const ListRunResponse = z.object({\n    data: z.array(ListRunResponseItem),\n    pagination: z.object({\n        next: z.string().optional(),\n        previous: z.string().optional(),\n    }),\n});\nexport const CreateEnvironmentVariableRequestBody = z.object({\n    name: z.string(),\n    value: z.string(),\n});\nexport const UpdateEnvironmentVariableRequestBody = z.object({\n    value: z.string(),\n});\nexport const ImportEnvironmentVariablesRequestBody = z.object({\n    variables: z.record(z.string()),\n    override: z.boolean().optional(),\n});\nexport const EnvironmentVariableResponseBody = z.object({\n    success: z.boolean(),\n});\nexport const EnvironmentVariableValue = z.object({\n    value: z.string(),\n});\nexport const EnvironmentVariable = z.object({\n    name: z.string(),\n    value: z.string(),\n});\nexport const EnvironmentVariables = z.array(EnvironmentVariable);\nexport const UpdateMetadataRequestBody = FlushedRunMetadata;\nexport const UpdateMetadataResponseBody = z.object({\n    metadata: z.record(DeserializedJsonSchema),\n});\nconst RawShapeDate = z\n    .string()\n    .transform((val) => `${val}Z`)\n    .pipe(z.coerce.date());\nconst RawOptionalShapeDate = z\n    .string()\n    .nullish()\n    .transform((val) => (val ? new Date(`${val}Z`) : val));\nexport const SubscribeRunRawShape = z.object({\n    id: z.string(),\n    idempotencyKey: z.string().nullish(),\n    createdAt: RawShapeDate,\n    updatedAt: RawShapeDate,\n    startedAt: RawOptionalShapeDate,\n    delayUntil: RawOptionalShapeDate,\n    queuedAt: RawOptionalShapeDate,\n    expiredAt: RawOptionalShapeDate,\n    completedAt: RawOptionalShapeDate,\n    taskIdentifier: z.string(),\n    friendlyId: z.string(),\n    number: z.number(),\n    isTest: z.boolean(),\n    status: z.string(),\n    usageDurationMs: z.number(),\n    costInCents: z.number(),\n    baseCostInCents: z.number(),\n    ttl: z.string().nullish(),\n    payload: z.string().nullish(),\n    payloadType: z.string().nullish(),\n    metadata: z.string().nullish(),\n    metadataType: z.string().nullish(),\n    output: z.string().nullish(),\n    outputType: z.string().nullish(),\n    runTags: z.array(z.string()).nullish().default([]),\n    error: TaskRunError.nullish(),\n});\nexport const BatchStatus = z.enum([\"PENDING\", \"COMPLETED\"]);\nexport const RetrieveBatchResponse = z.object({\n    id: z.string(),\n    status: BatchStatus,\n    idempotencyKey: z.string().optional(),\n    createdAt: z.coerce.date(),\n    updatedAt: z.coerce.date(),\n    runCount: z.number(),\n});\nexport const SubscribeRealtimeStreamChunkRawShape = z.object({\n    id: z.string(),\n    runId: z.string(),\n    sequence: z.number(),\n    key: z.string(),\n    value: z.string(),\n    createdAt: z.coerce.date(),\n});\n//# sourceMappingURL=api.js.map","import { z } from \"zod\";\nexport const ConfigManifest = z.object({\n    project: z.string(),\n    dirs: z.string().array(),\n});\n//# sourceMappingURL=config.js.map","import { z } from \"zod\";\nimport { ConfigManifest } from \"./config.js\";\nimport { TaskFile, TaskManifest } from \"./schemas.js\";\nexport const BuildExternal = z.object({\n    name: z.string(),\n    version: z.string(),\n});\nexport const BuildTarget = z.enum([\"dev\", \"deploy\"]);\nexport const BuildRuntime = z.enum([\"node\", \"bun\"]);\nexport const BuildManifest = z.object({\n    target: BuildTarget,\n    packageVersion: z.string(),\n    cliPackageVersion: z.string(),\n    contentHash: z.string(),\n    runtime: BuildRuntime,\n    environment: z.string(),\n    config: ConfigManifest,\n    files: z.array(TaskFile),\n    sources: z.record(z.object({\n        contents: z.string(),\n        contentHash: z.string(),\n    })),\n    outputPath: z.string(),\n    runWorkerEntryPoint: z.string(), // Dev & Deploy has a runWorkerEntryPoint\n    runControllerEntryPoint: z.string().optional(), // Only deploy has a runControllerEntryPoint\n    indexWorkerEntryPoint: z.string(), // Dev & Deploy has a indexWorkerEntryPoint\n    indexControllerEntryPoint: z.string().optional(), // Only deploy has a indexControllerEntryPoint\n    loaderEntryPoint: z.string().optional(),\n    configPath: z.string(),\n    externals: BuildExternal.array().optional(),\n    build: z.object({\n        env: z.record(z.string()).optional(),\n        commands: z.array(z.string()).optional(),\n    }),\n    customConditions: z.array(z.string()).optional(),\n    deploy: z.object({\n        env: z.record(z.string()).optional(),\n        sync: z\n            .object({\n            env: z.record(z.string()).optional(),\n        })\n            .optional(),\n    }),\n    image: z\n        .object({\n        pkgs: z.array(z.string()).optional(),\n        instructions: z.array(z.string()).optional(),\n    })\n        .optional(),\n    otelImportHook: z\n        .object({\n        include: z.array(z.string()).optional(),\n        exclude: z.array(z.string()).optional(),\n    })\n        .optional(),\n});\nexport const IndexMessage = z.object({\n    type: z.literal(\"index\"),\n    data: z.object({\n        build: BuildManifest,\n    }),\n});\nexport const WorkerManifest = z.object({\n    configPath: z.string(),\n    tasks: TaskManifest.array(),\n    workerEntryPoint: z.string(),\n    controllerEntryPoint: z.string().optional(),\n    loaderEntryPoint: z.string().optional(),\n    runtime: BuildRuntime,\n    customConditions: z.array(z.string()).optional(),\n    otelImportHook: z\n        .object({\n        include: z.array(z.string()).optional(),\n        exclude: z.array(z.string()).optional(),\n    })\n        .optional(),\n});\nexport const WorkerManifestMessage = z.object({\n    type: z.literal(\"worker-manifest\"),\n    data: z.object({\n        manifest: WorkerManifest,\n    }),\n});\nexport const ImportError = z.object({\n    message: z.string(),\n    file: z.string(),\n    stack: z.string().optional(),\n    name: z.string().optional(),\n});\nexport const ImportTaskFileErrors = z.array(ImportError);\n//# sourceMappingURL=build.js.map","import { z } from \"zod\";\nimport { ImportTaskFileErrors, WorkerManifest } from \"./build.js\";\nimport { MachinePreset, TaskRunExecution, TaskRunExecutionResult, TaskRunFailedExecutionResult, TaskRunInternalError, } from \"./common.js\";\nimport { TaskResource } from \"./resources.js\";\nimport { EnvironmentType, ProdTaskRunExecution, ProdTaskRunExecutionPayload, TaskRunExecutionLazyAttemptPayload, TaskRunExecutionMetrics, WaitReason, } from \"./schemas.js\";\nexport const AckCallbackResult = z.discriminatedUnion(\"success\", [\n    z.object({\n        success: z.literal(false),\n        error: z.object({\n            name: z.string(),\n            message: z.string(),\n            stack: z.string().optional(),\n            stderr: z.string().optional(),\n        }),\n    }),\n    z.object({\n        success: z.literal(true),\n    }),\n]);\nexport const BackgroundWorkerServerMessages = z.discriminatedUnion(\"type\", [\n    z.object({\n        type: z.literal(\"CANCEL_ATTEMPT\"),\n        taskAttemptId: z.string(),\n        taskRunId: z.string(),\n    }),\n    z.object({\n        type: z.literal(\"SCHEDULE_ATTEMPT\"),\n        image: z.string(),\n        version: z.string(),\n        machine: MachinePreset,\n        nextAttemptNumber: z.number().optional(),\n        // identifiers\n        id: z.string().optional(), // TODO: Remove this completely in a future release\n        envId: z.string(),\n        envType: EnvironmentType,\n        orgId: z.string(),\n        projectId: z.string(),\n        runId: z.string(),\n        dequeuedAt: z.number().optional(),\n    }),\n    z.object({\n        type: z.literal(\"EXECUTE_RUN_LAZY_ATTEMPT\"),\n        payload: TaskRunExecutionLazyAttemptPayload,\n    }),\n]);\nexport const serverWebsocketMessages = {\n    SERVER_READY: z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        id: z.string(),\n    }),\n    BACKGROUND_WORKER_MESSAGE: z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        backgroundWorkerId: z.string(),\n        data: BackgroundWorkerServerMessages,\n    }),\n};\nexport const BackgroundWorkerClientMessages = z.discriminatedUnion(\"type\", [\n    z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        type: z.literal(\"TASK_RUN_COMPLETED\"),\n        completion: TaskRunExecutionResult,\n        execution: TaskRunExecution,\n    }),\n    z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        type: z.literal(\"TASK_RUN_FAILED_TO_RUN\"),\n        completion: TaskRunFailedExecutionResult,\n    }),\n    z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        type: z.literal(\"TASK_HEARTBEAT\"),\n        id: z.string(),\n    }),\n    z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        type: z.literal(\"TASK_RUN_HEARTBEAT\"),\n        id: z.string(),\n    }),\n]);\nexport const ServerBackgroundWorker = z.object({\n    id: z.string(),\n    version: z.string(),\n    contentHash: z.string(),\n});\nexport const clientWebsocketMessages = {\n    READY_FOR_TASKS: z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        backgroundWorkerId: z.string(),\n        inProgressRuns: z.string().array().optional(),\n    }),\n    BACKGROUND_WORKER_DEPRECATED: z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        backgroundWorkerId: z.string(),\n    }),\n    BACKGROUND_WORKER_MESSAGE: z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        backgroundWorkerId: z.string(),\n        data: BackgroundWorkerClientMessages,\n    }),\n};\nexport const UncaughtExceptionMessage = z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n    }),\n    origin: z.enum([\"uncaughtException\", \"unhandledRejection\"]),\n});\nexport const TaskMetadataFailedToParseData = z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    tasks: z.unknown(),\n    zodIssues: z.custom((v) => {\n        return Array.isArray(v) && v.every((issue) => typeof issue === \"object\" && \"message\" in issue);\n    }),\n});\nexport const indexerToWorkerMessages = {\n    INDEX_COMPLETE: z.object({\n        version: z.literal(\"v1\").default(\"v1\"),\n        manifest: WorkerManifest,\n        importErrors: ImportTaskFileErrors,\n    }),\n    TASKS_FAILED_TO_PARSE: TaskMetadataFailedToParseData,\n    UNCAUGHT_EXCEPTION: UncaughtExceptionMessage,\n};\nexport const ExecutorToWorkerMessageCatalog = {\n    TASK_RUN_COMPLETED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            execution: TaskRunExecution,\n            result: TaskRunExecutionResult,\n        }),\n    },\n    TASK_HEARTBEAT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            id: z.string(),\n        }),\n    },\n    READY_TO_DISPOSE: {\n        message: z.undefined(),\n    },\n    WAIT_FOR_DURATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            ms: z.number(),\n            now: z.number(),\n            waitThresholdInMs: z.number(),\n        }),\n    },\n    WAIT_FOR_TASK: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            friendlyId: z.string(),\n        }),\n    },\n    WAIT_FOR_BATCH: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            batchFriendlyId: z.string(),\n            runFriendlyIds: z.string().array(),\n        }),\n    },\n    UNCAUGHT_EXCEPTION: {\n        message: UncaughtExceptionMessage,\n    },\n};\nexport const WorkerToExecutorMessageCatalog = {\n    EXECUTE_TASK_RUN: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            execution: TaskRunExecution,\n            traceContext: z.record(z.unknown()),\n            metadata: ServerBackgroundWorker,\n            metrics: TaskRunExecutionMetrics.optional(),\n        }),\n    },\n    TASK_RUN_COMPLETED_NOTIFICATION: {\n        message: z.discriminatedUnion(\"version\", [\n            z.object({\n                version: z.literal(\"v1\"),\n                completion: TaskRunExecutionResult,\n                execution: TaskRunExecution,\n            }),\n            z.object({\n                version: z.literal(\"v2\"),\n                completion: TaskRunExecutionResult,\n            }),\n        ]),\n    },\n    WAIT_COMPLETED_NOTIFICATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n        }),\n    },\n    FLUSH: {\n        message: z.object({\n            timeoutInMs: z.number(),\n        }),\n        callback: z.void(),\n    },\n};\nexport const ProviderToPlatformMessages = {\n    LOG: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            data: z.string(),\n        }),\n    },\n    LOG_WITH_ACK: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            data: z.string(),\n        }),\n        callback: z.object({\n            status: z.literal(\"ok\"),\n        }),\n    },\n    WORKER_CRASHED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            reason: z.string().optional(),\n            exitCode: z.number().optional(),\n            message: z.string().optional(),\n            logs: z.string().optional(),\n            /** This means we should only update the error if one exists */\n            overrideCompletion: z.boolean().optional(),\n            errorCode: TaskRunInternalError.shape.code.optional(),\n        }),\n    },\n    INDEXING_FAILED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            deploymentId: z.string(),\n            error: z.object({\n                name: z.string(),\n                message: z.string(),\n                stack: z.string().optional(),\n                stderr: z.string().optional(),\n            }),\n            overrideCompletion: z.boolean().optional(),\n        }),\n    },\n};\nexport const PlatformToProviderMessages = {\n    INDEX: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            imageTag: z.string(),\n            shortCode: z.string(),\n            apiKey: z.string(),\n            apiUrl: z.string(),\n            // identifiers\n            envId: z.string(),\n            envType: EnvironmentType,\n            orgId: z.string(),\n            projectId: z.string(),\n            deploymentId: z.string(),\n        }),\n        callback: AckCallbackResult,\n    },\n    RESTORE: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            type: z.enum([\"DOCKER\", \"KUBERNETES\"]),\n            location: z.string(),\n            reason: z.string().optional(),\n            imageRef: z.string(),\n            attemptNumber: z.number().optional(),\n            machine: MachinePreset,\n            // identifiers\n            checkpointId: z.string(),\n            envId: z.string(),\n            envType: EnvironmentType,\n            orgId: z.string(),\n            projectId: z.string(),\n            runId: z.string(),\n        }),\n    },\n    PRE_PULL_DEPLOYMENT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            imageRef: z.string(),\n            shortCode: z.string(),\n            // identifiers\n            envId: z.string(),\n            envType: EnvironmentType,\n            orgId: z.string(),\n            projectId: z.string(),\n            deploymentId: z.string(),\n        }),\n    },\n};\nconst CreateWorkerMessage = z.object({\n    projectRef: z.string(),\n    envId: z.string(),\n    deploymentId: z.string(),\n    metadata: z.object({\n        cliPackageVersion: z.string().optional(),\n        contentHash: z.string(),\n        packageVersion: z.string(),\n        tasks: TaskResource.array(),\n    }),\n});\nexport const CoordinatorToPlatformMessages = {\n    LOG: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            metadata: z.any(),\n            text: z.string(),\n        }),\n    },\n    CREATE_WORKER: {\n        message: z.discriminatedUnion(\"version\", [\n            CreateWorkerMessage.extend({\n                version: z.literal(\"v1\"),\n            }),\n            CreateWorkerMessage.extend({\n                version: z.literal(\"v2\"),\n                supportsLazyAttempts: z.boolean(),\n            }),\n        ]),\n        callback: z.discriminatedUnion(\"success\", [\n            z.object({\n                success: z.literal(false),\n            }),\n            z.object({\n                success: z.literal(true),\n            }),\n        ]),\n    },\n    CREATE_TASK_RUN_ATTEMPT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            envId: z.string(),\n        }),\n        callback: z.discriminatedUnion(\"success\", [\n            z.object({\n                success: z.literal(false),\n                reason: z.string().optional(),\n            }),\n            z.object({\n                success: z.literal(true),\n                executionPayload: ProdTaskRunExecutionPayload,\n            }),\n        ]),\n    },\n    // Deprecated: Only workers without lazy attempt support will use this\n    READY_FOR_EXECUTION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            totalCompletions: z.number(),\n        }),\n        callback: z.discriminatedUnion(\"success\", [\n            z.object({\n                success: z.literal(false),\n            }),\n            z.object({\n                success: z.literal(true),\n                payload: ProdTaskRunExecutionPayload,\n            }),\n        ]),\n    },\n    READY_FOR_LAZY_ATTEMPT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            envId: z.string(),\n            totalCompletions: z.number(),\n        }),\n        callback: z.discriminatedUnion(\"success\", [\n            z.object({\n                success: z.literal(false),\n                reason: z.string().optional(),\n            }),\n            z.object({\n                success: z.literal(true),\n                lazyPayload: TaskRunExecutionLazyAttemptPayload,\n            }),\n        ]),\n    },\n    READY_FOR_RESUME: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptFriendlyId: z.string(),\n            type: WaitReason,\n        }),\n    },\n    TASK_RUN_COMPLETED: {\n        message: z.object({\n            version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n            execution: ProdTaskRunExecution,\n            completion: TaskRunExecutionResult,\n            checkpoint: z\n                .object({\n                docker: z.boolean(),\n                location: z.string(),\n            })\n                .optional(),\n        }),\n    },\n    TASK_RUN_COMPLETED_WITH_ACK: {\n        message: z.object({\n            version: z.enum([\"v1\", \"v2\"]).default(\"v2\"),\n            execution: ProdTaskRunExecution,\n            completion: TaskRunExecutionResult,\n            checkpoint: z\n                .object({\n                docker: z.boolean(),\n                location: z.string(),\n            })\n                .optional(),\n        }),\n        callback: AckCallbackResult,\n    },\n    TASK_RUN_FAILED_TO_RUN: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            completion: TaskRunFailedExecutionResult,\n        }),\n    },\n    TASK_HEARTBEAT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptFriendlyId: z.string(),\n        }),\n    },\n    TASK_RUN_HEARTBEAT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n        }),\n    },\n    CHECKPOINT_CREATED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string().optional(),\n            attemptFriendlyId: z.string(),\n            docker: z.boolean(),\n            location: z.string(),\n            reason: z.discriminatedUnion(\"type\", [\n                z.object({\n                    type: z.literal(\"WAIT_FOR_DURATION\"),\n                    ms: z.number(),\n                    now: z.number(),\n                }),\n                z.object({\n                    type: z.literal(\"WAIT_FOR_BATCH\"),\n                    batchFriendlyId: z.string(),\n                    runFriendlyIds: z.string().array(),\n                }),\n                z.object({\n                    type: z.literal(\"WAIT_FOR_TASK\"),\n                    friendlyId: z.string(),\n                }),\n                z.object({\n                    type: z.literal(\"RETRYING_AFTER_FAILURE\"),\n                    attemptNumber: z.number(),\n                }),\n                z.object({\n                    type: z.literal(\"MANUAL\"),\n                    /** If unspecified it will be restored immediately, e.g. for live migration */\n                    restoreAtUnixTimeMs: z.number().optional(),\n                }),\n            ]),\n        }),\n        callback: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            keepRunAlive: z.boolean(),\n        }),\n    },\n    INDEXING_FAILED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            deploymentId: z.string(),\n            error: z.object({\n                name: z.string(),\n                message: z.string(),\n                stack: z.string().optional(),\n                stderr: z.string().optional(),\n            }),\n        }),\n    },\n    RUN_CRASHED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            error: z.object({\n                name: z.string(),\n                message: z.string(),\n                stack: z.string().optional(),\n            }),\n        }),\n    },\n};\nexport const PlatformToCoordinatorMessages = {\n    /** @deprecated use RESUME_AFTER_DEPENDENCY_WITH_ACK instead  */\n    RESUME_AFTER_DEPENDENCY: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            attemptId: z.string(),\n            attemptFriendlyId: z.string(),\n            completions: TaskRunExecutionResult.array(),\n            executions: TaskRunExecution.array(),\n        }),\n    },\n    RESUME_AFTER_DEPENDENCY_WITH_ACK: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            attemptId: z.string(),\n            attemptFriendlyId: z.string(),\n            completions: TaskRunExecutionResult.array(),\n            executions: TaskRunExecution.array(),\n        }),\n        callback: AckCallbackResult,\n    },\n    RESUME_AFTER_DURATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptId: z.string(),\n            attemptFriendlyId: z.string(),\n        }),\n    },\n    REQUEST_ATTEMPT_CANCELLATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptId: z.string(),\n            attemptFriendlyId: z.string(),\n        }),\n    },\n    REQUEST_RUN_CANCELLATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            delayInMs: z.number().optional(),\n        }),\n    },\n    READY_FOR_RETRY: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n        }),\n    },\n    DYNAMIC_CONFIG: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            checkpointThresholdInMs: z.number(),\n        }),\n    },\n};\nexport const ClientToSharedQueueMessages = {\n    READY_FOR_TASKS: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            backgroundWorkerId: z.string(),\n        }),\n    },\n    BACKGROUND_WORKER_DEPRECATED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            backgroundWorkerId: z.string(),\n        }),\n    },\n    BACKGROUND_WORKER_MESSAGE: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            backgroundWorkerId: z.string(),\n            data: BackgroundWorkerClientMessages,\n        }),\n    },\n};\nexport const SharedQueueToClientMessages = {\n    SERVER_READY: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            id: z.string(),\n        }),\n    },\n    BACKGROUND_WORKER_MESSAGE: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            backgroundWorkerId: z.string(),\n            data: BackgroundWorkerServerMessages,\n        }),\n    },\n};\nconst IndexTasksMessage = z.object({\n    version: z.literal(\"v1\"),\n    deploymentId: z.string(),\n    tasks: TaskResource.array(),\n    packageVersion: z.string(),\n});\nexport const ProdWorkerToCoordinatorMessages = {\n    TEST: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n        }),\n        callback: z.void(),\n    },\n    INDEX_TASKS: {\n        message: z.discriminatedUnion(\"version\", [\n            IndexTasksMessage.extend({\n                version: z.literal(\"v1\"),\n            }),\n            IndexTasksMessage.extend({\n                version: z.literal(\"v2\"),\n                supportsLazyAttempts: z.boolean(),\n            }),\n        ]),\n        callback: z.discriminatedUnion(\"success\", [\n            z.object({\n                success: z.literal(false),\n            }),\n            z.object({\n                success: z.literal(true),\n            }),\n        ]),\n    },\n    // Deprecated: Only workers without lazy attempt support will use this\n    READY_FOR_EXECUTION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            totalCompletions: z.number(),\n        }),\n    },\n    READY_FOR_LAZY_ATTEMPT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n            totalCompletions: z.number(),\n            startTime: z.number().optional(),\n        }),\n    },\n    READY_FOR_RESUME: {\n        message: z.discriminatedUnion(\"version\", [\n            z.object({\n                version: z.literal(\"v1\"),\n                attemptFriendlyId: z.string(),\n                type: WaitReason,\n            }),\n            z.object({\n                version: z.literal(\"v2\"),\n                attemptFriendlyId: z.string(),\n                attemptNumber: z.number(),\n                type: WaitReason,\n            }),\n        ]),\n    },\n    READY_FOR_CHECKPOINT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n        }),\n    },\n    CANCEL_CHECKPOINT: {\n        message: z\n            .discriminatedUnion(\"version\", [\n            z.object({\n                version: z.literal(\"v1\"),\n            }),\n            z.object({\n                version: z.literal(\"v2\"),\n                reason: WaitReason.optional(),\n            }),\n        ])\n            .default({ version: \"v1\" }),\n        callback: z.object({\n            version: z.literal(\"v2\").default(\"v2\"),\n            checkpointCanceled: z.boolean(),\n            reason: WaitReason.optional(),\n        }),\n    },\n    TASK_HEARTBEAT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptFriendlyId: z.string(),\n        }),\n    },\n    TASK_RUN_HEARTBEAT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n        }),\n    },\n    TASK_RUN_COMPLETED: {\n        message: z.object({\n            version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n            execution: ProdTaskRunExecution,\n            completion: TaskRunExecutionResult,\n        }),\n        callback: z.object({\n            willCheckpointAndRestore: z.boolean(),\n            shouldExit: z.boolean(),\n        }),\n    },\n    TASK_RUN_FAILED_TO_RUN: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            completion: TaskRunFailedExecutionResult,\n        }),\n    },\n    WAIT_FOR_DURATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            ms: z.number(),\n            now: z.number(),\n            attemptFriendlyId: z.string(),\n        }),\n        callback: z.object({\n            willCheckpointAndRestore: z.boolean(),\n        }),\n    },\n    WAIT_FOR_TASK: {\n        message: z.object({\n            version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n            friendlyId: z.string(),\n            // This is the attempt that is waiting\n            attemptFriendlyId: z.string(),\n        }),\n        callback: z.object({\n            willCheckpointAndRestore: z.boolean(),\n        }),\n    },\n    WAIT_FOR_BATCH: {\n        message: z.object({\n            version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n            batchFriendlyId: z.string(),\n            runFriendlyIds: z.string().array(),\n            // This is the attempt that is waiting\n            attemptFriendlyId: z.string(),\n        }),\n        callback: z.object({\n            willCheckpointAndRestore: z.boolean(),\n        }),\n    },\n    INDEXING_FAILED: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            deploymentId: z.string(),\n            error: z.object({\n                name: z.string(),\n                message: z.string(),\n                stack: z.string().optional(),\n                stderr: z.string().optional(),\n            }),\n        }),\n    },\n    CREATE_TASK_RUN_ATTEMPT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n        }),\n        callback: z.discriminatedUnion(\"success\", [\n            z.object({\n                success: z.literal(false),\n                reason: z.string().optional(),\n            }),\n            z.object({\n                success: z.literal(true),\n                executionPayload: ProdTaskRunExecutionPayload,\n            }),\n        ]),\n    },\n    UNRECOVERABLE_ERROR: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            error: z.object({\n                name: z.string(),\n                message: z.string(),\n                stack: z.string().optional(),\n            }),\n        }),\n    },\n    SET_STATE: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptFriendlyId: z.string().optional(),\n            attemptNumber: z.string().optional(),\n        }),\n    },\n};\n// TODO: The coordinator can only safely use v1 worker messages, higher versions will need a new flag, e.g. SUPPORTS_VERSIONED_MESSAGES\nexport const CoordinatorToProdWorkerMessages = {\n    RESUME_AFTER_DEPENDENCY: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptId: z.string(),\n            completions: TaskRunExecutionResult.array(),\n            executions: TaskRunExecution.array(),\n        }),\n    },\n    RESUME_AFTER_DURATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptId: z.string(),\n        }),\n    },\n    // Deprecated: Only workers without lazy attempt support will use this\n    EXECUTE_TASK_RUN: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            executionPayload: ProdTaskRunExecutionPayload,\n        }),\n    },\n    EXECUTE_TASK_RUN_LAZY_ATTEMPT: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            lazyPayload: TaskRunExecutionLazyAttemptPayload,\n        }),\n    },\n    REQUEST_ATTEMPT_CANCELLATION: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            attemptId: z.string(),\n        }),\n    },\n    REQUEST_EXIT: {\n        message: z.discriminatedUnion(\"version\", [\n            z.object({\n                version: z.literal(\"v1\"),\n            }),\n            z.object({\n                version: z.literal(\"v2\"),\n                delayInMs: z.number().optional(),\n            }),\n        ]),\n    },\n    READY_FOR_RETRY: {\n        message: z.object({\n            version: z.literal(\"v1\").default(\"v1\"),\n            runId: z.string(),\n        }),\n    },\n};\nexport const ProdWorkerSocketData = z.object({\n    contentHash: z.string(),\n    projectRef: z.string(),\n    envId: z.string(),\n    runId: z.string(),\n    attemptFriendlyId: z.string().optional(),\n    attemptNumber: z.string().optional(),\n    podName: z.string(),\n    deploymentId: z.string(),\n    deploymentVersion: z.string(),\n    requiresCheckpointResumeWithMessage: z.string().optional(),\n});\nexport const CoordinatorSocketData = z.object({\n    supportsDynamicConfig: z.string().optional(),\n});\n//# sourceMappingURL=messages.js.map","import { z } from \"zod\";\nexport const PRIMARY_VARIANT = \"primary\";\nconst Variant = z.enum([PRIMARY_VARIANT]);\nconst AccessoryItem = z.object({\n    text: z.string(),\n    variant: z.string().optional(),\n    url: z.string().optional(),\n});\nconst Accessory = z.object({\n    items: z.array(AccessoryItem),\n    style: z.enum([\"codepath\"]).optional(),\n});\nexport const TaskEventStyle = z\n    .object({\n    icon: z.string().optional(),\n    variant: Variant.optional(),\n    accessory: Accessory.optional(),\n})\n    .default({\n    icon: undefined,\n    variant: undefined,\n});\n//# sourceMappingURL=style.js.map","import { z } from \"zod\";\nexport const stringPatternMatchers = [\n    z.object({\n        $endsWith: z.string(),\n    }),\n    z.object({\n        $startsWith: z.string(),\n    }),\n    z.object({\n        $ignoreCaseEquals: z.string(),\n    }),\n];\nconst EventMatcher = z.union([\n    /** Match against a string */\n    z.array(z.string()),\n    /** Match against a number */\n    z.array(z.number()),\n    /** Match against a boolean */\n    z.array(z.boolean()),\n    z.array(z.union([\n        ...stringPatternMatchers,\n        z.object({\n            $exists: z.boolean(),\n        }),\n        z.object({\n            $isNull: z.boolean(),\n        }),\n        z.object({\n            $anythingBut: z.union([z.string(), z.number(), z.boolean()]),\n        }),\n        z.object({\n            $anythingBut: z.union([z.array(z.string()), z.array(z.number()), z.array(z.boolean())]),\n        }),\n        z.object({\n            $gt: z.number(),\n        }),\n        z.object({\n            $lt: z.number(),\n        }),\n        z.object({\n            $gte: z.number(),\n        }),\n        z.object({\n            $lte: z.number(),\n        }),\n        z.object({\n            $between: z.tuple([z.number(), z.number()]),\n        }),\n        z.object({\n            $includes: z.union([z.string(), z.number(), z.boolean()]),\n        }),\n        z.object({\n            $not: z.union([z.string(), z.number(), z.boolean()]),\n        }),\n    ])),\n]);\nexport const EventFilter = z.lazy(() => z.record(z.union([EventMatcher, EventFilter])));\n//# sourceMappingURL=eventFilter.js.map","import { z } from \"zod\";\nimport { RetryOptions } from \"./schemas.js\";\nimport { EventFilter } from \"./eventFilter.js\";\nexport const FetchRetryHeadersStrategy = z.object({\n    /** The `headers` strategy retries the request using info from the response headers. */\n    strategy: z.literal(\"headers\"),\n    /** The header to use to determine the maximum number of times to retry the request. */\n    limitHeader: z.string(),\n    /** The header to use to determine the number of remaining retries. */\n    remainingHeader: z.string(),\n    /** The header to use to determine the time when the number of remaining retries will be reset. */\n    resetHeader: z.string(),\n    /** The event filter to use to determine if the request should be retried. */\n    bodyFilter: EventFilter.optional(),\n    /** The format of the `resetHeader` value. */\n    resetFormat: z\n        .enum([\n        \"unix_timestamp\",\n        \"unix_timestamp_in_ms\",\n        \"iso_8601\",\n        \"iso_8601_duration_openai_variant\",\n    ])\n        .default(\"unix_timestamp\")\n        .optional(),\n});\nexport const FetchRetryBackoffStrategy = RetryOptions.extend({\n    /** The `backoff` strategy retries the request with an exponential backoff. */\n    strategy: z.literal(\"backoff\"),\n    /** The event filter to use to determine if the request should be retried. */\n    bodyFilter: EventFilter.optional(),\n});\nexport const FetchRetryStrategy = z.discriminatedUnion(\"strategy\", [\n    FetchRetryHeadersStrategy,\n    FetchRetryBackoffStrategy,\n]);\nexport const FetchRetryByStatusOptions = z.record(z.string(), FetchRetryStrategy);\nexport const FetchTimeoutOptions = z.object({\n    /** The maximum time to wait for the request to complete. */\n    durationInMs: z.number().optional(),\n    retry: RetryOptions.optional(),\n});\nexport const FetchRetryOptions = z.object({\n    /** The retrying strategy for specific status codes. */\n    byStatus: FetchRetryByStatusOptions.optional(),\n    /** The timeout options for the request. */\n    timeout: RetryOptions.optional(),\n    /**\n     * The retrying strategy for connection errors.\n     */\n    connectionError: RetryOptions.optional(),\n});\n//# sourceMappingURL=fetch.js.map","import { z } from \"zod\";\nexport const ExceptionEventProperties = z.object({\n    type: z.string().optional(),\n    message: z.string().optional(),\n    stacktrace: z.string().optional(),\n});\nexport const ExceptionSpanEvent = z.object({\n    name: z.literal(\"exception\"),\n    time: z.coerce.date(),\n    properties: z.object({\n        exception: ExceptionEventProperties,\n    }),\n});\nexport const CancellationSpanEvent = z.object({\n    name: z.literal(\"cancellation\"),\n    time: z.coerce.date(),\n    properties: z.object({\n        reason: z.string(),\n    }),\n});\nexport const OtherSpanEvent = z.object({\n    name: z.string(),\n    time: z.coerce.date(),\n    properties: z.record(z.unknown()),\n});\nexport const SpanEvent = z.union([ExceptionSpanEvent, CancellationSpanEvent, OtherSpanEvent]);\nexport const SpanEvents = z.array(SpanEvent);\nexport function isExceptionSpanEvent(event) {\n    return event.name === \"exception\";\n}\nexport function isCancellationSpanEvent(event) {\n    return event.name === \"cancellation\";\n}\nexport const SpanMessagingEvent = z.object({\n    system: z.string().optional(),\n    client_id: z.string().optional(),\n    operation: z.enum([\"publish\", \"create\", \"receive\", \"deliver\"]),\n    message: z.any(),\n    destination: z.string().optional(),\n});\n//# sourceMappingURL=openTelemetry.js.map","export function addMissingVersionField(val) {\n    if (val !== null && typeof val === \"object\" && !(\"version\" in val)) {\n        return {\n            ...val,\n            version: \"1\",\n        };\n    }\n    return val;\n}\n//# sourceMappingURL=addMissingVersionField.js.map","import { z } from \"zod\";\nexport const ErrorWithStackSchema = z.object({\n    message: z.string(),\n    name: z.string().optional(),\n    stack: z.string().optional(),\n});\nexport const SchemaErrorSchema = z.object({\n    path: z.array(z.string()),\n    message: z.string(),\n});\n//# sourceMappingURL=errors.js.map","import { z } from \"zod\";\nexport const stringPatternMatchers = [\n    z.object({\n        $endsWith: z.string(),\n    }),\n    z.object({\n        $startsWith: z.string(),\n    }),\n    z.object({\n        $ignoreCaseEquals: z.string(),\n    }),\n];\nconst EventMatcherSchema = z.union([\n    /** Match against a string */\n    z.array(z.string()),\n    /** Match against a number */\n    z.array(z.number()),\n    /** Match against a boolean */\n    z.array(z.boolean()),\n    z.array(z.union([\n        ...stringPatternMatchers,\n        z.object({\n            $exists: z.boolean(),\n        }),\n        z.object({\n            $isNull: z.boolean(),\n        }),\n        z.object({\n            $anythingBut: z.union([z.string(), z.number(), z.boolean()]),\n        }),\n        z.object({\n            $anythingBut: z.union([z.array(z.string()), z.array(z.number()), z.array(z.boolean())]),\n        }),\n        z.object({\n            $gt: z.number(),\n        }),\n        z.object({\n            $lt: z.number(),\n        }),\n        z.object({\n            $gte: z.number(),\n        }),\n        z.object({\n            $lte: z.number(),\n        }),\n        z.object({\n            $between: z.tuple([z.number(), z.number()]),\n        }),\n        z.object({\n            $includes: z.union([z.string(), z.number(), z.boolean()]),\n        }),\n        z.object({\n            $not: z.union([z.string(), z.number(), z.boolean()])\n        })\n    ])),\n]);\nexport const EventFilterSchema = z.lazy(() => z.record(z.union([EventMatcherSchema, EventFilterSchema])));\nexport const EventRuleSchema = z.object({\n    event: z.string().or(z.array(z.string())),\n    source: z.string(),\n    payload: EventFilterSchema.optional(),\n    context: EventFilterSchema.optional(),\n});\n//# sourceMappingURL=eventFilter.js.map","import { z } from \"zod\";\nexport const ConnectionAuthSchema = z.object({\n    type: z.enum([\"oauth2\", \"apiKey\"]),\n    accessToken: z.string(),\n    scopes: z.array(z.string()).optional(),\n    additionalFields: z.record(z.string()).optional(),\n});\nexport const IntegrationMetadataSchema = z.object({\n    id: z.string(),\n    name: z.string(),\n    instructions: z.string().optional(),\n});\nexport const IntegrationConfigSchema = z.object({\n    id: z.string(),\n    metadata: IntegrationMetadataSchema,\n    authSource: z.enum([\"HOSTED\", \"LOCAL\", \"RESOLVER\"]),\n});\n//# sourceMappingURL=integrations.js.map","import { z } from \"zod\";\n/** A property that is displayed in the logs */\nexport const DisplayPropertySchema = z.object({\n    /** The label for the property */\n    label: z.string(),\n    /** The value of the property */\n    text: z.string(),\n    /** The URL to link to when the property is clicked */\n    url: z.string().optional(),\n    /** The URL to a list of images to display next to the property */\n    imageUrl: z.array(z.string()).optional(),\n});\nexport const DisplayPropertiesSchema = z.array(DisplayPropertySchema);\nexport const StyleSchema = z.object({\n    /** The style, `normal` or `minimal` */\n    style: z.enum([\"normal\", \"minimal\"]),\n    /** A variant of the style. */\n    variant: z.string().optional(),\n});\n//# sourceMappingURL=properties.js.map","import { z } from \"zod\";\nexport const SCHEDULED_EVENT = \"dev.trigger.scheduled\";\nexport const ScheduledPayloadSchema = z.object({\n    ts: z.coerce.date(),\n    lastTimestamp: z.coerce.date().optional(),\n});\nexport const IntervalOptionsSchema = z.object({\n    /** The number of seconds for the interval. Min = 20, Max = 2_592_000 (30 days) */\n    seconds: z.number().int().positive().min(20).max(2_592_000),\n});\nexport const CronOptionsSchema = z.object({\n    /** A CRON expression that defines the schedule. A useful tool when writing CRON\n      expressions is [crontab guru](https://crontab.guru). Note that the timezone\n      used is UTC. */\n    cron: z.string(),\n});\nexport const CronMetadataSchema = z.object({\n    type: z.literal(\"cron\"),\n    options: CronOptionsSchema,\n    /** An optional Account ID to associate with runs triggered by this interval */\n    accountId: z.string().optional(),\n    metadata: z.any(),\n});\nexport const IntervalMetadataSchema = z.object({\n    /** An interval reoccurs at the specified number of seconds  */\n    type: z.literal(\"interval\"),\n    /** An object containing options about the interval. */\n    options: IntervalOptionsSchema,\n    /** An optional Account ID to associate with runs triggered by this interval */\n    accountId: z.string().optional(),\n    /** Any additional metadata about the schedule. */\n    metadata: z.any(),\n});\nexport const ScheduleMetadataSchema = z.discriminatedUnion(\"type\", [\n    IntervalMetadataSchema,\n    CronMetadataSchema,\n]);\nexport const RegisterDynamicSchedulePayloadSchema = z.object({\n    id: z.string(),\n    jobs: z.array(z.object({\n        id: z.string(),\n        version: z.string(),\n    })),\n});\n//# sourceMappingURL=schedules.js.map","import { z } from \"zod\";\nimport { DisplayPropertySchema, StyleSchema } from \"./properties.js\";\nimport { DeserializedJsonSchema } from \"./json.js\";\nexport const TaskStatusSchema = z.enum([\n    \"PENDING\",\n    \"WAITING\",\n    \"RUNNING\",\n    \"COMPLETED\",\n    \"ERRORED\",\n    \"CANCELED\",\n]);\nexport const TaskSchema = z.object({\n    id: z.string(),\n    name: z.string(),\n    icon: z.string().optional().nullable(),\n    noop: z.boolean(),\n    startedAt: z.coerce.date().optional().nullable(),\n    completedAt: z.coerce.date().optional().nullable(),\n    delayUntil: z.coerce.date().optional().nullable(),\n    status: TaskStatusSchema,\n    description: z.string().optional().nullable(),\n    properties: z.array(DisplayPropertySchema).optional().nullable(),\n    outputProperties: z.array(DisplayPropertySchema).optional().nullable(),\n    params: DeserializedJsonSchema.optional().nullable(),\n    output: DeserializedJsonSchema.optional().nullable(),\n    context: DeserializedJsonSchema.optional().nullable(),\n    error: z.string().optional().nullable(),\n    parentId: z.string().optional().nullable(),\n    style: StyleSchema.optional().nullable(),\n    operation: z.string().optional().nullable(),\n    callbackUrl: z.string().optional().nullable(),\n    childExecutionMode: z.enum([\"SEQUENTIAL\", \"PARALLEL\"]).optional().nullable(),\n});\nexport const ServerTaskSchema = TaskSchema.extend({\n    idempotencyKey: z.string(),\n    attempts: z.number(),\n    forceYield: z.boolean().optional().nullable(),\n});\nexport const CachedTaskSchema = z.object({\n    id: z.string(),\n    idempotencyKey: z.string(),\n    status: TaskStatusSchema,\n    noop: z.boolean().default(false),\n    output: DeserializedJsonSchema.optional().nullable(),\n    parentId: z.string().optional().nullable(),\n});\n//# sourceMappingURL=tasks.js.map","import { z } from \"zod\";\nimport { EventFilterSchema, EventRuleSchema } from \"./eventFilter.js\";\nimport { DisplayPropertySchema } from \"./properties.js\";\nimport { ScheduleMetadataSchema } from \"./schedules.js\";\nexport const EventExampleSchema = z.object({\n    id: z.string(),\n    icon: z.string().optional(),\n    name: z.string(),\n    payload: z.any(),\n});\nexport const EventSpecificationSchema = z.object({\n    name: z.string().or(z.array(z.string())),\n    title: z.string(),\n    source: z.string(),\n    icon: z.string(),\n    filter: EventFilterSchema.optional(),\n    properties: z.array(DisplayPropertySchema).optional(),\n    schema: z.any().optional(),\n    examples: z.array(EventExampleSchema).optional(),\n});\nexport const DynamicTriggerMetadataSchema = z.object({\n    type: z.literal(\"dynamic\"),\n    id: z.string(),\n});\nexport const TriggerHelpSchema = z.object({\n    noRuns: z\n        .object({\n        text: z.string(),\n        link: z.string().optional(),\n    })\n        .optional(),\n});\nexport const StaticTriggerMetadataSchema = z.object({\n    type: z.literal(\"static\"),\n    title: z.union([z.string(), z.array(z.string())]),\n    properties: z.array(DisplayPropertySchema).optional(),\n    rule: EventRuleSchema,\n    link: z.string().optional(),\n    help: TriggerHelpSchema.optional(),\n});\nexport const InvokeTriggerMetadataSchema = z.object({\n    type: z.literal(\"invoke\"),\n});\nexport const ScheduledTriggerMetadataSchema = z.object({\n    type: z.literal(\"scheduled\"),\n    schedule: ScheduleMetadataSchema,\n});\nexport const TriggerMetadataSchema = z.discriminatedUnion(\"type\", [\n    DynamicTriggerMetadataSchema,\n    StaticTriggerMetadataSchema,\n    ScheduledTriggerMetadataSchema,\n    InvokeTriggerMetadataSchema,\n]);\n//# sourceMappingURL=triggers.js.map","import { z } from \"zod\";\nimport { SerializableJsonSchema } from \"./json.js\";\nexport const StatusUpdateStateSchema = z.union([\n    z.literal(\"loading\"),\n    z.literal(\"success\"),\n    z.literal(\"failure\"),\n]);\nconst StatusUpdateDataSchema = z.record(SerializableJsonSchema);\nexport const StatusUpdateSchema = z.object({\n    label: z.string().optional(),\n    state: StatusUpdateStateSchema.optional(),\n    data: StatusUpdateDataSchema.optional(),\n});\nconst InitalStatusUpdateSchema = StatusUpdateSchema.required({ label: true });\nexport const StatusHistorySchema = z.array(StatusUpdateSchema);\nexport const JobRunStatusRecordSchema = InitalStatusUpdateSchema.extend({\n    key: z.string(),\n    history: StatusHistorySchema,\n});\n//# sourceMappingURL=statuses.js.map","import { z } from \"zod\";\nimport { JobRunStatusRecordSchema } from \"./statuses.js\";\nimport { TaskStatusSchema } from \"./tasks.js\";\nexport const RunStatusSchema = z.union([\n    z.literal(\"PENDING\"),\n    z.literal(\"QUEUED\"),\n    z.literal(\"WAITING_ON_CONNECTIONS\"),\n    z.literal(\"PREPROCESSING\"),\n    z.literal(\"STARTED\"),\n    z.literal(\"SUCCESS\"),\n    z.literal(\"FAILURE\"),\n    z.literal(\"TIMED_OUT\"),\n    z.literal(\"ABORTED\"),\n    z.literal(\"CANCELED\"),\n    z.literal(\"UNRESOLVED_AUTH\"),\n    z.literal(\"INVALID_PAYLOAD\"),\n    z.literal(\"EXECUTING\"),\n    z.literal(\"WAITING_TO_CONTINUE\"),\n    z.literal(\"WAITING_TO_EXECUTE\"),\n]);\nexport const RunTaskSchema = z.object({\n    /** The Task id */\n    id: z.string(),\n    /** The key that you defined when creating the Task, the first param in any task. */\n    displayKey: z.string().nullable(),\n    /** The Task status */\n    status: TaskStatusSchema,\n    /** The name of the Task */\n    name: z.string(),\n    /** The icon of the Task, a string.\n     * For integrations, this will be a lowercase name of the company.\n     * Can be used with the [@trigger.dev/companyicons](https://www.npmjs.com/package/@trigger.dev/companyicons) package to display an svg. */\n    icon: z.string().nullable(),\n    /** When the task started */\n    startedAt: z.coerce.date().nullable(),\n    /** When the task completed */\n    completedAt: z.coerce.date().nullable(),\n});\nconst RunTaskWithSubtasksSchema = RunTaskSchema.extend({\n    subtasks: z.lazy(() => RunTaskWithSubtasksSchema.array()).optional(),\n});\nconst GetRunOptionsSchema = z.object({\n    /** Return subtasks, which appear in a `subtasks` array on a task. @default false */\n    subtasks: z.boolean().optional(),\n    /** You can use this to get more tasks, if there are more than are returned in a single batch @default undefined */\n    cursor: z.string().optional(),\n    /** How many tasks you want to return in one go, max 50. @default 20 */\n    take: z.number().optional(),\n});\nconst GetRunOptionsWithTaskDetailsSchema = GetRunOptionsSchema.extend({\n    /** If `true`, it returns the `params` and `output` of all tasks. @default false */\n    taskdetails: z.boolean().optional(),\n});\nconst RunSchema = z.object({\n    /** The Run id */\n    id: z.string(),\n    /** The Run status */\n    status: RunStatusSchema,\n    /** When the run started */\n    startedAt: z.coerce.date().nullable(),\n    /** When the run was last updated */\n    updatedAt: z.coerce.date().nullable(),\n    /** When the run was completed */\n    completedAt: z.coerce.date().nullable(),\n});\nexport const GetRunSchema = RunSchema.extend({\n    /** The output of the run */\n    output: z.any().optional(),\n    /** The tasks from the run */\n    tasks: z.array(RunTaskWithSubtasksSchema),\n    /** Any status updates that were published from the run */\n    statuses: z.array(JobRunStatusRecordSchema).default([]),\n    /** If there are more tasks, you can use this to get them */\n    nextCursor: z.string().optional(),\n});\nconst GetRunsOptionsSchema = z.object({\n    /** You can use this to get more tasks, if there are more than are returned in a single batch @default undefined */\n    cursor: z.string().optional(),\n    /** How many runs you want to return in one go, max 50. @default 20 */\n    take: z.number().optional(),\n});\nexport const GetRunsSchema = z.object({\n    /** The runs from the query */\n    runs: RunSchema.array(),\n    /** If there are more runs, you can use this to get them */\n    nextCursor: z.string().optional(),\n});\n//# sourceMappingURL=runs.js.map","import { z } from \"zod\";\nimport { EventFilterSchema, stringPatternMatchers } from \"./eventFilter.js\";\nconst StringMatchSchema = z.union([\n    /** Match against a string */\n    z.array(z.string()),\n    z.array(z.union(stringPatternMatchers)),\n]);\nexport const HTTPMethodUnionSchema = z.union([\n    z.literal(\"GET\"),\n    z.literal(\"POST\"),\n    z.literal(\"PUT\"),\n    z.literal(\"PATCH\"),\n    z.literal(\"DELETE\"),\n    z.literal(\"HEAD\"),\n    z.literal(\"OPTIONS\"),\n]);\n/** Only Requests that match this filter will cause the `handler` function to run.\n * For example, you can use this to only respond to `GET` Requests. */\nexport const RequestFilterSchema = z.object({\n    /** An array of HTTP methods to match.\n     * For example, `[\"GET\", \"POST\"]` will match both `GET` and `POST` Requests. */\n    method: z.array(HTTPMethodUnionSchema).optional(),\n    /** An object of header key/values to match.\n     * This uses the [EventFilter matching syntax](https://trigger.dev/docs/documentation/guides/event-filter).\n  \n      @example\n    ```ts\n    filter: {\n      header: {\n        \"content-type\": [\"application/json\"],\n      },\n    },\n    ``` */\n    headers: z.record(StringMatchSchema).optional(),\n    /** An object of query parameters to match.\n     * This uses the [EventFilter matching syntax](https://trigger.dev/docs/documentation/guides/event-filter).\n  \n    @example\n    ```ts\n    filter: {\n      query: {\n        \"hub.mode\": [{ $startsWith: \"sub\" }],\n      },\n    },\n    ``` */\n    query: z.record(StringMatchSchema).optional(),\n    /** An object of key/values to match.\n     * This uses the [EventFilter matching syntax](https://trigger.dev/docs/documentation/guides/event-filter).\n     */\n    body: EventFilterSchema.optional(),\n});\n/** Only Requests that match this filter will cause the `handler` function to run.\n * For example, you can use this to only respond to `GET` Requests. */\nexport const ResponseFilterSchema = RequestFilterSchema.omit({ method: true, query: true }).extend({\n    status: z.array(z.number()).optional(),\n});\n//# sourceMappingURL=requestFilter.js.map","import { z } from \"zod\";\nimport { addMissingVersionField } from \"./addMissingVersionField.js\";\nimport { ErrorWithStackSchema, SchemaErrorSchema } from \"./errors.js\";\nimport { EventFilterSchema, EventRuleSchema } from \"./eventFilter.js\";\nimport { ConnectionAuthSchema, IntegrationConfigSchema } from \"./integrations.js\";\nimport { DeserializedJsonSchema, SerializableJsonSchema } from \"./json.js\";\nimport { DisplayPropertySchema, StyleSchema } from \"./properties.js\";\nimport { CronMetadataSchema, IntervalMetadataSchema, RegisterDynamicSchedulePayloadSchema, ScheduleMetadataSchema, } from \"./schedules.js\";\nimport { CachedTaskSchema, ServerTaskSchema, TaskSchema } from \"./tasks.js\";\nimport { EventSpecificationSchema, TriggerMetadataSchema } from \"./triggers.js\";\nimport { RunStatusSchema } from \"./runs.js\";\nimport { JobRunStatusRecordSchema } from \"./statuses.js\";\nimport { RequestFilterSchema } from \"./requestFilter.js\";\nexport const UpdateTriggerSourceBodyV1Schema = z.object({\n    registeredEvents: z.array(z.string()),\n    secret: z.string().optional(),\n    data: SerializableJsonSchema.optional(),\n});\nexport const UpdateTriggerSourceBodyV2Schema = z.object({\n    secret: z.string().optional(),\n    data: SerializableJsonSchema.optional(),\n    options: z\n        .object({\n        event: z.array(z.string()),\n    })\n        .and(z.record(z.string(), z.array(z.string())).optional()),\n});\nexport const UpdateWebhookBodySchema = z.discriminatedUnion(\"active\", [\n    z.object({\n        active: z.literal(false),\n    }),\n    z.object({\n        active: z.literal(true),\n        config: z.record(z.string().array()),\n    }),\n]);\nexport const RegisterHTTPTriggerSourceBodySchema = z.object({\n    type: z.literal(\"HTTP\"),\n    url: z.string().url(),\n});\nexport const RegisterSMTPTriggerSourceBodySchema = z.object({\n    type: z.literal(\"SMTP\"),\n});\nexport const RegisterSQSTriggerSourceBodySchema = z.object({\n    type: z.literal(\"SQS\"),\n});\nexport const RegisterSourceChannelBodySchema = z.discriminatedUnion(\"type\", [\n    RegisterHTTPTriggerSourceBodySchema,\n    RegisterSMTPTriggerSourceBodySchema,\n    RegisterSQSTriggerSourceBodySchema,\n]);\nexport const REGISTER_WEBHOOK = \"dev.trigger.webhook.register\";\nexport const DELIVER_WEBHOOK_REQUEST = \"dev.trigger.webhook.deliver\";\nexport const RegisterWebhookSourceSchema = z.object({\n    key: z.string(),\n    params: z.any(),\n    config: z.any(),\n    active: z.boolean(),\n    secret: z.string(),\n    url: z.string(),\n    data: DeserializedJsonSchema.optional(),\n    clientId: z.string().optional(),\n});\nexport const RegisterWebhookPayloadSchema = z.object({\n    active: z.boolean(),\n    params: z.any().optional(),\n    config: z.object({\n        current: z.record(z.string().array()),\n        desired: z.record(z.string().array()),\n    }),\n    // from HTTP Endpoint\n    url: z.string(),\n    secret: z.string(),\n});\nexport const REGISTER_SOURCE_EVENT_V1 = \"dev.trigger.source.register\";\nexport const REGISTER_SOURCE_EVENT_V2 = \"dev.trigger.source.register.v2\";\nexport const RegisterTriggerSourceSchema = z.object({\n    key: z.string(),\n    params: z.any(),\n    active: z.boolean(),\n    secret: z.string(),\n    data: DeserializedJsonSchema.optional(),\n    channel: RegisterSourceChannelBodySchema,\n    clientId: z.string().optional(),\n});\nconst SourceEventOptionSchema = z.object({\n    name: z.string(),\n    value: z.string(),\n});\nexport const RegisterSourceEventSchemaV1 = z.object({\n    /** The id of the source */\n    id: z.string(),\n    source: RegisterTriggerSourceSchema,\n    events: z.array(z.string()),\n    missingEvents: z.array(z.string()),\n    orphanedEvents: z.array(z.string()),\n    dynamicTriggerId: z.string().optional(),\n});\nconst RegisteredOptionsDiffSchema = z.object({\n    desired: z.array(z.string()),\n    missing: z.array(z.string()),\n    orphaned: z.array(z.string()),\n});\nconst RegisterSourceEventOptionsSchema = z\n    .object({\n    event: RegisteredOptionsDiffSchema,\n})\n    .and(z.record(z.string(), RegisteredOptionsDiffSchema));\nexport const RegisterSourceEventSchemaV2 = z.object({\n    /** The id of the source */\n    id: z.string(),\n    source: RegisterTriggerSourceSchema,\n    options: RegisterSourceEventOptionsSchema,\n    dynamicTriggerId: z.string().optional(),\n});\nexport const TriggerSourceSchema = z.object({\n    id: z.string(),\n    key: z.string(),\n});\nconst HttpSourceResponseMetadataSchema = DeserializedJsonSchema;\nexport const HandleTriggerSourceSchema = z.object({\n    key: z.string(),\n    secret: z.string(),\n    data: z.any(),\n    params: z.any(),\n    auth: ConnectionAuthSchema.optional(),\n    metadata: HttpSourceResponseMetadataSchema.optional(),\n});\nexport const HttpSourceRequestHeadersSchema = z.object({\n    \"x-ts-key\": z.string(),\n    \"x-ts-dynamic-id\": z.string().optional(),\n    \"x-ts-secret\": z.string(),\n    \"x-ts-data\": z.string().transform((s) => JSON.parse(s)),\n    \"x-ts-params\": z.string().transform((s) => JSON.parse(s)),\n    \"x-ts-http-url\": z.string(),\n    \"x-ts-http-method\": z.string(),\n    \"x-ts-http-headers\": z.string().transform((s) => z.record(z.string()).parse(JSON.parse(s))),\n    \"x-ts-auth\": z\n        .string()\n        .optional()\n        .transform((s) => {\n        if (s === undefined)\n            return;\n        const json = JSON.parse(s);\n        return ConnectionAuthSchema.parse(json);\n    }),\n    \"x-ts-metadata\": z\n        .string()\n        .optional()\n        .transform((s) => {\n        if (s === undefined)\n            return;\n        const json = JSON.parse(s);\n        return DeserializedJsonSchema.parse(json);\n    }),\n});\nexport const HttpEndpointRequestHeadersSchema = z.object({\n    \"x-ts-key\": z.string(),\n    \"x-ts-http-url\": z.string(),\n    \"x-ts-http-method\": z.string(),\n    \"x-ts-http-headers\": z.string().transform((s) => z.record(z.string()).parse(JSON.parse(s))),\n});\nexport const WebhookSourceRequestHeadersSchema = z.object({\n    \"x-ts-key\": z.string(),\n    \"x-ts-dynamic-id\": z.string().optional(),\n    \"x-ts-secret\": z.string(),\n    \"x-ts-params\": z.string().transform((s) => JSON.parse(s)),\n    \"x-ts-http-url\": z.string(),\n    \"x-ts-http-method\": z.string(),\n    \"x-ts-http-headers\": z.string().transform((s) => z.record(z.string()).parse(JSON.parse(s))),\n});\nexport const PongSuccessResponseSchema = z.object({\n    ok: z.literal(true),\n    triggerVersion: z.string().optional(),\n    triggerSdkVersion: z.string().optional(),\n});\nexport const PongErrorResponseSchema = z.object({\n    ok: z.literal(false),\n    error: z.string(),\n    triggerVersion: z.string().optional(),\n    triggerSdkVersion: z.string().optional(),\n});\nexport const PongResponseSchema = z.discriminatedUnion(\"ok\", [\n    PongSuccessResponseSchema,\n    PongErrorResponseSchema,\n]);\nexport const ValidateSuccessResponseSchema = z.object({\n    ok: z.literal(true),\n    endpointId: z.string(),\n    triggerVersion: z.string().optional(),\n});\nexport const ValidateErrorResponseSchema = z.object({\n    ok: z.literal(false),\n    error: z.string(),\n    triggerVersion: z.string().optional(),\n});\nexport const ValidateResponseSchema = z.discriminatedUnion(\"ok\", [\n    ValidateSuccessResponseSchema,\n    ValidateErrorResponseSchema,\n]);\nexport const QueueOptionsSchema = z.object({\n    name: z.string(),\n    maxConcurrent: z.number().optional(),\n});\nexport const ConcurrencyLimitOptionsSchema = z.object({\n    id: z.string(),\n    limit: z.number(),\n});\nexport const JobMetadataSchema = z.object({\n    id: z.string(),\n    name: z.string(),\n    version: z.string(),\n    event: EventSpecificationSchema,\n    trigger: TriggerMetadataSchema,\n    integrations: z.record(IntegrationConfigSchema),\n    internal: z.boolean().default(false),\n    enabled: z.boolean(),\n    startPosition: z.enum([\"initial\", \"latest\"]),\n    preprocessRuns: z.boolean(),\n    concurrencyLimit: ConcurrencyLimitOptionsSchema.or(z.number().int().positive()).optional(),\n});\nconst SourceMetadataV1Schema = z.object({\n    version: z.literal(\"1\"),\n    channel: z.enum([\"HTTP\", \"SQS\", \"SMTP\"]),\n    integration: IntegrationConfigSchema,\n    key: z.string(),\n    params: z.any(),\n    events: z.array(z.string()),\n    registerSourceJob: z\n        .object({\n        id: z.string(),\n        version: z.string(),\n    })\n        .optional(),\n});\nexport const SourceMetadataV2Schema = z.object({\n    version: z.literal(\"2\"),\n    channel: z.enum([\"HTTP\", \"SQS\", \"SMTP\"]),\n    integration: IntegrationConfigSchema,\n    key: z.string(),\n    params: z.any(),\n    options: z.record(z.array(z.string())),\n    registerSourceJob: z\n        .object({\n        id: z.string(),\n        version: z.string(),\n    })\n        .optional(),\n});\nconst SourceMetadataSchema = z.preprocess(addMissingVersionField, z.discriminatedUnion(\"version\", [SourceMetadataV1Schema, SourceMetadataV2Schema]));\nexport const WebhookMetadataSchema = z.object({\n    key: z.string(),\n    params: z.any(),\n    config: z.record(z.array(z.string())),\n    integration: IntegrationConfigSchema,\n    httpEndpoint: z.object({\n        id: z.string(),\n    }),\n});\nexport const WebhookContextMetadataSchema = z.object({\n    params: z.any(),\n    config: z.record(z.string().array()),\n    secret: z.string(),\n});\nexport const DynamicTriggerEndpointMetadataSchema = z.object({\n    id: z.string(),\n    jobs: z.array(JobMetadataSchema.pick({ id: true, version: true })),\n    registerSourceJob: z\n        .object({\n        id: z.string(),\n        version: z.string(),\n    })\n        .optional(),\n});\nconst HttpEndpointMetadataSchema = z.object({\n    id: z.string(),\n    version: z.string(),\n    enabled: z.boolean(),\n    title: z.string().optional(),\n    icon: z.string().optional(),\n    properties: z.array(DisplayPropertySchema).optional(),\n    event: EventSpecificationSchema,\n    immediateResponseFilter: RequestFilterSchema.optional(),\n    skipTriggeringRuns: z.boolean().optional(),\n    source: z.string(),\n});\nexport const IndexEndpointResponseSchema = z.object({\n    jobs: z.array(JobMetadataSchema),\n    sources: z.array(SourceMetadataSchema),\n    webhooks: z.array(WebhookMetadataSchema).optional(),\n    dynamicTriggers: z.array(DynamicTriggerEndpointMetadataSchema),\n    dynamicSchedules: z.array(RegisterDynamicSchedulePayloadSchema),\n    httpEndpoints: z.array(HttpEndpointMetadataSchema).optional(),\n});\nexport const EndpointIndexErrorSchema = z.object({\n    message: z.string(),\n    raw: z.any().optional(),\n});\nconst IndexEndpointStatsSchema = z.object({\n    jobs: z.number(),\n    sources: z.number(),\n    webhooks: z.number().optional(),\n    dynamicTriggers: z.number(),\n    dynamicSchedules: z.number(),\n    disabledJobs: z.number().default(0),\n    httpEndpoints: z.number().default(0),\n});\nexport function parseEndpointIndexStats(stats) {\n    if (stats === null || stats === undefined) {\n        return;\n    }\n    return IndexEndpointStatsSchema.parse(stats);\n}\nexport const GetEndpointIndexResponseSchema = z.discriminatedUnion(\"status\", [\n    z.object({\n        status: z.literal(\"PENDING\"),\n        updatedAt: z.coerce.date(),\n    }),\n    z.object({\n        status: z.literal(\"STARTED\"),\n        updatedAt: z.coerce.date(),\n    }),\n    z.object({\n        status: z.literal(\"SUCCESS\"),\n        stats: IndexEndpointStatsSchema,\n        updatedAt: z.coerce.date(),\n    }),\n    z.object({\n        status: z.literal(\"FAILURE\"),\n        error: EndpointIndexErrorSchema,\n        updatedAt: z.coerce.date(),\n    }),\n]);\nexport const EndpointHeadersSchema = z.object({\n    \"trigger-version\": z.string().optional(),\n    \"trigger-sdk-version\": z.string().optional(),\n});\nexport const ExecuteJobRunMetadataSchema = z.object({\n    successSubscription: z.boolean().optional(),\n    failedSubscription: z.boolean().optional(),\n});\nexport const ExecuteJobHeadersSchema = EndpointHeadersSchema.extend({\n    \"x-trigger-run-metadata\": z\n        .preprocess((val) => typeof val === \"string\" && JSON.parse(val), ExecuteJobRunMetadataSchema)\n        .optional(),\n});\nexport const RawEventSchema = z.object({\n    /** The `name` property must exactly match any subscriptions you want to\n        trigger. */\n    name: z.string(),\n    /** The `payload` property will be sent to any matching Jobs and will appear\n        as the `payload` param of the `run()` function. You can leave this\n        parameter out if you just want to trigger a Job without any input data. */\n    payload: z.any(),\n    /** The optional `context` property will be sent to any matching Jobs and will\n        be passed through as the `context.event.context` param of the `run()`\n        function. This is optional but can be useful if you want to pass through\n        some additional context to the Job. */\n    context: z.any().optional(),\n    /** The `id` property uniquely identify this particular event. If unset it\n        will be set automatically using `ulid`. */\n    id: z.string().default(() => globalThis.crypto.randomUUID()),\n    /** This is optional, it defaults to the current timestamp. Usually you would\n        only set this if you have a timestamp that you wish to pass through, e.g.\n        you receive a timestamp from a service and you want the same timestamp to\n        be used in your Job. */\n    timestamp: z.coerce.date().optional(),\n    /** This is optional, it defaults to \"trigger.dev\". It can be useful to set\n        this as you can filter events using this in the `eventTrigger()`. */\n    source: z.string().optional(),\n    /** This is optional, it defaults to \"JSON\". If your event is actually a request,\n        with a url, headers, method and rawBody you can use \"REQUEST\" */\n    payloadType: z.union([z.literal(\"JSON\"), z.literal(\"REQUEST\")]).optional(),\n});\n/** The event that was sent */\nexport const ApiEventLogSchema = z.object({\n    /** The `id` of the event that was sent.\n     */\n    id: z.string(),\n    /** The `name` of the event that was sent. */\n    name: z.string(),\n    /** The `payload` of the event that was sent */\n    payload: DeserializedJsonSchema,\n    /** The `context` of the event that was sent. Is `undefined` if no context was\n        set when sending the event. */\n    context: DeserializedJsonSchema.optional().nullable(),\n    /** The `timestamp` of the event that was sent */\n    timestamp: z.coerce.date(),\n    /** The timestamp when the event will be delivered to any matching Jobs. Is\n        `undefined` if `deliverAt` or `deliverAfter` wasn't set when sending the\n        event. */\n    deliverAt: z.coerce.date().optional().nullable(),\n    /** The timestamp when the event was delivered. Is `undefined` if `deliverAt`\n        or `deliverAfter` were set when sending the event. */\n    deliveredAt: z.coerce.date().optional().nullable(),\n    /** The timestamp when the event was cancelled. Is `undefined` if the event\n     * wasn't cancelled. */\n    cancelledAt: z.coerce.date().optional().nullable(),\n});\n/** Options to control the delivery of the event */\nexport const SendEventOptionsSchema = z.object({\n    /** An optional Date when you want the event to trigger Jobs. The event will\n        be sent to the platform immediately but won't be acted upon until the\n        specified time. */\n    deliverAt: z.coerce.date().optional(),\n    /** An optional number of seconds you want to wait for the event to trigger\n        any relevant Jobs. The event will be sent to the platform immediately but\n        won't be delivered until after the elapsed number of seconds. */\n    deliverAfter: z.number().int().optional(),\n    /** This optional param will be used by Trigger.dev Connect, which\n        is coming soon. */\n    accountId: z.string().optional(),\n});\nexport const SendEventBodySchema = z.object({\n    event: RawEventSchema,\n    options: SendEventOptionsSchema.optional(),\n});\nexport const SendBulkEventsBodySchema = z.object({\n    events: RawEventSchema.array(),\n    options: SendEventOptionsSchema.optional(),\n});\nexport const DeliverEventResponseSchema = z.object({\n    deliveredAt: z.string().datetime(),\n});\nexport const RuntimeEnvironmentTypeSchema = z.enum([\n    \"PRODUCTION\",\n    \"STAGING\",\n    \"DEVELOPMENT\",\n    \"PREVIEW\",\n]);\nexport const RunSourceContextSchema = z.object({\n    id: z.string(),\n    metadata: z.any(),\n});\nexport const AutoYieldConfigSchema = z.object({\n    startTaskThreshold: z.number(),\n    beforeExecuteTaskThreshold: z.number(),\n    beforeCompleteTaskThreshold: z.number(),\n    afterCompleteTaskThreshold: z.number(),\n});\nexport const RunJobBodySchema = z.object({\n    event: ApiEventLogSchema,\n    job: z.object({\n        id: z.string(),\n        version: z.string(),\n    }),\n    run: z.object({\n        id: z.string(),\n        isTest: z.boolean(),\n        isRetry: z.boolean().default(false),\n        startedAt: z.coerce.date(),\n    }),\n    environment: z.object({\n        id: z.string(),\n        slug: z.string(),\n        type: RuntimeEnvironmentTypeSchema,\n    }),\n    organization: z.object({\n        id: z.string(),\n        title: z.string(),\n        slug: z.string(),\n    }),\n    project: z\n        .object({\n        id: z.string(),\n        name: z.string(),\n        slug: z.string(),\n    })\n        .optional(),\n    account: z\n        .object({\n        id: z.string(),\n        metadata: z.any(),\n    })\n        .optional(),\n    source: RunSourceContextSchema.optional(),\n    tasks: z.array(CachedTaskSchema).optional(),\n    cachedTaskCursor: z.string().optional(),\n    noopTasksSet: z.string().optional(),\n    connections: z.record(ConnectionAuthSchema).optional(),\n    yieldedExecutions: z.string().array().optional(),\n    runChunkExecutionLimit: z.number().optional(),\n    autoYieldConfig: AutoYieldConfigSchema.optional(),\n});\nexport const RunJobErrorSchema = z.object({\n    status: z.literal(\"ERROR\"),\n    error: ErrorWithStackSchema,\n    task: TaskSchema.optional(),\n});\nexport const RunJobYieldExecutionErrorSchema = z.object({\n    status: z.literal(\"YIELD_EXECUTION\"),\n    key: z.string(),\n});\nexport const AutoYieldMetadataSchema = z.object({\n    location: z.string(),\n    timeRemaining: z.number(),\n    timeElapsed: z.number(),\n    limit: z.number().optional(),\n});\nexport const RunJobAutoYieldExecutionErrorSchema = AutoYieldMetadataSchema.extend({\n    status: z.literal(\"AUTO_YIELD_EXECUTION\"),\n});\nexport const RunJobAutoYieldWithCompletedTaskExecutionErrorSchema = z.object({\n    status: z.literal(\"AUTO_YIELD_EXECUTION_WITH_COMPLETED_TASK\"),\n    id: z.string(),\n    properties: z.array(DisplayPropertySchema).optional(),\n    output: z.string().optional(),\n    data: AutoYieldMetadataSchema,\n});\nexport const RunJobAutoYieldRateLimitErrorSchema = z.object({\n    status: z.literal(\"AUTO_YIELD_RATE_LIMIT\"),\n    reset: z.coerce.number(),\n});\nexport const RunJobInvalidPayloadErrorSchema = z.object({\n    status: z.literal(\"INVALID_PAYLOAD\"),\n    errors: z.array(SchemaErrorSchema),\n});\nexport const RunJobUnresolvedAuthErrorSchema = z.object({\n    status: z.literal(\"UNRESOLVED_AUTH_ERROR\"),\n    issues: z.record(z.object({ id: z.string(), error: z.string() })),\n});\nexport const RunJobResumeWithTaskSchema = z.object({\n    status: z.literal(\"RESUME_WITH_TASK\"),\n    task: TaskSchema,\n});\nexport const RunJobRetryWithTaskSchema = z.object({\n    status: z.literal(\"RETRY_WITH_TASK\"),\n    task: TaskSchema,\n    error: ErrorWithStackSchema,\n    retryAt: z.coerce.date(),\n});\nexport const RunJobCanceledWithTaskSchema = z.object({\n    status: z.literal(\"CANCELED\"),\n    task: TaskSchema,\n});\nexport const RunJobSuccessSchema = z.object({\n    status: z.literal(\"SUCCESS\"),\n    output: DeserializedJsonSchema.optional(),\n});\nexport const RunJobErrorResponseSchema = z.union([\n    RunJobAutoYieldExecutionErrorSchema,\n    RunJobAutoYieldWithCompletedTaskExecutionErrorSchema,\n    RunJobYieldExecutionErrorSchema,\n    RunJobAutoYieldRateLimitErrorSchema,\n    RunJobErrorSchema,\n    RunJobUnresolvedAuthErrorSchema,\n    RunJobInvalidPayloadErrorSchema,\n    RunJobResumeWithTaskSchema,\n    RunJobRetryWithTaskSchema,\n    RunJobCanceledWithTaskSchema,\n]);\nexport const RunJobResumeWithParallelTaskSchema = z.object({\n    status: z.literal(\"RESUME_WITH_PARALLEL_TASK\"),\n    task: TaskSchema,\n    childErrors: z.array(RunJobErrorResponseSchema),\n});\nexport const RunJobResponseSchema = z.discriminatedUnion(\"status\", [\n    RunJobAutoYieldExecutionErrorSchema,\n    RunJobAutoYieldWithCompletedTaskExecutionErrorSchema,\n    RunJobYieldExecutionErrorSchema,\n    RunJobAutoYieldRateLimitErrorSchema,\n    RunJobErrorSchema,\n    RunJobUnresolvedAuthErrorSchema,\n    RunJobInvalidPayloadErrorSchema,\n    RunJobResumeWithTaskSchema,\n    RunJobResumeWithParallelTaskSchema,\n    RunJobRetryWithTaskSchema,\n    RunJobCanceledWithTaskSchema,\n    RunJobSuccessSchema,\n]);\nexport const PreprocessRunBodySchema = z.object({\n    event: ApiEventLogSchema,\n    job: z.object({\n        id: z.string(),\n        version: z.string(),\n    }),\n    run: z.object({\n        id: z.string(),\n        isTest: z.boolean(),\n    }),\n    environment: z.object({\n        id: z.string(),\n        slug: z.string(),\n        type: RuntimeEnvironmentTypeSchema,\n    }),\n    organization: z.object({\n        id: z.string(),\n        title: z.string(),\n        slug: z.string(),\n    }),\n    account: z\n        .object({\n        id: z.string(),\n        metadata: z.any(),\n    })\n        .optional(),\n});\nexport const PreprocessRunResponseSchema = z.object({\n    abort: z.boolean(),\n    properties: z.array(DisplayPropertySchema).optional(),\n});\nconst CreateRunResponseOkSchema = z.object({\n    ok: z.literal(true),\n    data: z.object({\n        id: z.string(),\n    }),\n});\nconst CreateRunResponseErrorSchema = z.object({\n    ok: z.literal(false),\n    error: z.string(),\n});\nexport const CreateRunResponseBodySchema = z.discriminatedUnion(\"ok\", [\n    CreateRunResponseOkSchema,\n    CreateRunResponseErrorSchema,\n]);\nexport const RedactStringSchema = z.object({\n    __redactedString: z.literal(true),\n    strings: z.array(z.string()),\n    interpolations: z.array(z.string()),\n});\nexport const LogMessageSchema = z.object({\n    level: z.enum([\"DEBUG\", \"INFO\", \"WARN\", \"ERROR\"]),\n    message: z.string(),\n    data: SerializableJsonSchema.optional(),\n});\nexport const RedactSchema = z.object({\n    paths: z.array(z.string()),\n});\nexport const RetryOptionsSchema = z.object({\n    /** The maximum number of times to retry the request. */\n    limit: z.number().optional(),\n    /** The exponential factor to use when calculating the next retry time. */\n    factor: z.number().optional(),\n    /** The minimum amount of time to wait before retrying the request. */\n    minTimeoutInMs: z.number().optional(),\n    /** The maximum amount of time to wait before retrying the request. */\n    maxTimeoutInMs: z.number().optional(),\n    /** Whether to randomize the retry time. */\n    randomize: z.boolean().optional(),\n});\nexport const RunTaskOptionsSchema = z.object({\n    /** The name of the Task is required. This is displayed on the Task in the logs. */\n    name: z.string().optional(),\n    /** The Task will wait and only start at the specified Date  */\n    delayUntil: z.coerce.date().optional(),\n    /** Retry options */\n    retry: RetryOptionsSchema.optional(),\n    /** The icon for the Task, it will appear in the logs.\n     *  You can use the name of a company in lowercase, e.g. \"github\".\n     *  Or any icon name that [Tabler Icons](https://tabler-icons.io/) supports. */\n    icon: z.string().optional(),\n    /** The key for the Task that you want to appear in the logs */\n    displayKey: z.string().optional(),\n    /** A description of the Task */\n    description: z.string().optional(),\n    /** Properties that are displayed in the logs */\n    properties: z.array(DisplayPropertySchema).optional(),\n    /** The input params to the Task, will be displayed in the logs  */\n    params: z.any(),\n    /** The style of the log entry. */\n    style: StyleSchema.optional(),\n    /** Allows you to expose a `task.callbackUrl` to use in your tasks. Enabling this feature will cause the task to return the data sent to the callbackUrl instead of the usual async callback result. */\n    callback: z\n        .object({\n        /** Causes the task to wait for and return the data of the first request sent to `task.callbackUrl`. */\n        enabled: z.boolean(),\n        /** Time to wait for the first request to `task.callbackUrl`. Default: One hour. */\n        timeoutInSeconds: z.number(),\n    })\n        .partial()\n        .optional(),\n    /** Allows you to link the Integration connection in the logs. This is handled automatically in integrations.  */\n    connectionKey: z.string().optional(),\n    /** An operation you want to perform on the Trigger.dev platform, current only \"fetch\", \"fetch-response\", and \"fetch-poll\" is supported. If you wish to `fetch` use [`io.backgroundFetch()`](https://trigger.dev/docs/sdk/io/backgroundfetch) instead. */\n    operation: z.enum([\"fetch\", \"fetch-response\", \"fetch-poll\"]).optional(),\n    /** A No Operation means that the code won't be executed. This is used internally to implement features like [io.wait()](https://trigger.dev/docs/sdk/io/wait).  */\n    noop: z.boolean().default(false),\n    redact: RedactSchema.optional(),\n    parallel: z.boolean().optional(),\n});\nexport const RunTaskBodyInputSchema = RunTaskOptionsSchema.extend({\n    idempotencyKey: z.string(),\n    parentId: z.string().optional(),\n});\nexport const RunTaskBodyOutputSchema = RunTaskBodyInputSchema.extend({\n    properties: z.array(DisplayPropertySchema.partial()).optional(),\n    params: DeserializedJsonSchema.optional().nullable(),\n    callback: z\n        .object({\n        enabled: z.boolean(),\n        timeoutInSeconds: z.number().default(3600),\n    })\n        .optional(),\n});\nexport const RunTaskResponseWithCachedTasksBodySchema = z.object({\n    task: ServerTaskSchema,\n    cachedTasks: z\n        .object({\n        tasks: z.array(CachedTaskSchema),\n        cursor: z.string().optional(),\n    })\n        .optional(),\n});\nexport const CompleteTaskBodyInputSchema = RunTaskBodyInputSchema.pick({\n    properties: true,\n    description: true,\n    params: true,\n}).extend({\n    output: SerializableJsonSchema.optional().transform((v) => v ? DeserializedJsonSchema.parse(JSON.parse(JSON.stringify(v))) : {}),\n});\nexport const CompleteTaskBodyV2InputSchema = RunTaskBodyInputSchema.pick({\n    properties: true,\n    description: true,\n    params: true,\n}).extend({\n    output: z.string().optional(),\n});\nexport const FailTaskBodyInputSchema = z.object({\n    error: ErrorWithStackSchema,\n});\nexport const NormalizedRequestSchema = z.object({\n    headers: z.record(z.string()),\n    method: z.string(),\n    query: z.record(z.string()),\n    url: z.string(),\n    body: z.any(),\n});\nexport const NormalizedResponseSchema = z.object({\n    status: z.number(),\n    body: z.any(),\n    headers: z.record(z.string()).optional(),\n});\nexport const HttpSourceResponseSchema = z.object({\n    response: NormalizedResponseSchema,\n    events: z.array(RawEventSchema),\n    metadata: HttpSourceResponseMetadataSchema.optional(),\n});\nexport const WebhookDeliveryResponseSchema = z.object({\n    response: NormalizedResponseSchema,\n    verified: z.boolean(),\n    error: z.string().optional(),\n});\nexport const RegisterTriggerBodySchemaV1 = z.object({\n    rule: EventRuleSchema,\n    source: SourceMetadataV1Schema,\n});\nexport const RegisterTriggerBodySchemaV2 = z.object({\n    rule: EventRuleSchema,\n    source: SourceMetadataV2Schema,\n    accountId: z.string().optional(),\n});\nexport const InitializeTriggerBodySchema = z.object({\n    id: z.string(),\n    params: z.any(),\n    accountId: z.string().optional(),\n    metadata: z.any().optional(),\n});\nconst RegisterCommonScheduleBodySchema = z.object({\n    /** A unique id for the schedule. This is used to identify and unregister the schedule later. */\n    id: z.string(),\n    /** Any additional metadata about the schedule. */\n    metadata: z.any(),\n    /** An optional Account ID to associate with runs triggered by this schedule */\n    accountId: z.string().optional(),\n});\nexport const RegisterIntervalScheduleBodySchema = RegisterCommonScheduleBodySchema.merge(IntervalMetadataSchema);\nexport const InitializeCronScheduleBodySchema = RegisterCommonScheduleBodySchema.merge(CronMetadataSchema);\nexport const RegisterScheduleBodySchema = z.discriminatedUnion(\"type\", [\n    RegisterIntervalScheduleBodySchema,\n    InitializeCronScheduleBodySchema,\n]);\nexport const RegisterScheduleResponseBodySchema = z.object({\n    id: z.string(),\n    schedule: ScheduleMetadataSchema,\n    metadata: z.any(),\n    active: z.boolean(),\n});\nexport const CreateExternalConnectionBodySchema = z.object({\n    accessToken: z.string(),\n    type: z.enum([\"oauth2\"]),\n    scopes: z.array(z.string()).optional(),\n    metadata: z.any(),\n});\nexport const GetRunStatusesSchema = z.object({\n    run: z.object({ id: z.string(), status: RunStatusSchema, output: z.any().optional() }),\n    statuses: z.array(JobRunStatusRecordSchema),\n});\nexport const InvokeJobResponseSchema = z.object({\n    id: z.string(),\n});\nexport const InvokeJobRequestBodySchema = z.object({\n    payload: z.any(),\n    context: z.any().optional(),\n    options: z\n        .object({\n        accountId: z.string().optional(),\n        callbackUrl: z.string().optional(),\n    })\n        .optional(),\n});\nexport const InvokeOptionsSchema = z.object({\n    accountId: z.string().optional(),\n    idempotencyKey: z.string().optional(),\n    context: z.any().optional(),\n    callbackUrl: z.string().optional(),\n});\nexport const EphemeralEventDispatcherRequestBodySchema = z.object({\n    url: z.string(),\n    name: z.string().or(z.array(z.string())),\n    source: z.string().optional(),\n    filter: EventFilterSchema.optional(),\n    contextFilter: EventFilterSchema.optional(),\n    accountId: z.string().optional(),\n    timeoutInSeconds: z\n        .number()\n        .int()\n        .positive()\n        .min(10)\n        .max(60 * 60 * 24 * 365)\n        .default(3600),\n});\nexport const EphemeralEventDispatcherResponseBodySchema = z.object({\n    id: z.string(),\n});\nexport const KeyValueStoreResponseBodySchema = z.discriminatedUnion(\"action\", [\n    z.object({\n        action: z.literal(\"DELETE\"),\n        key: z.string(),\n        deleted: z.boolean(),\n    }),\n    z.object({\n        action: z.literal(\"GET\"),\n        key: z.string(),\n        value: z.string().optional(),\n    }),\n    z.object({\n        action: z.literal(\"HAS\"),\n        key: z.string(),\n        has: z.boolean(),\n    }),\n    z.object({\n        action: z.literal(\"SET\"),\n        key: z.string(),\n        value: z.string().optional(),\n    }),\n]);\n//# sourceMappingURL=api.js.map","import { z } from \"zod\";\nimport { RuntimeEnvironmentTypeSchema } from \"../../schemas/api.js\";\nimport { RunStatus } from \"./api.js\";\nimport { TaskRunError } from \"./common.js\";\n/** Represents a failed run alert webhook payload */\nconst AlertWebhookRunFailedObject = z.object({\n    /** Task information */\n    task: z.object({\n        /** Unique identifier for the task */\n        id: z.string(),\n        /** File path where the task is defined */\n        filePath: z.string(),\n        /** Name of the exported task function */\n        exportName: z.string(),\n        /** Version of the task */\n        version: z.string(),\n        /** Version of the SDK used */\n        sdkVersion: z.string(),\n        /** Version of the CLI used */\n        cliVersion: z.string(),\n    }),\n    /** Run information */\n    run: z.object({\n        /** Unique identifier for the run */\n        id: z.string(),\n        /** Run number */\n        number: z.number(),\n        /** Current status of the run */\n        status: RunStatus,\n        /** When the run was created */\n        createdAt: z.coerce.date(),\n        /** When the run started executing */\n        startedAt: z.coerce.date().optional(),\n        /** When the run finished executing */\n        completedAt: z.coerce.date().optional(),\n        /** Whether this is a test run */\n        isTest: z.boolean(),\n        /** Idempotency key for the run */\n        idempotencyKey: z.string().optional(),\n        /** Associated tags */\n        tags: z.array(z.string()),\n        /** Error information */\n        error: TaskRunError,\n        /** Whether the run was an out-of-memory error */\n        isOutOfMemoryError: z.boolean(),\n        /** Machine preset used for the run */\n        machine: z.string(),\n        /** URL to view the run in the dashboard */\n        dashboardUrl: z.string(),\n    }),\n    /** Environment information */\n    environment: z.object({\n        /** Environment ID */\n        id: z.string(),\n        /** Environment type */\n        type: RuntimeEnvironmentTypeSchema,\n        /** Environment slug */\n        slug: z.string(),\n    }),\n    /** Organization information */\n    organization: z.object({\n        /** Organization ID */\n        id: z.string(),\n        /** Organization slug */\n        slug: z.string(),\n        /** Organization name */\n        name: z.string(),\n    }),\n    /** Project information */\n    project: z.object({\n        /** Project ID */\n        id: z.string(),\n        /** Project reference */\n        ref: z.string(),\n        /** Project slug */\n        slug: z.string(),\n        /** Project name */\n        name: z.string(),\n    }),\n});\n/** Represents a deployment error */\nexport const DeployError = z.object({\n    /** Error name */\n    name: z.string(),\n    /** Error message */\n    message: z.string(),\n    /** Error stack trace */\n    stack: z.string().optional(),\n    /** Standard error output */\n    stderr: z.string().optional(),\n});\nconst deploymentCommonProperties = {\n    /** Environment information */\n    environment: z.object({\n        id: z.string(),\n        type: RuntimeEnvironmentTypeSchema,\n        slug: z.string(),\n    }),\n    /** Organization information */\n    organization: z.object({\n        id: z.string(),\n        slug: z.string(),\n        name: z.string(),\n    }),\n    /** Project information */\n    project: z.object({\n        id: z.string(),\n        ref: z.string(),\n        slug: z.string(),\n        name: z.string(),\n    }),\n};\nconst deploymentDeploymentCommonProperties = {\n    /** Deployment ID */\n    id: z.string(),\n    /** Deployment status */\n    status: z.string(),\n    /** Deployment version */\n    version: z.string(),\n    /** Short code identifier */\n    shortCode: z.string(),\n};\n/** Represents a successful deployment alert webhook payload */\nexport const AlertWebhookDeploymentSuccessObject = z.object({\n    ...deploymentCommonProperties,\n    deployment: z.object({\n        ...deploymentDeploymentCommonProperties,\n        /** When the deployment completed */\n        deployedAt: z.coerce.date(),\n    }),\n    /** Deployed tasks */\n    tasks: z.array(z.object({\n        /** Task ID */\n        id: z.string(),\n        /** File path where the task is defined */\n        filePath: z.string(),\n        /** Name of the exported task function */\n        exportName: z.string(),\n        /** Source of the trigger */\n        triggerSource: z.string(),\n    })),\n});\n/** Represents a failed deployment alert webhook payload */\nexport const AlertWebhookDeploymentFailedObject = z.object({\n    ...deploymentCommonProperties,\n    deployment: z.object({\n        ...deploymentDeploymentCommonProperties,\n        /** When the deployment failed */\n        failedAt: z.coerce.date(),\n    }),\n    /** Error information */\n    error: DeployError,\n});\n/** Common properties for all webhooks */\nconst commonProperties = {\n    /** Webhook ID */\n    id: z.string(),\n    /** When the webhook was created */\n    created: z.coerce.date(),\n    /** Version of the webhook */\n    webhookVersion: z.string(),\n};\n/** Represents all possible webhook types */\nexport const Webhook = z.discriminatedUnion(\"type\", [\n    /** Run failed alert webhook */\n    z.object({\n        ...commonProperties,\n        type: z.literal(\"alert.run.failed\"),\n        object: AlertWebhookRunFailedObject,\n    }),\n    /** Deployment success alert webhook */\n    z.object({\n        ...commonProperties,\n        type: z.literal(\"alert.deployment.success\"),\n        object: AlertWebhookDeploymentSuccessObject,\n    }),\n    /** Deployment failed alert webhook */\n    z.object({\n        ...commonProperties,\n        type: z.literal(\"alert.deployment.failed\"),\n        object: AlertWebhookDeploymentFailedObject,\n    }),\n]);\n//# sourceMappingURL=webhooks.js.map","export * from \"./tokens.js\";\nexport * from \"./api.js\";\nexport * from \"./resources.js\";\nexport * from \"./common.js\";\nexport * from \"./messages.js\";\nexport * from \"./schemas.js\";\nexport * from \"./style.js\";\nexport * from \"./fetch.js\";\nexport * from \"./eventFilter.js\";\nexport * from \"./openTelemetry.js\";\nexport * from \"./config.js\";\nexport * from \"./build.js\";\nexport * from \"./webhooks.js\";\n//# sourceMappingURL=index.js.map","export const SemanticInternalAttributes = {\n    ENVIRONMENT_ID: \"ctx.environment.id\",\n    ENVIRONMENT_TYPE: \"ctx.environment.type\",\n    ORGANIZATION_ID: \"ctx.organization.id\",\n    ORGANIZATION_SLUG: \"ctx.organization.slug\",\n    ORGANIZATION_NAME: \"ctx.organization.name\",\n    PROJECT_ID: \"ctx.project.id\",\n    PROJECT_REF: \"ctx.project.ref\",\n    PROJECT_NAME: \"ctx.project.title\",\n    PROJECT_DIR: \"project.dir\",\n    ATTEMPT_ID: \"ctx.attempt.id\",\n    ATTEMPT_NUMBER: \"ctx.attempt.number\",\n    RUN_ID: \"ctx.run.id\",\n    RUN_IS_TEST: \"ctx.run.isTest\",\n    BATCH_ID: \"ctx.batch.id\",\n    TASK_SLUG: \"ctx.task.id\",\n    TASK_PATH: \"ctx.task.filePath\",\n    TASK_EXPORT_NAME: \"ctx.task.exportName\",\n    QUEUE_NAME: \"ctx.queue.name\",\n    QUEUE_ID: \"ctx.queue.id\",\n    MACHINE_PRESET_NAME: \"ctx.machine.name\",\n    MACHINE_PRESET_CPU: \"ctx.machine.cpu\",\n    MACHINE_PRESET_MEMORY: \"ctx.machine.memory\",\n    MACHINE_PRESET_CENTS_PER_MS: \"ctx.machine.centsPerMs\",\n    SPAN_PARTIAL: \"$span.partial\",\n    SPAN_ID: \"$span.span_id\",\n    OUTPUT: \"$output\",\n    OUTPUT_TYPE: \"$mime_type_output\",\n    STYLE: \"$style\",\n    STYLE_ICON: \"$style.icon\",\n    STYLE_VARIANT: \"$style.variant\",\n    STYLE_ACCESSORY: \"$style.accessory\",\n    METADATA: \"$metadata\",\n    TRIGGER: \"$trigger\",\n    PAYLOAD: \"$payload\",\n    PAYLOAD_TYPE: \"$mime_type_payload\",\n    SHOW: \"$show\",\n    SHOW_ACTIONS: \"$show.actions\",\n    WORKER_ID: \"worker.id\",\n    WORKER_VERSION: \"worker.version\",\n    CLI_VERSION: \"cli.version\",\n    SDK_VERSION: \"sdk.version\",\n    SDK_LANGUAGE: \"sdk.language\",\n    RETRY_AT: \"retry.at\",\n    RETRY_DELAY: \"retry.delay\",\n    RETRY_COUNT: \"retry.count\",\n    LINK_TITLE: \"$link.title\",\n    IDEMPOTENCY_KEY: \"ctx.run.idempotencyKey\",\n    USAGE_DURATION_MS: \"$usage.durationMs\",\n    USAGE_COST_IN_CENTS: \"$usage.costInCents\",\n    RATE_LIMIT_LIMIT: \"response.rateLimit.limit\",\n    RATE_LIMIT_REMAINING: \"response.rateLimit.remaining\",\n    RATE_LIMIT_RESET: \"response.rateLimit.reset\",\n    SPAN_ATTEMPT: \"$span.attempt\",\n    METRIC_EVENTS: \"$metrics.events\",\n};\n//# sourceMappingURL=semanticInternalAttributes.js.map","export const _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n//# sourceMappingURL=platform.js.map","import { _globalThis } from \"./platform.js\";\nconst GLOBAL_TRIGGER_DOT_DEV_KEY = Symbol.for(`dev.trigger.ts.api`);\nconst _global = _globalThis;\nexport function registerGlobal(type, instance, allowOverride = false) {\n    const api = (_global[GLOBAL_TRIGGER_DOT_DEV_KEY] = _global[GLOBAL_TRIGGER_DOT_DEV_KEY] ?? {});\n    if (!allowOverride && api[type]) {\n        // already registered an API of this type\n        const err = new Error(`trigger.dev: Attempted duplicate registration of API: ${type}`);\n        return false;\n    }\n    api[type] = instance;\n    return true;\n}\nexport function getGlobal(type) {\n    return _global[GLOBAL_TRIGGER_DOT_DEV_KEY]?.[type];\n}\nexport function unregisterGlobal(type) {\n    const api = _global[GLOBAL_TRIGGER_DOT_DEV_KEY];\n    if (api) {\n        delete api[type];\n    }\n}\n//# sourceMappingURL=globals.js.map","import { SemanticInternalAttributes } from \"../semanticInternalAttributes.js\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals.js\";\nconst API_NAME = \"task-context\";\nexport class TaskContextAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new TaskContextAPI();\n        }\n        return this._instance;\n    }\n    get isInsideTask() {\n        return this.#getTaskContext() !== undefined;\n    }\n    get ctx() {\n        return this.#getTaskContext()?.ctx;\n    }\n    get worker() {\n        return this.#getTaskContext()?.worker;\n    }\n    get attributes() {\n        if (this.ctx) {\n            return {\n                ...this.contextAttributes,\n                ...this.workerAttributes,\n            };\n        }\n        return {};\n    }\n    get workerAttributes() {\n        if (this.worker) {\n            return {\n                [SemanticInternalAttributes.WORKER_ID]: this.worker.id,\n                [SemanticInternalAttributes.WORKER_VERSION]: this.worker.version,\n            };\n        }\n        return {};\n    }\n    get contextAttributes() {\n        if (this.ctx) {\n            return {\n                [SemanticInternalAttributes.ATTEMPT_ID]: this.ctx.attempt.id,\n                [SemanticInternalAttributes.ATTEMPT_NUMBER]: this.ctx.attempt.number,\n                [SemanticInternalAttributes.TASK_SLUG]: this.ctx.task.id,\n                [SemanticInternalAttributes.TASK_PATH]: this.ctx.task.filePath,\n                [SemanticInternalAttributes.TASK_EXPORT_NAME]: this.ctx.task.exportName,\n                [SemanticInternalAttributes.QUEUE_NAME]: this.ctx.queue.name,\n                [SemanticInternalAttributes.QUEUE_ID]: this.ctx.queue.id,\n                [SemanticInternalAttributes.ENVIRONMENT_ID]: this.ctx.environment.id,\n                [SemanticInternalAttributes.ENVIRONMENT_TYPE]: this.ctx.environment.type,\n                [SemanticInternalAttributes.ORGANIZATION_ID]: this.ctx.organization.id,\n                [SemanticInternalAttributes.PROJECT_ID]: this.ctx.project.id,\n                [SemanticInternalAttributes.PROJECT_REF]: this.ctx.project.ref,\n                [SemanticInternalAttributes.PROJECT_NAME]: this.ctx.project.name,\n                [SemanticInternalAttributes.RUN_ID]: this.ctx.run.id,\n                [SemanticInternalAttributes.RUN_IS_TEST]: this.ctx.run.isTest,\n                [SemanticInternalAttributes.ORGANIZATION_SLUG]: this.ctx.organization.slug,\n                [SemanticInternalAttributes.ORGANIZATION_NAME]: this.ctx.organization.name,\n                [SemanticInternalAttributes.BATCH_ID]: this.ctx.batch?.id,\n                [SemanticInternalAttributes.IDEMPOTENCY_KEY]: this.ctx.run.idempotencyKey,\n                [SemanticInternalAttributes.MACHINE_PRESET_NAME]: this.ctx.machine?.name,\n                [SemanticInternalAttributes.MACHINE_PRESET_CPU]: this.ctx.machine?.cpu,\n                [SemanticInternalAttributes.MACHINE_PRESET_MEMORY]: this.ctx.machine?.memory,\n                [SemanticInternalAttributes.MACHINE_PRESET_CENTS_PER_MS]: this.ctx.machine?.centsPerMs,\n            };\n        }\n        return {};\n    }\n    disable() {\n        unregisterGlobal(API_NAME);\n    }\n    setGlobalTaskContext(taskContext) {\n        return registerGlobal(API_NAME, taskContext);\n    }\n    #getTaskContext() {\n        return getGlobal(API_NAME);\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskContextAPI } from \"./taskContext/index.js\";\n/** Entrypoint for logger API */\nexport const taskContext = TaskContextAPI.getInstance();\n//# sourceMappingURL=task-context-api.js.map","const identifierRegex = /[$_\\p{ID_Start}][$\\u200c\\u200d\\p{ID_Continue}]*/u;\nexport function joinPath(path) {\n    if (path.length === 1) {\n        return path[0].toString();\n    }\n    return path.reduce((acc, item) => {\n        if (typeof item === 'number') {\n            return acc + '[' + item.toString() + ']';\n        }\n        if (item.includes('\"')) {\n            return acc + '[\"' + escapeQuotes(item) + '\"]';\n        }\n        if (!identifierRegex.test(item)) {\n            return acc + '[\"' + item + '\"]';\n        }\n        const separator = acc.length === 0 ? '' : '.';\n        return acc + separator + item;\n    }, '');\n}\nfunction escapeQuotes(str) {\n    return str.replace(/\"/g, '\\\\\"');\n}\n","export function isNonEmptyArray(value) {\n    return value.length !== 0;\n}\n","import * as zod from 'zod';\nimport { joinPath } from './utils/joinPath';\nimport { isNonEmptyArray } from './utils/NonEmptyArray';\nconst MAX_ISSUES_IN_MESSAGE = 99;\nconst ISSUE_SEPARATOR = '; ';\nconst UNION_SEPARATOR = ', or ';\nconst PREFIX = 'Validation error';\nconst PREFIX_SEPARATOR = ': ';\nexport class ValidationError extends Error {\n    details;\n    name;\n    constructor(message, details = []) {\n        super(message);\n        this.details = details;\n        this.name = 'ZodValidationError';\n    }\n    toString() {\n        return this.message;\n    }\n}\nfunction getMessageFromZodIssue(issue, issueSeparator, unionSeparator) {\n    if (issue.code === 'invalid_union') {\n        return issue.unionErrors\n            .reduce((acc, zodError) => {\n            const newIssues = zodError.issues\n                .map((issue) => getMessageFromZodIssue(issue, issueSeparator, unionSeparator))\n                .join(issueSeparator);\n            if (!acc.includes(newIssues)) {\n                acc.push(newIssues);\n            }\n            return acc;\n        }, [])\n            .join(unionSeparator);\n    }\n    if (isNonEmptyArray(issue.path)) {\n        if (issue.path.length === 1) {\n            const identifier = issue.path[0];\n            if (typeof identifier === 'number') {\n                return `${issue.message} at index ${identifier}`;\n            }\n        }\n        return `${issue.message} at \"${joinPath(issue.path)}\"`;\n    }\n    return issue.message;\n}\nfunction conditionallyPrefixMessage(reason, prefix, prefixSeparator) {\n    if (prefix !== null) {\n        if (reason.length > 0) {\n            return [prefix, reason].join(prefixSeparator);\n        }\n        return prefix;\n    }\n    if (reason.length > 0) {\n        return reason;\n    }\n    return PREFIX;\n}\nexport function fromZodIssue(issue, options = {}) {\n    const { issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX, } = options;\n    const reason = getMessageFromZodIssue(issue, issueSeparator, unionSeparator);\n    const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);\n    return new ValidationError(message, [issue]);\n}\nexport function fromZodError(zodError, options = {}) {\n    const { maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE, issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX, } = options;\n    const reason = zodError.errors\n        .slice(0, maxIssuesInMessage)\n        .map((issue) => getMessageFromZodIssue(issue, issueSeparator, unionSeparator))\n        .join(issueSeparator);\n    const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);\n    return new ValidationError(message, zodError.errors);\n}\nexport const toValidationError = (options = {}) => (err) => {\n    if (err instanceof zod.ZodError) {\n        return fromZodError(err, options);\n    }\n    if (err instanceof Error) {\n        return err;\n    }\n    return new Error('Unknown error');\n};\nexport function isValidationError(err) {\n    return err instanceof ValidationError;\n}\nexport function isValidationErrorLike(err) {\n    return err instanceof Error && err.name === 'ZodValidationError';\n}\nexport const errorMap = (issue, ctx) => {\n    const error = fromZodIssue({\n        ...issue,\n        message: issue.message ?? ctx.defaultError,\n    });\n    return {\n        message: error.message,\n    };\n};\n","const DEFAULT_RETRY_OPTIONS = {\n    limit: 5,\n    factor: 1.8,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 60000,\n    randomize: true,\n};\nexport function calculateRetryAt(retryOptions, attempts) {\n    const options = {\n        ...DEFAULT_RETRY_OPTIONS,\n        ...retryOptions,\n    };\n    const retryCount = attempts + 1;\n    if (retryCount >= options.limit) {\n        return;\n    }\n    const random = options.randomize ? Math.random() + 1 : 1;\n    let timeoutInMs = Math.round(random *\n        Math.max(options.minTimeoutInMs, 1) *\n        Math.pow(options.factor, Math.max(attempts - 1, 0)));\n    timeoutInMs = Math.min(timeoutInMs, options.maxTimeoutInMs);\n    return new Date(Date.now() + timeoutInMs);\n}\nexport function calculateResetAt(resets, format, now = new Date()) {\n    if (!resets)\n        return;\n    switch (format) {\n        case \"iso_8601_duration_openai_variant\": {\n            return calculateISO8601DurationOpenAIVariantResetAt(resets, now);\n        }\n        case \"iso_8601\": {\n            return calculateISO8601ResetAt(resets, now);\n        }\n        case \"unix_timestamp\": {\n            return calculateUnixTimestampResetAt(resets, now);\n        }\n        case \"unix_timestamp_in_ms\": {\n            return calculateUnixTimestampInMsResetAt(resets, now);\n        }\n    }\n}\nfunction calculateUnixTimestampResetAt(resets, now = new Date()) {\n    // Check if the input is null or undefined\n    if (!resets)\n        return undefined;\n    // Convert the string to a number\n    const resetAt = parseInt(resets, 10);\n    // If the string doesn't match the expected format, return undefined\n    if (isNaN(resetAt))\n        return undefined;\n    // Return the date\n    return new Date(resetAt * 1000);\n}\nfunction calculateUnixTimestampInMsResetAt(resets, now = new Date()) {\n    // Check if the input is null or undefined\n    if (!resets)\n        return undefined;\n    // Convert the string to a number\n    const resetAt = parseInt(resets, 10);\n    // If the string doesn't match the expected format, return undefined\n    if (isNaN(resetAt))\n        return undefined;\n    // Return the date\n    return new Date(resetAt);\n}\nfunction calculateISO8601ResetAt(resets, now = new Date()) {\n    // Check if the input is null or undefined\n    if (!resets)\n        return undefined;\n    // Parse the date\n    const resetAt = new Date(resets);\n    // If the string doesn't match the expected format, return undefined\n    if (isNaN(resetAt.getTime()))\n        return undefined;\n    return resetAt;\n}\nfunction calculateISO8601DurationOpenAIVariantResetAt(resets, now = new Date()) {\n    // Check if the input is null or undefined\n    if (!resets)\n        return undefined;\n    // Regular expression to match the duration string pattern\n    const pattern = /^(?:(\\d+)d)?(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+(?:\\.\\d+)?)s)?(?:(\\d+)ms)?$/;\n    const match = resets.match(pattern);\n    // If the string doesn't match the expected format, return undefined\n    if (!match)\n        return undefined;\n    // Extract days, hours, minutes, seconds, and milliseconds from the string\n    const days = parseInt(match[1] ?? \"0\", 10) || 0;\n    const hours = parseInt(match[2] ?? \"0\", 10) || 0;\n    const minutes = parseInt(match[3] ?? \"0\", 10) || 0;\n    const seconds = parseFloat(match[4] ?? \"0\") || 0;\n    const milliseconds = parseInt(match[5] ?? \"0\", 10) || 0;\n    // Calculate the future date based on the current date plus the extracted time\n    const resetAt = new Date(now);\n    resetAt.setDate(resetAt.getDate() + days);\n    resetAt.setHours(resetAt.getHours() + hours);\n    resetAt.setMinutes(resetAt.getMinutes() + minutes);\n    resetAt.setSeconds(resetAt.getSeconds() + Math.floor(seconds));\n    resetAt.setMilliseconds(resetAt.getMilliseconds() + (seconds - Math.floor(seconds)) * 1000 + milliseconds);\n    return resetAt;\n}\n//# sourceMappingURL=retry.js.map","import { calculateResetAt as calculateResetAtInternal } from \"../../retry.js\";\nexport const defaultRetryOptions = {\n    maxAttempts: 3,\n    factor: 2,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 60000,\n    randomize: true,\n};\nexport const defaultFetchRetryOptions = {\n    byStatus: {\n        \"429,408,409,5xx\": {\n            strategy: \"backoff\",\n            ...defaultRetryOptions,\n        },\n    },\n    connectionError: defaultRetryOptions,\n    timeout: defaultRetryOptions,\n};\n/**\n *\n * @param options\n * @param attempt - The current attempt number. If the first attempt has failed, this will be 1.\n * @returns\n */\nexport function calculateNextRetryDelay(options, attempt) {\n    const opts = { ...defaultRetryOptions, ...options };\n    if (attempt >= opts.maxAttempts) {\n        return;\n    }\n    const { factor, minTimeoutInMs, maxTimeoutInMs, randomize } = opts;\n    const random = randomize ? Math.random() + 1 : 1;\n    const timeout = Math.min(maxTimeoutInMs, random * minTimeoutInMs * Math.pow(factor, attempt - 1));\n    // Round to the nearest integer\n    return Math.round(timeout);\n}\nexport function calculateResetAt(resets, format, now = Date.now()) {\n    const resetAt = calculateResetAtInternal(resets, format, new Date(now));\n    return resetAt?.getTime();\n}\n//# sourceMappingURL=retries.js.map","export class ApiError extends Error {\n    status;\n    headers;\n    error;\n    code;\n    param;\n    type;\n    constructor(status, error, message, headers) {\n        super(`${ApiError.makeMessage(status, error, message)}`);\n        this.name = \"TriggerApiError\";\n        this.status = status;\n        this.headers = headers;\n        const data = error;\n        this.error = data;\n        this.code = data?.[\"code\"];\n        this.param = data?.[\"param\"];\n        this.type = data?.[\"type\"];\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message\n            ? typeof error.message === \"string\"\n                ? error.message\n                : JSON.stringify(error.message)\n            : error\n                ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return \"(no status code or body)\";\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status) {\n            return new ApiConnectionError({ cause: castToError(errorResponse) });\n        }\n        const error = errorResponse?.[\"error\"];\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new ApiError(status, error, message, headers);\n    }\n}\nexport class ApiConnectionError extends ApiError {\n    status = undefined;\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || \"Connection error.\", undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nexport class BadRequestError extends ApiError {\n    status = 400;\n}\nexport class AuthenticationError extends ApiError {\n    status = 401;\n}\nexport class PermissionDeniedError extends ApiError {\n    status = 403;\n}\nexport class NotFoundError extends ApiError {\n    status = 404;\n}\nexport class ConflictError extends ApiError {\n    status = 409;\n}\nexport class UnprocessableEntityError extends ApiError {\n    status = 422;\n}\nexport class RateLimitError extends ApiError {\n    status = 429;\n    get millisecondsUntilReset() {\n        // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n        const resetAtUnixEpochMs = (this.headers ?? {})[\"x-ratelimit-reset\"];\n        if (typeof resetAtUnixEpochMs === \"string\") {\n            const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n            if (isNaN(resetAtUnixEpoch)) {\n                return;\n            }\n            // Add between 0 and 2000ms to the reset time to add jitter\n            return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);\n        }\n        return;\n    }\n}\nexport class InternalServerError extends ApiError {\n}\nexport class ApiSchemaValidationError extends ApiError {\n    status = 200;\n    rawBody;\n    constructor({ message, cause, status, rawBody, headers, }) {\n        super(status, undefined, message || \"Validation error.\", headers);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n        this.rawBody = rawBody;\n    }\n}\nfunction castToError(err) {\n    if (err instanceof Error)\n        return err;\n    return new Error(err);\n}\n//# sourceMappingURL=errors.js.map","export const NULL_SENTINEL = \"$@null((\";\nexport const CIRCULAR_REFERENCE_SENTINEL = \"$@circular((\";\nexport function flattenAttributes(obj, prefix, seen = new WeakSet()) {\n    const result = {};\n    // Check if obj is null or undefined\n    if (obj === undefined) {\n        return result;\n    }\n    if (obj === null) {\n        result[prefix || \"\"] = NULL_SENTINEL;\n        return result;\n    }\n    if (typeof obj === \"string\") {\n        result[prefix || \"\"] = obj;\n        return result;\n    }\n    if (typeof obj === \"number\") {\n        result[prefix || \"\"] = obj;\n        return result;\n    }\n    if (typeof obj === \"boolean\") {\n        result[prefix || \"\"] = obj;\n        return result;\n    }\n    if (obj instanceof Date) {\n        result[prefix || \"\"] = obj.toISOString();\n        return result;\n    }\n    // Check for circular reference\n    if (obj !== null && typeof obj === \"object\" && seen.has(obj)) {\n        result[prefix || \"\"] = CIRCULAR_REFERENCE_SENTINEL;\n        return result;\n    }\n    // Add object to seen set\n    if (obj !== null && typeof obj === \"object\") {\n        seen.add(obj);\n    }\n    for (const [key, value] of Object.entries(obj)) {\n        const newPrefix = `${prefix ? `${prefix}.` : \"\"}${Array.isArray(obj) ? `[${key}]` : key}`;\n        if (Array.isArray(value)) {\n            for (let i = 0; i < value.length; i++) {\n                if (typeof value[i] === \"object\" && value[i] !== null) {\n                    // update null check here as well\n                    Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`, seen));\n                }\n                else {\n                    if (value[i] === null) {\n                        result[`${newPrefix}.[${i}]`] = NULL_SENTINEL;\n                    }\n                    else {\n                        result[`${newPrefix}.[${i}]`] = value[i];\n                    }\n                }\n            }\n        }\n        else if (isRecord(value)) {\n            // update null check here\n            Object.assign(result, flattenAttributes(value, newPrefix, seen));\n        }\n        else {\n            if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n                result[newPrefix] = value;\n            }\n            else if (value === null) {\n                result[newPrefix] = NULL_SENTINEL;\n            }\n        }\n    }\n    return result;\n}\nfunction isRecord(value) {\n    return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\nexport function unflattenAttributes(obj) {\n    if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n        return obj;\n    }\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        Object.keys(obj).length === 1 &&\n        Object.keys(obj)[0] === \"\") {\n        return rehydrateNull(obj[\"\"]);\n    }\n    if (Object.keys(obj).length === 0) {\n        return;\n    }\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        const parts = key.split(\".\").reduce((acc, part) => {\n            if (part.startsWith(\"[\") && part.endsWith(\"]\")) {\n                // Handle array indices more precisely\n                const match = part.match(/^\\[(\\d+)\\]$/);\n                if (match && match[1]) {\n                    acc.push(parseInt(match[1]));\n                }\n                else {\n                    // Remove brackets for non-numeric array keys\n                    acc.push(part.slice(1, -1));\n                }\n            }\n            else {\n                acc.push(part);\n            }\n            return acc;\n        }, []);\n        let current = result;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            const nextPart = parts[i + 1];\n            if (!part && part !== 0) {\n                continue;\n            }\n            if (typeof nextPart === \"number\") {\n                // Ensure we create an array for numeric indices\n                current[part] = Array.isArray(current[part]) ? current[part] : [];\n            }\n            else if (current[part] === undefined) {\n                // Create an object for non-numeric paths\n                current[part] = {};\n            }\n            current = current[part];\n        }\n        const lastPart = parts[parts.length - 1];\n        if (lastPart !== undefined) {\n            current[lastPart] = rehydrateNull(rehydrateCircular(value));\n        }\n    }\n    // Convert the result to an array if all top-level keys are numeric indices\n    if (Object.keys(result).every((k) => /^\\d+$/.test(k))) {\n        const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));\n        const arrayResult = Array(maxIndex + 1);\n        for (const key in result) {\n            arrayResult[parseInt(key)] = result[key];\n        }\n        return arrayResult;\n    }\n    return result;\n}\nfunction rehydrateCircular(value) {\n    if (value === CIRCULAR_REFERENCE_SENTINEL) {\n        return \"[Circular Reference]\";\n    }\n    return value;\n}\nexport function primitiveValueOrflattenedAttributes(obj, prefix) {\n    if (typeof obj === \"string\" ||\n        typeof obj === \"number\" ||\n        typeof obj === \"boolean\" ||\n        obj === null ||\n        obj === undefined) {\n        return obj;\n    }\n    const attributes = flattenAttributes(obj, prefix);\n    if (prefix !== undefined &&\n        typeof attributes[prefix] !== \"undefined\" &&\n        attributes[prefix] !== null) {\n        return attributes[prefix];\n    }\n    return attributes;\n}\nfunction rehydrateNull(value) {\n    if (value === NULL_SENTINEL) {\n        return null;\n    }\n    return value;\n}\n//# sourceMappingURL=flattenAttributes.js.map","import { flattenAttributes } from \"./flattenAttributes.js\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes.js\";\nexport function accessoryAttributes(accessory) {\n    return flattenAttributes(accessory, SemanticInternalAttributes.STYLE_ACCESSORY);\n}\n//# sourceMappingURL=styleAttributes.js.map","export class CursorPage {\n    pageFetcher;\n    data;\n    pagination;\n    constructor(data, pagination, pageFetcher) {\n        this.pageFetcher = pageFetcher;\n        this.data = data;\n        this.pagination = pagination;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        return !!this.pagination.next;\n    }\n    hasPreviousPage() {\n        return !!this.pagination.previous;\n    }\n    getNextPage() {\n        if (!this.pagination.next) {\n            throw new Error(\"No next page available\");\n        }\n        return this.pageFetcher({ after: this.pagination.next });\n    }\n    getPreviousPage() {\n        if (!this.pagination.previous) {\n            throw new Error(\"No previous page available\");\n        }\n        return this.pageFetcher({ before: this.pagination.previous });\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[Symbol.asyncIterator]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\nexport class OffsetLimitPage {\n    pageFetcher;\n    data;\n    pagination;\n    constructor(data, pagination, pageFetcher) {\n        this.pageFetcher = pageFetcher;\n        this.data = data;\n        this.pagination = pagination;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        return this.pagination.currentPage < this.pagination.totalPages;\n    }\n    hasPreviousPage() {\n        return this.pagination.currentPage > 1;\n    }\n    getNextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No next page available\");\n        }\n        return this.pageFetcher({\n            page: this.pagination.currentPage + 1,\n        });\n    }\n    getPreviousPage() {\n        if (!this.hasPreviousPage()) {\n            throw new Error(\"No previous page available\");\n        }\n        return this.pageFetcher({\n            page: this.pagination.currentPage - 1,\n        });\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[Symbol.asyncIterator]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n//# sourceMappingURL=pagination.js.map","import { z } from \"zod\";\nimport { fromZodError, ValidationError } from \"zod-validation-error\";\nimport { calculateNextRetryDelay } from \"../utils/retries.js\";\nimport { ApiConnectionError, ApiError, ApiSchemaValidationError } from \"./errors.js\";\nimport { context, propagation } from \"@opentelemetry/api\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes.js\";\nimport { accessoryAttributes } from \"../utils/styleAttributes.js\";\nimport { CursorPage, OffsetLimitPage, } from \"./pagination.js\";\nimport { EventSource } from \"eventsource\";\nexport const defaultRetryOptions = {\n    maxAttempts: 3,\n    factor: 2,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 60000,\n    randomize: false,\n};\n// This is required so that we can determine if a given object matches the ApiRequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n    retry: true,\n};\nexport const isRequestOptions = (obj) => {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        !isEmptyObj(obj) &&\n        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n};\nexport function zodfetch(schema, url, requestInit, options) {\n    return new ApiPromise(_doZodFetch(schema, url, requestInit, options));\n}\nexport function zodfetchCursorPage(schema, url, params, requestInit, options) {\n    const query = new URLSearchParams(params.query);\n    if (params.limit) {\n        query.set(\"page[size]\", String(params.limit));\n    }\n    if (params.after) {\n        query.set(\"page[after]\", params.after);\n    }\n    if (params.before) {\n        query.set(\"page[before]\", params.before);\n    }\n    const cursorPageSchema = z.object({\n        data: z.array(schema),\n        pagination: z.object({\n            next: z.string().optional(),\n            previous: z.string().optional(),\n        }),\n    });\n    const $url = new URL(url);\n    $url.search = query.toString();\n    const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);\n    return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\nexport function zodfetchOffsetLimitPage(schema, url, params, requestInit, options) {\n    const query = new URLSearchParams(params.query);\n    if (params.limit) {\n        query.set(\"perPage\", String(params.limit));\n    }\n    if (params.page) {\n        query.set(\"page\", String(params.page));\n    }\n    const offsetLimitPageSchema = z.object({\n        data: z.array(schema),\n        pagination: z.object({\n            currentPage: z.coerce.number(),\n            totalPages: z.coerce.number(),\n            count: z.coerce.number(),\n        }),\n    });\n    const $url = new URL(url);\n    $url.search = query.toString();\n    const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);\n    return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\nasync function traceZodFetch(params, callback) {\n    if (!params.options?.tracer) {\n        return callback();\n    }\n    const url = new URL(params.url);\n    const method = params.requestInit?.method ?? \"GET\";\n    const name = params.options.name ?? `${method} ${url.pathname}`;\n    return await params.options.tracer.startActiveSpan(name, async (span) => {\n        return await callback(span);\n    }, {\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? \"api\",\n            ...params.options.attributes,\n        },\n    });\n}\nasync function _doZodFetch(schema, url, requestInit, options) {\n    let $requestInit = await requestInit;\n    return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {\n        $requestInit = injectPropagationHeadersIfInWorker($requestInit);\n        const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);\n        if (options?.onResponseBody && span) {\n            options.onResponseBody(result.data, span);\n        }\n        if (options?.prepareData) {\n            result.data = await options.prepareData(result.data);\n        }\n        return result;\n    });\n}\nasync function _doZodFetchWithRetries(schema, url, requestInit, options, attempt = 1) {\n    try {\n        const response = await fetch(url, requestInitWithCache(requestInit));\n        const responseHeaders = createResponseHeaders(response.headers);\n        if (!response.ok) {\n            const retryResult = shouldRetry(response, attempt, options?.retry);\n            if (retryResult.retry) {\n                await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);\n                return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n            }\n            else {\n                const errText = await response.text().catch((e) => castToError(e).message);\n                const errJSON = safeJsonParse(errText);\n                const errMessage = errJSON ? undefined : errText;\n                throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);\n            }\n        }\n        const jsonBody = await safeJsonFromResponse(response);\n        const parsedResult = schema.safeParse(jsonBody);\n        if (parsedResult.success) {\n            return { data: parsedResult.data, response };\n        }\n        const validationError = fromZodError(parsedResult.error);\n        throw new ApiSchemaValidationError({\n            status: response.status,\n            cause: validationError,\n            message: validationError.message,\n            rawBody: jsonBody,\n            headers: responseHeaders,\n        });\n    }\n    catch (error) {\n        if (error instanceof ApiError) {\n            throw error;\n        }\n        if (error instanceof ValidationError) {\n        }\n        if (options?.retry) {\n            const retry = { ...defaultRetryOptions, ...options.retry };\n            const delay = calculateNextRetryDelay(retry, attempt);\n            if (delay) {\n                await waitForRetry(url, attempt + 1, delay, options, requestInit);\n                return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n            }\n        }\n        throw new ApiConnectionError({ cause: castToError(error) });\n    }\n}\nasync function safeJsonFromResponse(response) {\n    try {\n        return await response.clone().json();\n    }\n    catch (error) {\n        return;\n    }\n}\nfunction castToError(err) {\n    if (err instanceof Error)\n        return err;\n    return new Error(err);\n}\nfunction shouldRetry(response, attempt, retryOptions) {\n    function shouldRetryForOptions() {\n        const retry = { ...defaultRetryOptions, ...retryOptions };\n        const delay = calculateNextRetryDelay(retry, attempt);\n        if (delay) {\n            return { retry: true, delay };\n        }\n        else {\n            return { retry: false };\n        }\n    }\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n    // If the server explicitly says whether or not to retry, obey.\n    if (shouldRetryHeader === \"true\")\n        return shouldRetryForOptions();\n    if (shouldRetryHeader === \"false\")\n        return { retry: false };\n    // Retry on request timeouts.\n    if (response.status === 408)\n        return shouldRetryForOptions();\n    // Retry on lock timeouts.\n    if (response.status === 409)\n        return shouldRetryForOptions();\n    // Retry on rate limits.\n    if (response.status === 429) {\n        if (attempt >= (typeof retryOptions?.maxAttempts === \"number\" ? retryOptions?.maxAttempts : 3)) {\n            return { retry: false };\n        }\n        // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n        const resetAtUnixEpochMs = response.headers.get(\"x-ratelimit-reset\");\n        if (resetAtUnixEpochMs) {\n            const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n            const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);\n            if (delay > 0) {\n                return { retry: true, delay };\n            }\n        }\n        return shouldRetryForOptions();\n    }\n    // Retry internal errors.\n    if (response.status >= 500)\n        return shouldRetryForOptions();\n    return { retry: false };\n}\nfunction safeJsonParse(text) {\n    try {\n        return JSON.parse(text);\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nfunction createResponseHeaders(headers) {\n    return new Proxy(Object.fromEntries(\n    // @ts-ignore\n    headers.entries()), {\n        get(target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        },\n    });\n}\nfunction requestInitWithCache(requestInit) {\n    try {\n        const withCache = {\n            ...requestInit,\n            cache: \"no-cache\",\n        };\n        const _ = new Request(\"http://localhost\", withCache);\n        return withCache;\n    }\n    catch (error) {\n        return requestInit ?? {};\n    }\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class ApiPromise extends Promise {\n    responsePromise;\n    constructor(responsePromise) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data and the raw `Response` instance.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response };\n    }\n    parse() {\n        return this.responsePromise.then((result) => result.data);\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nexport class CursorPagePromise extends ApiPromise {\n    schema;\n    url;\n    params;\n    requestInit;\n    options;\n    constructor(result, schema, url, params, requestInit, options) {\n        super(result.then((result) => ({\n            data: new CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),\n            response: result.response,\n        })));\n        this.schema = schema;\n        this.url = url;\n        this.params = params;\n        this.requestInit = requestInit;\n        this.options = options;\n    }\n    #fetchPage(params) {\n        return zodfetchCursorPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexport class OffsetLimitPagePromise extends ApiPromise {\n    schema;\n    url;\n    params;\n    requestInit;\n    options;\n    constructor(result, schema, url, params, requestInit, options) {\n        super(result.then((result) => ({\n            data: new OffsetLimitPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),\n            response: result.response,\n        })));\n        this.schema = schema;\n        this.url = url;\n        this.params = params;\n        this.requestInit = requestInit;\n        this.options = options;\n    }\n    #fetchPage(params) {\n        return zodfetchOffsetLimitPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nasync function waitForRetry(url, attempt, delay, options, requestInit, response) {\n    if (options?.tracer) {\n        const method = requestInit?.method ?? \"GET\";\n        return options.tracer.startActiveSpan(response ? `wait after ${response.status}` : `wait after error`, async (span) => {\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }, {\n            attributes: {\n                [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n                ...accessoryAttributes({\n                    items: [\n                        {\n                            text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,\n                            variant: \"normal\",\n                        },\n                    ],\n                    style: \"codepath\",\n                }),\n            },\n        });\n    }\n    await new Promise((resolve) => setTimeout(resolve, delay));\n}\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n// If the requestInit has a header x-trigger-worker = true, then we will do\n// propagation.inject(context.active(), headers);\n// and return the new requestInit.\nfunction injectPropagationHeadersIfInWorker(requestInit) {\n    const headers = new Headers(requestInit?.headers);\n    if (headers.get(\"x-trigger-worker\") !== \"true\") {\n        return requestInit;\n    }\n    const headersObject = Object.fromEntries(headers.entries());\n    propagation.inject(context.active(), headersObject);\n    return {\n        ...requestInit,\n        headers: new Headers(headersObject),\n    };\n}\nexport class ZodFetchSSEResult {\n    options;\n    _eventSource;\n    constructor(options) {\n        this.options = options;\n        this._eventSource = new EventSource(options.url, {\n            fetch: (input, init) => {\n                return fetch(input, {\n                    ...init,\n                    ...options.request,\n                    headers: {\n                        ...options.request?.headers,\n                        Accept: \"text/event-stream\",\n                    },\n                });\n            },\n        });\n    }\n    onConnectionError(handler) {\n        this._eventSource.onerror = handler;\n    }\n    onMessage(type, handler) {\n        this._eventSource.addEventListener(type, (event) => {\n            const payload = safeJsonParse(event.data);\n            if (!payload) {\n                return;\n            }\n            const schema = this.options.messages[type];\n            const result = schema.safeParse(payload);\n            if (result.success) {\n                handler?.(result.data);\n            }\n            else {\n                console.error(result.error);\n            }\n        });\n    }\n    stop() {\n        this._eventSource.close();\n    }\n}\nexport function zodfetchSSE(options) {\n    return new ZodFetchSSEResult(options);\n}\n//# sourceMappingURL=core.js.map","class ParseError extends Error {\n  constructor(message, options) {\n    super(message), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n}\nfunction noop(_arg) {\n}\nfunction createParser(callbacks) {\n  if (typeof callbacks == \"function\")\n    throw new TypeError(\n      \"`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?\"\n    );\n  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;\n  let incompleteLine = \"\", isFirstChunk = !0, id, data = \"\", eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete)\n      parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = !1;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(\n          new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n            type: \"invalid-retry\",\n            value,\n            line\n          })\n        );\n        break;\n      default:\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`,\n            { type: \"unknown-field\", field, value, line }\n          )\n        );\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return { feed, reset };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\", searchIndex = 0;\n  for (; searchIndex < chunk.length; ) {\n    const crIndex = chunk.indexOf(\"\\r\", searchIndex), lfIndex = chunk.indexOf(`\n`, searchIndex);\n    let lineEnd = -1;\n    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {\n      incompleteLine = chunk.slice(searchIndex);\n      break;\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd);\n      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === \"\\r\" && chunk[searchIndex] === `\n` && searchIndex++;\n    }\n  }\n  return [lines, incompleteLine];\n}\nexport {\n  ParseError,\n  createParser\n};\n//# sourceMappingURL=index.js.map\n","import { createParser } from \"./index.js\";\nimport { ParseError } from \"./index.js\";\nclass EventSourceParserStream extends TransformStream {\n  constructor({ onError, onRetry, onComment } = {}) {\n    let parser;\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          },\n          onError(error) {\n            onError === \"terminate\" ? controller.error(error) : typeof onError == \"function\" && onError(error);\n          },\n          onRetry,\n          onComment\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      }\n    });\n  }\n}\nexport {\n  EventSourceParserStream,\n  ParseError\n};\n//# sourceMappingURL=stream.js.map\n","export const links = {\n    docs: {\n        config: {\n            home: \"https://trigger.dev/docs/config/config-file\",\n            additionalPackages: \"https://trigger.dev/docs/config/config-file#additionalpackages\",\n            extensions: \"https://trigger.dev/docs/config/config-file#extensions\",\n            prisma: \"https://trigger.dev/docs/config/config-file#prisma\",\n        },\n        machines: {\n            home: \"https://trigger.dev/docs/v3/machines\",\n        },\n        upgrade: {\n            beta: \"https://trigger.dev/docs/upgrading-beta\",\n        },\n        troubleshooting: {\n            concurrentWaits: \"https://trigger.dev/docs/troubleshooting#parallel-waits-are-not-supported\",\n        },\n        concurrency: {\n            recursiveDeadlock: \"https://trigger.dev/docs/queue-concurrency#waiting-for-a-subtask-on-the-same-queue\",\n        },\n    },\n    site: {\n        home: \"https://trigger.dev\",\n        contact: \"https://trigger.dev/contact\",\n    },\n};\n//# sourceMappingURL=links.js.map","import { ImportTaskFileErrors } from \"./schemas/build.js\";\nimport { TaskRunErrorCodes, } from \"./schemas/common.js\";\nimport { TaskMetadataFailedToParseData } from \"./schemas/messages.js\";\nimport { links } from \"./links.js\";\nimport { assertExhaustive } from \"../utils.js\";\n/**\n * If you throw this, it will get converted into an INTERNAL_ERROR\n */\nexport class InternalError extends Error {\n    code;\n    skipRetrying;\n    constructor({ code, message, showStackTrace = true, skipRetrying = false, }) {\n        super(`${code}: ${message ?? \"No message\"}`);\n        this.name = \"TriggerInternalError\";\n        this.code = code;\n        this.message = message ?? \"InternalError\";\n        if (!showStackTrace) {\n            this.stack = undefined;\n        }\n        this.skipRetrying = skipRetrying;\n    }\n}\nexport function isInternalError(error) {\n    return error instanceof Error && error.name === \"TriggerInternalError\";\n}\nexport class AbortTaskRunError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"AbortTaskRunError\";\n    }\n}\nconst MANUAL_OOM_KILL_ERROR_MESSAGE = \"MANUAL_OOM_KILL_ERROR\";\n/**\n * This causes an Out Of Memory error on the run (if it's uncaught).\n * This can be useful if you use a native package that detects it's run out of memory but doesn't kill Node.js\n */\nexport class OutOfMemoryError extends Error {\n    constructor() {\n        super(MANUAL_OOM_KILL_ERROR_MESSAGE);\n        this.name = \"OutOfMemoryError\";\n    }\n}\nexport function isManualOutOfMemoryError(error) {\n    if (error.type === \"BUILT_IN_ERROR\") {\n        if (error.message && error.message === MANUAL_OOM_KILL_ERROR_MESSAGE) {\n            return true;\n        }\n    }\n    return false;\n}\nexport class TaskPayloadParsedError extends Error {\n    cause;\n    constructor(cause) {\n        const causeMessage = cause instanceof Error ? cause.message : String(cause);\n        super(\"Parsing payload with schema failed: \" + causeMessage);\n        this.name = \"TaskPayloadParsedError\";\n        this.cause = cause;\n    }\n}\nexport function parseError(error) {\n    if (isInternalError(error)) {\n        return {\n            type: \"INTERNAL_ERROR\",\n            code: error.code,\n            message: error.message,\n            stackTrace: error.stack ?? \"\",\n        };\n    }\n    if (error instanceof Error) {\n        return {\n            type: \"BUILT_IN_ERROR\",\n            name: error.name,\n            message: error.message,\n            stackTrace: error.stack ?? \"\",\n        };\n    }\n    if (typeof error === \"string\") {\n        return {\n            type: \"STRING_ERROR\",\n            raw: error,\n        };\n    }\n    try {\n        return {\n            type: \"CUSTOM_ERROR\",\n            raw: JSON.stringify(error),\n        };\n    }\n    catch (e) {\n        return {\n            type: \"CUSTOM_ERROR\",\n            raw: String(error),\n        };\n    }\n}\nexport function createErrorTaskError(error) {\n    switch (error.type) {\n        case \"BUILT_IN_ERROR\": {\n            const e = new Error(error.message);\n            e.name = error.name;\n            e.stack = error.stackTrace;\n            return e;\n        }\n        case \"STRING_ERROR\": {\n            return error.raw;\n        }\n        case \"CUSTOM_ERROR\": {\n            return JSON.parse(error.raw);\n        }\n        case \"INTERNAL_ERROR\": {\n            const e = new Error(error.message ?? `Internal error (${error.code})`);\n            e.name = error.code;\n            e.stack = error.stackTrace;\n            return e;\n        }\n    }\n}\nexport function createJsonErrorObject(error) {\n    const enhancedError = taskRunErrorEnhancer(error);\n    switch (enhancedError.type) {\n        case \"BUILT_IN_ERROR\": {\n            return {\n                name: enhancedError.name,\n                message: enhancedError.message,\n                stackTrace: enhancedError.stackTrace,\n            };\n        }\n        case \"STRING_ERROR\": {\n            return {\n                message: enhancedError.raw,\n            };\n        }\n        case \"CUSTOM_ERROR\": {\n            return {\n                message: enhancedError.raw,\n            };\n        }\n        case \"INTERNAL_ERROR\": {\n            return {\n                message: `trigger.dev internal error (${enhancedError.code})`,\n            };\n        }\n    }\n}\n// Removes any null characters from the error message\nexport function sanitizeError(error) {\n    switch (error.type) {\n        case \"BUILT_IN_ERROR\": {\n            return {\n                type: \"BUILT_IN_ERROR\",\n                message: error.message?.replace(/\\0/g, \"\"),\n                name: error.name?.replace(/\\0/g, \"\"),\n                stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n            };\n        }\n        case \"STRING_ERROR\": {\n            return {\n                type: \"STRING_ERROR\",\n                raw: error.raw.replace(/\\0/g, \"\"),\n            };\n        }\n        case \"CUSTOM_ERROR\": {\n            return {\n                type: \"CUSTOM_ERROR\",\n                raw: error.raw.replace(/\\0/g, \"\"),\n            };\n        }\n        case \"INTERNAL_ERROR\": {\n            return {\n                type: \"INTERNAL_ERROR\",\n                code: error.code,\n                message: error.message?.replace(/\\0/g, \"\"),\n                stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n            };\n        }\n    }\n}\nexport function shouldRetryError(error) {\n    switch (error.type) {\n        case \"INTERNAL_ERROR\": {\n            switch (error.code) {\n                case \"COULD_NOT_FIND_EXECUTOR\":\n                case \"COULD_NOT_FIND_TASK\":\n                case \"COULD_NOT_IMPORT_TASK\":\n                case \"CONFIGURED_INCORRECTLY\":\n                case \"TASK_ALREADY_RUNNING\":\n                case \"TASK_PROCESS_SIGKILL_TIMEOUT\":\n                case \"TASK_PROCESS_SIGSEGV\":\n                case \"TASK_PROCESS_OOM_KILLED\":\n                case \"TASK_PROCESS_MAYBE_OOM_KILLED\":\n                case \"TASK_RUN_CANCELLED\":\n                case \"MAX_DURATION_EXCEEDED\":\n                case \"DISK_SPACE_EXCEEDED\":\n                case \"TASK_RUN_HEARTBEAT_TIMEOUT\":\n                case \"OUTDATED_SDK_VERSION\":\n                case \"TASK_DID_CONCURRENT_WAIT\":\n                case \"RECURSIVE_WAIT_DEADLOCK\":\n                    return false;\n                case \"GRACEFUL_EXIT_TIMEOUT\":\n                case \"HANDLE_ERROR_ERROR\":\n                case \"TASK_INPUT_ERROR\":\n                case \"TASK_OUTPUT_ERROR\":\n                case \"POD_EVICTED\":\n                case \"POD_UNKNOWN_ERROR\":\n                case \"TASK_EXECUTION_ABORTED\":\n                case \"TASK_EXECUTION_FAILED\":\n                case \"TASK_RUN_CRASHED\":\n                case \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\":\n                case \"TASK_PROCESS_SIGTERM\":\n                    return true;\n                default:\n                    assertExhaustive(error.code);\n            }\n        }\n        case \"STRING_ERROR\": {\n            return true;\n        }\n        case \"BUILT_IN_ERROR\": {\n            return true;\n        }\n        case \"CUSTOM_ERROR\": {\n            return true;\n        }\n        default: {\n            assertExhaustive(error);\n        }\n    }\n}\nexport function correctErrorStackTrace(stackTrace, projectDir, options) {\n    const [errorLine, ...traceLines] = stackTrace.split(\"\\n\");\n    return [\n        options?.removeFirstLine ? undefined : errorLine,\n        ...traceLines.map((line) => correctStackTraceLine(line, projectDir, options?.isDev)),\n    ]\n        .filter(Boolean)\n        .join(\"\\n\");\n}\nconst LINES_TO_IGNORE = [\n    /ConsoleInterceptor/,\n    /TriggerTracer/,\n    /TaskExecutor/,\n    /EXECUTE_TASK_RUN/,\n    /@trigger.dev\\/core/,\n    /packages\\/core\\/src\\/v3/,\n    /safeJsonProcess/,\n    /__entryPoint.ts/,\n    /ZodIpc/,\n    /startActiveSpan/,\n    /processTicksAndRejections/,\n];\nfunction correctStackTraceLine(line, projectDir, isDev) {\n    if (LINES_TO_IGNORE.some((regex) => regex.test(line))) {\n        return;\n    }\n    // Check to see if the path is inside the project directory\n    if (isDev && projectDir && !line.includes(projectDir)) {\n        return;\n    }\n    return line.trim();\n}\nexport function groupTaskMetadataIssuesByTask(tasks, issues) {\n    return issues.reduce((acc, issue) => {\n        if (issue.path.length === 0) {\n            return acc;\n        }\n        const taskIndex = issue.path[2];\n        if (typeof taskIndex !== \"number\") {\n            return acc;\n        }\n        const task = tasks[taskIndex];\n        if (!task) {\n            return acc;\n        }\n        const restOfPath = issue.path.slice(3);\n        const taskId = task.id;\n        const taskName = task.exportName;\n        const filePath = task.filePath;\n        const key = taskIndex;\n        const existing = acc[key] ?? {\n            id: taskId,\n            exportName: taskName,\n            filePath,\n            issues: [],\n        };\n        existing.issues.push({\n            message: issue.message,\n            path: restOfPath.length === 0 ? undefined : restOfPath.join(\".\"),\n        });\n        return {\n            ...acc,\n            [key]: existing,\n        };\n    }, {});\n}\nexport class UncaughtExceptionError extends Error {\n    originalError;\n    origin;\n    constructor(originalError, origin) {\n        super(`Uncaught exception: ${originalError.message}`);\n        this.originalError = originalError;\n        this.origin = origin;\n        this.name = \"UncaughtExceptionError\";\n    }\n}\nexport class TaskMetadataParseError extends Error {\n    zodIssues;\n    tasks;\n    constructor(zodIssues, tasks) {\n        super(`Failed to parse task metadata`);\n        this.zodIssues = zodIssues;\n        this.tasks = tasks;\n        this.name = \"TaskMetadataParseError\";\n    }\n}\nexport class TaskIndexingImportError extends Error {\n    importErrors;\n    manifest;\n    constructor(importErrors, manifest) {\n        super(`Failed to import some task files`);\n        this.importErrors = importErrors;\n        this.manifest = manifest;\n        this.name = \"TaskIndexingImportError\";\n    }\n}\nexport class UnexpectedExitError extends Error {\n    code;\n    signal;\n    stderr;\n    constructor(code, signal, stderr) {\n        super(`Unexpected exit with code ${code} after signal ${signal}`);\n        this.code = code;\n        this.signal = signal;\n        this.stderr = stderr;\n        this.name = \"UnexpectedExitError\";\n    }\n}\nexport class CleanupProcessError extends Error {\n    constructor() {\n        super(\"Cancelled\");\n        this.name = \"CleanupProcessError\";\n    }\n}\nexport class CancelledProcessError extends Error {\n    constructor() {\n        super(\"Cancelled\");\n        this.name = \"CancelledProcessError\";\n    }\n}\nexport class SigKillTimeoutProcessError extends Error {\n    constructor() {\n        super(\"Process kill timeout\");\n        this.name = \"SigKillTimeoutProcessError\";\n    }\n}\nexport class GracefulExitTimeoutError extends Error {\n    constructor() {\n        super(\"Graceful exit timeout\");\n        this.name = \"GracefulExitTimeoutError\";\n    }\n}\nconst prettyInternalErrors = {\n    TASK_PROCESS_OOM_KILLED: {\n        message: \"Your task ran out of memory. Try increasing the machine specs. If this doesn't fix it there might be a memory leak.\",\n        link: {\n            name: \"Machines\",\n            href: links.docs.machines.home,\n        },\n    },\n    TASK_PROCESS_MAYBE_OOM_KILLED: {\n        message: \"We think your task ran out of memory, but we can't be certain. If this keeps happening, try increasing the machine specs.\",\n        link: {\n            name: \"Machines\",\n            href: links.docs.machines.home,\n        },\n    },\n    TASK_PROCESS_SIGSEGV: {\n        message: \"Your task crashed with a segmentation fault (SIGSEGV). Most likely there's a bug in a package or binary you're using. If this keeps happening and you're unsure why, please get in touch.\",\n        link: {\n            name: \"Contact us\",\n            href: links.site.contact,\n            magic: \"CONTACT_FORM\",\n        },\n    },\n    TASK_PROCESS_SIGTERM: {\n        message: \"Your task exited after receiving SIGTERM but we don't know why. If this keeps happening, please get in touch so we can investigate.\",\n        link: {\n            name: \"Contact us\",\n            href: links.site.contact,\n            magic: \"CONTACT_FORM\",\n        },\n    },\n    OUTDATED_SDK_VERSION: {\n        message: \"Your task is using an outdated version of the SDK. Please upgrade to the latest version.\",\n        link: {\n            name: \"Beta upgrade guide\",\n            href: links.docs.upgrade.beta,\n        },\n    },\n    TASK_DID_CONCURRENT_WAIT: {\n        message: \"Parallel waits are not supported, e.g. using Promise.all() around our wait functions.\",\n        link: {\n            name: \"Read the docs for solutions\",\n            href: links.docs.troubleshooting.concurrentWaits,\n        },\n    },\n    RECURSIVE_WAIT_DEADLOCK: {\n        message: \"This run will never execute because it was triggered recursively and the task has no remaining concurrency available.\",\n        link: {\n            name: \"See docs for help\",\n            href: links.docs.concurrency.recursiveDeadlock,\n        },\n    },\n};\nconst getPrettyTaskRunError = (code) => {\n    return {\n        type: \"INTERNAL_ERROR\",\n        code,\n        ...prettyInternalErrors[code],\n    };\n};\nconst getPrettyExceptionEvent = (code) => {\n    return {\n        type: code,\n        ...prettyInternalErrors[code],\n    };\n};\nconst findSignalInMessage = (message, truncateLength = 100) => {\n    if (!message) {\n        return;\n    }\n    const trunc = truncateLength ? message.slice(0, truncateLength) : message;\n    if (trunc.includes(\"SIGTERM\")) {\n        return \"SIGTERM\";\n    }\n    else if (trunc.includes(\"SIGSEGV\")) {\n        return \"SIGSEGV\";\n    }\n    else if (trunc.includes(\"SIGKILL\")) {\n        return \"SIGKILL\";\n    }\n    else {\n        return;\n    }\n};\nexport function taskRunErrorEnhancer(error) {\n    switch (error.type) {\n        case \"BUILT_IN_ERROR\": {\n            if (error.name === \"UnexpectedExitError\") {\n                if (error.message.startsWith(\"Unexpected exit with code -1\")) {\n                    const signal = findSignalInMessage(error.stackTrace);\n                    switch (signal) {\n                        case \"SIGTERM\":\n                            return {\n                                ...getPrettyTaskRunError(\"TASK_PROCESS_SIGTERM\"),\n                            };\n                        case \"SIGSEGV\":\n                            return {\n                                ...getPrettyTaskRunError(\"TASK_PROCESS_SIGSEGV\"),\n                            };\n                        case \"SIGKILL\":\n                            return {\n                                ...getPrettyTaskRunError(\"TASK_PROCESS_MAYBE_OOM_KILLED\"),\n                            };\n                        default:\n                            return {\n                                ...getPrettyTaskRunError(\"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\"),\n                                message: error.message,\n                                stackTrace: error.stackTrace,\n                            };\n                    }\n                }\n            }\n            if (error.name === \"Error\") {\n                if (error.message === \"ffmpeg was killed with signal SIGKILL\") {\n                    return {\n                        ...getPrettyTaskRunError(\"TASK_PROCESS_OOM_KILLED\"),\n                    };\n                }\n            }\n            if (isManualOutOfMemoryError(error)) {\n                return {\n                    ...getPrettyTaskRunError(\"TASK_PROCESS_OOM_KILLED\"),\n                };\n            }\n            break;\n        }\n        case \"STRING_ERROR\": {\n            break;\n        }\n        case \"CUSTOM_ERROR\": {\n            break;\n        }\n        case \"INTERNAL_ERROR\": {\n            if (error.code === TaskRunErrorCodes.TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE) {\n                const signal = findSignalInMessage(error.message);\n                switch (signal) {\n                    case \"SIGTERM\":\n                        return {\n                            ...getPrettyTaskRunError(\"TASK_PROCESS_SIGTERM\"),\n                        };\n                    case \"SIGSEGV\":\n                        return {\n                            ...getPrettyTaskRunError(\"TASK_PROCESS_SIGSEGV\"),\n                        };\n                    case \"SIGKILL\":\n                        return {\n                            ...getPrettyTaskRunError(\"TASK_PROCESS_MAYBE_OOM_KILLED\"),\n                        };\n                    default: {\n                        return {\n                            ...getPrettyTaskRunError(\"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\"),\n                            message: error.message,\n                            stackTrace: error.stackTrace,\n                        };\n                    }\n                }\n            }\n            return {\n                ...error,\n                ...getPrettyTaskRunError(error.code),\n            };\n        }\n    }\n    return error;\n}\nexport function exceptionEventEnhancer(exception) {\n    switch (exception.type) {\n        case \"UnexpectedExitError\": {\n            if (exception.message?.startsWith(\"Unexpected exit with code -1\")) {\n                return {\n                    ...exception,\n                    ...prettyInternalErrors.TASK_PROCESS_MAYBE_OOM_KILLED,\n                };\n            }\n            break;\n        }\n        case \"Internal error\": {\n            if (exception.message?.startsWith(TaskRunErrorCodes.TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE)) {\n                const signal = findSignalInMessage(exception.message);\n                switch (signal) {\n                    case \"SIGTERM\":\n                        return {\n                            ...exception,\n                            ...getPrettyExceptionEvent(\"TASK_PROCESS_SIGTERM\"),\n                        };\n                    case \"SIGSEGV\":\n                        return {\n                            ...exception,\n                            ...getPrettyExceptionEvent(\"TASK_PROCESS_SIGSEGV\"),\n                        };\n                    case \"SIGKILL\":\n                        return {\n                            ...exception,\n                            ...getPrettyExceptionEvent(\"TASK_PROCESS_MAYBE_OOM_KILLED\"),\n                        };\n                    default:\n                        return exception;\n                }\n            }\n            else if (exception.message?.includes(TaskRunErrorCodes.RECURSIVE_WAIT_DEADLOCK)) {\n                return {\n                    ...exception,\n                    ...prettyInternalErrors.RECURSIVE_WAIT_DEADLOCK,\n                };\n            }\n            break;\n        }\n        case \"Error\": {\n            if (exception.message === \"ffmpeg was killed with signal SIGKILL\") {\n                return {\n                    ...exception,\n                    ...prettyInternalErrors.TASK_PROCESS_OOM_KILLED,\n                };\n            }\n            break;\n        }\n        case TaskRunErrorCodes.TASK_PROCESS_MAYBE_OOM_KILLED:\n        case TaskRunErrorCodes.TASK_PROCESS_OOM_KILLED:\n        case TaskRunErrorCodes.TASK_PROCESS_SIGTERM: {\n            return {\n                ...exception,\n                ...getPrettyExceptionEvent(exception.type),\n            };\n        }\n    }\n    return exception;\n}\nexport function internalErrorFromUnexpectedExit(error, dockerMode = true) {\n    const internalError = {\n        type: \"INTERNAL_ERROR\",\n        code: TaskRunErrorCodes.TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE,\n        message: `Process exited with code ${error.code} after signal ${error.signal}.`,\n        stackTrace: error.stderr,\n    };\n    if (error.code === 137) {\n        if (dockerMode) {\n            return {\n                ...internalError,\n                code: TaskRunErrorCodes.TASK_PROCESS_OOM_KILLED,\n            };\n        }\n        else {\n            // Note: containerState reason and message could be checked to clarify the error, maybe the task monitor should be allowed to override these\n            return {\n                ...internalError,\n                code: TaskRunErrorCodes.TASK_PROCESS_MAYBE_OOM_KILLED,\n            };\n        }\n    }\n    if (error.stderr?.includes(\"OOMErrorHandler\")) {\n        return {\n            ...internalError,\n            code: TaskRunErrorCodes.TASK_PROCESS_OOM_KILLED,\n        };\n    }\n    if (error.signal === \"SIGTERM\") {\n        return {\n            ...internalError,\n            code: TaskRunErrorCodes.TASK_PROCESS_SIGTERM,\n        };\n    }\n    return {\n        ...internalError,\n        code: TaskRunErrorCodes.TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE,\n    };\n}\nexport function serializeIndexingError(error, stderr) {\n    if (error instanceof TaskMetadataParseError) {\n        return {\n            name: \"TaskMetadataParseError\",\n            message: \"There was an error parsing the task metadata\",\n            stack: JSON.stringify({ zodIssues: error.zodIssues, tasks: error.tasks }),\n            stderr,\n        };\n    }\n    else if (error instanceof TaskIndexingImportError) {\n        return {\n            name: \"TaskIndexingImportError\",\n            message: \"There was an error importing task files\",\n            stack: JSON.stringify(error.importErrors),\n            stderr,\n        };\n    }\n    else if (error instanceof UncaughtExceptionError) {\n        const originalError = error.originalError;\n        return {\n            name: originalError.name,\n            message: originalError.message,\n            stack: originalError.stack,\n            stderr,\n        };\n    }\n    else if (error instanceof Error) {\n        return {\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n            stderr,\n        };\n    }\n    return {\n        name: \"UnknownError\",\n        message: String(error),\n        stderr,\n    };\n}\nexport function prepareDeploymentError(errorData) {\n    if (!errorData) {\n        return;\n    }\n    if (errorData.name === \"TaskMetadataParseError\") {\n        const errorJson = tryJsonParse(errorData.stack);\n        if (errorJson) {\n            const parsedError = TaskMetadataFailedToParseData.safeParse(errorJson);\n            if (parsedError.success) {\n                return {\n                    name: errorData.name,\n                    message: errorData.message,\n                    stack: createTaskMetadataFailedErrorStack(parsedError.data),\n                    stderr: errorData.stderr,\n                };\n            }\n            else {\n                return {\n                    name: errorData.name,\n                    message: errorData.message,\n                    stderr: errorData.stderr,\n                };\n            }\n        }\n        else {\n            return {\n                name: errorData.name,\n                message: errorData.message,\n                stderr: errorData.stderr,\n            };\n        }\n    }\n    else if (errorData.name === \"TaskIndexingImportError\") {\n        const errorJson = tryJsonParse(errorData.stack);\n        if (errorJson) {\n            const parsedError = ImportTaskFileErrors.safeParse(errorJson);\n            if (parsedError.success) {\n                return {\n                    name: errorData.name,\n                    message: errorData.message,\n                    stack: parsedError.data\n                        .map((error) => {\n                        return `x ${error.message} in ${error.file}`;\n                    })\n                        .join(\"\\n\"),\n                    stderr: errorData.stderr,\n                };\n            }\n            else {\n                return {\n                    name: errorData.name,\n                    message: errorData.message,\n                    stderr: errorData.stderr,\n                };\n            }\n        }\n        else {\n            return {\n                name: errorData.name,\n                message: errorData.message,\n                stderr: errorData.stderr,\n            };\n        }\n    }\n    return {\n        name: errorData.name,\n        message: errorData.message,\n        stack: errorData.stack,\n        stderr: errorData.stderr,\n    };\n}\nexport function createTaskMetadataFailedErrorStack(data) {\n    const stack = [];\n    const groupedIssues = groupTaskMetadataIssuesByTask(data.tasks, data.zodIssues);\n    for (const key in groupedIssues) {\n        const taskWithIssues = groupedIssues[key];\n        if (!taskWithIssues) {\n            continue;\n        }\n        stack.push(\"\\n\");\n        stack.push(`   ${taskWithIssues.exportName} in ${taskWithIssues.filePath}`);\n        for (const issue of taskWithIssues.issues) {\n            if (issue.path) {\n                stack.push(`    x ${issue.path} ${issue.message}`);\n            }\n            else {\n                stack.push(`    x ${issue.message}`);\n            }\n        }\n    }\n    return stack.join(\"\\n\");\n}\nfunction tryJsonParse(data) {\n    if (!data) {\n        return;\n    }\n    try {\n        return JSON.parse(data);\n    }\n    catch {\n        return;\n    }\n}\nexport function taskRunErrorToString(error) {\n    switch (error.type) {\n        case \"INTERNAL_ERROR\": {\n            return `Internal error [${error.code}]${error.message ? `: ${error.message}` : \"\"}`;\n        }\n        case \"BUILT_IN_ERROR\": {\n            return `${error.name}: ${error.message}`;\n        }\n        case \"STRING_ERROR\": {\n            return error.raw;\n        }\n        case \"CUSTOM_ERROR\": {\n            return error.raw;\n        }\n    }\n}\n//# sourceMappingURL=errors.js.map","export function getEnvVar(name, defaultValue) {\n    // This could run in a non-Node.js environment (Bun, Deno, CF Worker, etc.), so don't just assume process.env is a thing\n    if (typeof process !== \"undefined\" && typeof process.env === \"object\" && process.env !== null) {\n        return process.env[name] ?? defaultValue;\n    }\n    return defaultValue;\n}\nexport function getNumberEnvVar(name, defaultValue) {\n    const value = getEnvVar(name);\n    if (value === undefined) {\n        return defaultValue;\n    }\n    const parsed = Number(value);\n    if (isNaN(parsed)) {\n        return defaultValue;\n    }\n    return parsed;\n}\n//# sourceMappingURL=getEnv.js.map","import { ApiClient } from \"../apiClient/index.js\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals.js\";\nimport { getEnvVar } from \"../utils/getEnv.js\";\nconst API_NAME = \"api-client\";\nexport class ApiClientMissingError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"ApiClientMissingError\";\n    }\n}\nexport class APIClientManagerAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new APIClientManagerAPI();\n        }\n        return this._instance;\n    }\n    disable() {\n        unregisterGlobal(API_NAME);\n    }\n    get baseURL() {\n        const config = this.#getConfig();\n        return config?.baseURL ?? getEnvVar(\"TRIGGER_API_URL\") ?? \"https://api.trigger.dev\";\n    }\n    get accessToken() {\n        const config = this.#getConfig();\n        return (config?.secretKey ??\n            config?.accessToken ??\n            getEnvVar(\"TRIGGER_SECRET_KEY\") ??\n            getEnvVar(\"TRIGGER_ACCESS_TOKEN\"));\n    }\n    get client() {\n        if (!this.baseURL || !this.accessToken) {\n            return undefined;\n        }\n        return new ApiClient(this.baseURL, this.accessToken);\n    }\n    clientOrThrow() {\n        if (!this.baseURL || !this.accessToken) {\n            throw new ApiClientMissingError(this.apiClientMissingError());\n        }\n        return new ApiClient(this.baseURL, this.accessToken);\n    }\n    runWithConfig(config, fn) {\n        const originalConfig = this.#getConfig();\n        const $config = { ...originalConfig, ...config };\n        registerGlobal(API_NAME, $config, true);\n        return fn().finally(() => {\n            registerGlobal(API_NAME, originalConfig, true);\n        });\n    }\n    setGlobalAPIClientConfiguration(config) {\n        return registerGlobal(API_NAME, config);\n    }\n    #getConfig() {\n        return getGlobal(API_NAME);\n    }\n    apiClientMissingError() {\n        const hasBaseUrl = !!this.baseURL;\n        const hasAccessToken = !!this.accessToken;\n        if (!hasBaseUrl && !hasAccessToken) {\n            return `You need to set the TRIGGER_API_URL and TRIGGER_SECRET_KEY environment variables. See https://trigger.dev/docs/management/overview#authentication`;\n        }\n        else if (!hasBaseUrl) {\n            return `You need to set the TRIGGER_API_URL environment variable. See https://trigger.dev/docs/management/overview#authentication`;\n        }\n        else if (!hasAccessToken) {\n            return `You need to set the TRIGGER_SECRET_KEY environment variable. See https://trigger.dev/docs/management/overview#authentication`;\n        }\n        return `Unknown error`;\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { APIClientManagerAPI } from \"./apiClientManager/index.js\";\n/** Entrypoint for logger API */\nexport const apiClientManager = APIClientManagerAPI.getInstance();\n//# sourceMappingURL=apiClientManager-api.js.map","export * from \"./apiClient/core.js\";\nexport * from \"./apiClient/errors.js\";\nexport * from \"./apiClient/pagination.js\";\n//# sourceMappingURL=zodfetch.js.map","import { OFFLOAD_IO_PACKET_LENGTH_LIMIT, imposeAttributeLimits } from \"../limits.js\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes.js\";\nimport { flattenAttributes } from \"./flattenAttributes.js\";\nimport { apiClientManager } from \"../apiClientManager-api.js\";\nimport { zodfetch } from \"../zodfetch.js\";\nimport { z } from \"zod\";\nexport async function parsePacket(value, options) {\n    if (!value.data) {\n        return undefined;\n    }\n    switch (value.dataType) {\n        case \"application/json\":\n            return JSON.parse(value.data, makeSafeReviver(options));\n        case \"application/super+json\":\n            const { parse } = await loadSuperJSON();\n            return parse(value.data);\n        case \"text/plain\":\n            return value.data;\n        case \"application/store\":\n            throw new Error(`Cannot parse an application/store packet (${value.data}). Needs to be imported first.`);\n        default:\n            return value.data;\n    }\n}\nexport async function conditionallyImportAndParsePacket(value, client) {\n    const importedPacket = await conditionallyImportPacket(value, undefined, client);\n    return await parsePacket(importedPacket);\n}\nexport async function stringifyIO(value) {\n    if (value === undefined) {\n        return { dataType: \"application/json\" };\n    }\n    if (typeof value === \"string\") {\n        return { data: value, dataType: \"text/plain\" };\n    }\n    try {\n        const { stringify } = await loadSuperJSON();\n        const data = stringify(value);\n        return { data, dataType: \"application/super+json\" };\n    }\n    catch {\n        return { data: value, dataType: \"application/json\" };\n    }\n}\nexport async function conditionallyExportPacket(packet, pathPrefix, tracer) {\n    if (apiClientManager.client) {\n        const { needsOffloading, size } = packetRequiresOffloading(packet);\n        if (needsOffloading) {\n            if (!tracer) {\n                return await exportPacket(packet, pathPrefix);\n            }\n            else {\n                const result = await tracer.startActiveSpan(\"store.uploadOutput\", async (span) => {\n                    return await exportPacket(packet, pathPrefix);\n                }, {\n                    attributes: {\n                        byteLength: size,\n                        [SemanticInternalAttributes.STYLE_ICON]: \"cloud-upload\",\n                    },\n                });\n                return result ?? packet;\n            }\n        }\n    }\n    return packet;\n}\nexport function packetRequiresOffloading(packet, lengthLimit) {\n    if (!packet.data) {\n        return {\n            needsOffloading: false,\n            size: 0,\n        };\n    }\n    const byteSize = Buffer.byteLength(packet.data, \"utf8\");\n    return {\n        needsOffloading: byteSize >= (lengthLimit ?? OFFLOAD_IO_PACKET_LENGTH_LIMIT),\n        size: byteSize,\n    };\n}\nconst ioRetryOptions = {\n    minTimeoutInMs: 500,\n    maxTimeoutInMs: 5000,\n    maxAttempts: 5,\n    factor: 2,\n    randomize: true,\n};\nasync function exportPacket(packet, pathPrefix) {\n    // Offload the output\n    const filename = `${pathPrefix}.${getPacketExtension(packet.dataType)}`;\n    const presignedResponse = await apiClientManager.client.createUploadPayloadUrl(filename);\n    const uploadResponse = await zodfetch(z.any(), presignedResponse.presignedUrl, {\n        method: \"PUT\",\n        headers: {\n            \"Content-Type\": packet.dataType,\n        },\n        body: packet.data,\n    }, {\n        retry: ioRetryOptions,\n    }).asResponse();\n    if (!uploadResponse.ok) {\n        throw new Error(`Failed to upload output to ${presignedResponse.presignedUrl}: ${uploadResponse.statusText}`);\n    }\n    return {\n        data: filename,\n        dataType: \"application/store\",\n    };\n}\nexport async function conditionallyImportPacket(packet, tracer, client) {\n    if (packet.dataType !== \"application/store\") {\n        return packet;\n    }\n    if (!tracer) {\n        return await importPacket(packet, undefined, client);\n    }\n    else {\n        const result = await tracer.startActiveSpan(\"store.downloadPayload\", async (span) => {\n            return await importPacket(packet, span, client);\n        }, {\n            attributes: {\n                [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n            },\n        });\n        return result ?? packet;\n    }\n}\nexport async function resolvePresignedPacketUrl(url, tracer) {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            return;\n        }\n        const data = await response.text();\n        const dataType = response.headers.get(\"content-type\") ?? \"application/json\";\n        const packet = {\n            data,\n            dataType,\n        };\n        return await parsePacket(packet);\n    }\n    catch (error) {\n        return;\n    }\n}\nasync function importPacket(packet, span, client) {\n    if (!packet.data) {\n        return packet;\n    }\n    const $client = client ?? apiClientManager.client;\n    if (!$client) {\n        return packet;\n    }\n    const presignedResponse = await $client.getPayloadUrl(packet.data);\n    const response = await zodfetch(z.any(), presignedResponse.presignedUrl, undefined, {\n        retry: ioRetryOptions,\n    }).asResponse();\n    if (!response.ok) {\n        throw new Error(`Failed to import packet ${presignedResponse.presignedUrl}: ${response.statusText}`);\n    }\n    const data = await response.text();\n    span?.setAttribute(\"size\", Buffer.byteLength(data, \"utf8\"));\n    return {\n        data,\n        dataType: response.headers.get(\"content-type\") ?? \"application/json\",\n    };\n}\nexport async function createPacketAttributes(packet, dataKey, dataTypeKey) {\n    if (!packet.data) {\n        return;\n    }\n    switch (packet.dataType) {\n        case \"application/json\":\n            return {\n                ...flattenAttributes(packet, dataKey),\n                [dataTypeKey]: packet.dataType,\n            };\n        case \"application/super+json\":\n            const { parse } = await loadSuperJSON();\n            if (typeof packet.data === \"undefined\" || packet.data === null) {\n                return;\n            }\n            try {\n                const parsed = parse(packet.data);\n                const jsonified = JSON.parse(JSON.stringify(parsed, makeSafeReplacer()));\n                const result = {\n                    ...flattenAttributes(jsonified, dataKey),\n                    [dataTypeKey]: \"application/json\",\n                };\n                return result;\n            }\n            catch (e) {\n                return;\n            }\n        case \"application/store\":\n            return {\n                [dataKey]: packet.data,\n                [dataTypeKey]: packet.dataType,\n            };\n        case \"text/plain\":\n            return {\n                [dataKey]: packet.data,\n                [dataTypeKey]: packet.dataType,\n            };\n        default:\n            return;\n    }\n}\nexport async function createPacketAttributesAsJson(data, dataType) {\n    if (typeof data === \"string\" ||\n        typeof data === \"number\" ||\n        typeof data === \"boolean\" ||\n        data === null ||\n        data === undefined) {\n        return data;\n    }\n    switch (dataType) {\n        case \"application/json\":\n            return imposeAttributeLimits(flattenAttributes(data, undefined));\n        case \"application/super+json\":\n            const { deserialize } = await loadSuperJSON();\n            const deserialized = deserialize(data);\n            const jsonify = safeJsonParse(JSON.stringify(deserialized, makeSafeReplacer()));\n            return imposeAttributeLimits(flattenAttributes(jsonify, undefined));\n        case \"application/store\":\n            return data;\n        default:\n            return {};\n    }\n}\nexport async function prettyPrintPacket(rawData, dataType, options) {\n    if (rawData === undefined) {\n        return \"\";\n    }\n    if (dataType === \"application/super+json\") {\n        if (typeof rawData === \"string\") {\n            rawData = safeJsonParse(rawData);\n        }\n        const { deserialize } = await loadSuperJSON();\n        return await prettyPrintPacket(deserialize(rawData), \"application/json\");\n    }\n    if (dataType === \"application/json\") {\n        if (typeof rawData === \"string\") {\n            rawData = safeJsonParse(rawData);\n        }\n        return JSON.stringify(rawData, makeSafeReplacer(options), 2);\n    }\n    if (typeof rawData === \"string\") {\n        return rawData;\n    }\n    return JSON.stringify(rawData, makeSafeReplacer(options), 2);\n}\nfunction makeSafeReplacer(options) {\n    return function replacer(key, value) {\n        // Check if the key should be filtered out\n        if (options?.filteredKeys?.includes(key)) {\n            return undefined;\n        }\n        // If it is a BigInt\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        // if it is a Regex\n        if (value instanceof RegExp) {\n            return value.toString();\n        }\n        // if it is a Set\n        if (value instanceof Set) {\n            return Array.from(value);\n        }\n        // if it is a Map, convert it to an object\n        if (value instanceof Map) {\n            const obj = {};\n            value.forEach((v, k) => {\n                obj[k] = v;\n            });\n            return obj;\n        }\n        return value;\n    };\n}\nfunction makeSafeReviver(options) {\n    if (!options) {\n        return undefined;\n    }\n    return function reviver(key, value) {\n        // Check if the key should be filtered out\n        if (options?.filteredKeys?.includes(key)) {\n            return undefined;\n        }\n        return value;\n    };\n}\nfunction getPacketExtension(outputType) {\n    switch (outputType) {\n        case \"application/json\":\n            return \"json\";\n        case \"application/super+json\":\n            return \"json\";\n        case \"text/plain\":\n            return \"txt\";\n        default:\n            return \"txt\";\n    }\n}\nasync function loadSuperJSON() {\n    const superjson = await import(\"superjson\");\n    superjson.registerCustom({\n        isApplicable: (v) => typeof Buffer === \"function\" && Buffer.isBuffer(v),\n        serialize: (v) => [...v],\n        deserialize: (v) => Buffer.from(v),\n    }, \"buffer\");\n    return superjson;\n}\nfunction safeJsonParse(value) {\n    try {\n        return JSON.parse(value);\n    }\n    catch {\n        return;\n    }\n}\nexport async function replaceSuperJsonPayload(original, newPayload) {\n    const superjson = await loadSuperJSON();\n    const originalObject = superjson.parse(original);\n    const { meta } = superjson.serialize(originalObject);\n    const newSuperJson = {\n        json: JSON.parse(newPayload),\n        meta,\n    };\n    return superjson.deserialize(newSuperJson);\n}\n//# sourceMappingURL=ioSerialization.js.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/error.ts\nvar FetchError = class _FetchError extends Error {\n  constructor(status, text, json, headers, url, message) {\n    super(\n      message || `HTTP Error ${status} at ${url}: ${text != null ? text : JSON.stringify(json)}`\n    );\n    this.url = url;\n    this.name = `FetchError`;\n    this.status = status;\n    this.text = text;\n    this.json = json;\n    this.headers = headers;\n  }\n  static fromResponse(response, url) {\n    return __async(this, null, function* () {\n      const status = response.status;\n      const headers = Object.fromEntries([...response.headers.entries()]);\n      let text = void 0;\n      let json = void 0;\n      const contentType = response.headers.get(`content-type`);\n      if (contentType && contentType.includes(`application/json`)) {\n        json = yield response.json();\n      } else {\n        text = yield response.text();\n      }\n      return new _FetchError(status, text, json, headers, url);\n    });\n  }\n};\nvar FetchBackoffAbortError = class extends Error {\n  constructor() {\n    super(`Fetch with backoff aborted`);\n    this.name = `FetchBackoffAbortError`;\n  }\n};\nvar MissingShapeUrlError = class extends Error {\n  constructor() {\n    super(`Invalid shape options: missing required url parameter`);\n    this.name = `MissingShapeUrlError`;\n  }\n};\nvar InvalidSignalError = class extends Error {\n  constructor() {\n    super(`Invalid signal option. It must be an instance of AbortSignal.`);\n    this.name = `InvalidSignalError`;\n  }\n};\nvar MissingShapeHandleError = class extends Error {\n  constructor() {\n    super(\n      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`\n    );\n    this.name = `MissingShapeHandleError`;\n  }\n};\nvar ReservedParamError = class extends Error {\n  constructor(reservedParams) {\n    super(\n      `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`\n    );\n    this.name = `ReservedParamError`;\n  }\n};\nvar ParserNullValueError = class extends Error {\n  constructor(columnName) {\n    super(`Column \"${columnName != null ? columnName : `unknown`}\" does not allow NULL values`);\n    this.name = `ParserNullValueError`;\n  }\n};\nvar MissingHeadersError = class extends Error {\n  constructor(url, missingHeaders) {\n    let msg = `The response for the shape request to ${url} didn't include the following required headers:\n`;\n    missingHeaders.forEach((h) => {\n      msg += `- ${h}\n`;\n    });\n    msg += `\nThis is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`;\n    msg += `\nFor more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`;\n    super(msg);\n  }\n};\n\n// src/parser.ts\nvar parseNumber = (value) => Number(value);\nvar parseBool = (value) => value === `true` || value === `t`;\nvar parseBigInt = (value) => BigInt(value);\nvar parseJson = (value) => JSON.parse(value);\nvar identityParser = (v) => v;\nvar defaultParser = {\n  int2: parseNumber,\n  int4: parseNumber,\n  int8: parseBigInt,\n  bool: parseBool,\n  float4: parseNumber,\n  float8: parseNumber,\n  json: parseJson,\n  jsonb: parseJson\n};\nfunction pgArrayParser(value, parser) {\n  let i = 0;\n  let char = null;\n  let str = ``;\n  let quoted = false;\n  let last = 0;\n  let p = void 0;\n  function loop(x) {\n    const xs = [];\n    for (; i < x.length; i++) {\n      char = x[i];\n      if (quoted) {\n        if (char === `\\\\`) {\n          str += x[++i];\n        } else if (char === `\"`) {\n          xs.push(parser ? parser(str) : str);\n          str = ``;\n          quoted = x[i + 1] === `\"`;\n          last = i + 2;\n        } else {\n          str += char;\n        }\n      } else if (char === `\"`) {\n        quoted = true;\n      } else if (char === `{`) {\n        last = ++i;\n        xs.push(loop(x));\n      } else if (char === `}`) {\n        quoted = false;\n        last < i && xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));\n        last = i + 1;\n        break;\n      } else if (char === `,` && p !== `}` && p !== `\"`) {\n        xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));\n        last = i + 1;\n      }\n      p = char;\n    }\n    last < i && xs.push(parser ? parser(x.slice(last, i + 1)) : x.slice(last, i + 1));\n    return xs;\n  }\n  return loop(value)[0];\n}\nvar MessageParser = class {\n  constructor(parser) {\n    this.parser = __spreadValues(__spreadValues({}, defaultParser), parser);\n  }\n  parse(messages, schema) {\n    return JSON.parse(messages, (key, value) => {\n      if (key === `value` && typeof value === `object` && value !== null) {\n        const row = value;\n        Object.keys(row).forEach((key2) => {\n          row[key2] = this.parseRow(key2, row[key2], schema);\n        });\n      }\n      return value;\n    });\n  }\n  // Parses the message values using the provided parser based on the schema information\n  parseRow(key, value, schema) {\n    var _b;\n    const columnInfo = schema[key];\n    if (!columnInfo) {\n      return value;\n    }\n    const _a = columnInfo, { type: typ, dims: dimensions } = _a, additionalInfo = __objRest(_a, [\"type\", \"dims\"]);\n    const typeParser = (_b = this.parser[typ]) != null ? _b : identityParser;\n    const parser = makeNullableParser(typeParser, columnInfo, key);\n    if (dimensions && dimensions > 0) {\n      const nullablePgArrayParser = makeNullableParser(\n        (value2, _) => pgArrayParser(value2, parser),\n        columnInfo,\n        key\n      );\n      return nullablePgArrayParser(value);\n    }\n    return parser(value, additionalInfo);\n  }\n};\nfunction makeNullableParser(parser, columnInfo, columnName) {\n  var _a;\n  const isNullable = !((_a = columnInfo.not_null) != null ? _a : false);\n  return (value) => {\n    if (isPgNull(value)) {\n      if (!isNullable) {\n        throw new ParserNullValueError(columnName != null ? columnName : `unknown`);\n      }\n      return null;\n    }\n    return parser(value, columnInfo);\n  };\n}\nfunction isPgNull(value) {\n  return value === null || value === `NULL`;\n}\n\n// src/helpers.ts\nfunction isChangeMessage(message) {\n  return `key` in message;\n}\nfunction isControlMessage(message) {\n  return !isChangeMessage(message);\n}\nfunction isUpToDateMessage(message) {\n  return isControlMessage(message) && message.headers.control === `up-to-date`;\n}\n\n// src/constants.ts\nvar LIVE_CACHE_BUSTER_HEADER = `electric-cursor`;\nvar SHAPE_HANDLE_HEADER = `electric-handle`;\nvar CHUNK_LAST_OFFSET_HEADER = `electric-offset`;\nvar SHAPE_SCHEMA_HEADER = `electric-schema`;\nvar CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`;\nvar COLUMNS_QUERY_PARAM = `columns`;\nvar LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`;\nvar SHAPE_HANDLE_QUERY_PARAM = `handle`;\nvar LIVE_QUERY_PARAM = `live`;\nvar OFFSET_QUERY_PARAM = `offset`;\nvar TABLE_QUERY_PARAM = `table`;\nvar WHERE_QUERY_PARAM = `where`;\nvar REPLICA_PARAM = `replica`;\n\n// src/fetch.ts\nvar HTTP_RETRY_STATUS_CODES = [429];\nvar BackoffDefaults = {\n  initialDelay: 100,\n  maxDelay: 1e4,\n  multiplier: 1.3\n};\nfunction createFetchWithBackoff(fetchClient, backoffOptions = BackoffDefaults) {\n  const {\n    initialDelay,\n    maxDelay,\n    multiplier,\n    debug = false,\n    onFailedAttempt\n  } = backoffOptions;\n  return (...args) => __async(this, null, function* () {\n    var _a;\n    const url = args[0];\n    const options = args[1];\n    let delay = initialDelay;\n    let attempt = 0;\n    while (true) {\n      try {\n        const result = yield fetchClient(...args);\n        if (result.ok) return result;\n        else throw yield FetchError.fromResponse(result, url.toString());\n      } catch (e) {\n        onFailedAttempt == null ? void 0 : onFailedAttempt();\n        if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {\n          throw new FetchBackoffAbortError();\n        } else if (e instanceof FetchError && !HTTP_RETRY_STATUS_CODES.includes(e.status) && e.status >= 400 && e.status < 500) {\n          throw e;\n        } else {\n          yield new Promise((resolve) => setTimeout(resolve, delay));\n          delay = Math.min(delay * multiplier, maxDelay);\n          if (debug) {\n            attempt++;\n            console.log(`Retry attempt #${attempt} after ${delay}ms`);\n          }\n        }\n      }\n    }\n  });\n}\nvar ChunkPrefetchDefaults = {\n  maxChunksToPrefetch: 2\n};\nfunction createFetchWithChunkBuffer(fetchClient, prefetchOptions = ChunkPrefetchDefaults) {\n  const { maxChunksToPrefetch } = prefetchOptions;\n  let prefetchQueue;\n  const prefetchClient = (...args) => __async(this, null, function* () {\n    const url = args[0].toString();\n    const prefetchedRequest = prefetchQueue == null ? void 0 : prefetchQueue.consume(...args);\n    if (prefetchedRequest) {\n      return prefetchedRequest;\n    }\n    prefetchQueue == null ? void 0 : prefetchQueue.abort();\n    const response = yield fetchClient(...args);\n    const nextUrl = getNextChunkUrl(url, response);\n    if (nextUrl) {\n      prefetchQueue = new PrefetchQueue({\n        fetchClient,\n        maxPrefetchedRequests: maxChunksToPrefetch,\n        url: nextUrl,\n        requestInit: args[1]\n      });\n    }\n    return response;\n  });\n  return prefetchClient;\n}\nvar requiredElectricResponseHeaders = [\n  `electric-offset`,\n  `electric-handle`\n];\nvar requiredLiveResponseHeaders = [`electric-cursor`];\nvar requiredNonLiveResponseHeaders = [`electric-schema`];\nfunction createFetchWithResponseHeadersCheck(fetchClient) {\n  return (...args) => __async(this, null, function* () {\n    const response = yield fetchClient(...args);\n    if (response.ok) {\n      const headers = response.headers;\n      const missingHeaders = [];\n      const addMissingHeaders = (requiredHeaders) => missingHeaders.push(...requiredHeaders.filter((h) => !headers.has(h)));\n      addMissingHeaders(requiredElectricResponseHeaders);\n      const input = args[0];\n      const urlString = input.toString();\n      const url = new URL(urlString);\n      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {\n        addMissingHeaders(requiredLiveResponseHeaders);\n      }\n      if (!url.searchParams.has(LIVE_QUERY_PARAM) || url.searchParams.get(LIVE_QUERY_PARAM) === `false`) {\n        addMissingHeaders(requiredNonLiveResponseHeaders);\n      }\n      if (missingHeaders.length > 0) {\n        throw new MissingHeadersError(urlString, missingHeaders);\n      }\n    }\n    return response;\n  });\n}\nvar _fetchClient, _maxPrefetchedRequests, _prefetchQueue, _queueHeadUrl, _queueTailUrl, _PrefetchQueue_instances, prefetch_fn;\nvar PrefetchQueue = class {\n  constructor(options) {\n    __privateAdd(this, _PrefetchQueue_instances);\n    __privateAdd(this, _fetchClient);\n    __privateAdd(this, _maxPrefetchedRequests);\n    __privateAdd(this, _prefetchQueue, /* @__PURE__ */ new Map());\n    __privateAdd(this, _queueHeadUrl);\n    __privateAdd(this, _queueTailUrl);\n    var _a;\n    __privateSet(this, _fetchClient, (_a = options.fetchClient) != null ? _a : (...args) => fetch(...args));\n    __privateSet(this, _maxPrefetchedRequests, options.maxPrefetchedRequests);\n    __privateSet(this, _queueHeadUrl, options.url.toString());\n    __privateSet(this, _queueTailUrl, __privateGet(this, _queueHeadUrl));\n    __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, options.url, options.requestInit);\n  }\n  abort() {\n    __privateGet(this, _prefetchQueue).forEach(([_, aborter]) => aborter.abort());\n  }\n  consume(...args) {\n    var _a;\n    const url = args[0].toString();\n    const request = (_a = __privateGet(this, _prefetchQueue).get(url)) == null ? void 0 : _a[0];\n    if (!request || url !== __privateGet(this, _queueHeadUrl)) return;\n    __privateGet(this, _prefetchQueue).delete(url);\n    request.then((response) => {\n      const nextUrl = getNextChunkUrl(url, response);\n      __privateSet(this, _queueHeadUrl, nextUrl);\n      if (__privateGet(this, _queueTailUrl) && !__privateGet(this, _prefetchQueue).has(__privateGet(this, _queueTailUrl))) {\n        __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, __privateGet(this, _queueTailUrl), args[1]);\n      }\n    }).catch(() => {\n    });\n    return request;\n  }\n};\n_fetchClient = new WeakMap();\n_maxPrefetchedRequests = new WeakMap();\n_prefetchQueue = new WeakMap();\n_queueHeadUrl = new WeakMap();\n_queueTailUrl = new WeakMap();\n_PrefetchQueue_instances = new WeakSet();\nprefetch_fn = function(...args) {\n  var _a, _b;\n  const url = args[0].toString();\n  if (__privateGet(this, _prefetchQueue).size >= __privateGet(this, _maxPrefetchedRequests)) return;\n  const aborter = new AbortController();\n  try {\n    const request = __privateGet(this, _fetchClient).call(this, url, __spreadProps(__spreadValues({}, (_a = args[1]) != null ? _a : {}), {\n      signal: chainAborter(aborter, (_b = args[1]) == null ? void 0 : _b.signal)\n    }));\n    __privateGet(this, _prefetchQueue).set(url, [request, aborter]);\n    request.then((response) => {\n      if (!response.ok || aborter.signal.aborted) return;\n      const nextUrl = getNextChunkUrl(url, response);\n      if (!nextUrl || nextUrl === url) {\n        __privateSet(this, _queueTailUrl, void 0);\n        return;\n      }\n      __privateSet(this, _queueTailUrl, nextUrl);\n      return __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, nextUrl, args[1]);\n    }).catch(() => {\n    });\n  } catch (_) {\n  }\n};\nfunction getNextChunkUrl(url, res) {\n  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER);\n  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER);\n  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER);\n  if (!shapeHandle || !lastOffset || isUpToDate) return;\n  const nextUrl = new URL(url);\n  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return;\n  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle);\n  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset);\n  nextUrl.searchParams.sort();\n  return nextUrl.toString();\n}\nfunction chainAborter(aborter, sourceSignal) {\n  if (!sourceSignal) return aborter.signal;\n  if (sourceSignal.aborted) aborter.abort();\n  else\n    sourceSignal.addEventListener(`abort`, () => aborter.abort(), {\n      once: true\n    });\n  return aborter.signal;\n}\n\n// src/client.ts\nvar RESERVED_PARAMS = /* @__PURE__ */ new Set([\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  SHAPE_HANDLE_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM\n]);\nfunction toInternalParams(params) {\n  const result = {};\n  for (const [key, value] of Object.entries(params)) {\n    result[key] = Array.isArray(value) ? value.join(`,`) : value;\n  }\n  return result;\n}\nvar _error, _fetchClient2, _messageParser, _subscribers, _lastOffset, _liveCacheBuster, _lastSyncedAt, _isUpToDate, _connected, _shapeHandle, _schema, _onError, _ShapeStream_instances, start_fn, publish_fn, sendErrorToSubscribers_fn, reset_fn;\nvar ShapeStream = class {\n  constructor(options) {\n    __privateAdd(this, _ShapeStream_instances);\n    __privateAdd(this, _error, null);\n    __privateAdd(this, _fetchClient2);\n    __privateAdd(this, _messageParser);\n    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map());\n    __privateAdd(this, _lastOffset);\n    __privateAdd(this, _liveCacheBuster);\n    // Seconds since our Electric Epoch \n    __privateAdd(this, _lastSyncedAt);\n    // unix time\n    __privateAdd(this, _isUpToDate, false);\n    __privateAdd(this, _connected, false);\n    __privateAdd(this, _shapeHandle);\n    __privateAdd(this, _schema);\n    __privateAdd(this, _onError);\n    var _a, _b, _c;\n    this.options = __spreadValues({ subscribe: true }, options);\n    validateOptions(this.options);\n    __privateSet(this, _lastOffset, (_a = this.options.offset) != null ? _a : `-1`);\n    __privateSet(this, _liveCacheBuster, ``);\n    __privateSet(this, _shapeHandle, this.options.handle);\n    __privateSet(this, _messageParser, new MessageParser(options.parser));\n    __privateSet(this, _onError, this.options.onError);\n    const baseFetchClient = (_b = options.fetchClient) != null ? _b : (...args) => fetch(...args);\n    const fetchWithBackoffClient = createFetchWithBackoff(baseFetchClient, __spreadProps(__spreadValues({}, (_c = options.backoffOptions) != null ? _c : BackoffDefaults), {\n      onFailedAttempt: () => {\n        var _a2, _b2;\n        __privateSet(this, _connected, false);\n        (_b2 = (_a2 = options.backoffOptions) == null ? void 0 : _a2.onFailedAttempt) == null ? void 0 : _b2.call(_a2);\n      }\n    }));\n    __privateSet(this, _fetchClient2, createFetchWithResponseHeadersCheck(\n      createFetchWithChunkBuffer(fetchWithBackoffClient)\n    ));\n    __privateMethod(this, _ShapeStream_instances, start_fn).call(this);\n  }\n  get shapeHandle() {\n    return __privateGet(this, _shapeHandle);\n  }\n  get error() {\n    return __privateGet(this, _error);\n  }\n  get isUpToDate() {\n    return __privateGet(this, _isUpToDate);\n  }\n  get lastOffset() {\n    return __privateGet(this, _lastOffset);\n  }\n  subscribe(callback, onError = () => {\n  }) {\n    const subscriptionId = Math.random();\n    __privateGet(this, _subscribers).set(subscriptionId, [callback, onError]);\n    return () => {\n      __privateGet(this, _subscribers).delete(subscriptionId);\n    };\n  }\n  unsubscribeAll() {\n    __privateGet(this, _subscribers).clear();\n  }\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt() {\n    return __privateGet(this, _lastSyncedAt);\n  }\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    if (__privateGet(this, _lastSyncedAt) === void 0) return Infinity;\n    return Date.now() - __privateGet(this, _lastSyncedAt);\n  }\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected() {\n    return __privateGet(this, _connected);\n  }\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return !__privateGet(this, _isUpToDate);\n  }\n};\n_error = new WeakMap();\n_fetchClient2 = new WeakMap();\n_messageParser = new WeakMap();\n_subscribers = new WeakMap();\n_lastOffset = new WeakMap();\n_liveCacheBuster = new WeakMap();\n_lastSyncedAt = new WeakMap();\n_isUpToDate = new WeakMap();\n_connected = new WeakMap();\n_shapeHandle = new WeakMap();\n_schema = new WeakMap();\n_onError = new WeakMap();\n_ShapeStream_instances = new WeakSet();\nstart_fn = function() {\n  return __async(this, null, function* () {\n    var _a, _b;\n    try {\n      while (!((_a = this.options.signal) == null ? void 0 : _a.aborted) && !__privateGet(this, _isUpToDate) || this.options.subscribe) {\n        const { url, signal } = this.options;\n        const fetchUrl = new URL(url);\n        if (this.options.params) {\n          const reservedParams = Object.keys(this.options.params).filter(\n            (key) => RESERVED_PARAMS.has(key)\n          );\n          if (reservedParams.length > 0) {\n            throw new Error(\n              `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`\n            );\n          }\n          const params = toInternalParams(this.options.params);\n          if (params.table)\n            fetchUrl.searchParams.set(TABLE_QUERY_PARAM, params.table);\n          if (params.where)\n            fetchUrl.searchParams.set(WHERE_QUERY_PARAM, params.where);\n          if (params.columns)\n            fetchUrl.searchParams.set(COLUMNS_QUERY_PARAM, params.columns);\n          if (params.replica)\n            fetchUrl.searchParams.set(REPLICA_PARAM, params.replica);\n          const customParams = __spreadValues({}, params);\n          delete customParams.table;\n          delete customParams.where;\n          delete customParams.columns;\n          delete customParams.replica;\n          for (const [key, value] of Object.entries(customParams)) {\n            fetchUrl.searchParams.set(key, value);\n          }\n        }\n        fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, __privateGet(this, _lastOffset));\n        if (__privateGet(this, _isUpToDate)) {\n          fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`);\n          fetchUrl.searchParams.set(\n            LIVE_CACHE_BUSTER_QUERY_PARAM,\n            __privateGet(this, _liveCacheBuster)\n          );\n        }\n        if (__privateGet(this, _shapeHandle)) {\n          fetchUrl.searchParams.set(\n            SHAPE_HANDLE_QUERY_PARAM,\n            __privateGet(this, _shapeHandle)\n          );\n        }\n        fetchUrl.searchParams.sort();\n        let response;\n        try {\n          response = yield __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {\n            signal,\n            headers: this.options.headers\n          });\n          __privateSet(this, _connected, true);\n        } catch (e) {\n          if (e instanceof FetchBackoffAbortError) break;\n          if (!(e instanceof FetchError)) throw e;\n          if (e.status == 409) {\n            const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER];\n            __privateMethod(this, _ShapeStream_instances, reset_fn).call(this, newShapeHandle);\n            yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, e.json);\n            continue;\n          } else if (e.status >= 400 && e.status < 500) {\n            __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, e);\n            throw e;\n          }\n        }\n        const { headers, status } = response;\n        const shapeHandle = headers.get(SHAPE_HANDLE_HEADER);\n        if (shapeHandle) {\n          __privateSet(this, _shapeHandle, shapeHandle);\n        }\n        const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER);\n        if (lastOffset) {\n          __privateSet(this, _lastOffset, lastOffset);\n        }\n        const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER);\n        if (liveCacheBuster) {\n          __privateSet(this, _liveCacheBuster, liveCacheBuster);\n        }\n        const getSchema = () => {\n          const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER);\n          return schemaHeader ? JSON.parse(schemaHeader) : {};\n        };\n        __privateSet(this, _schema, (_b = __privateGet(this, _schema)) != null ? _b : getSchema());\n        const messages = status === 204 ? `[]` : yield response.text();\n        if (status === 204) {\n          __privateSet(this, _lastSyncedAt, Date.now());\n        }\n        const batch = __privateGet(this, _messageParser).parse(messages, __privateGet(this, _schema));\n        if (batch.length > 0) {\n          const lastMessage = batch[batch.length - 1];\n          if (isUpToDateMessage(lastMessage)) {\n            __privateSet(this, _lastSyncedAt, Date.now());\n            __privateSet(this, _isUpToDate, true);\n          }\n          yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, batch);\n        }\n      }\n    } catch (err) {\n      __privateSet(this, _error, err);\n      if (__privateGet(this, _onError)) {\n        const retryOpts = yield __privateGet(this, _onError).call(this, err);\n        if (typeof retryOpts === `object`) {\n          __privateMethod(this, _ShapeStream_instances, reset_fn).call(this);\n          if (`params` in retryOpts) {\n            this.options.params = retryOpts.params;\n          }\n          if (`headers` in retryOpts) {\n            this.options.headers = retryOpts.headers;\n          }\n          __privateMethod(this, _ShapeStream_instances, start_fn).call(this);\n        }\n        return;\n      }\n      throw err;\n    } finally {\n      __privateSet(this, _connected, false);\n    }\n  });\n};\npublish_fn = function(messages) {\n  return __async(this, null, function* () {\n    yield Promise.all(\n      Array.from(__privateGet(this, _subscribers).values()).map((_0) => __async(this, [_0], function* ([callback, __]) {\n        try {\n          yield callback(messages);\n        } catch (err) {\n          queueMicrotask(() => {\n            throw err;\n          });\n        }\n      }))\n    );\n  });\n};\nsendErrorToSubscribers_fn = function(error) {\n  __privateGet(this, _subscribers).forEach(([_, errorFn]) => {\n    errorFn == null ? void 0 : errorFn(error);\n  });\n};\n/**\n * Resets the state of the stream, optionally with a provided\n * shape handle\n */\nreset_fn = function(handle) {\n  __privateSet(this, _lastOffset, `-1`);\n  __privateSet(this, _liveCacheBuster, ``);\n  __privateSet(this, _shapeHandle, handle);\n  __privateSet(this, _isUpToDate, false);\n  __privateSet(this, _connected, false);\n  __privateSet(this, _schema, void 0);\n};\nShapeStream.Replica = {\n  FULL: `full`,\n  DEFAULT: `default`\n};\nfunction validateOptions(options) {\n  if (!options.url) {\n    throw new MissingShapeUrlError();\n  }\n  if (options.signal && !(options.signal instanceof AbortSignal)) {\n    throw new InvalidSignalError();\n  }\n  if (options.offset !== void 0 && options.offset !== `-1` && !options.handle) {\n    throw new MissingShapeHandleError();\n  }\n  if (options.params) {\n    const reservedParams = Object.keys(options.params).filter(\n      (key) => RESERVED_PARAMS.has(key)\n    );\n    if (reservedParams.length > 0) {\n      throw new ReservedParamError(reservedParams);\n    }\n  }\n  return;\n}\n\n// src/shape.ts\nvar _data, _subscribers2, _hasNotifiedSubscribersUpToDate, _error2, _Shape_instances, process_fn, handleError_fn, notify_fn;\nvar Shape = class {\n  constructor(stream) {\n    __privateAdd(this, _Shape_instances);\n    __privateAdd(this, _data, /* @__PURE__ */ new Map());\n    __privateAdd(this, _subscribers2, /* @__PURE__ */ new Map());\n    __privateAdd(this, _hasNotifiedSubscribersUpToDate, false);\n    __privateAdd(this, _error2, false);\n    this.stream = stream;\n    this.stream.subscribe(\n      __privateMethod(this, _Shape_instances, process_fn).bind(this),\n      __privateMethod(this, _Shape_instances, handleError_fn).bind(this)\n    );\n  }\n  get isUpToDate() {\n    return this.stream.isUpToDate;\n  }\n  get lastOffset() {\n    return this.stream.lastOffset;\n  }\n  get handle() {\n    return this.stream.shapeHandle;\n  }\n  get rows() {\n    return this.value.then((v) => Array.from(v.values()));\n  }\n  get currentRows() {\n    return Array.from(this.currentValue.values());\n  }\n  get value() {\n    return new Promise((resolve, reject) => {\n      if (this.stream.isUpToDate) {\n        resolve(this.currentValue);\n      } else {\n        const unsubscribe = this.subscribe(({ value }) => {\n          unsubscribe();\n          if (__privateGet(this, _error2)) reject(__privateGet(this, _error2));\n          resolve(value);\n        });\n      }\n    });\n  }\n  get currentValue() {\n    return __privateGet(this, _data);\n  }\n  get error() {\n    return __privateGet(this, _error2);\n  }\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt() {\n    return this.stream.lastSyncedAt();\n  }\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    return this.stream.lastSynced();\n  }\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return this.stream.isLoading();\n  }\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected() {\n    return this.stream.isConnected();\n  }\n  subscribe(callback) {\n    const subscriptionId = Math.random();\n    __privateGet(this, _subscribers2).set(subscriptionId, callback);\n    return () => {\n      __privateGet(this, _subscribers2).delete(subscriptionId);\n    };\n  }\n  unsubscribeAll() {\n    __privateGet(this, _subscribers2).clear();\n  }\n  get numSubscribers() {\n    return __privateGet(this, _subscribers2).size;\n  }\n};\n_data = new WeakMap();\n_subscribers2 = new WeakMap();\n_hasNotifiedSubscribersUpToDate = new WeakMap();\n_error2 = new WeakMap();\n_Shape_instances = new WeakSet();\nprocess_fn = function(messages) {\n  let dataMayHaveChanged = false;\n  let isUpToDate = false;\n  let newlyUpToDate = false;\n  messages.forEach((message) => {\n    if (isChangeMessage(message)) {\n      dataMayHaveChanged = [`insert`, `update`, `delete`].includes(\n        message.headers.operation\n      );\n      switch (message.headers.operation) {\n        case `insert`:\n          __privateGet(this, _data).set(message.key, message.value);\n          break;\n        case `update`:\n          __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));\n          break;\n        case `delete`:\n          __privateGet(this, _data).delete(message.key);\n          break;\n      }\n    }\n    if (isControlMessage(message)) {\n      switch (message.headers.control) {\n        case `up-to-date`:\n          isUpToDate = true;\n          if (!__privateGet(this, _hasNotifiedSubscribersUpToDate)) {\n            newlyUpToDate = true;\n          }\n          break;\n        case `must-refetch`:\n          __privateGet(this, _data).clear();\n          __privateSet(this, _error2, false);\n          __privateSet(this, _hasNotifiedSubscribersUpToDate, false);\n          isUpToDate = false;\n          newlyUpToDate = false;\n          break;\n      }\n    }\n  });\n  if (newlyUpToDate || isUpToDate && dataMayHaveChanged) {\n    __privateSet(this, _hasNotifiedSubscribersUpToDate, true);\n    __privateMethod(this, _Shape_instances, notify_fn).call(this);\n  }\n};\nhandleError_fn = function(e) {\n  if (e instanceof FetchError) {\n    __privateSet(this, _error2, e);\n    __privateMethod(this, _Shape_instances, notify_fn).call(this);\n  }\n};\nnotify_fn = function() {\n  __privateGet(this, _subscribers2).forEach((callback) => {\n    callback({ value: this.currentValue, rows: this.currentRows });\n  });\n};\nexport {\n  BackoffDefaults,\n  FetchError,\n  Shape,\n  ShapeStream,\n  isChangeMessage,\n  isControlMessage\n};\n//# sourceMappingURL=index.mjs.map","export function createAsyncIterableStream(source, transformer) {\n    const transformedStream = source.pipeThrough(new TransformStream(transformer));\n    transformedStream[Symbol.asyncIterator] = () => {\n        const reader = transformedStream.getReader();\n        return {\n            async next() {\n                const { done, value } = await reader.read();\n                return done ? { done: true, value: undefined } : { done: false, value };\n            },\n        };\n    };\n    return transformedStream;\n}\nexport function createAsyncIterableReadable(source, transformer, signal) {\n    return new ReadableStream({\n        async start(controller) {\n            const transformedStream = source.pipeThrough(new TransformStream(transformer));\n            const reader = transformedStream.getReader();\n            signal.addEventListener(\"abort\", () => {\n                queueMicrotask(() => {\n                    reader.cancel();\n                    controller.close();\n                });\n            });\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                    controller.close();\n                    break;\n                }\n                controller.enqueue(value);\n            }\n        },\n    });\n}\nexport function createAsyncIterableStreamFromAsyncIterable(asyncIterable, transformer, signal) {\n    const stream = new ReadableStream({\n        async start(controller) {\n            try {\n                if (signal) {\n                    signal.addEventListener(\"abort\", () => {\n                        controller.close();\n                    });\n                }\n                const iterator = asyncIterable[Symbol.asyncIterator]();\n                while (true) {\n                    if (signal?.aborted) {\n                        break;\n                    }\n                    const { done, value } = await iterator.next();\n                    if (done) {\n                        controller.close();\n                        break;\n                    }\n                    controller.enqueue(value);\n                }\n            }\n            catch (error) {\n                controller.error(error);\n            }\n        },\n        cancel() {\n            // If the stream is a tinyexec process with a kill method, kill it\n            if (\"kill\" in asyncIterable) {\n                asyncIterable.kill();\n            }\n        },\n    });\n    const transformedStream = stream.pipeThrough(new TransformStream(transformer));\n    return transformedStream;\n}\n//# sourceMappingURL=asyncIterableStream.js.map","import { FetchError, isChangeMessage, isControlMessage, ShapeStream, } from \"@electric-sql/client\";\nimport { createAsyncIterableStream } from \"../streams/asyncIterableStream.js\";\nexport function zodShapeStream(schema, url, options) {\n    const abortController = new AbortController();\n    options?.signal?.addEventListener(\"abort\", () => {\n        abortController.abort();\n    }, { once: true });\n    const shapeStream = new ShapeStream({\n        url,\n        headers: {\n            ...options?.headers,\n            \"x-trigger-electric-version\": \"1.0.0-beta.1\",\n        },\n        fetchClient: options?.fetchClient,\n        signal: abortController.signal,\n        onError: (e) => {\n            options?.onError?.(e);\n        },\n    });\n    const readableShape = new ReadableShapeStream(shapeStream);\n    const stream = readableShape.stream.pipeThrough(new TransformStream({\n        async transform(chunk, controller) {\n            const result = schema.safeParse(chunk);\n            if (result.success) {\n                controller.enqueue(result.data);\n            }\n            else {\n                controller.error(new Error(`Unable to parse shape: ${result.error.message}`));\n            }\n        },\n    }));\n    return {\n        stream: stream,\n        stop: (delay) => {\n            if (delay) {\n                setTimeout(() => {\n                    if (abortController.signal.aborted)\n                        return;\n                    abortController.abort();\n                }, delay);\n            }\n            else {\n                abortController.abort();\n            }\n        },\n    };\n}\nclass ReadableShapeStream {\n    #stream;\n    #currentState = new Map();\n    #changeStream;\n    #error = false;\n    #unsubscribe;\n    stop() {\n        this.#unsubscribe?.();\n    }\n    constructor(stream) {\n        this.#stream = stream;\n        // Create the source stream that will receive messages\n        const source = new ReadableStream({\n            start: (controller) => {\n                this.#unsubscribe = this.#stream.subscribe((messages) => controller.enqueue(messages), this.#handleError.bind(this));\n            },\n        });\n        // Create the transformed stream that processes messages and emits complete rows\n        this.#changeStream = createAsyncIterableStream(source, {\n            transform: (messages, controller) => {\n                const updatedKeys = new Set();\n                for (const message of messages) {\n                    if (isChangeMessage(message)) {\n                        const key = message.key;\n                        switch (message.headers.operation) {\n                            case \"insert\": {\n                                // New row entirely\n                                this.#currentState.set(key, message.value);\n                                updatedKeys.add(key);\n                                break;\n                            }\n                            case \"update\": {\n                                // Merge updates into existing row if any, otherwise treat as new\n                                const existingRow = this.#currentState.get(key);\n                                const updatedRow = existingRow\n                                    ? { ...existingRow, ...message.value }\n                                    : message.value;\n                                this.#currentState.set(key, updatedRow);\n                                updatedKeys.add(key);\n                                break;\n                            }\n                        }\n                    }\n                    else if (isControlMessage(message)) {\n                        if (message.headers.control === \"must-refetch\") {\n                            this.#currentState.clear();\n                            this.#error = false;\n                        }\n                    }\n                }\n                // Now enqueue only one updated row per key, after all messages have been processed.\n                for (const key of updatedKeys) {\n                    const finalRow = this.#currentState.get(key);\n                    if (finalRow) {\n                        controller.enqueue(finalRow);\n                    }\n                }\n            },\n        });\n    }\n    get stream() {\n        return this.#changeStream;\n    }\n    get isUpToDate() {\n        return this.#stream.isUpToDate;\n    }\n    get lastOffset() {\n        return this.#stream.lastOffset;\n    }\n    get handle() {\n        return this.#stream.shapeHandle;\n    }\n    get error() {\n        return this.#error;\n    }\n    lastSyncedAt() {\n        return this.#stream.lastSyncedAt();\n    }\n    lastSynced() {\n        return this.#stream.lastSynced();\n    }\n    isLoading() {\n        return this.#stream.isLoading();\n    }\n    isConnected() {\n        return this.#stream.isConnected();\n    }\n    #handleError(e) {\n        if (e instanceof FetchError) {\n            this.#error = e;\n        }\n    }\n}\nexport class LineTransformStream extends TransformStream {\n    buffer = \"\";\n    constructor() {\n        super({\n            transform: (chunk, controller) => {\n                // Append the chunk to the buffer\n                this.buffer += chunk;\n                // Split on newlines\n                const lines = this.buffer.split(\"\\n\");\n                // The last element might be incomplete, hold it back in buffer\n                this.buffer = lines.pop() || \"\";\n                // Filter out empty or whitespace-only lines\n                const fullLines = lines.filter((line) => line.trim().length > 0);\n                // If we got any complete lines, emit them as an array\n                if (fullLines.length > 0) {\n                    controller.enqueue(fullLines);\n                }\n            },\n            flush: (controller) => {\n                // On stream end, if there's leftover text, emit it as a single-element array\n                const trimmed = this.buffer.trim();\n                if (trimmed.length > 0) {\n                    controller.enqueue([trimmed]);\n                }\n            },\n        });\n    }\n}\n//# sourceMappingURL=stream.js.map","import { EventSourceParserStream } from \"eventsource-parser/stream\";\nimport { createJsonErrorObject } from \"../errors.js\";\nimport { SubscribeRealtimeStreamChunkRawShape, SubscribeRunRawShape, } from \"../schemas/api.js\";\nimport { getEnvVar } from \"../utils/getEnv.js\";\nimport { conditionallyImportAndParsePacket, parsePacket, } from \"../utils/ioSerialization.js\";\nimport { ApiError } from \"./errors.js\";\nimport { LineTransformStream, zodShapeStream } from \"./stream.js\";\nimport { createAsyncIterableReadable, } from \"../streams/asyncIterableStream.js\";\nexport function runShapeStream(url, options) {\n    const abortController = new AbortController();\n    const streamFactory = new SSEStreamSubscriptionFactory(getEnvVar(\"TRIGGER_STREAM_URL\", getEnvVar(\"TRIGGER_API_URL\")) ?? \"https://api.trigger.dev\", {\n        headers: options?.headers,\n        signal: abortController.signal,\n    });\n    // If the user supplied AbortSignal is aborted, we should abort the internal controller\n    options?.signal?.addEventListener(\"abort\", () => {\n        if (!abortController.signal.aborted) {\n            abortController.abort();\n        }\n    }, { once: true });\n    const runStreamInstance = zodShapeStream(SubscribeRunRawShape, url, {\n        ...options,\n        signal: abortController.signal,\n        onError: (e) => {\n            options?.onFetchError?.(e);\n        },\n    });\n    const $options = {\n        runShapeStream: runStreamInstance.stream,\n        stopRunShapeStream: () => runStreamInstance.stop(30 * 1000),\n        streamFactory: streamFactory,\n        abortController,\n        ...options,\n    };\n    return new RunSubscription($options);\n}\n// Real implementation for production\nexport class SSEStreamSubscription {\n    url;\n    options;\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n    }\n    async subscribe() {\n        return fetch(this.url, {\n            headers: {\n                Accept: \"text/event-stream\",\n                ...this.options.headers,\n            },\n            signal: this.options.signal,\n        }).then((response) => {\n            if (!response.ok) {\n                throw ApiError.generate(response.status, {}, \"Could not subscribe to stream\", Object.fromEntries(response.headers));\n            }\n            if (!response.body) {\n                throw new Error(\"No response body\");\n            }\n            return response.body\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new EventSourceParserStream())\n                .pipeThrough(new TransformStream({\n                transform(chunk, controller) {\n                    controller.enqueue(safeParseJSON(chunk.data));\n                },\n            }));\n        });\n    }\n}\nexport class SSEStreamSubscriptionFactory {\n    baseUrl;\n    options;\n    constructor(baseUrl, options) {\n        this.baseUrl = baseUrl;\n        this.options = options;\n    }\n    createSubscription(runId, streamKey, baseUrl) {\n        if (!runId || !streamKey) {\n            throw new Error(\"runId and streamKey are required\");\n        }\n        const url = `${baseUrl ?? this.baseUrl}/realtime/v1/streams/${runId}/${streamKey}`;\n        return new SSEStreamSubscription(url, this.options);\n    }\n}\n// Real implementation for production\nexport class ElectricStreamSubscription {\n    url;\n    options;\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n    }\n    async subscribe() {\n        return zodShapeStream(SubscribeRealtimeStreamChunkRawShape, this.url, this.options)\n            .stream.pipeThrough(new TransformStream({\n            transform(chunk, controller) {\n                controller.enqueue(chunk.value);\n            },\n        }))\n            .pipeThrough(new LineTransformStream())\n            .pipeThrough(new TransformStream({\n            transform(chunk, controller) {\n                for (const line of chunk) {\n                    controller.enqueue(safeParseJSON(line));\n                }\n            },\n        }));\n    }\n}\nexport class RunSubscription {\n    options;\n    stream;\n    packetCache = new Map();\n    _closeOnComplete;\n    _isRunComplete = false;\n    constructor(options) {\n        this.options = options;\n        this._closeOnComplete =\n            typeof options.closeOnComplete === \"undefined\" ? true : options.closeOnComplete;\n        this.stream = createAsyncIterableReadable(this.options.runShapeStream, {\n            transform: async (chunk, controller) => {\n                const run = await this.transformRunShape(chunk);\n                controller.enqueue(run);\n                // only set the run to complete when finishedAt is set\n                this._isRunComplete = !!run.finishedAt;\n                if (this._closeOnComplete &&\n                    this._isRunComplete &&\n                    !this.options.abortController.signal.aborted) {\n                    this.options.stopRunShapeStream();\n                }\n            },\n        }, this.options.abortController.signal);\n    }\n    unsubscribe() {\n        if (!this.options.abortController.signal.aborted) {\n            this.options.abortController.abort();\n        }\n        this.options.stopRunShapeStream();\n    }\n    [Symbol.asyncIterator]() {\n        return this.stream[Symbol.asyncIterator]();\n    }\n    getReader() {\n        return this.stream.getReader();\n    }\n    withStreams() {\n        // Keep track of which streams we've already subscribed to\n        const activeStreams = new Set();\n        return createAsyncIterableReadable(this.stream, {\n            transform: async (run, controller) => {\n                controller.enqueue({\n                    type: \"run\",\n                    run,\n                });\n                // Check for stream metadata\n                if (run.metadata &&\n                    \"$$streams\" in run.metadata &&\n                    Array.isArray(run.metadata.$$streams)) {\n                    for (const streamKey of run.metadata.$$streams) {\n                        if (typeof streamKey !== \"string\") {\n                            continue;\n                        }\n                        if (!activeStreams.has(streamKey)) {\n                            activeStreams.add(streamKey);\n                            const subscription = this.options.streamFactory.createSubscription(run.id, streamKey, this.options.client?.baseUrl);\n                            // Start stream processing in the background\n                            subscription\n                                .subscribe()\n                                .then((stream) => {\n                                stream\n                                    .pipeThrough(new TransformStream({\n                                    transform(chunk, controller) {\n                                        controller.enqueue({\n                                            type: streamKey,\n                                            chunk: chunk,\n                                            run,\n                                        });\n                                    },\n                                }))\n                                    .pipeTo(new WritableStream({\n                                    write(chunk) {\n                                        controller.enqueue(chunk);\n                                    },\n                                }))\n                                    .catch((error) => {\n                                    console.error(`Error in stream ${streamKey}:`, error);\n                                });\n                            })\n                                .catch((error) => {\n                                console.error(`Error subscribing to stream ${streamKey}:`, error);\n                            });\n                        }\n                    }\n                }\n            },\n        }, this.options.abortController.signal);\n    }\n    async transformRunShape(row) {\n        const payloadPacket = row.payloadType\n            ? { data: row.payload ?? undefined, dataType: row.payloadType }\n            : undefined;\n        const outputPacket = row.outputType\n            ? { data: row.output ?? undefined, dataType: row.outputType }\n            : undefined;\n        const [payload, output] = await Promise.all([\n            { packet: payloadPacket, key: \"payload\" },\n            { packet: outputPacket, key: \"output\" },\n        ].map(async ({ packet, key }) => {\n            if (!packet) {\n                return;\n            }\n            const cachedResult = this.packetCache.get(`${row.friendlyId}/${key}`);\n            if (typeof cachedResult !== \"undefined\") {\n                return cachedResult;\n            }\n            const result = await conditionallyImportAndParsePacket(packet, this.options.client);\n            this.packetCache.set(`${row.friendlyId}/${key}`, result);\n            return result;\n        }));\n        const metadata = row.metadata && row.metadataType\n            ? await parsePacket({ data: row.metadata, dataType: row.metadataType })\n            : undefined;\n        return {\n            id: row.friendlyId,\n            payload,\n            output,\n            createdAt: row.createdAt,\n            updatedAt: row.updatedAt,\n            taskIdentifier: row.taskIdentifier,\n            number: row.number,\n            status: apiStatusFromRunStatus(row.status),\n            durationMs: row.usageDurationMs,\n            costInCents: row.costInCents,\n            baseCostInCents: row.baseCostInCents,\n            tags: row.runTags ?? [],\n            idempotencyKey: row.idempotencyKey ?? undefined,\n            expiredAt: row.expiredAt ?? undefined,\n            finishedAt: row.completedAt ?? undefined,\n            startedAt: row.startedAt ?? undefined,\n            delayedUntil: row.delayUntil ?? undefined,\n            queuedAt: row.queuedAt ?? undefined,\n            error: row.error ? createJsonErrorObject(row.error) : undefined,\n            isTest: row.isTest,\n            metadata,\n        };\n    }\n}\nfunction apiStatusFromRunStatus(status) {\n    switch (status) {\n        case \"DELAYED\": {\n            return \"DELAYED\";\n        }\n        case \"WAITING_FOR_DEPLOY\": {\n            return \"WAITING_FOR_DEPLOY\";\n        }\n        case \"PENDING\": {\n            return \"QUEUED\";\n        }\n        case \"PAUSED\":\n        case \"WAITING_TO_RESUME\": {\n            return \"FROZEN\";\n        }\n        case \"RETRYING_AFTER_FAILURE\": {\n            return \"REATTEMPTING\";\n        }\n        case \"EXECUTING\": {\n            return \"EXECUTING\";\n        }\n        case \"CANCELED\": {\n            return \"CANCELED\";\n        }\n        case \"COMPLETED_SUCCESSFULLY\": {\n            return \"COMPLETED\";\n        }\n        case \"SYSTEM_FAILURE\": {\n            return \"SYSTEM_FAILURE\";\n        }\n        case \"INTERRUPTED\": {\n            return \"INTERRUPTED\";\n        }\n        case \"CRASHED\": {\n            return \"CRASHED\";\n        }\n        case \"COMPLETED_WITH_ERRORS\": {\n            return \"FAILED\";\n        }\n        case \"EXPIRED\": {\n            return \"EXPIRED\";\n        }\n        case \"TIMED_OUT\": {\n            return \"TIMED_OUT\";\n        }\n        default: {\n            throw new Error(`Unknown status: ${status}`);\n        }\n    }\n}\nfunction safeParseJSON(data) {\n    try {\n        return JSON.parse(data);\n    }\n    catch (error) {\n        return data;\n    }\n}\nconst isSafari = () => {\n    // Check if we're in a browser environment\n    if (typeof window !== \"undefined\" &&\n        typeof navigator !== \"undefined\" &&\n        typeof navigator.userAgent === \"string\") {\n        return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) ||\n            /iPad|iPhone|iPod/.test(navigator.userAgent));\n    }\n    // If we're not in a browser environment, return false\n    return false;\n};\n/**\n * A polyfill for `ReadableStream.protototype[Symbol.asyncIterator]`,\n * aligning as closely as possible to the specification.\n *\n * @see https://streams.spec.whatwg.org/#rs-asynciterator\n * @see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#async_iteration\n *\n * This is needed for Safari: https://bugs.webkit.org/show_bug.cgi?id=194379\n *\n * From https://gist.github.com/MattiasBuelens/496fc1d37adb50a733edd43853f2f60e\n *\n */\nif (isSafari()) {\n    // @ts-ignore-error\n    ReadableStream.prototype.values ??= function ({ preventCancel = false } = {}) {\n        const reader = this.getReader();\n        return {\n            async next() {\n                try {\n                    const result = await reader.read();\n                    if (result.done) {\n                        reader.releaseLock();\n                    }\n                    return result;\n                }\n                catch (e) {\n                    reader.releaseLock();\n                    throw e;\n                }\n            },\n            async return(value) {\n                if (!preventCancel) {\n                    const cancelPromise = reader.cancel(value);\n                    reader.releaseLock();\n                    await cancelPromise;\n                }\n                else {\n                    reader.releaseLock();\n                }\n                return { done: true, value };\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    };\n    // @ts-ignore-error\n    ReadableStream.prototype[Symbol.asyncIterator] ??= ReadableStream.prototype.values;\n}\n//# sourceMappingURL=runStream.js.map","import { z } from \"zod\";\nimport { VERSION } from \"../../version.js\";\nimport { generateJWT } from \"../jwt.js\";\nimport { BatchTaskRunExecutionResult, BatchTriggerTaskV2Response, CanceledRunResponse, CreateUploadPayloadUrlResponseBody, DeletedScheduleObject, EnvironmentVariableResponseBody, EnvironmentVariableValue, EnvironmentVariables, ListRunResponseItem, ReplayRunResponse, RetrieveBatchResponse, RetrieveRunResponse, ScheduleObject, TaskRunExecutionResult, TriggerTaskResponse, UpdateMetadataResponseBody, } from \"../schemas/index.js\";\nimport { taskContext } from \"../task-context-api.js\";\nimport { isRequestOptions, zodfetch, zodfetchCursorPage, zodfetchOffsetLimitPage, } from \"./core.js\";\nimport { ApiError } from \"./errors.js\";\nimport { runShapeStream, SSEStreamSubscriptionFactory, } from \"./runStream.js\";\nconst DEFAULT_ZOD_FETCH_OPTIONS = {\n    retry: {\n        maxAttempts: 5,\n        minTimeoutInMs: 1000,\n        maxTimeoutInMs: 30_000,\n        factor: 1.6,\n        randomize: false,\n    },\n};\nexport { isRequestOptions };\n/**\n * Trigger.dev v3 API client\n */\nexport class ApiClient {\n    baseUrl;\n    accessToken;\n    defaultRequestOptions;\n    constructor(baseUrl, accessToken, requestOptions = {}) {\n        this.accessToken = accessToken;\n        this.baseUrl = baseUrl.replace(/\\/$/, \"\");\n        this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);\n    }\n    get fetchClient() {\n        const headers = this.#getHeaders(false);\n        const fetchClient = (input, requestInit) => {\n            const $requestInit = {\n                ...requestInit,\n                headers: {\n                    ...requestInit?.headers,\n                    ...headers,\n                },\n            };\n            return fetch(input, $requestInit);\n        };\n        return fetchClient;\n    }\n    getHeaders() {\n        return this.#getHeaders(false);\n    }\n    async getRunResult(runId, requestOptions) {\n        try {\n            return await zodfetch(TaskRunExecutionResult, `${this.baseUrl}/api/v1/runs/${runId}/result`, {\n                method: \"GET\",\n                headers: this.#getHeaders(false),\n            }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n        }\n        catch (error) {\n            if (error instanceof ApiError) {\n                if (error.status === 404) {\n                    return undefined;\n                }\n            }\n            throw error;\n        }\n    }\n    async getBatchResults(batchId, requestOptions) {\n        return await zodfetch(BatchTaskRunExecutionResult, `${this.baseUrl}/api/v1/batches/${batchId}/results`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    triggerTask(taskId, body, clientOptions, requestOptions) {\n        const encodedTaskId = encodeURIComponent(taskId);\n        return zodfetch(TriggerTaskResponse, `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`, {\n            method: \"POST\",\n            headers: this.#getHeaders(clientOptions?.spanParentAsLink ?? false),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions))\n            .withResponse()\n            .then(async ({ response, data }) => {\n            const jwtHeader = response.headers.get(\"x-trigger-jwt\");\n            if (typeof jwtHeader === \"string\") {\n                return {\n                    ...data,\n                    publicAccessToken: jwtHeader,\n                };\n            }\n            const claimsHeader = response.headers.get(\"x-trigger-jwt-claims\");\n            const claims = claimsHeader ? JSON.parse(claimsHeader) : undefined;\n            const jwt = await generateJWT({\n                secretKey: this.accessToken,\n                payload: {\n                    ...claims,\n                    scopes: [`read:runs:${data.id}`],\n                },\n                expirationTime: requestOptions?.publicAccessToken?.expirationTime ?? \"1h\",\n            });\n            return {\n                ...data,\n                publicAccessToken: jwt,\n            };\n        });\n    }\n    batchTriggerV2(body, clientOptions, requestOptions) {\n        return zodfetch(BatchTriggerTaskV2Response, `${this.baseUrl}/api/v1/tasks/batch`, {\n            method: \"POST\",\n            headers: this.#getHeaders(clientOptions?.spanParentAsLink ?? false, {\n                \"idempotency-key\": clientOptions?.idempotencyKey,\n                \"idempotency-key-ttl\": clientOptions?.idempotencyKeyTTL,\n                \"batch-processing-strategy\": clientOptions?.processingStrategy,\n            }),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions))\n            .withResponse()\n            .then(async ({ response, data }) => {\n            const claimsHeader = response.headers.get(\"x-trigger-jwt-claims\");\n            const claims = claimsHeader ? JSON.parse(claimsHeader) : undefined;\n            const jwt = await generateJWT({\n                secretKey: this.accessToken,\n                payload: {\n                    ...claims,\n                    scopes: [`read:batch:${data.id}`],\n                },\n                expirationTime: requestOptions?.publicAccessToken?.expirationTime ?? \"1h\",\n            });\n            return {\n                ...data,\n                publicAccessToken: jwt,\n            };\n        });\n    }\n    createUploadPayloadUrl(filename, requestOptions) {\n        return zodfetch(CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {\n            method: \"PUT\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    getPayloadUrl(filename, requestOptions) {\n        return zodfetch(CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    retrieveRun(runId, requestOptions) {\n        return zodfetch(RetrieveRunResponse, `${this.baseUrl}/api/v3/runs/${runId}`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    listRuns(query, requestOptions) {\n        const searchParams = createSearchQueryForListRuns(query);\n        return zodfetchCursorPage(ListRunResponseItem, `${this.baseUrl}/api/v1/runs`, {\n            query: searchParams,\n            limit: query?.limit,\n            after: query?.after,\n            before: query?.before,\n        }, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    listProjectRuns(projectRef, query, requestOptions) {\n        const searchParams = createSearchQueryForListRuns(query);\n        if (query?.env) {\n            searchParams.append(\"filter[env]\", Array.isArray(query.env) ? query.env.join(\",\") : query.env);\n        }\n        return zodfetchCursorPage(ListRunResponseItem, `${this.baseUrl}/api/v1/projects/${projectRef}/runs`, {\n            query: searchParams,\n            limit: query?.limit,\n            after: query?.after,\n            before: query?.before,\n        }, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    replayRun(runId, requestOptions) {\n        return zodfetch(ReplayRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/replay`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    cancelRun(runId, requestOptions) {\n        return zodfetch(CanceledRunResponse, `${this.baseUrl}/api/v2/runs/${runId}/cancel`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    rescheduleRun(runId, body, requestOptions) {\n        return zodfetch(RetrieveRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/reschedule`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    addTags(runId, body, requestOptions) {\n        return zodfetch(z.object({ message: z.string() }), `${this.baseUrl}/api/v1/runs/${runId}/tags`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    createSchedule(options, requestOptions) {\n        return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(options),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    listSchedules(options, requestOptions) {\n        const searchParams = new URLSearchParams();\n        if (options?.page) {\n            searchParams.append(\"page\", options.page.toString());\n        }\n        if (options?.perPage) {\n            searchParams.append(\"perPage\", options.perPage.toString());\n        }\n        return zodfetchOffsetLimitPage(ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {\n            page: options?.page,\n            limit: options?.perPage,\n        }, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    retrieveSchedule(scheduleId, requestOptions) {\n        return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    updateSchedule(scheduleId, options, requestOptions) {\n        return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {\n            method: \"PUT\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(options),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    deactivateSchedule(scheduleId, requestOptions) {\n        return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    activateSchedule(scheduleId, requestOptions) {\n        return zodfetch(ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    deleteSchedule(scheduleId, requestOptions) {\n        return zodfetch(DeletedScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {\n            method: \"DELETE\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    listEnvVars(projectRef, slug, requestOptions) {\n        return zodfetch(EnvironmentVariables, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    importEnvVars(projectRef, slug, body, requestOptions) {\n        return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    retrieveEnvVar(projectRef, slug, key, requestOptions) {\n        return zodfetch(EnvironmentVariableValue, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    createEnvVar(projectRef, slug, body, requestOptions) {\n        return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    updateEnvVar(projectRef, slug, key, body, requestOptions) {\n        return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {\n            method: \"PUT\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    deleteEnvVar(projectRef, slug, key, requestOptions) {\n        return zodfetch(EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {\n            method: \"DELETE\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    updateRunMetadata(runId, body, requestOptions) {\n        return zodfetch(UpdateMetadataResponseBody, `${this.baseUrl}/api/v1/runs/${runId}/metadata`, {\n            method: \"PUT\",\n            headers: this.#getHeaders(false),\n            body: JSON.stringify(body),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    getRunMetadata(runId, requestOptions) {\n        return zodfetch(UpdateMetadataResponseBody, `${this.baseUrl}/api/v1/runs/${runId}/metadata`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    subscribeToRun(runId, options) {\n        return runShapeStream(`${this.baseUrl}/realtime/v1/runs/${runId}`, {\n            closeOnComplete: typeof options?.closeOnComplete === \"boolean\" ? options.closeOnComplete : true,\n            headers: this.#getRealtimeHeaders(),\n            client: this,\n            signal: options?.signal,\n            onFetchError: options?.onFetchError,\n        });\n    }\n    subscribeToRunsWithTag(tag, options) {\n        const searchParams = createSearchQueryForSubscribeToRuns({\n            tags: tag,\n        });\n        return runShapeStream(`${this.baseUrl}/realtime/v1/runs${searchParams ? `?${searchParams}` : \"\"}`, {\n            closeOnComplete: false,\n            headers: this.#getRealtimeHeaders(),\n            client: this,\n            signal: options?.signal,\n            onFetchError: options?.onFetchError,\n        });\n    }\n    subscribeToBatch(batchId, options) {\n        return runShapeStream(`${this.baseUrl}/realtime/v1/batches/${batchId}`, {\n            closeOnComplete: false,\n            headers: this.#getRealtimeHeaders(),\n            client: this,\n            signal: options?.signal,\n            onFetchError: options?.onFetchError,\n        });\n    }\n    async fetchStream(runId, streamKey, options) {\n        const streamFactory = new SSEStreamSubscriptionFactory(options?.baseUrl ?? this.baseUrl, {\n            headers: this.getHeaders(),\n            signal: options?.signal,\n        });\n        const subscription = streamFactory.createSubscription(runId, streamKey);\n        const stream = await subscription.subscribe();\n        return stream;\n    }\n    async generateJWTClaims(requestOptions) {\n        return zodfetch(z.record(z.any()), `${this.baseUrl}/api/v1/auth/jwt/claims`, {\n            method: \"POST\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    retrieveBatch(batchId, requestOptions) {\n        return zodfetch(RetrieveBatchResponse, `${this.baseUrl}/api/v1/batches/${batchId}`, {\n            method: \"GET\",\n            headers: this.#getHeaders(false),\n        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));\n    }\n    #getHeaders(spanParentAsLink, additionalHeaders) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${this.accessToken}`,\n            \"trigger-version\": VERSION,\n            ...Object.entries(additionalHeaders ?? {}).reduce((acc, [key, value]) => {\n                if (value !== undefined) {\n                    acc[key] = value;\n                }\n                return acc;\n            }, {}),\n        };\n        // Only inject the context if we are inside a task\n        if (taskContext.isInsideTask) {\n            headers[\"x-trigger-worker\"] = \"true\";\n            if (spanParentAsLink) {\n                headers[\"x-trigger-span-parent-as-link\"] = \"1\";\n            }\n        }\n        if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\n            headers[\"x-trigger-client\"] = \"browser\";\n        }\n        return headers;\n    }\n    #getRealtimeHeaders() {\n        const headers = {\n            Authorization: `Bearer ${this.accessToken}`,\n            \"trigger-version\": VERSION,\n        };\n        return headers;\n    }\n}\nfunction createSearchQueryForSubscribeToRuns(query) {\n    const searchParams = new URLSearchParams();\n    if (query) {\n        if (query.tasks) {\n            searchParams.append(\"tasks\", Array.isArray(query.tasks) ? query.tasks.join(\",\") : query.tasks);\n        }\n        if (query.tags) {\n            searchParams.append(\"tags\", Array.isArray(query.tags) ? query.tags.join(\",\") : query.tags);\n        }\n    }\n    return searchParams;\n}\nfunction createSearchQueryForListRuns(query) {\n    const searchParams = new URLSearchParams();\n    if (query) {\n        if (query.status) {\n            searchParams.append(\"filter[status]\", Array.isArray(query.status) ? query.status.join(\",\") : query.status);\n        }\n        if (query.taskIdentifier) {\n            searchParams.append(\"filter[taskIdentifier]\", Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(\",\") : query.taskIdentifier);\n        }\n        if (query.version) {\n            searchParams.append(\"filter[version]\", Array.isArray(query.version) ? query.version.join(\",\") : query.version);\n        }\n        if (query.bulkAction) {\n            searchParams.append(\"filter[bulkAction]\", query.bulkAction);\n        }\n        if (query.tag) {\n            searchParams.append(\"filter[tag]\", Array.isArray(query.tag) ? query.tag.join(\",\") : query.tag);\n        }\n        if (query.schedule) {\n            searchParams.append(\"filter[schedule]\", query.schedule);\n        }\n        if (typeof query.isTest === \"boolean\") {\n            searchParams.append(\"filter[isTest]\", String(query.isTest));\n        }\n        if (query.from) {\n            searchParams.append(\"filter[createdAt][from]\", query.from instanceof Date ? query.from.getTime().toString() : query.from.toString());\n        }\n        if (query.to) {\n            searchParams.append(\"filter[createdAt][to]\", query.to instanceof Date ? query.to.getTime().toString() : query.to.toString());\n        }\n        if (query.period) {\n            searchParams.append(\"filter[createdAt][period]\", query.period);\n        }\n        if (query.batch) {\n            searchParams.append(\"filter[batch]\", query.batch);\n        }\n    }\n    return searchParams;\n}\nexport function mergeRequestOptions(defaultOptions, options) {\n    if (!options) {\n        return defaultOptions;\n    }\n    return {\n        ...defaultOptions,\n        ...options,\n        retry: {\n            ...defaultOptions.retry,\n            ...options.retry,\n        },\n    };\n}\n//# sourceMappingURL=index.js.map","import { PreciseDate } from \"@google-cloud/precise-date\";\nexport class SimpleClock {\n    preciseNow() {\n        const now = new PreciseDate();\n        const nowStruct = now.toStruct();\n        return [nowStruct.seconds, nowStruct.nanos];\n    }\n    reset() {\n        // do nothing\n    }\n}\n//# sourceMappingURL=simpleClock.js.map","const API_NAME = \"clock\";\nimport { getGlobal, registerGlobal } from \"../utils/globals.js\";\nimport { SimpleClock } from \"./simpleClock.js\";\nconst SIMPLE_CLOCK = new SimpleClock();\nexport class ClockAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new ClockAPI();\n        }\n        return this._instance;\n    }\n    setGlobalClock(clock) {\n        return registerGlobal(API_NAME, clock);\n    }\n    preciseNow() {\n        return this.#getClock().preciseNow();\n    }\n    reset() {\n        this.#getClock().reset();\n    }\n    #getClock() {\n        return getGlobal(API_NAME) ?? SIMPLE_CLOCK;\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ClockAPI } from \"./clock/index.js\";\n/** Entrypoint for clock API */\nexport const clock = ClockAPI.getInstance();\n//# sourceMappingURL=clock-api.js.map","import { SeverityNumber } from \"@opentelemetry/api-logs\";\nimport { iconStringForSeverity } from \"../icons.js\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes.js\";\nimport { flattenAttributes } from \"../utils/flattenAttributes.js\";\nimport { clock } from \"../clock-api.js\";\nexport const logLevels = [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\nexport class OtelTaskLogger {\n    _config;\n    _level;\n    constructor(_config) {\n        this._config = _config;\n        this._level = logLevels.indexOf(_config.level);\n    }\n    debug(message, properties) {\n        if (this._level < 4)\n            return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n        this.#emitLog(message, this.#getTimestampInHrTime(), \"debug\", SeverityNumber.DEBUG, properties);\n    }\n    log(message, properties) {\n        if (this._level < 3)\n            return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n        this.#emitLog(message, this.#getTimestampInHrTime(), \"log\", SeverityNumber.INFO, properties);\n    }\n    info(message, properties) {\n        if (this._level < 3)\n            return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n        this.#emitLog(message, this.#getTimestampInHrTime(), \"info\", SeverityNumber.INFO, properties);\n    }\n    warn(message, properties) {\n        if (this._level < 2)\n            return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n        this.#emitLog(message, this.#getTimestampInHrTime(), \"warn\", SeverityNumber.WARN, properties);\n    }\n    error(message, properties) {\n        if (this._level < 1)\n            return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n        this.#emitLog(message, this.#getTimestampInHrTime(), \"error\", SeverityNumber.ERROR, properties);\n    }\n    #emitLog(message, timestamp, severityText, severityNumber, properties) {\n        let attributes = { ...flattenAttributes(safeJsonProcess(properties)) };\n        const icon = iconStringForSeverity(severityNumber);\n        if (icon !== undefined) {\n            attributes[SemanticInternalAttributes.STYLE_ICON] = icon;\n        }\n        this._config.logger.emit({\n            severityNumber,\n            severityText,\n            body: message,\n            attributes,\n            timestamp,\n        });\n    }\n    trace(name, fn, options) {\n        return this._config.tracer.startActiveSpan(name, fn, options);\n    }\n    startSpan(name, options) {\n        return this._config.tracer.startSpan(name, options);\n    }\n    #getTimestampInHrTime() {\n        return clock.preciseNow();\n    }\n}\nexport class NoopTaskLogger {\n    debug() { }\n    log() { }\n    info() { }\n    warn() { }\n    error() { }\n    trace(name, fn) {\n        return fn({});\n    }\n    startSpan() {\n        return {};\n    }\n}\nfunction safeJsonProcess(value) {\n    try {\n        return JSON.parse(JSON.stringify(value, jsonErrorReplacer));\n    }\n    catch {\n        return value;\n    }\n}\nfunction jsonErrorReplacer(key, value) {\n    if (value instanceof Error) {\n        return {\n            name: value.name,\n            message: value.message,\n            stack: value.stack,\n        };\n    }\n    return value;\n}\n//# sourceMappingURL=taskLogger.js.map","import { NoopTaskLogger } from \"./taskLogger.js\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals.js\";\nconst API_NAME = \"logger\";\nconst NOOP_TASK_LOGGER = new NoopTaskLogger();\nexport class LoggerAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new LoggerAPI();\n        }\n        return this._instance;\n    }\n    disable() {\n        unregisterGlobal(API_NAME);\n    }\n    setGlobalTaskLogger(taskLogger) {\n        return registerGlobal(API_NAME, taskLogger);\n    }\n    debug(message, metadata) {\n        this.#getTaskLogger().debug(message, metadata);\n    }\n    log(message, metadata) {\n        this.#getTaskLogger().log(message, metadata);\n    }\n    info(message, metadata) {\n        this.#getTaskLogger().info(message, metadata);\n    }\n    warn(message, metadata) {\n        this.#getTaskLogger().warn(message, metadata);\n    }\n    error(message, metadata) {\n        this.#getTaskLogger().error(message, metadata);\n    }\n    trace(name, fn, options) {\n        return this.#getTaskLogger().trace(name, fn, options);\n    }\n    startSpan(name, options) {\n        return this.#getTaskLogger().startSpan(name, options);\n    }\n    #getTaskLogger() {\n        return getGlobal(API_NAME) ?? NOOP_TASK_LOGGER;\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { LoggerAPI } from \"./logger/index.js\";\n/** Entrypoint for logger API */\nexport const logger = LoggerAPI.getInstance();\n//# sourceMappingURL=logger-api.js.map","import { TaskRunErrorCodes, } from \"../schemas/index.js\";\nexport class NoopRuntimeManager {\n    disable() {\n        // do nothing\n    }\n    waitForDuration(ms) {\n        return Promise.resolve();\n    }\n    waitUntil(date) {\n        return Promise.resolve();\n    }\n    waitForTask(params) {\n        return Promise.resolve({\n            ok: false,\n            id: params.id,\n            error: {\n                type: \"INTERNAL_ERROR\",\n                code: TaskRunErrorCodes.CONFIGURED_INCORRECTLY,\n            },\n        });\n    }\n    waitForBatch(params) {\n        return Promise.resolve({\n            id: params.id,\n            items: [],\n        });\n    }\n}\n//# sourceMappingURL=noopRuntimeManager.js.map","export class NoopUsageManager {\n    disable() {\n        // Noop\n    }\n    start() {\n        return {\n            sample: () => ({ cpuTime: 0, wallTime: 0 }),\n        };\n    }\n    stop(measurement) {\n        return measurement.sample();\n    }\n    pauseAsync(cb) {\n        return cb();\n    }\n    sample() {\n        return undefined;\n    }\n}\n//# sourceMappingURL=noopUsageManager.js.map","const API_NAME = \"usage\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals.js\";\nimport { NoopUsageManager } from \"./noopUsageManager.js\";\nconst NOOP_USAGE_MANAGER = new NoopUsageManager();\nexport class UsageAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new UsageAPI();\n        }\n        return this._instance;\n    }\n    setGlobalUsageManager(manager) {\n        return registerGlobal(API_NAME, manager);\n    }\n    disable() {\n        this.#getUsageManager().disable();\n        unregisterGlobal(API_NAME);\n    }\n    start() {\n        return this.#getUsageManager().start();\n    }\n    stop(measurement) {\n        return this.#getUsageManager().stop(measurement);\n    }\n    pauseAsync(cb) {\n        return this.#getUsageManager().pauseAsync(cb);\n    }\n    sample() {\n        return this.#getUsageManager().sample();\n    }\n    #getUsageManager() {\n        return getGlobal(API_NAME) ?? NOOP_USAGE_MANAGER;\n    }\n}\n//# sourceMappingURL=api.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { UsageAPI } from \"./usage/api.js\";\n/** Entrypoint for usage API */\nexport const usage = UsageAPI.getInstance();\n//# sourceMappingURL=usage-api.js.map","const API_NAME = \"runtime\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals.js\";\nimport { NoopRuntimeManager } from \"./noopRuntimeManager.js\";\nimport { usage } from \"../usage-api.js\";\nconst NOOP_RUNTIME_MANAGER = new NoopRuntimeManager();\n/**\n * All state must be inside the RuntimeManager, do NOT store it on this class.\n * This is because of the \"dual package hazard\", this can be bundled multiple times.\n */\nexport class RuntimeAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new RuntimeAPI();\n        }\n        return this._instance;\n    }\n    waitForDuration(ms) {\n        return usage.pauseAsync(() => this.#getRuntimeManager().waitForDuration(ms));\n    }\n    waitUntil(date) {\n        return usage.pauseAsync(() => this.#getRuntimeManager().waitUntil(date));\n    }\n    waitForTask(params) {\n        return usage.pauseAsync(() => this.#getRuntimeManager().waitForTask(params));\n    }\n    waitForBatch(params) {\n        return usage.pauseAsync(() => this.#getRuntimeManager().waitForBatch(params));\n    }\n    setGlobalRuntimeManager(runtimeManager) {\n        return registerGlobal(API_NAME, runtimeManager);\n    }\n    disable() {\n        this.#getRuntimeManager().disable();\n        unregisterGlobal(API_NAME);\n    }\n    #getRuntimeManager() {\n        return getGlobal(API_NAME) ?? NOOP_RUNTIME_MANAGER;\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { RuntimeAPI } from \"./runtime/index.js\";\n/** Entrypoint for runtime API */\nexport const runtime = RuntimeAPI.getInstance();\n//# sourceMappingURL=runtime-api.js.map","export class NoopRunMetadataManager {\n    append(key, value) {\n        throw new Error(\"Method not implemented.\");\n    }\n    remove(key, value) {\n        throw new Error(\"Method not implemented.\");\n    }\n    increment(key, value) {\n        throw new Error(\"Method not implemented.\");\n    }\n    decrement(key, value) {\n        throw new Error(\"Method not implemented.\");\n    }\n    stream(key, value) {\n        throw new Error(\"Method not implemented.\");\n    }\n    fetchStream(key, signal) {\n        throw new Error(\"Method not implemented.\");\n    }\n    flush(requestOptions) {\n        throw new Error(\"Method not implemented.\");\n    }\n    refresh(requestOptions) {\n        throw new Error(\"Method not implemented.\");\n    }\n    enterWithMetadata(metadata) { }\n    current() {\n        throw new Error(\"Method not implemented.\");\n    }\n    getKey(key) {\n        throw new Error(\"Method not implemented.\");\n    }\n    set(key, value) {\n        throw new Error(\"Method not implemented.\");\n    }\n    del(key) {\n        throw new Error(\"Method not implemented.\");\n    }\n    update(metadata) {\n        throw new Error(\"Method not implemented.\");\n    }\n    get parent() {\n        return {\n            append: () => this.parent,\n            set: () => this.parent,\n            del: () => this.parent,\n            increment: () => this.parent,\n            decrement: () => this.parent,\n            remove: () => this.parent,\n            stream: () => Promise.resolve({\n                [Symbol.asyncIterator]: () => ({\n                    next: () => Promise.resolve({ done: true, value: undefined }),\n                }),\n            }),\n            update: () => this.parent,\n        };\n    }\n    get root() {\n        return {\n            append: () => this.root,\n            set: () => this.root,\n            del: () => this.root,\n            increment: () => this.root,\n            decrement: () => this.root,\n            remove: () => this.root,\n            stream: () => Promise.resolve({\n                [Symbol.asyncIterator]: () => ({\n                    next: () => Promise.resolve({ done: true, value: undefined }),\n                }),\n            }),\n            update: () => this.root,\n        };\n    }\n}\n//# sourceMappingURL=noopManager.js.map","import { getGlobal, registerGlobal } from \"../utils/globals.js\";\nimport { NoopRunMetadataManager } from \"./noopManager.js\";\nconst API_NAME = \"run-metadata\";\nconst NOOP_MANAGER = new NoopRunMetadataManager();\nexport class RunMetadataAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new RunMetadataAPI();\n        }\n        return this._instance;\n    }\n    setGlobalManager(manager) {\n        return registerGlobal(API_NAME, manager);\n    }\n    #getManager() {\n        return getGlobal(API_NAME) ?? NOOP_MANAGER;\n    }\n    enterWithMetadata(metadata) {\n        this.#getManager().enterWithMetadata(metadata);\n    }\n    current() {\n        return this.#getManager().current();\n    }\n    getKey(key) {\n        return this.#getManager().getKey(key);\n    }\n    set(key, value) {\n        this.#getManager().set(key, value);\n        return this;\n    }\n    del(key) {\n        this.#getManager().del(key);\n        return this;\n    }\n    increment(key, value) {\n        this.#getManager().increment(key, value);\n        return this;\n    }\n    decrement(key, value) {\n        this.#getManager().decrement(key, value);\n        return this;\n    }\n    append(key, value) {\n        this.#getManager().append(key, value);\n        return this;\n    }\n    remove(key, value) {\n        this.#getManager().remove(key, value);\n        return this;\n    }\n    update(metadata) {\n        this.#getManager().update(metadata);\n        return this;\n    }\n    stream(key, value, signal) {\n        return this.#getManager().stream(key, value, signal);\n    }\n    fetchStream(key, signal) {\n        return this.#getManager().fetchStream(key, signal);\n    }\n    flush(requestOptions) {\n        return this.#getManager().flush(requestOptions);\n    }\n    refresh(requestOptions) {\n        return this.#getManager().refresh(requestOptions);\n    }\n    get parent() {\n        return this.#getManager().parent;\n    }\n    get root() {\n        return this.#getManager().root;\n    }\n}\n//# sourceMappingURL=index.js.map","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { JSONHeroPath } from \"@jsonhero/path\";\nimport { dequal } from \"dequal\";\nexport function applyMetadataOperations(currentMetadata, operations) {\n    const unappliedOperations = [];\n    // Start with a mutable copy of the current metadata\n    let newMetadata = structuredClone(currentMetadata);\n    for (const operation of Array.isArray(operations) ? operations : [operations]) {\n        switch (operation.type) {\n            case \"set\": {\n                if (operation.key.startsWith(\"$.\")) {\n                    const path = new JSONHeroPath(operation.key);\n                    path.set(newMetadata, operation.value);\n                }\n                else {\n                    // Set the value directly\n                    newMetadata[operation.key] = operation.value;\n                }\n                break;\n            }\n            case \"delete\": {\n                // Safely delete the key if it exists\n                if (operation.key in newMetadata) {\n                    delete newMetadata[operation.key];\n                }\n                break;\n            }\n            case \"append\": {\n                if (operation.key.startsWith(\"$.\")) {\n                    const path = new JSONHeroPath(operation.key);\n                    const currentValue = path.first(newMetadata);\n                    if (currentValue === undefined) {\n                        // Initialize as array with single item\n                        path.set(newMetadata, [operation.value]);\n                    }\n                    else if (Array.isArray(currentValue)) {\n                        // Append to existing array\n                        path.set(newMetadata, [...currentValue, operation.value]);\n                    }\n                    else {\n                        // Convert to array if not already\n                        path.set(newMetadata, [currentValue, operation.value]);\n                    }\n                }\n                else {\n                    // Ensure the value at key is an array or initialize as an array\n                    const existingValue = newMetadata[operation.key];\n                    if (Array.isArray(existingValue)) {\n                        existingValue.push(operation.value);\n                    }\n                    else if (existingValue === undefined) {\n                        newMetadata[operation.key] = [operation.value];\n                    }\n                    else {\n                        // Convert to array if not already\n                        newMetadata[operation.key] = [existingValue, operation.value];\n                    }\n                }\n                break;\n            }\n            case \"remove\": {\n                if (operation.key.startsWith(\"$.\")) {\n                    const path = new JSONHeroPath(operation.key);\n                    const currentValue = path.first(newMetadata);\n                    if (Array.isArray(currentValue)) {\n                        // Remove the value from array using deep equality check\n                        const newArray = currentValue.filter((item) => !dequal(item, operation.value));\n                        path.set(newMetadata, newArray);\n                    }\n                    else {\n                        unappliedOperations.push(operation);\n                    }\n                }\n                else {\n                    // Remove matching values if the key points to an array\n                    const existingValue = newMetadata[operation.key];\n                    if (Array.isArray(existingValue)) {\n                        newMetadata[operation.key] = existingValue.filter((item) => !dequal(item, operation.value));\n                    }\n                    else {\n                        unappliedOperations.push(operation);\n                    }\n                }\n                break;\n            }\n            case \"increment\": {\n                let currentValue = operation.key.startsWith(\"$.\")\n                    ? new JSONHeroPath(operation.key).first(newMetadata)\n                    : newMetadata[operation.key];\n                const newValue = (typeof currentValue === \"number\" ? currentValue : 0) + operation.value;\n                if (operation.key.startsWith(\"$.\")) {\n                    new JSONHeroPath(operation.key).set(newMetadata, newValue);\n                }\n                else {\n                    newMetadata[operation.key] = newValue;\n                }\n                break;\n            }\n            case \"update\": {\n                // Update the metadata object with the new object\n                newMetadata = operation.value;\n                break;\n            }\n            default: {\n                // Log unsupported operation type\n                unappliedOperations.push(operation);\n                break;\n            }\n        }\n    }\n    return { newMetadata, unappliedOperations };\n}\n//# sourceMappingURL=operations.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { RunMetadataAPI } from \"./runMetadata/index.js\";\nexport const runMetadata = RunMetadataAPI.getInstance();\nexport * from \"./runMetadata/types.js\";\nexport * from \"./runMetadata/operations.js\";\n//# sourceMappingURL=run-metadata-api.js.map","import { getGlobal, registerGlobal } from \"../utils/globals.js\";\nconst API_NAME = \"wait-until\";\nclass NoopManager {\n    register(promise) {\n        // noop\n    }\n    blockUntilSettled(timeout) {\n        return Promise.resolve();\n    }\n    requiresResolving() {\n        return false;\n    }\n}\nconst NOOP_MANAGER = new NoopManager();\nexport class WaitUntilAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new WaitUntilAPI();\n        }\n        return this._instance;\n    }\n    setGlobalManager(manager) {\n        return registerGlobal(API_NAME, manager);\n    }\n    #getManager() {\n        return getGlobal(API_NAME) ?? NOOP_MANAGER;\n    }\n    register(promise) {\n        return this.#getManager().register(promise);\n    }\n    blockUntilSettled(timeout) {\n        return this.#getManager().blockUntilSettled(timeout);\n    }\n    requiresResolving() {\n        return this.#getManager().requiresResolving();\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { WaitUntilAPI } from \"./waitUntil/index.js\";\nexport const waitUntil = WaitUntilAPI.getInstance();\n//# sourceMappingURL=wait-until-api.js.map","import { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals.js\";\nconst API_NAME = \"timeout\";\nclass NoopTimeoutManager {\n    abortAfterTimeout(timeoutInSeconds) {\n        return new AbortController().signal;\n    }\n}\nconst NOOP_TIMEOUT_MANAGER = new NoopTimeoutManager();\nexport class TimeoutAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new TimeoutAPI();\n        }\n        return this._instance;\n    }\n    get signal() {\n        return this.#getManagerManager().signal;\n    }\n    abortAfterTimeout(timeoutInSeconds) {\n        return this.#getManagerManager().abortAfterTimeout(timeoutInSeconds);\n    }\n    setGlobalManager(manager) {\n        return registerGlobal(API_NAME, manager);\n    }\n    disable() {\n        unregisterGlobal(API_NAME);\n    }\n    #getManagerManager() {\n        return getGlobal(API_NAME) ?? NOOP_TIMEOUT_MANAGER;\n    }\n}\n//# sourceMappingURL=api.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TimeoutAPI } from \"./timeout/api.js\";\n/** Entrypoint for timeout API */\nexport const timeout = TimeoutAPI.getInstance();\n//# sourceMappingURL=timeout-api.js.map","import { getEnvVar } from \"../utils/getEnv.js\";\nexport class StandardRunTimelineMetricsManager {\n    _metrics = [];\n    registerMetric(metric) {\n        this._metrics.push(metric);\n    }\n    getMetrics() {\n        return this._metrics;\n    }\n    registerMetricsFromExecution(metrics) {\n        if (metrics) {\n            metrics.forEach((metric) => {\n                this.registerMetric({\n                    name: `trigger.dev/${metric.name}`,\n                    event: metric.event,\n                    timestamp: metric.timestamp,\n                    attributes: {\n                        duration: metric.duration,\n                    },\n                });\n            });\n        }\n    }\n    seedMetricsFromEnvironment() {\n        const forkStartTime = getEnvVar(\"TRIGGER_PROCESS_FORK_START_TIME\");\n        if (typeof forkStartTime === \"string\") {\n            const forkStartTimeMs = parseInt(forkStartTime, 10);\n            this.registerMetric({\n                name: \"trigger.dev/start\",\n                event: \"fork\",\n                attributes: {\n                    duration: Date.now() - forkStartTimeMs,\n                },\n                timestamp: forkStartTimeMs,\n            });\n        }\n    }\n}\nexport class NoopRunTimelineMetricsManager {\n    registerMetric(metric) {\n        // Do nothing\n    }\n    getMetrics() {\n        return [];\n    }\n}\n//# sourceMappingURL=runTimelineMetricsManager.js.map","import { getGlobal, registerGlobal } from \"../utils/globals.js\";\nimport { NoopRunTimelineMetricsManager } from \"./runTimelineMetricsManager.js\";\nimport { flattenAttributes } from \"../utils/flattenAttributes.js\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes.js\";\nconst API_NAME = \"run-timeline-metrics\";\nconst NOOP_MANAGER = new NoopRunTimelineMetricsManager();\nexport class RunTimelineMetricsAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new RunTimelineMetricsAPI();\n        }\n        return this._instance;\n    }\n    registerMetric(metric) {\n        this.#getManager().registerMetric(metric);\n    }\n    getMetrics() {\n        return this.#getManager().getMetrics();\n    }\n    /**\n     * Measures the execution time of an async function and registers it as a metric\n     * @param metricName The name of the metric\n     * @param eventName The event name\n     * @param attributesOrCallback Optional attributes or the callback function\n     * @param callbackFn The async function to measure (if attributes were provided)\n     * @returns The result of the callback function\n     */\n    async measureMetric(metricName, eventName, attributesOrCallback, callbackFn) {\n        // Handle overloaded function signature\n        let attributes = {};\n        let callback;\n        if (typeof attributesOrCallback === \"function\") {\n            callback = attributesOrCallback;\n        }\n        else {\n            attributes = attributesOrCallback || {};\n            if (!callbackFn) {\n                throw new Error(\"Callback function is required when attributes are provided\");\n            }\n            callback = callbackFn;\n        }\n        // Record start time\n        const startTime = Date.now();\n        try {\n            // Execute the callback\n            const result = await callback();\n            // Calculate duration\n            const duration = Date.now() - startTime;\n            // Register the metric\n            this.registerMetric({\n                name: metricName,\n                event: eventName,\n                attributes: {\n                    ...attributes,\n                    duration,\n                },\n                timestamp: startTime,\n            });\n            return result;\n        }\n        catch (error) {\n            // Register the metric even if there's an error, but mark it as failed\n            const duration = Date.now() - startTime;\n            this.registerMetric({\n                name: metricName,\n                event: eventName,\n                attributes: {\n                    ...attributes,\n                    duration,\n                    error: error instanceof Error ? error.message : String(error),\n                    status: \"failed\",\n                },\n                timestamp: startTime,\n            });\n            // Re-throw the error\n            throw error;\n        }\n    }\n    convertMetricsToSpanEvents() {\n        const metrics = this.getMetrics();\n        const spanEvents = metrics.map((metric) => {\n            return {\n                name: metric.name,\n                startTime: metric.timestamp,\n                attributes: {\n                    ...metric.attributes,\n                    event: metric.event,\n                },\n            };\n        });\n        return spanEvents;\n    }\n    convertMetricsToSpanAttributes() {\n        const metrics = this.getMetrics();\n        if (metrics.length === 0) {\n            return {};\n        }\n        // Group metrics by name\n        const metricsByName = metrics.reduce((acc, metric) => {\n            if (!acc[metric.name]) {\n                acc[metric.name] = [];\n            }\n            acc[metric.name].push(metric);\n            return acc;\n        }, {});\n        // Process each metric type\n        const reducedMetrics = metrics.reduce((acc, metric) => {\n            acc[metric.event] = {\n                name: metric.name,\n                timestamp: metric.timestamp,\n                event: metric.event,\n                ...flattenAttributes(metric.attributes, \"attributes\"),\n            };\n            return acc;\n        }, {});\n        const metricEventRollups = {};\n        // Calculate duration for each metric type\n        // Calculate duration for each metric type\n        for (const [metricName, metricEvents] of Object.entries(metricsByName)) {\n            // Skip if there are no events for this metric\n            if (metricEvents.length === 0)\n                continue;\n            // Sort events by timestamp\n            const sortedEvents = [...metricEvents].sort((a, b) => a.timestamp - b.timestamp);\n            // Get first event timestamp (we know it exists because we checked length above)\n            const firstTimestamp = sortedEvents[0].timestamp;\n            // Get last event (we know it exists because we checked length above)\n            const lastEvent = sortedEvents[sortedEvents.length - 1];\n            // Calculate total duration: from first event to (last event + its duration)\n            // Use optional chaining and nullish coalescing for safety\n            const lastEventDuration = lastEvent.attributes?.duration ?? 0;\n            const lastEventEndTime = lastEvent.timestamp + lastEventDuration;\n            // Store the total duration for this metric type\n            const duration = lastEventEndTime - firstTimestamp;\n            const timestamp = firstTimestamp;\n            metricEventRollups[metricName] = {\n                name: metricName,\n                duration,\n                timestamp,\n            };\n        }\n        return {\n            ...flattenAttributes(reducedMetrics, SemanticInternalAttributes.METRIC_EVENTS),\n            ...flattenAttributes(metricEventRollups, SemanticInternalAttributes.METRIC_EVENTS),\n        };\n    }\n    setGlobalManager(manager) {\n        return registerGlobal(API_NAME, manager);\n    }\n    #getManager() {\n        return getGlobal(API_NAME) ?? NOOP_MANAGER;\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { RunTimelineMetricsAPI } from \"./runTimelineMetrics/index.js\";\nexport const runTimelineMetrics = RunTimelineMetricsAPI.getInstance();\n//# sourceMappingURL=run-timeline-metrics-api.js.map","export class NoopTaskCatalog {\n    registerTaskMetadata(task) {\n        // noop\n    }\n    registerTaskFileMetadata(id, metadata) {\n        // noop\n    }\n    updateTaskMetadata(id, updates) {\n        // noop\n    }\n    listTaskManifests() {\n        return [];\n    }\n    getTaskManifest(id) {\n        return undefined;\n    }\n    getTask(id) {\n        return undefined;\n    }\n    taskExists(id) {\n        return false;\n    }\n    disable() {\n        // noop\n    }\n}\n//# sourceMappingURL=noopTaskCatalog.js.map","const API_NAME = \"task-catalog\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals.js\";\nimport { NoopTaskCatalog } from \"./noopTaskCatalog.js\";\nconst NOOP_TASK_CATALOG = new NoopTaskCatalog();\nexport class TaskCatalogAPI {\n    static _instance;\n    constructor() { }\n    static getInstance() {\n        if (!this._instance) {\n            this._instance = new TaskCatalogAPI();\n        }\n        return this._instance;\n    }\n    setGlobalTaskCatalog(taskCatalog) {\n        return registerGlobal(API_NAME, taskCatalog);\n    }\n    disable() {\n        unregisterGlobal(API_NAME);\n    }\n    registerTaskMetadata(task) {\n        this.#getCatalog().registerTaskMetadata(task);\n    }\n    updateTaskMetadata(id, updates) {\n        this.#getCatalog().updateTaskMetadata(id, updates);\n    }\n    registerTaskFileMetadata(id, metadata) {\n        this.#getCatalog().registerTaskFileMetadata(id, metadata);\n    }\n    listTaskManifests() {\n        return this.#getCatalog().listTaskManifests();\n    }\n    getTaskManifest(id) {\n        return this.#getCatalog().getTaskManifest(id);\n    }\n    getTask(id) {\n        return this.#getCatalog().getTask(id);\n    }\n    taskExists(id) {\n        return this.#getCatalog().taskExists(id);\n    }\n    #getCatalog() {\n        return getGlobal(API_NAME) ?? NOOP_TASK_CATALOG;\n    }\n}\n//# sourceMappingURL=index.js.map","// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskCatalogAPI } from \"./task-catalog/index.js\";\n/** Entrypoint for runtime API */\nexport const taskCatalog = TaskCatalogAPI.getInstance();\n//# sourceMappingURL=task-catalog-api.js.map","export class SubtaskUnwrapError extends Error {\n    taskId;\n    runId;\n    cause;\n    constructor(taskId, runId, subtaskError) {\n        if (subtaskError instanceof Error) {\n            super(`Error in ${taskId}: ${subtaskError.message}`);\n            this.cause = subtaskError;\n            this.name = \"SubtaskUnwrapError\";\n        }\n        else {\n            super(`Error in ${taskId}`);\n            this.name = \"SubtaskUnwrapError\";\n            this.cause = subtaskError;\n        }\n        this.taskId = taskId;\n        this.runId = runId;\n    }\n}\nexport class TaskRunPromise extends Promise {\n    taskId;\n    constructor(executor, taskId) {\n        super(executor);\n        this.taskId = taskId;\n    }\n    unwrap() {\n        return this.then((result) => {\n            if (result.ok) {\n                return result.output;\n            }\n            else {\n                throw new SubtaskUnwrapError(this.taskId, result.id, result.error);\n            }\n        });\n    }\n}\n//# sourceMappingURL=tasks.js.map","export * from \"./utils.js\";\nexport * from \"./tasks.js\";\nexport * from \"./idempotencyKeys.js\";\nexport * from \"./tools.js\";\n//# sourceMappingURL=index.js.map","import { taskContext } from \"./task-context-api.js\";\nexport function isIdempotencyKey(value) {\n    // Cannot check the brand at runtime because it doesn't exist (it's a TypeScript-only construct)\n    return typeof value === \"string\" && value.length === 64;\n}\nexport async function makeIdempotencyKey(idempotencyKey) {\n    if (!idempotencyKey) {\n        return;\n    }\n    if (isIdempotencyKey(idempotencyKey)) {\n        return idempotencyKey;\n    }\n    return await createIdempotencyKey(idempotencyKey, { scope: \"global\" });\n}\n/**\n * Creates a deterministic idempotency key based on the provided key material.\n *\n * If running inside a task, the task run ID is automatically included in the key material, giving you a unique key per task run.\n * This ensures that a given child task is only triggered once per task run, even if the parent task is retried.\n *\n * @param {string | string[]} key The key material to create the idempotency key from.\n * @param {object} [options] Additional options.\n * @param {\"run\" | \"attempt\" | \"global\"} [options.scope=\"run\"] The scope of the idempotency key.\n *\n * @returns {Promise<IdempotencyKey>} The idempotency key as a branded string.\n *\n * @example\n *\n * ```typescript\n * import { idempotencyKeys, task } from \"@trigger.dev/sdk/v3\";\n *\n * export const myTask = task({\n *  id: \"my-task\",\n *  run: async (payload: any) => {\n *   const idempotencyKey = await idempotencyKeys.create(\"my-task-key\");\n *\n *   // Use the idempotency key when triggering child tasks\n *   await childTask.triggerAndWait(payload, { idempotencyKey });\n *  }\n * });\n * ```\n *\n * You can also use the `scope` parameter to create a key that is unique per task run, task run attempts (retries of the same run), or globally:\n *\n * ```typescript\n *  await idempotencyKeys.create(\"my-task-key\", { scope: \"attempt\" }); // Creates a key that is unique per task run attempt\n *  await idempotencyKeys.create(\"my-task-key\", { scope: \"global\" }); // Skips including the task run ID\n * ```\n */\nexport async function createIdempotencyKey(key, options) {\n    const idempotencyKey = await generateIdempotencyKey([...(Array.isArray(key) ? key : [key])].concat(injectScope(options?.scope ?? \"run\")));\n    return idempotencyKey;\n}\nfunction injectScope(scope) {\n    switch (scope) {\n        case \"run\": {\n            if (taskContext?.ctx) {\n                return [taskContext.ctx.run.id];\n            }\n            break;\n        }\n        case \"attempt\": {\n            if (taskContext?.ctx) {\n                return [taskContext.ctx.attempt.id];\n            }\n            break;\n        }\n    }\n    return [];\n}\nasync function generateIdempotencyKey(keyMaterial) {\n    const hash = await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(keyMaterial.join(\"-\")));\n    // Return a hex string, using cross-runtime compatible methods\n    return Array.from(new Uint8Array(hash))\n        .map((byte) => byte.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n}\n//# sourceMappingURL=idempotencyKeys.js.map","import humanizeDuration from \"humanize-duration\";\nfunction dateDifference(date1, date2) {\n    return Math.abs(date1.getTime() - date2.getTime());\n}\nexport function formatDuration(start, end, options) {\n    if (!start || !end) {\n        return \"\";\n    }\n    return formatDurationMilliseconds(dateDifference(start, end), options);\n}\nexport function nanosecondsToMilliseconds(nanoseconds) {\n    return nanoseconds / 1_000_000;\n}\nexport function millisecondsToNanoseconds(milliseconds) {\n    return milliseconds * 1_000_000;\n}\nexport function formatDurationNanoseconds(nanoseconds, options) {\n    return formatDurationMilliseconds(nanosecondsToMilliseconds(nanoseconds), options);\n}\nconst aboveOneSecondUnits = [\"d\", \"h\", \"m\", \"s\"];\nconst belowOneSecondUnits = [\"ms\"];\nexport function formatDurationMilliseconds(milliseconds, options) {\n    let duration = humanizeDuration(milliseconds, {\n        units: options?.units\n            ? options.units\n            : milliseconds < 1000\n                ? belowOneSecondUnits\n                : aboveOneSecondUnits,\n        maxDecimalPoints: options?.maxDecimalPoints ?? 1,\n        largest: 2,\n    });\n    if (!options) {\n        return duration;\n    }\n    switch (options.style) {\n        case \"short\":\n            duration = duration.replace(\" milliseconds\", \"ms\");\n            duration = duration.replace(\" millisecond\", \"ms\");\n            duration = duration.replace(\" seconds\", \"s\");\n            duration = duration.replace(\" second\", \"s\");\n            duration = duration.replace(\" minutes\", \"m\");\n            duration = duration.replace(\" minute\", \"m\");\n            duration = duration.replace(\" hours\", \"h\");\n            duration = duration.replace(\" hour\", \"h\");\n            duration = duration.replace(\" days\", \"d\");\n            duration = duration.replace(\" day\", \"d\");\n            duration = duration.replace(\" weeks\", \"w\");\n            duration = duration.replace(\" week\", \"w\");\n            duration = duration.replace(\" months\", \"mo\");\n            duration = duration.replace(\" month\", \"mo\");\n            duration = duration.replace(\" years\", \"y\");\n            duration = duration.replace(\" year\", \"y\");\n    }\n    return duration;\n}\nexport function formatDurationInDays(milliseconds) {\n    let duration = humanizeDuration(milliseconds, {\n        maxDecimalPoints: 0,\n        largest: 2,\n        units: [\"d\"],\n    });\n    return duration;\n}\n//# sourceMappingURL=durations.js.map","// EventFilter is a recursive type, where the keys are strings and the values are an array of strings, numbers, booleans, or objects.\n// If the values of the array are strings, numbers, or booleans, than we are matching against the value of the payload.\n// If the values of the array are objects, then we are doing content filtering\n// An example would be [{ $endsWith: \".png\" }, { $startsWith: \"images/\" } ]\nexport function eventFilterMatches(payload, filter) {\n    if (payload === undefined || payload === null) {\n        if (Object.entries(filter).length === 0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    for (const [patternKey, patternValue] of Object.entries(filter)) {\n        const payloadValue = payload[patternKey];\n        if (Array.isArray(patternValue)) {\n            if (patternValue.length === 0) {\n                continue;\n            }\n            // Check to see if all the items in the array are a string\n            if (patternValue.every((item) => typeof item === \"string\")) {\n                if (patternValue.includes(payloadValue)) {\n                    continue;\n                }\n                return false;\n            }\n            // Check to see if all the items in the array are a number\n            if (patternValue.every((item) => typeof item === \"number\")) {\n                if (patternValue.includes(payloadValue)) {\n                    continue;\n                }\n                return false;\n            }\n            // Check to see if all the items in the array are a boolean\n            if (patternValue.every((item) => typeof item === \"boolean\")) {\n                if (patternValue.includes(payloadValue)) {\n                    continue;\n                }\n                return false;\n            }\n            // Now we know that all the items in the array are objects\n            const objectArray = patternValue;\n            if (!contentFiltersMatches(payloadValue, objectArray)) {\n                return false;\n            }\n            continue;\n        }\n        else if (typeof patternValue === \"object\") {\n            if (Array.isArray(payloadValue)) {\n                if (!payloadValue.some((item) => eventFilterMatches(item, patternValue))) {\n                    return false;\n                }\n            }\n            else {\n                if (!eventFilterMatches(payloadValue, patternValue)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction contentFiltersMatches(actualValue, contentFilters) {\n    for (const contentFilter of contentFilters) {\n        if (typeof contentFilter === \"object\") {\n            if (!contentFilterMatches(actualValue, contentFilter)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction contentFilterMatches(actualValue, contentFilter) {\n    if (\"$endsWith\" in contentFilter) {\n        if (typeof actualValue !== \"string\") {\n            return false;\n        }\n        return actualValue.endsWith(contentFilter.$endsWith);\n    }\n    if (\"$startsWith\" in contentFilter) {\n        if (typeof actualValue !== \"string\") {\n            return false;\n        }\n        return actualValue.startsWith(contentFilter.$startsWith);\n    }\n    if (\"$anythingBut\" in contentFilter) {\n        if (Array.isArray(contentFilter.$anythingBut)) {\n            if (contentFilter.$anythingBut.includes(actualValue)) {\n                return false;\n            }\n        }\n        if (contentFilter.$anythingBut === actualValue) {\n            return false;\n        }\n        return true;\n    }\n    if (\"$exists\" in contentFilter) {\n        if (contentFilter.$exists) {\n            return actualValue !== undefined;\n        }\n        return actualValue === undefined;\n    }\n    if (\"$gt\" in contentFilter) {\n        if (typeof actualValue !== \"number\") {\n            return false;\n        }\n        return actualValue > contentFilter.$gt;\n    }\n    if (\"$lt\" in contentFilter) {\n        if (typeof actualValue !== \"number\") {\n            return false;\n        }\n        return actualValue < contentFilter.$lt;\n    }\n    if (\"$gte\" in contentFilter) {\n        if (typeof actualValue !== \"number\") {\n            return false;\n        }\n        return actualValue >= contentFilter.$gte;\n    }\n    if (\"$lte\" in contentFilter) {\n        if (typeof actualValue !== \"number\") {\n            return false;\n        }\n        return actualValue <= contentFilter.$lte;\n    }\n    if (\"$between\" in contentFilter) {\n        if (typeof actualValue !== \"number\") {\n            return false;\n        }\n        return actualValue >= contentFilter.$between[0] && actualValue <= contentFilter.$between[1];\n    }\n    if (\"$includes\" in contentFilter) {\n        if (Array.isArray(actualValue)) {\n            return actualValue.includes(contentFilter.$includes);\n        }\n        return false;\n    }\n    // Use localCompare\n    if (\"$ignoreCaseEquals\" in contentFilter) {\n        if (typeof actualValue !== \"string\") {\n            return false;\n        }\n        return (actualValue.localeCompare(contentFilter.$ignoreCaseEquals, undefined, {\n            sensitivity: \"accent\",\n        }) === 0);\n    }\n    if (\"$isNull\" in contentFilter) {\n        if (contentFilter.$isNull) {\n            return actualValue === null;\n        }\n        return actualValue !== null;\n    }\n    if (\"$not\" in contentFilter) {\n        if (Array.isArray(actualValue)) {\n            return !actualValue.includes(contentFilter.$not);\n        }\n        else if (typeof actualValue === \"number\" ||\n            typeof actualValue === \"boolean\" ||\n            typeof actualValue === \"string\") {\n            return actualValue !== contentFilter.$not;\n        }\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=eventFilterMatches.js.map","export * from \"./apiClient/index.js\";\nexport * from \"./apiClient/types.js\";\nexport * from \"./apiClient/pagination.js\";\nexport * from \"./apiClient/errors.js\";\nexport * from \"./clock-api.js\";\nexport * from \"./errors.js\";\nexport * from \"./limits.js\";\nexport * from \"./logger-api.js\";\nexport * from \"./runtime-api.js\";\nexport * from \"./task-context-api.js\";\nexport * from \"./apiClientManager-api.js\";\nexport * from \"./usage-api.js\";\nexport * from \"./run-metadata-api.js\";\nexport * from \"./wait-until-api.js\";\nexport * from \"./timeout-api.js\";\nexport * from \"./run-timeline-metrics-api.js\";\nexport * from \"./schemas/index.js\";\nexport { SemanticInternalAttributes } from \"./semanticInternalAttributes.js\";\nexport * from \"./task-catalog-api.js\";\nexport * from \"./types/index.js\";\nexport { links } from \"./links.js\";\nexport * from \"./jwt.js\";\nexport * from \"./idempotencyKeys.js\";\nexport * from \"./streams/asyncIterableStream.js\";\nexport * from \"./utils/getEnv.js\";\nexport { formatDuration, formatDurationInDays, formatDurationMilliseconds, formatDurationNanoseconds, millisecondsToNanoseconds, nanosecondsToMilliseconds, } from \"./utils/durations.js\";\nexport { eventFilterMatches } from \"../eventFilterMatches.js\";\nexport { flattenAttributes, primitiveValueOrflattenedAttributes, unflattenAttributes, NULL_SENTINEL, } from \"./utils/flattenAttributes.js\";\nexport { omit } from \"./utils/omit.js\";\nexport { calculateNextRetryDelay, calculateResetAt, defaultFetchRetryOptions, defaultRetryOptions, } from \"./utils/retries.js\";\nexport { accessoryAttributes } from \"./utils/styleAttributes.js\";\nexport { conditionallyExportPacket, conditionallyImportPacket, createPacketAttributes, createPacketAttributesAsJson, packetRequiresOffloading, parsePacket, prettyPrintPacket, stringifyIO, } from \"./utils/ioSerialization.js\";\nexport * from \"./config.js\";\nexport { getSchemaParseFn } from \"./types/schemas.js\";\nimport { VERSION } from \"../version.js\";\nexport { VERSION as CORE_VERSION };\n//# sourceMappingURL=index.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins\nexport var _globalThis = typeof globalThis === 'object' ? globalThis : global;\n//# sourceMappingURL=globalThis.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { _globalThis } from '../platform';\nexport var GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');\nexport var _global = _globalThis;\n/**\n * Make a function which accepts a version integer and returns the instance of an API if the version\n * is compatible, or a fallback version (usually NOOP) if it is not.\n *\n * @param requiredVersion Backwards compatibility version which is required to return the instance\n * @param instance Instance which should be returned if the required version is compatible\n * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible\n */\nexport function makeGetter(requiredVersion, instance, fallback) {\n    return function (version) {\n        return version === requiredVersion ? instance : fallback;\n    };\n}\n/**\n * A number which should be incremented each time a backwards incompatible\n * change is made to the API. This number is used when an API package\n * attempts to access the global API to ensure it is getting a compatible\n * version. If the global API is not compatible with the API package\n * attempting to get it, a NOOP API implementation will be returned.\n */\nexport var API_BACKWARDS_COMPATIBILITY_VERSION = 1;\n//# sourceMappingURL=global-utils.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar NoopLogger = /** @class */ (function () {\n    function NoopLogger() {\n    }\n    NoopLogger.prototype.emit = function (_logRecord) { };\n    return NoopLogger;\n}());\nexport { NoopLogger };\nexport var NOOP_LOGGER = new NoopLogger();\n//# sourceMappingURL=NoopLogger.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { NoopLogger } from './NoopLogger';\nvar NoopLoggerProvider = /** @class */ (function () {\n    function NoopLoggerProvider() {\n    }\n    NoopLoggerProvider.prototype.getLogger = function (_name, _version, _options) {\n        return new NoopLogger();\n    };\n    return NoopLoggerProvider;\n}());\nexport { NoopLoggerProvider };\nexport var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();\n//# sourceMappingURL=NoopLoggerProvider.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { API_BACKWARDS_COMPATIBILITY_VERSION, GLOBAL_LOGS_API_KEY, _global, makeGetter, } from '../internal/global-utils';\nimport { NOOP_LOGGER_PROVIDER } from '../NoopLoggerProvider';\nvar LogsAPI = /** @class */ (function () {\n    function LogsAPI() {\n    }\n    LogsAPI.getInstance = function () {\n        if (!this._instance) {\n            this._instance = new LogsAPI();\n        }\n        return this._instance;\n    };\n    LogsAPI.prototype.setGlobalLoggerProvider = function (provider) {\n        if (_global[GLOBAL_LOGS_API_KEY]) {\n            return this.getLoggerProvider();\n        }\n        _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);\n        return provider;\n    };\n    /**\n     * Returns the global logger provider.\n     *\n     * @returns LoggerProvider\n     */\n    LogsAPI.prototype.getLoggerProvider = function () {\n        var _a, _b;\n        return ((_b = (_a = _global[GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_LOGGER_PROVIDER);\n    };\n    /**\n     * Returns a logger from the global logger provider.\n     *\n     * @returns Logger\n     */\n    LogsAPI.prototype.getLogger = function (name, version, options) {\n        return this.getLoggerProvider().getLogger(name, version, options);\n    };\n    /** Remove the global logger provider */\n    LogsAPI.prototype.disable = function () {\n        delete _global[GLOBAL_LOGS_API_KEY];\n    };\n    return LogsAPI;\n}());\nexport { LogsAPI };\n//# sourceMappingURL=logs.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport * from './types/Logger';\nexport * from './types/LoggerProvider';\nexport * from './types/LogRecord';\nexport * from './types/LoggerOptions';\nexport * from './types/AnyValue';\nexport * from './NoopLogger';\nexport * from './NoopLoggerProvider';\nimport { LogsAPI } from './api/logs';\nexport var logs = LogsAPI.getInstance();\n//# sourceMappingURL=index.js.map","import { SpanStatusCode } from \"@opentelemetry/api\";\nexport function recordSpanException(span, error) {\n    if (error instanceof Error) {\n        span.recordException(sanitizeSpanError(error));\n    }\n    else if (typeof error === \"string\") {\n        span.recordException(error.replace(/\\0/g, \"\"));\n    }\n    else {\n        span.recordException(JSON.stringify(error).replace(/\\0/g, \"\"));\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR });\n}\nfunction sanitizeSpanError(error) {\n    // Create a new error object with the same name, message and stack trace\n    const sanitizedError = new Error(error.message.replace(/\\0/g, \"\"));\n    sanitizedError.name = error.name.replace(/\\0/g, \"\");\n    sanitizedError.stack = error.stack?.replace(/\\0/g, \"\");\n    return sanitizedError;\n}\n//# sourceMappingURL=utils.js.map","import { SpanStatusCode, context, propagation, trace, } from \"@opentelemetry/api\";\nimport { logs } from \"@opentelemetry/api-logs\";\nimport { SemanticInternalAttributes } from \"./semanticInternalAttributes.js\";\nimport { clock } from \"./clock-api.js\";\nimport { usage } from \"./usage-api.js\";\nimport { taskContext } from \"./task-context-api.js\";\nimport { recordSpanException } from \"./otel/utils.js\";\nexport class TriggerTracer {\n    _config;\n    constructor(_config) {\n        this._config = _config;\n    }\n    _tracer;\n    get tracer() {\n        if (!this._tracer) {\n            if (\"tracer\" in this._config)\n                return this._config.tracer;\n            this._tracer = trace.getTracer(this._config.name, this._config.version);\n        }\n        return this._tracer;\n    }\n    _logger;\n    get logger() {\n        if (!this._logger) {\n            if (\"logger\" in this._config)\n                return this._config.logger;\n            this._logger = logs.getLogger(this._config.name, this._config.version);\n        }\n        return this._logger;\n    }\n    extractContext(traceContext) {\n        return propagation.extract(context.active(), traceContext ?? {});\n    }\n    startActiveSpan(name, fn, options, ctx, signal) {\n        const parentContext = ctx ?? context.active();\n        const attributes = options?.attributes ?? {};\n        let spanEnded = false;\n        return this.tracer.startActiveSpan(name, {\n            ...options,\n            attributes,\n            startTime: clock.preciseNow(),\n        }, parentContext, async (span) => {\n            signal?.addEventListener(\"abort\", () => {\n                if (!spanEnded) {\n                    spanEnded = true;\n                    recordSpanException(span, signal.reason);\n                    span.end();\n                }\n            });\n            if (taskContext.ctx) {\n                const partialSpan = this.tracer.startSpan(name, {\n                    ...options,\n                    attributes: {\n                        ...attributes,\n                        [SemanticInternalAttributes.SPAN_PARTIAL]: true,\n                        [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,\n                    },\n                }, parentContext);\n                if (options?.events) {\n                    for (const event of options.events) {\n                        partialSpan.addEvent(event.name, event.attributes, event.startTime);\n                    }\n                }\n                partialSpan.end();\n            }\n            if (options?.events) {\n                for (const event of options.events) {\n                    span.addEvent(event.name, event.attributes, event.startTime);\n                }\n            }\n            const usageMeasurement = usage.start();\n            try {\n                return await fn(span);\n            }\n            catch (e) {\n                if (!spanEnded) {\n                    if (typeof e === \"string\" || e instanceof Error) {\n                        span.recordException(e);\n                    }\n                    span.setStatus({ code: SpanStatusCode.ERROR });\n                }\n                throw e;\n            }\n            finally {\n                if (!spanEnded) {\n                    spanEnded = true;\n                    if (taskContext.ctx) {\n                        const usageSample = usage.stop(usageMeasurement);\n                        const machine = taskContext.ctx.machine;\n                        span.setAttributes({\n                            [SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,\n                            [SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs\n                                ? usageSample.cpuTime * machine.centsPerMs\n                                : 0,\n                        });\n                    }\n                    span.end(clock.preciseNow());\n                }\n            }\n        });\n    }\n    startSpan(name, options, ctx) {\n        const parentContext = ctx ?? context.active();\n        const attributes = options?.attributes ?? {};\n        const span = this.tracer.startSpan(name, options, ctx);\n        this.tracer\n            .startSpan(name, {\n            ...options,\n            attributes: {\n                ...attributes,\n                [SemanticInternalAttributes.SPAN_PARTIAL]: true,\n                [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,\n            },\n        }, parentContext)\n            .end();\n        return span;\n    }\n}\n//# sourceMappingURL=tracer.js.map","export const VERSION = \"3.3.17\";\n//# sourceMappingURL=version.js.map","import { TriggerTracer } from \"@trigger.dev/core/v3/tracer\";\nimport { VERSION } from \"../version.js\";\nexport const tracer = new TriggerTracer({ name: \"@trigger.dev/sdk\", version: VERSION });\n//# sourceMappingURL=tracer.js.map","import { SemanticInternalAttributes } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer.js\";\nexport class InMemoryCache {\n    _cache = new Map();\n    get(key) {\n        return this._cache.get(key);\n    }\n    set(key, value) {\n        this._cache.set(key, value);\n        return undefined;\n    }\n    delete(key) {\n        this._cache.delete(key);\n        return undefined;\n    }\n}\n/**\n * Create a cache function that uses the provided store to cache values. Using InMemoryCache is safe because each task run is isolated.\n * @param store\n * @returns\n */\nexport function createCache(store) {\n    return function cache(cacheKey, fn) {\n        return tracer.startActiveSpan(\"cache\", async (span) => {\n            span.setAttribute(\"cache.key\", cacheKey);\n            span.setAttribute(SemanticInternalAttributes.STYLE_ICON, \"device-sd-card\");\n            const cacheEntry = await store.get(cacheKey);\n            if (cacheEntry) {\n                span.updateName(`cache.hit ${cacheKey}`);\n                return cacheEntry.value;\n            }\n            span.updateName(`cache.miss ${cacheKey}`);\n            const value = await tracer.startActiveSpan(\"cache.getFreshValue\", async (span) => {\n                return await fn();\n            }, {\n                attributes: {\n                    \"cache.key\": cacheKey,\n                    [SemanticInternalAttributes.STYLE_ICON]: \"device-sd-card\",\n                },\n            });\n            await tracer.startActiveSpan(\"cache.set\", async (span) => {\n                await store.set(cacheKey, {\n                    value,\n                    metadata: {\n                        createdTime: Date.now(),\n                    },\n                });\n            }, {\n                attributes: {\n                    \"cache.key\": cacheKey,\n                    [SemanticInternalAttributes.STYLE_ICON]: \"device-sd-card\",\n                },\n            });\n            return value;\n        });\n    };\n}\n//# sourceMappingURL=cache.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Creates a const map from the given values\n * @param values - An array of values to be used as keys and values in the map.\n * @returns A populated version of the map with the values and keys derived from the values.\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function createConstMap(values) {\n    // eslint-disable-next-line prefer-const, @typescript-eslint/no-explicit-any\n    var res = {};\n    var len = values.length;\n    for (var lp = 0; lp < len; lp++) {\n        var val = values[lp];\n        if (val) {\n            res[String(val).toUpperCase().replace(/[-.]/g, '_')] = val;\n        }\n    }\n    return res;\n}\n//# sourceMappingURL=utils.js.map","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createConstMap } from '../internal/utils';\n//----------------------------------------------------------------------------------------------------------\n// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2\n//----------------------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------------------\n// Constant values for SemanticAttributes\n//----------------------------------------------------------------------------------------------------------\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_AWS_LAMBDA_INVOKED_ARN = 'aws.lambda.invoked_arn';\nvar TMP_DB_SYSTEM = 'db.system';\nvar TMP_DB_CONNECTION_STRING = 'db.connection_string';\nvar TMP_DB_USER = 'db.user';\nvar TMP_DB_JDBC_DRIVER_CLASSNAME = 'db.jdbc.driver_classname';\nvar TMP_DB_NAME = 'db.name';\nvar TMP_DB_STATEMENT = 'db.statement';\nvar TMP_DB_OPERATION = 'db.operation';\nvar TMP_DB_MSSQL_INSTANCE_NAME = 'db.mssql.instance_name';\nvar TMP_DB_CASSANDRA_KEYSPACE = 'db.cassandra.keyspace';\nvar TMP_DB_CASSANDRA_PAGE_SIZE = 'db.cassandra.page_size';\nvar TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = 'db.cassandra.consistency_level';\nvar TMP_DB_CASSANDRA_TABLE = 'db.cassandra.table';\nvar TMP_DB_CASSANDRA_IDEMPOTENCE = 'db.cassandra.idempotence';\nvar TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = 'db.cassandra.speculative_execution_count';\nvar TMP_DB_CASSANDRA_COORDINATOR_ID = 'db.cassandra.coordinator.id';\nvar TMP_DB_CASSANDRA_COORDINATOR_DC = 'db.cassandra.coordinator.dc';\nvar TMP_DB_HBASE_NAMESPACE = 'db.hbase.namespace';\nvar TMP_DB_REDIS_DATABASE_INDEX = 'db.redis.database_index';\nvar TMP_DB_MONGODB_COLLECTION = 'db.mongodb.collection';\nvar TMP_DB_SQL_TABLE = 'db.sql.table';\nvar TMP_EXCEPTION_TYPE = 'exception.type';\nvar TMP_EXCEPTION_MESSAGE = 'exception.message';\nvar TMP_EXCEPTION_STACKTRACE = 'exception.stacktrace';\nvar TMP_EXCEPTION_ESCAPED = 'exception.escaped';\nvar TMP_FAAS_TRIGGER = 'faas.trigger';\nvar TMP_FAAS_EXECUTION = 'faas.execution';\nvar TMP_FAAS_DOCUMENT_COLLECTION = 'faas.document.collection';\nvar TMP_FAAS_DOCUMENT_OPERATION = 'faas.document.operation';\nvar TMP_FAAS_DOCUMENT_TIME = 'faas.document.time';\nvar TMP_FAAS_DOCUMENT_NAME = 'faas.document.name';\nvar TMP_FAAS_TIME = 'faas.time';\nvar TMP_FAAS_CRON = 'faas.cron';\nvar TMP_FAAS_COLDSTART = 'faas.coldstart';\nvar TMP_FAAS_INVOKED_NAME = 'faas.invoked_name';\nvar TMP_FAAS_INVOKED_PROVIDER = 'faas.invoked_provider';\nvar TMP_FAAS_INVOKED_REGION = 'faas.invoked_region';\nvar TMP_NET_TRANSPORT = 'net.transport';\nvar TMP_NET_PEER_IP = 'net.peer.ip';\nvar TMP_NET_PEER_PORT = 'net.peer.port';\nvar TMP_NET_PEER_NAME = 'net.peer.name';\nvar TMP_NET_HOST_IP = 'net.host.ip';\nvar TMP_NET_HOST_PORT = 'net.host.port';\nvar TMP_NET_HOST_NAME = 'net.host.name';\nvar TMP_NET_HOST_CONNECTION_TYPE = 'net.host.connection.type';\nvar TMP_NET_HOST_CONNECTION_SUBTYPE = 'net.host.connection.subtype';\nvar TMP_NET_HOST_CARRIER_NAME = 'net.host.carrier.name';\nvar TMP_NET_HOST_CARRIER_MCC = 'net.host.carrier.mcc';\nvar TMP_NET_HOST_CARRIER_MNC = 'net.host.carrier.mnc';\nvar TMP_NET_HOST_CARRIER_ICC = 'net.host.carrier.icc';\nvar TMP_PEER_SERVICE = 'peer.service';\nvar TMP_ENDUSER_ID = 'enduser.id';\nvar TMP_ENDUSER_ROLE = 'enduser.role';\nvar TMP_ENDUSER_SCOPE = 'enduser.scope';\nvar TMP_THREAD_ID = 'thread.id';\nvar TMP_THREAD_NAME = 'thread.name';\nvar TMP_CODE_FUNCTION = 'code.function';\nvar TMP_CODE_NAMESPACE = 'code.namespace';\nvar TMP_CODE_FILEPATH = 'code.filepath';\nvar TMP_CODE_LINENO = 'code.lineno';\nvar TMP_HTTP_METHOD = 'http.method';\nvar TMP_HTTP_URL = 'http.url';\nvar TMP_HTTP_TARGET = 'http.target';\nvar TMP_HTTP_HOST = 'http.host';\nvar TMP_HTTP_SCHEME = 'http.scheme';\nvar TMP_HTTP_STATUS_CODE = 'http.status_code';\nvar TMP_HTTP_FLAVOR = 'http.flavor';\nvar TMP_HTTP_USER_AGENT = 'http.user_agent';\nvar TMP_HTTP_REQUEST_CONTENT_LENGTH = 'http.request_content_length';\nvar TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = 'http.request_content_length_uncompressed';\nvar TMP_HTTP_RESPONSE_CONTENT_LENGTH = 'http.response_content_length';\nvar TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = 'http.response_content_length_uncompressed';\nvar TMP_HTTP_SERVER_NAME = 'http.server_name';\nvar TMP_HTTP_ROUTE = 'http.route';\nvar TMP_HTTP_CLIENT_IP = 'http.client_ip';\nvar TMP_AWS_DYNAMODB_TABLE_NAMES = 'aws.dynamodb.table_names';\nvar TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = 'aws.dynamodb.consumed_capacity';\nvar TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = 'aws.dynamodb.item_collection_metrics';\nvar TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = 'aws.dynamodb.provisioned_read_capacity';\nvar TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = 'aws.dynamodb.provisioned_write_capacity';\nvar TMP_AWS_DYNAMODB_CONSISTENT_READ = 'aws.dynamodb.consistent_read';\nvar TMP_AWS_DYNAMODB_PROJECTION = 'aws.dynamodb.projection';\nvar TMP_AWS_DYNAMODB_LIMIT = 'aws.dynamodb.limit';\nvar TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = 'aws.dynamodb.attributes_to_get';\nvar TMP_AWS_DYNAMODB_INDEX_NAME = 'aws.dynamodb.index_name';\nvar TMP_AWS_DYNAMODB_SELECT = 'aws.dynamodb.select';\nvar TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = 'aws.dynamodb.global_secondary_indexes';\nvar TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = 'aws.dynamodb.local_secondary_indexes';\nvar TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = 'aws.dynamodb.exclusive_start_table';\nvar TMP_AWS_DYNAMODB_TABLE_COUNT = 'aws.dynamodb.table_count';\nvar TMP_AWS_DYNAMODB_SCAN_FORWARD = 'aws.dynamodb.scan_forward';\nvar TMP_AWS_DYNAMODB_SEGMENT = 'aws.dynamodb.segment';\nvar TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = 'aws.dynamodb.total_segments';\nvar TMP_AWS_DYNAMODB_COUNT = 'aws.dynamodb.count';\nvar TMP_AWS_DYNAMODB_SCANNED_COUNT = 'aws.dynamodb.scanned_count';\nvar TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = 'aws.dynamodb.attribute_definitions';\nvar TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = 'aws.dynamodb.global_secondary_index_updates';\nvar TMP_MESSAGING_SYSTEM = 'messaging.system';\nvar TMP_MESSAGING_DESTINATION = 'messaging.destination';\nvar TMP_MESSAGING_DESTINATION_KIND = 'messaging.destination_kind';\nvar TMP_MESSAGING_TEMP_DESTINATION = 'messaging.temp_destination';\nvar TMP_MESSAGING_PROTOCOL = 'messaging.protocol';\nvar TMP_MESSAGING_PROTOCOL_VERSION = 'messaging.protocol_version';\nvar TMP_MESSAGING_URL = 'messaging.url';\nvar TMP_MESSAGING_MESSAGE_ID = 'messaging.message_id';\nvar TMP_MESSAGING_CONVERSATION_ID = 'messaging.conversation_id';\nvar TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = 'messaging.message_payload_size_bytes';\nvar TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = 'messaging.message_payload_compressed_size_bytes';\nvar TMP_MESSAGING_OPERATION = 'messaging.operation';\nvar TMP_MESSAGING_CONSUMER_ID = 'messaging.consumer_id';\nvar TMP_MESSAGING_RABBITMQ_ROUTING_KEY = 'messaging.rabbitmq.routing_key';\nvar TMP_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message_key';\nvar TMP_MESSAGING_KAFKA_CONSUMER_GROUP = 'messaging.kafka.consumer_group';\nvar TMP_MESSAGING_KAFKA_CLIENT_ID = 'messaging.kafka.client_id';\nvar TMP_MESSAGING_KAFKA_PARTITION = 'messaging.kafka.partition';\nvar TMP_MESSAGING_KAFKA_TOMBSTONE = 'messaging.kafka.tombstone';\nvar TMP_RPC_SYSTEM = 'rpc.system';\nvar TMP_RPC_SERVICE = 'rpc.service';\nvar TMP_RPC_METHOD = 'rpc.method';\nvar TMP_RPC_GRPC_STATUS_CODE = 'rpc.grpc.status_code';\nvar TMP_RPC_JSONRPC_VERSION = 'rpc.jsonrpc.version';\nvar TMP_RPC_JSONRPC_REQUEST_ID = 'rpc.jsonrpc.request_id';\nvar TMP_RPC_JSONRPC_ERROR_CODE = 'rpc.jsonrpc.error_code';\nvar TMP_RPC_JSONRPC_ERROR_MESSAGE = 'rpc.jsonrpc.error_message';\nvar TMP_MESSAGE_TYPE = 'message.type';\nvar TMP_MESSAGE_ID = 'message.id';\nvar TMP_MESSAGE_COMPRESSED_SIZE = 'message.compressed_size';\nvar TMP_MESSAGE_UNCOMPRESSED_SIZE = 'message.uncompressed_size';\n/**\n * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).\n *\n * Note: This may be different from `faas.id` if an alias is involved.\n */\nexport var SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;\n/**\n * The connection string used to connect to the database. It is recommended to remove embedded credentials.\n */\nexport var SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;\n/**\n * Username for accessing the database.\n */\nexport var SEMATTRS_DB_USER = TMP_DB_USER;\n/**\n * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.\n */\nexport var SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;\n/**\n * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).\n *\n * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.\n */\nexport var SEMATTRS_DB_NAME = TMP_DB_NAME;\n/**\n * The database statement being executed.\n *\n * Note: The value may be sanitized to exclude sensitive information.\n */\nexport var SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;\n/**\n * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.\n *\n * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.\n */\nexport var SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;\n/**\n * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.\n *\n * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).\n */\nexport var SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;\n/**\n * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.\n */\nexport var SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;\n/**\n * The fetch size used for paging, i.e. how many rows will be returned at once.\n */\nexport var SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;\n/**\n * The name of the primary table that the operation is acting upon, including the schema name (if applicable).\n *\n * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.\n */\nexport var SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;\n/**\n * Whether or not the query is idempotent.\n */\nexport var SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;\n/**\n * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.\n */\nexport var SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;\n/**\n * The ID of the coordinating node for a query.\n */\nexport var SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;\n/**\n * The data center of the coordinating node for a query.\n */\nexport var SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;\n/**\n * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.\n */\nexport var SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;\n/**\n * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.\n */\nexport var SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;\n/**\n * The collection being accessed within the database stated in `db.name`.\n */\nexport var SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;\n/**\n * The name of the primary table that the operation is acting upon, including the schema name (if applicable).\n *\n * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.\n */\nexport var SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;\n/**\n * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.\n */\nexport var SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;\n/**\n * The exception message.\n */\nexport var SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;\n/**\n * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.\n */\nexport var SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;\n/**\n* SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.\n*\n* Note: An exception is considered to have escaped (or left) the scope of a span,\nif that span is ended while the exception is still logically &#34;in flight&#34;.\nThis may be actually &#34;in flight&#34; in some languages (e.g. if the exception\nis passed to a Context manager&#39;s `__exit__` method in Python) but will\nusually be caught at the point of recording the exception in most languages.\n\nIt is usually not possible to determine at the point where an exception is thrown\nwhether it will escape the scope of a span.\nHowever, it is trivial to know that an exception\nwill escape, if one checks for an active exception just before ending the span,\nas done in the [example above](#exception-end-example).\n\nIt follows that an exception may still escape the scope of the span\neven if the `exception.escaped` attribute was not set or set to false,\nsince the event might have been recorded at a time where it was not\nclear whether the exception will escape.\n*/\nexport var SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;\n/**\n * Type of the trigger on which the function is executed.\n */\nexport var SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;\n/**\n * The execution ID of the current function execution.\n */\nexport var SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;\n/**\n * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.\n */\nexport var SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;\n/**\n * Describes the type of the operation that was performed on the data.\n */\nexport var SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;\n/**\n * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).\n */\nexport var SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;\n/**\n * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.\n */\nexport var SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;\n/**\n * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).\n */\nexport var SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;\n/**\n * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).\n */\nexport var SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;\n/**\n * A boolean that is true if the serverless function is executed for the first time (aka cold-start).\n */\nexport var SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;\n/**\n * The name of the invoked function.\n *\n * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.\n */\nexport var SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;\n/**\n * The cloud provider of the invoked function.\n *\n * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.\n */\nexport var SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;\n/**\n * The cloud region of the invoked function.\n *\n * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.\n */\nexport var SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;\n/**\n * Transport protocol used. See note below.\n */\nexport var SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;\n/**\n * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).\n */\nexport var SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;\n/**\n * Remote port number.\n */\nexport var SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;\n/**\n * Remote hostname or similar, see note below.\n */\nexport var SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;\n/**\n * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.\n */\nexport var SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;\n/**\n * Like `net.peer.port` but for the host port.\n */\nexport var SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;\n/**\n * Local hostname or similar, see note below.\n */\nexport var SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;\n/**\n * The internet connection type currently being used by the host.\n */\nexport var SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;\n/**\n * The name of the mobile carrier.\n */\nexport var SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;\n/**\n * The mobile carrier country code.\n */\nexport var SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;\n/**\n * The mobile carrier network code.\n */\nexport var SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;\n/**\n * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.\n */\nexport var SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;\n/**\n * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.\n */\nexport var SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;\n/**\n * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.\n */\nexport var SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;\n/**\n * Actual/assumed role the client is making the request under extracted from token or application security context.\n */\nexport var SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;\n/**\n * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).\n */\nexport var SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;\n/**\n * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).\n */\nexport var SEMATTRS_THREAD_ID = TMP_THREAD_ID;\n/**\n * Current thread name.\n */\nexport var SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;\n/**\n * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).\n */\nexport var SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;\n/**\n * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.\n */\nexport var SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;\n/**\n * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).\n */\nexport var SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;\n/**\n * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.\n */\nexport var SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;\n/**\n * HTTP request method.\n */\nexport var SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;\n/**\n * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.\n *\n * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.\n */\nexport var SEMATTRS_HTTP_URL = TMP_HTTP_URL;\n/**\n * The full request target as passed in a HTTP request line or equivalent.\n */\nexport var SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;\n/**\n * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.\n *\n * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.\n */\nexport var SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;\n/**\n * The URI scheme identifying the used protocol.\n */\nexport var SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;\n/**\n * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).\n */\nexport var SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;\n/**\n * Kind of HTTP protocol used.\n *\n * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.\n */\nexport var SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;\n/**\n * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.\n */\nexport var SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;\n/**\n * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.\n */\nexport var SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;\n/**\n * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.\n */\nexport var SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;\n/**\n * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.\n */\nexport var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;\n/**\n * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.\n */\nexport var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;\n/**\n * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).\n *\n * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.\n */\nexport var SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;\n/**\n * The matched route (path template).\n */\nexport var SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;\n/**\n* The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).\n*\n* Note: This is not necessarily the same as `net.peer.ip`, which would\nidentify the network-level peer, which may be a proxy.\n\nThis attribute should be set when a source of information different\nfrom the one used for `net.peer.ip`, is available even if that other\nsource just confirms the same value as `net.peer.ip`.\nRationale: For `net.peer.ip`, one typically does not know if it\ncomes from a proxy, reverse proxy, or the actual client. Setting\n`http.client_ip` when it&#39;s the same as `net.peer.ip` means that\none is at least somewhat confident that the address is not that of\nthe closest proxy.\n*/\nexport var SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;\n/**\n * The keys in the `RequestItems` object field.\n */\nexport var SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;\n/**\n * The JSON-serialized value of each item in the `ConsumedCapacity` response field.\n */\nexport var SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;\n/**\n * The JSON-serialized value of the `ItemCollectionMetrics` response field.\n */\nexport var SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;\n/**\n * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;\n/**\n * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;\n/**\n * The value of the `ConsistentRead` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;\n/**\n * The value of the `ProjectionExpression` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;\n/**\n * The value of the `Limit` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;\n/**\n * The value of the `AttributesToGet` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;\n/**\n * The value of the `IndexName` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;\n/**\n * The value of the `Select` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;\n/**\n * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.\n */\nexport var SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;\n/**\n * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.\n */\nexport var SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;\n/**\n * The value of the `ExclusiveStartTableName` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;\n/**\n * The the number of items in the `TableNames` response parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;\n/**\n * The value of the `ScanIndexForward` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;\n/**\n * The value of the `Segment` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;\n/**\n * The value of the `TotalSegments` request parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;\n/**\n * The value of the `Count` response parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;\n/**\n * The value of the `ScannedCount` response parameter.\n */\nexport var SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;\n/**\n * The JSON-serialized value of each item in the `AttributeDefinitions` request field.\n */\nexport var SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;\n/**\n * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.\n */\nexport var SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;\n/**\n * A string identifying the messaging system.\n */\nexport var SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;\n/**\n * The message destination name. This might be equal to the span name but is required nevertheless.\n */\nexport var SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;\n/**\n * The kind of message destination.\n */\nexport var SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;\n/**\n * A boolean that is true if the message destination is temporary.\n */\nexport var SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;\n/**\n * The name of the transport protocol.\n */\nexport var SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;\n/**\n * The version of the transport protocol.\n */\nexport var SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;\n/**\n * Connection string.\n */\nexport var SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;\n/**\n * A value used by the messaging system as an identifier for the message, represented as a string.\n */\nexport var SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;\n/**\n * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.\n */\nexport var SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;\n/**\n * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.\n */\nexport var SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;\n/**\n * The compressed size of the message payload in bytes.\n */\nexport var SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;\n/**\n * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.\n */\nexport var SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;\n/**\n * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.\n */\nexport var SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;\n/**\n * RabbitMQ message routing key.\n */\nexport var SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;\n/**\n * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.\n *\n * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.\n */\nexport var SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;\n/**\n * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.\n */\nexport var SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;\n/**\n * Client Id for the Consumer or Producer that is handling the message.\n */\nexport var SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;\n/**\n * Partition the message is sent to.\n */\nexport var SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;\n/**\n * A boolean that is true if the message is a tombstone.\n */\nexport var SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;\n/**\n * A string identifying the remoting system.\n */\nexport var SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;\n/**\n * The full (logical) name of the service being called, including its package name, if applicable.\n *\n * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).\n */\nexport var SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;\n/**\n * The name of the (logical) method being called, must be equal to the $method part in the span name.\n *\n * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).\n */\nexport var SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;\n/**\n * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.\n */\nexport var SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;\n/**\n * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.\n */\nexport var SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;\n/**\n * `error.code` property of response if it is an error response.\n */\nexport var SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;\n/**\n * `error.message` property of response if it is an error response.\n */\nexport var SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;\n/**\n * Whether this is a received or sent message.\n */\nexport var SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;\n/**\n * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.\n *\n * Note: This way we guarantee that the values will be consistent between different implementations.\n */\nexport var SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;\n/**\n * Compressed size of the message in bytes.\n */\nexport var SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;\n/**\n * Uncompressed size of the message in bytes.\n */\nexport var SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;\n/**\n * Create exported Value Map for SemanticAttributes values\n * @deprecated Use the SEMATTRS_XXXXX constants rather than the SemanticAttributes.XXXXX for bundle minification\n */\nexport var SemanticAttributes = \n/*#__PURE__*/ createConstMap([\n    TMP_AWS_LAMBDA_INVOKED_ARN,\n    TMP_DB_SYSTEM,\n    TMP_DB_CONNECTION_STRING,\n    TMP_DB_USER,\n    TMP_DB_JDBC_DRIVER_CLASSNAME,\n    TMP_DB_NAME,\n    TMP_DB_STATEMENT,\n    TMP_DB_OPERATION,\n    TMP_DB_MSSQL_INSTANCE_NAME,\n    TMP_DB_CASSANDRA_KEYSPACE,\n    TMP_DB_CASSANDRA_PAGE_SIZE,\n    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,\n    TMP_DB_CASSANDRA_TABLE,\n    TMP_DB_CASSANDRA_IDEMPOTENCE,\n    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,\n    TMP_DB_CASSANDRA_COORDINATOR_ID,\n    TMP_DB_CASSANDRA_COORDINATOR_DC,\n    TMP_DB_HBASE_NAMESPACE,\n    TMP_DB_REDIS_DATABASE_INDEX,\n    TMP_DB_MONGODB_COLLECTION,\n    TMP_DB_SQL_TABLE,\n    TMP_EXCEPTION_TYPE,\n    TMP_EXCEPTION_MESSAGE,\n    TMP_EXCEPTION_STACKTRACE,\n    TMP_EXCEPTION_ESCAPED,\n    TMP_FAAS_TRIGGER,\n    TMP_FAAS_EXECUTION,\n    TMP_FAAS_DOCUMENT_COLLECTION,\n    TMP_FAAS_DOCUMENT_OPERATION,\n    TMP_FAAS_DOCUMENT_TIME,\n    TMP_FAAS_DOCUMENT_NAME,\n    TMP_FAAS_TIME,\n    TMP_FAAS_CRON,\n    TMP_FAAS_COLDSTART,\n    TMP_FAAS_INVOKED_NAME,\n    TMP_FAAS_INVOKED_PROVIDER,\n    TMP_FAAS_INVOKED_REGION,\n    TMP_NET_TRANSPORT,\n    TMP_NET_PEER_IP,\n    TMP_NET_PEER_PORT,\n    TMP_NET_PEER_NAME,\n    TMP_NET_HOST_IP,\n    TMP_NET_HOST_PORT,\n    TMP_NET_HOST_NAME,\n    TMP_NET_HOST_CONNECTION_TYPE,\n    TMP_NET_HOST_CONNECTION_SUBTYPE,\n    TMP_NET_HOST_CARRIER_NAME,\n    TMP_NET_HOST_CARRIER_MCC,\n    TMP_NET_HOST_CARRIER_MNC,\n    TMP_NET_HOST_CARRIER_ICC,\n    TMP_PEER_SERVICE,\n    TMP_ENDUSER_ID,\n    TMP_ENDUSER_ROLE,\n    TMP_ENDUSER_SCOPE,\n    TMP_THREAD_ID,\n    TMP_THREAD_NAME,\n    TMP_CODE_FUNCTION,\n    TMP_CODE_NAMESPACE,\n    TMP_CODE_FILEPATH,\n    TMP_CODE_LINENO,\n    TMP_HTTP_METHOD,\n    TMP_HTTP_URL,\n    TMP_HTTP_TARGET,\n    TMP_HTTP_HOST,\n    TMP_HTTP_SCHEME,\n    TMP_HTTP_STATUS_CODE,\n    TMP_HTTP_FLAVOR,\n    TMP_HTTP_USER_AGENT,\n    TMP_HTTP_REQUEST_CONTENT_LENGTH,\n    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n    TMP_HTTP_RESPONSE_CONTENT_LENGTH,\n    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,\n    TMP_HTTP_SERVER_NAME,\n    TMP_HTTP_ROUTE,\n    TMP_HTTP_CLIENT_IP,\n    TMP_AWS_DYNAMODB_TABLE_NAMES,\n    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,\n    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,\n    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,\n    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,\n    TMP_AWS_DYNAMODB_CONSISTENT_READ,\n    TMP_AWS_DYNAMODB_PROJECTION,\n    TMP_AWS_DYNAMODB_LIMIT,\n    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,\n    TMP_AWS_DYNAMODB_INDEX_NAME,\n    TMP_AWS_DYNAMODB_SELECT,\n    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,\n    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,\n    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,\n    TMP_AWS_DYNAMODB_TABLE_COUNT,\n    TMP_AWS_DYNAMODB_SCAN_FORWARD,\n    TMP_AWS_DYNAMODB_SEGMENT,\n    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,\n    TMP_AWS_DYNAMODB_COUNT,\n    TMP_AWS_DYNAMODB_SCANNED_COUNT,\n    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,\n    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,\n    TMP_MESSAGING_SYSTEM,\n    TMP_MESSAGING_DESTINATION,\n    TMP_MESSAGING_DESTINATION_KIND,\n    TMP_MESSAGING_TEMP_DESTINATION,\n    TMP_MESSAGING_PROTOCOL,\n    TMP_MESSAGING_PROTOCOL_VERSION,\n    TMP_MESSAGING_URL,\n    TMP_MESSAGING_MESSAGE_ID,\n    TMP_MESSAGING_CONVERSATION_ID,\n    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,\n    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,\n    TMP_MESSAGING_OPERATION,\n    TMP_MESSAGING_CONSUMER_ID,\n    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,\n    TMP_MESSAGING_KAFKA_MESSAGE_KEY,\n    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,\n    TMP_MESSAGING_KAFKA_CLIENT_ID,\n    TMP_MESSAGING_KAFKA_PARTITION,\n    TMP_MESSAGING_KAFKA_TOMBSTONE,\n    TMP_RPC_SYSTEM,\n    TMP_RPC_SERVICE,\n    TMP_RPC_METHOD,\n    TMP_RPC_GRPC_STATUS_CODE,\n    TMP_RPC_JSONRPC_VERSION,\n    TMP_RPC_JSONRPC_REQUEST_ID,\n    TMP_RPC_JSONRPC_ERROR_CODE,\n    TMP_RPC_JSONRPC_ERROR_MESSAGE,\n    TMP_MESSAGE_TYPE,\n    TMP_MESSAGE_ID,\n    TMP_MESSAGE_COMPRESSED_SIZE,\n    TMP_MESSAGE_UNCOMPRESSED_SIZE,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for DbSystemValues enum definition\n *\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_DBSYSTEMVALUES_OTHER_SQL = 'other_sql';\nvar TMP_DBSYSTEMVALUES_MSSQL = 'mssql';\nvar TMP_DBSYSTEMVALUES_MYSQL = 'mysql';\nvar TMP_DBSYSTEMVALUES_ORACLE = 'oracle';\nvar TMP_DBSYSTEMVALUES_DB2 = 'db2';\nvar TMP_DBSYSTEMVALUES_POSTGRESQL = 'postgresql';\nvar TMP_DBSYSTEMVALUES_REDSHIFT = 'redshift';\nvar TMP_DBSYSTEMVALUES_HIVE = 'hive';\nvar TMP_DBSYSTEMVALUES_CLOUDSCAPE = 'cloudscape';\nvar TMP_DBSYSTEMVALUES_HSQLDB = 'hsqldb';\nvar TMP_DBSYSTEMVALUES_PROGRESS = 'progress';\nvar TMP_DBSYSTEMVALUES_MAXDB = 'maxdb';\nvar TMP_DBSYSTEMVALUES_HANADB = 'hanadb';\nvar TMP_DBSYSTEMVALUES_INGRES = 'ingres';\nvar TMP_DBSYSTEMVALUES_FIRSTSQL = 'firstsql';\nvar TMP_DBSYSTEMVALUES_EDB = 'edb';\nvar TMP_DBSYSTEMVALUES_CACHE = 'cache';\nvar TMP_DBSYSTEMVALUES_ADABAS = 'adabas';\nvar TMP_DBSYSTEMVALUES_FIREBIRD = 'firebird';\nvar TMP_DBSYSTEMVALUES_DERBY = 'derby';\nvar TMP_DBSYSTEMVALUES_FILEMAKER = 'filemaker';\nvar TMP_DBSYSTEMVALUES_INFORMIX = 'informix';\nvar TMP_DBSYSTEMVALUES_INSTANTDB = 'instantdb';\nvar TMP_DBSYSTEMVALUES_INTERBASE = 'interbase';\nvar TMP_DBSYSTEMVALUES_MARIADB = 'mariadb';\nvar TMP_DBSYSTEMVALUES_NETEZZA = 'netezza';\nvar TMP_DBSYSTEMVALUES_PERVASIVE = 'pervasive';\nvar TMP_DBSYSTEMVALUES_POINTBASE = 'pointbase';\nvar TMP_DBSYSTEMVALUES_SQLITE = 'sqlite';\nvar TMP_DBSYSTEMVALUES_SYBASE = 'sybase';\nvar TMP_DBSYSTEMVALUES_TERADATA = 'teradata';\nvar TMP_DBSYSTEMVALUES_VERTICA = 'vertica';\nvar TMP_DBSYSTEMVALUES_H2 = 'h2';\nvar TMP_DBSYSTEMVALUES_COLDFUSION = 'coldfusion';\nvar TMP_DBSYSTEMVALUES_CASSANDRA = 'cassandra';\nvar TMP_DBSYSTEMVALUES_HBASE = 'hbase';\nvar TMP_DBSYSTEMVALUES_MONGODB = 'mongodb';\nvar TMP_DBSYSTEMVALUES_REDIS = 'redis';\nvar TMP_DBSYSTEMVALUES_COUCHBASE = 'couchbase';\nvar TMP_DBSYSTEMVALUES_COUCHDB = 'couchdb';\nvar TMP_DBSYSTEMVALUES_COSMOSDB = 'cosmosdb';\nvar TMP_DBSYSTEMVALUES_DYNAMODB = 'dynamodb';\nvar TMP_DBSYSTEMVALUES_NEO4J = 'neo4j';\nvar TMP_DBSYSTEMVALUES_GEODE = 'geode';\nvar TMP_DBSYSTEMVALUES_ELASTICSEARCH = 'elasticsearch';\nvar TMP_DBSYSTEMVALUES_MEMCACHED = 'memcached';\nvar TMP_DBSYSTEMVALUES_COCKROACHDB = 'cockroachdb';\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;\n/**\n * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.\n */\nexport var DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;\n/**\n * The constant map of values for DbSystemValues.\n * @deprecated Use the DBSYSTEMVALUES_XXXXX constants rather than the DbSystemValues.XXXXX for bundle minification.\n */\nexport var DbSystemValues = \n/*#__PURE__*/ createConstMap([\n    TMP_DBSYSTEMVALUES_OTHER_SQL,\n    TMP_DBSYSTEMVALUES_MSSQL,\n    TMP_DBSYSTEMVALUES_MYSQL,\n    TMP_DBSYSTEMVALUES_ORACLE,\n    TMP_DBSYSTEMVALUES_DB2,\n    TMP_DBSYSTEMVALUES_POSTGRESQL,\n    TMP_DBSYSTEMVALUES_REDSHIFT,\n    TMP_DBSYSTEMVALUES_HIVE,\n    TMP_DBSYSTEMVALUES_CLOUDSCAPE,\n    TMP_DBSYSTEMVALUES_HSQLDB,\n    TMP_DBSYSTEMVALUES_PROGRESS,\n    TMP_DBSYSTEMVALUES_MAXDB,\n    TMP_DBSYSTEMVALUES_HANADB,\n    TMP_DBSYSTEMVALUES_INGRES,\n    TMP_DBSYSTEMVALUES_FIRSTSQL,\n    TMP_DBSYSTEMVALUES_EDB,\n    TMP_DBSYSTEMVALUES_CACHE,\n    TMP_DBSYSTEMVALUES_ADABAS,\n    TMP_DBSYSTEMVALUES_FIREBIRD,\n    TMP_DBSYSTEMVALUES_DERBY,\n    TMP_DBSYSTEMVALUES_FILEMAKER,\n    TMP_DBSYSTEMVALUES_INFORMIX,\n    TMP_DBSYSTEMVALUES_INSTANTDB,\n    TMP_DBSYSTEMVALUES_INTERBASE,\n    TMP_DBSYSTEMVALUES_MARIADB,\n    TMP_DBSYSTEMVALUES_NETEZZA,\n    TMP_DBSYSTEMVALUES_PERVASIVE,\n    TMP_DBSYSTEMVALUES_POINTBASE,\n    TMP_DBSYSTEMVALUES_SQLITE,\n    TMP_DBSYSTEMVALUES_SYBASE,\n    TMP_DBSYSTEMVALUES_TERADATA,\n    TMP_DBSYSTEMVALUES_VERTICA,\n    TMP_DBSYSTEMVALUES_H2,\n    TMP_DBSYSTEMVALUES_COLDFUSION,\n    TMP_DBSYSTEMVALUES_CASSANDRA,\n    TMP_DBSYSTEMVALUES_HBASE,\n    TMP_DBSYSTEMVALUES_MONGODB,\n    TMP_DBSYSTEMVALUES_REDIS,\n    TMP_DBSYSTEMVALUES_COUCHBASE,\n    TMP_DBSYSTEMVALUES_COUCHDB,\n    TMP_DBSYSTEMVALUES_COSMOSDB,\n    TMP_DBSYSTEMVALUES_DYNAMODB,\n    TMP_DBSYSTEMVALUES_NEO4J,\n    TMP_DBSYSTEMVALUES_GEODE,\n    TMP_DBSYSTEMVALUES_ELASTICSEARCH,\n    TMP_DBSYSTEMVALUES_MEMCACHED,\n    TMP_DBSYSTEMVALUES_COCKROACHDB,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for DbCassandraConsistencyLevelValues enum definition\n *\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = 'all';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = 'each_quorum';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = 'quorum';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = 'local_quorum';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = 'one';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = 'two';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = 'three';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = 'local_one';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = 'any';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = 'serial';\nvar TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = 'local_serial';\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;\n/**\n * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).\n */\nexport var DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;\n/**\n * The constant map of values for DbCassandraConsistencyLevelValues.\n * @deprecated Use the DBCASSANDRACONSISTENCYLEVELVALUES_XXXXX constants rather than the DbCassandraConsistencyLevelValues.XXXXX for bundle minification.\n */\nexport var DbCassandraConsistencyLevelValues = \n/*#__PURE__*/ createConstMap([\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for FaasTriggerValues enum definition\n *\n * Type of the trigger on which the function is executed.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_FAASTRIGGERVALUES_DATASOURCE = 'datasource';\nvar TMP_FAASTRIGGERVALUES_HTTP = 'http';\nvar TMP_FAASTRIGGERVALUES_PUBSUB = 'pubsub';\nvar TMP_FAASTRIGGERVALUES_TIMER = 'timer';\nvar TMP_FAASTRIGGERVALUES_OTHER = 'other';\n/**\n * Type of the trigger on which the function is executed.\n */\nexport var FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;\n/**\n * Type of the trigger on which the function is executed.\n */\nexport var FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;\n/**\n * Type of the trigger on which the function is executed.\n */\nexport var FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;\n/**\n * Type of the trigger on which the function is executed.\n */\nexport var FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;\n/**\n * Type of the trigger on which the function is executed.\n */\nexport var FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;\n/**\n * The constant map of values for FaasTriggerValues.\n * @deprecated Use the FAASTRIGGERVALUES_XXXXX constants rather than the FaasTriggerValues.XXXXX for bundle minification.\n */\nexport var FaasTriggerValues = \n/*#__PURE__*/ createConstMap([\n    TMP_FAASTRIGGERVALUES_DATASOURCE,\n    TMP_FAASTRIGGERVALUES_HTTP,\n    TMP_FAASTRIGGERVALUES_PUBSUB,\n    TMP_FAASTRIGGERVALUES_TIMER,\n    TMP_FAASTRIGGERVALUES_OTHER,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for FaasDocumentOperationValues enum definition\n *\n * Describes the type of the operation that was performed on the data.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = 'insert';\nvar TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = 'edit';\nvar TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = 'delete';\n/**\n * Describes the type of the operation that was performed on the data.\n */\nexport var FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;\n/**\n * Describes the type of the operation that was performed on the data.\n */\nexport var FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;\n/**\n * Describes the type of the operation that was performed on the data.\n */\nexport var FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;\n/**\n * The constant map of values for FaasDocumentOperationValues.\n * @deprecated Use the FAASDOCUMENTOPERATIONVALUES_XXXXX constants rather than the FaasDocumentOperationValues.XXXXX for bundle minification.\n */\nexport var FaasDocumentOperationValues = \n/*#__PURE__*/ createConstMap([\n    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,\n    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,\n    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for FaasInvokedProviderValues enum definition\n *\n * The cloud provider of the invoked function.\n *\n * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = 'alibaba_cloud';\nvar TMP_FAASINVOKEDPROVIDERVALUES_AWS = 'aws';\nvar TMP_FAASINVOKEDPROVIDERVALUES_AZURE = 'azure';\nvar TMP_FAASINVOKEDPROVIDERVALUES_GCP = 'gcp';\n/**\n * The cloud provider of the invoked function.\n *\n * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.\n */\nexport var FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;\n/**\n * The cloud provider of the invoked function.\n *\n * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.\n */\nexport var FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;\n/**\n * The cloud provider of the invoked function.\n *\n * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.\n */\nexport var FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;\n/**\n * The cloud provider of the invoked function.\n *\n * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.\n */\nexport var FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;\n/**\n * The constant map of values for FaasInvokedProviderValues.\n * @deprecated Use the FAASINVOKEDPROVIDERVALUES_XXXXX constants rather than the FaasInvokedProviderValues.XXXXX for bundle minification.\n */\nexport var FaasInvokedProviderValues = \n/*#__PURE__*/ createConstMap([\n    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,\n    TMP_FAASINVOKEDPROVIDERVALUES_AWS,\n    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,\n    TMP_FAASINVOKEDPROVIDERVALUES_GCP,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for NetTransportValues enum definition\n *\n * Transport protocol used. See note below.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_NETTRANSPORTVALUES_IP_TCP = 'ip_tcp';\nvar TMP_NETTRANSPORTVALUES_IP_UDP = 'ip_udp';\nvar TMP_NETTRANSPORTVALUES_IP = 'ip';\nvar TMP_NETTRANSPORTVALUES_UNIX = 'unix';\nvar TMP_NETTRANSPORTVALUES_PIPE = 'pipe';\nvar TMP_NETTRANSPORTVALUES_INPROC = 'inproc';\nvar TMP_NETTRANSPORTVALUES_OTHER = 'other';\n/**\n * Transport protocol used. See note below.\n */\nexport var NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;\n/**\n * Transport protocol used. See note below.\n */\nexport var NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;\n/**\n * Transport protocol used. See note below.\n */\nexport var NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;\n/**\n * Transport protocol used. See note below.\n */\nexport var NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;\n/**\n * Transport protocol used. See note below.\n */\nexport var NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;\n/**\n * Transport protocol used. See note below.\n */\nexport var NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;\n/**\n * Transport protocol used. See note below.\n */\nexport var NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;\n/**\n * The constant map of values for NetTransportValues.\n * @deprecated Use the NETTRANSPORTVALUES_XXXXX constants rather than the NetTransportValues.XXXXX for bundle minification.\n */\nexport var NetTransportValues = \n/*#__PURE__*/ createConstMap([\n    TMP_NETTRANSPORTVALUES_IP_TCP,\n    TMP_NETTRANSPORTVALUES_IP_UDP,\n    TMP_NETTRANSPORTVALUES_IP,\n    TMP_NETTRANSPORTVALUES_UNIX,\n    TMP_NETTRANSPORTVALUES_PIPE,\n    TMP_NETTRANSPORTVALUES_INPROC,\n    TMP_NETTRANSPORTVALUES_OTHER,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for NetHostConnectionTypeValues enum definition\n *\n * The internet connection type currently being used by the host.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = 'wifi';\nvar TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = 'wired';\nvar TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = 'cell';\nvar TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = 'unavailable';\nvar TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = 'unknown';\n/**\n * The internet connection type currently being used by the host.\n */\nexport var NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;\n/**\n * The internet connection type currently being used by the host.\n */\nexport var NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;\n/**\n * The internet connection type currently being used by the host.\n */\nexport var NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;\n/**\n * The internet connection type currently being used by the host.\n */\nexport var NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;\n/**\n * The internet connection type currently being used by the host.\n */\nexport var NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;\n/**\n * The constant map of values for NetHostConnectionTypeValues.\n * @deprecated Use the NETHOSTCONNECTIONTYPEVALUES_XXXXX constants rather than the NetHostConnectionTypeValues.XXXXX for bundle minification.\n */\nexport var NetHostConnectionTypeValues = \n/*#__PURE__*/ createConstMap([\n    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,\n    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,\n    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,\n    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,\n    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for NetHostConnectionSubtypeValues enum definition\n *\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = 'gprs';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = 'edge';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = 'umts';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = 'cdma';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = 'evdo_0';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = 'evdo_a';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = 'cdma2000_1xrtt';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = 'hsdpa';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = 'hsupa';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = 'hspa';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = 'iden';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = 'evdo_b';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = 'lte';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = 'ehrpd';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = 'hspap';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = 'gsm';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = 'td_scdma';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = 'iwlan';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = 'nr';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = 'nrnsa';\nvar TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = 'lte_ca';\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;\n/**\n * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.\n */\nexport var NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;\n/**\n * The constant map of values for NetHostConnectionSubtypeValues.\n * @deprecated Use the NETHOSTCONNECTIONSUBTYPEVALUES_XXXXX constants rather than the NetHostConnectionSubtypeValues.XXXXX for bundle minification.\n */\nexport var NetHostConnectionSubtypeValues = \n/*#__PURE__*/ createConstMap([\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for HttpFlavorValues enum definition\n *\n * Kind of HTTP protocol used.\n *\n * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_HTTPFLAVORVALUES_HTTP_1_0 = '1.0';\nvar TMP_HTTPFLAVORVALUES_HTTP_1_1 = '1.1';\nvar TMP_HTTPFLAVORVALUES_HTTP_2_0 = '2.0';\nvar TMP_HTTPFLAVORVALUES_SPDY = 'SPDY';\nvar TMP_HTTPFLAVORVALUES_QUIC = 'QUIC';\n/**\n * Kind of HTTP protocol used.\n *\n * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.\n */\nexport var HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;\n/**\n * Kind of HTTP protocol used.\n *\n * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.\n */\nexport var HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;\n/**\n * Kind of HTTP protocol used.\n *\n * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.\n */\nexport var HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;\n/**\n * Kind of HTTP protocol used.\n *\n * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.\n */\nexport var HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;\n/**\n * Kind of HTTP protocol used.\n *\n * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.\n */\nexport var HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;\n/**\n * The constant map of values for HttpFlavorValues.\n * @deprecated Use the HTTPFLAVORVALUES_XXXXX constants rather than the HttpFlavorValues.XXXXX for bundle minification.\n */\nexport var HttpFlavorValues = {\n    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,\n    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,\n    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,\n    SPDY: TMP_HTTPFLAVORVALUES_SPDY,\n    QUIC: TMP_HTTPFLAVORVALUES_QUIC,\n};\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for MessagingDestinationKindValues enum definition\n *\n * The kind of message destination.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = 'queue';\nvar TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = 'topic';\n/**\n * The kind of message destination.\n */\nexport var MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;\n/**\n * The kind of message destination.\n */\nexport var MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;\n/**\n * The constant map of values for MessagingDestinationKindValues.\n * @deprecated Use the MESSAGINGDESTINATIONKINDVALUES_XXXXX constants rather than the MessagingDestinationKindValues.XXXXX for bundle minification.\n */\nexport var MessagingDestinationKindValues = \n/*#__PURE__*/ createConstMap([\n    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,\n    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for MessagingOperationValues enum definition\n *\n * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_MESSAGINGOPERATIONVALUES_RECEIVE = 'receive';\nvar TMP_MESSAGINGOPERATIONVALUES_PROCESS = 'process';\n/**\n * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.\n */\nexport var MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;\n/**\n * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.\n */\nexport var MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;\n/**\n * The constant map of values for MessagingOperationValues.\n * @deprecated Use the MESSAGINGOPERATIONVALUES_XXXXX constants rather than the MessagingOperationValues.XXXXX for bundle minification.\n */\nexport var MessagingOperationValues = \n/*#__PURE__*/ createConstMap([\n    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,\n    TMP_MESSAGINGOPERATIONVALUES_PROCESS,\n]);\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for RpcGrpcStatusCodeValues enum definition\n *\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;\nvar TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;\nvar TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;\nvar TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;\nvar TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;\nvar TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;\nvar TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;\nvar TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;\nvar TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;\nvar TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;\nvar TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;\nvar TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;\nvar TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;\nvar TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;\nvar TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;\nvar TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;\nvar TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;\n/**\n * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.\n */\nexport var RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;\n/**\n * The constant map of values for RpcGrpcStatusCodeValues.\n * @deprecated Use the RPCGRPCSTATUSCODEVALUES_XXXXX constants rather than the RpcGrpcStatusCodeValues.XXXXX for bundle minification.\n */\nexport var RpcGrpcStatusCodeValues = {\n    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,\n    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,\n    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,\n    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,\n    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,\n    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,\n    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,\n    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,\n    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,\n    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,\n    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,\n    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,\n    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,\n    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,\n    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,\n    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,\n    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED,\n};\n/* ----------------------------------------------------------------------------------------------------------\n * Constant values for MessageTypeValues enum definition\n *\n * Whether this is a received or sent message.\n * ---------------------------------------------------------------------------------------------------------- */\n// Temporary local constants to assign to the individual exports and the namespaced version\n// Required to avoid the namespace exports using the unminifable export names for some package types\nvar TMP_MESSAGETYPEVALUES_SENT = 'SENT';\nvar TMP_MESSAGETYPEVALUES_RECEIVED = 'RECEIVED';\n/**\n * Whether this is a received or sent message.\n */\nexport var MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;\n/**\n * Whether this is a received or sent message.\n */\nexport var MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;\n/**\n * The constant map of values for MessageTypeValues.\n * @deprecated Use the MESSAGETYPEVALUES_XXXXX constants rather than the MessageTypeValues.XXXXX for bundle minification.\n */\nexport var MessageTypeValues = \n/*#__PURE__*/ createConstMap([\n    TMP_MESSAGETYPEVALUES_SENT,\n    TMP_MESSAGETYPEVALUES_RECEIVED,\n]);\n//# sourceMappingURL=SemanticAttributes.js.map","import { SpanStatusCode, context, trace } from \"@opentelemetry/api\";\nimport { SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_URL, } from \"@opentelemetry/semantic-conventions\";\nimport { SemanticInternalAttributes, accessoryAttributes, calculateNextRetryDelay, calculateResetAt, defaultFetchRetryOptions, defaultRetryOptions, eventFilterMatches, flattenAttributes, runtime, } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer.js\";\nfunction onThrow(fn, options) {\n    const opts = {\n        ...defaultRetryOptions,\n        ...options,\n    };\n    return tracer.startActiveSpan(`retry.onThrow()`, async (span) => {\n        let attempt = 1;\n        while (attempt <= opts.maxAttempts) {\n            const innerSpan = tracer.startSpan(\"retry.fn()\", {\n                attributes: {\n                    [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n                    ...accessoryAttributes({\n                        items: [\n                            {\n                                text: `${attempt}/${opts.maxAttempts}`,\n                                variant: \"normal\",\n                            },\n                        ],\n                        style: \"codepath\",\n                    }),\n                },\n            });\n            const contextWithSpanSet = trace.setSpan(context.active(), innerSpan);\n            try {\n                const result = await context.with(contextWithSpanSet, async () => {\n                    return fn({ attempt, maxAttempts: opts.maxAttempts });\n                });\n                innerSpan.end();\n                return result;\n            }\n            catch (e) {\n                if (e instanceof Error || typeof e === \"string\") {\n                    innerSpan.recordException(e);\n                }\n                else {\n                    innerSpan.recordException(String(e));\n                }\n                innerSpan.setStatus({ code: SpanStatusCode.ERROR });\n                if (e instanceof Error && e.name === \"AbortTaskRunError\") {\n                    innerSpan.end();\n                    throw e;\n                }\n                const nextRetryDelay = calculateNextRetryDelay(opts, attempt);\n                if (!nextRetryDelay) {\n                    innerSpan.end();\n                    throw e;\n                }\n                innerSpan.setAttribute(SemanticInternalAttributes.RETRY_AT, new Date(Date.now() + nextRetryDelay).toISOString());\n                innerSpan.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n                innerSpan.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetryDelay}ms`);\n                innerSpan.end();\n                await runtime.waitForDuration(nextRetryDelay);\n            }\n            finally {\n                attempt++;\n            }\n        }\n        throw new Error(\"Max attempts reached\");\n    }, {\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"arrow-capsule\",\n        },\n    });\n}\nconst normalizeUrlFromInput = (input) => {\n    if (typeof input === \"string\") {\n        return new URL(input);\n    }\n    if (input instanceof URL) {\n        return input;\n    }\n    return new URL(input.url);\n};\nconst normalizeHttpMethod = (input, init) => {\n    if (typeof input === \"string\" || input instanceof URL) {\n        return (init?.method || \"GET\").toUpperCase();\n    }\n    return (input.method ?? init?.method ?? \"GET\").toUpperCase();\n};\nclass FetchErrorWithSpan extends Error {\n    originalError;\n    span;\n    constructor(originalError, span) {\n        super(\"Fetch error\");\n        this.originalError = originalError;\n        this.span = span;\n    }\n}\nconst MAX_ATTEMPTS = 10;\nasync function retryFetch(input, init) {\n    return tracer.startActiveSpan(\"retry.fetch()\", async (span) => {\n        let attempt = 1;\n        while (true) {\n            try {\n                const abortController = new AbortController();\n                const timeoutId = init?.timeoutInMs\n                    ? setTimeout(() => {\n                        abortController.abort();\n                    }, init?.timeoutInMs)\n                    : undefined;\n                init?.signal?.addEventListener(\"abort\", () => {\n                    abortController.abort();\n                });\n                const [response, span] = await doFetchRequest(input, { ...(init ?? {}), signal: abortController.signal }, attempt);\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                if (response.ok) {\n                    span.setAttributes(createFetchResponseAttributes(response));\n                    span.end();\n                    return response;\n                }\n                const nextRetry = await calculateRetryDelayForResponse(resolveDefaults(init?.retry, \"byStatus\", defaultFetchRetryOptions.byStatus), response, attempt);\n                if (!nextRetry) {\n                    span.setAttributes(createFetchResponseAttributes(response));\n                    span.end();\n                    return response;\n                }\n                if (attempt >= MAX_ATTEMPTS) {\n                    span.setAttributes(createFetchResponseAttributes(response));\n                    span.end();\n                    return response;\n                }\n                if (nextRetry.type === \"delay\") {\n                    span.setAttribute(SemanticInternalAttributes.RETRY_AT, new Date(Date.now() + nextRetry.value).toISOString());\n                    span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n                    span.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetry.value}ms`);\n                    span.end();\n                    await runtime.waitForDuration(nextRetry.value);\n                }\n                else {\n                    const now = Date.now();\n                    const nextRetryDate = new Date(nextRetry.value);\n                    const isInFuture = nextRetryDate.getTime() > now;\n                    span.setAttribute(SemanticInternalAttributes.RETRY_AT, new Date(nextRetry.value).toISOString());\n                    span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n                    if (isInFuture) {\n                        span.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetry.value - now}ms`);\n                    }\n                    span.end();\n                    await runtime.waitUntil(new Date(nextRetry.value));\n                }\n            }\n            catch (e) {\n                if (e instanceof FetchErrorWithSpan && e.originalError instanceof Error) {\n                    if (e.originalError.name === \"AbortError\") {\n                        const nextRetryDelay = calculateNextRetryDelay(resolveDefaults(init?.retry, \"timeout\", defaultFetchRetryOptions.timeout), attempt);\n                        if (!nextRetryDelay) {\n                            e.span.end();\n                            throw e;\n                        }\n                        if (attempt >= MAX_ATTEMPTS) {\n                            e.span.end();\n                            throw e;\n                        }\n                        e.span.setAttribute(SemanticInternalAttributes.RETRY_AT, new Date(Date.now() + nextRetryDelay).toISOString());\n                        e.span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n                        e.span.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetryDelay}ms`);\n                        e.span.end();\n                        await runtime.waitForDuration(nextRetryDelay);\n                        continue; // Move to the next attempt\n                    }\n                    else if (e.originalError.name === \"TypeError\" &&\n                        \"cause\" in e.originalError &&\n                        e.originalError.cause instanceof Error) {\n                        const nextRetryDelay = calculateNextRetryDelay(resolveDefaults(init?.retry, \"connectionError\", defaultFetchRetryOptions.connectionError), attempt);\n                        if (!nextRetryDelay) {\n                            e.span.end();\n                            throw e;\n                        }\n                        if (attempt >= MAX_ATTEMPTS) {\n                            e.span.end();\n                            throw e;\n                        }\n                        e.span.setAttribute(SemanticInternalAttributes.RETRY_AT, new Date(Date.now() + nextRetryDelay).toISOString());\n                        e.span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n                        e.span.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetryDelay}ms`);\n                        e.span.end();\n                        await runtime.waitForDuration(nextRetryDelay);\n                        continue; // Move to the next attempt\n                    }\n                }\n                if (e instanceof FetchErrorWithSpan) {\n                    e.span.end();\n                }\n                throw e;\n            }\n            finally {\n                attempt++;\n            }\n        }\n    }, {\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"arrow-capsule\",\n            ...createFetchAttributes(input, init),\n            ...createFetchRetryOptionsAttributes(init?.retry),\n        },\n    });\n}\nconst doFetchRequest = async (input, init, attemptCount = 0) => {\n    const httpMethod = normalizeHttpMethod(input, init);\n    const span = tracer.startSpan(`HTTP ${httpMethod}`, {\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"world\",\n            ...(attemptCount > 1 ? { [\"http.request.resend_count\"]: attemptCount - 1 } : {}),\n            ...createFetchAttributes(input, init),\n        },\n    });\n    try {\n        const response = await fetch(input, {\n            ...init,\n            headers: {\n                ...init?.headers,\n                \"x-retry-count\": attemptCount.toString(),\n            },\n        });\n        span.setAttributes(createFetchResponseAttributes(response));\n        if (!response.ok) {\n            span.recordException(`${response.status}: ${response.statusText}`);\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: `${response.status}: ${response.statusText}`,\n            });\n        }\n        return [response, span];\n    }\n    catch (e) {\n        if (typeof e === \"string\" || e instanceof Error) {\n            span.recordException(e);\n        }\n        span.setStatus({ code: SpanStatusCode.ERROR });\n        span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, 0);\n        span.setAttribute(\"http.status_text\", \"This operation was aborted.\");\n        throw new FetchErrorWithSpan(e, span);\n    }\n};\nconst calculateRetryDelayForResponse = async (retry, response, attemptCount) => {\n    if (!retry) {\n        return;\n    }\n    const strategy = await getRetryStrategyForResponse(response, retry);\n    if (!strategy) {\n        return;\n    }\n    switch (strategy.strategy) {\n        case \"backoff\": {\n            const value = calculateNextRetryDelay({ ...defaultRetryOptions, ...strategy }, attemptCount);\n            if (value) {\n                return { type: \"delay\", value };\n            }\n            break;\n        }\n        case \"headers\": {\n            const resetAt = response.headers.get(strategy.resetHeader);\n            if (typeof resetAt === \"string\") {\n                const resetTimestamp = calculateResetAt(resetAt, strategy.resetFormat ?? \"unix_timestamp_in_ms\");\n                if (resetTimestamp) {\n                    return { type: \"timestamp\", value: resetTimestamp };\n                }\n            }\n            break;\n        }\n    }\n    return;\n};\nconst getRetryStrategyForResponse = async (response, retry) => {\n    const statusCodes = Object.keys(retry);\n    const clonedResponse = response.clone();\n    for (let i = 0; i < statusCodes.length; i++) {\n        const statusRange = statusCodes[i];\n        if (!statusRange) {\n            continue;\n        }\n        const strategy = retry[statusRange];\n        if (!strategy) {\n            continue;\n        }\n        if (isStatusCodeInRange(response.status, statusRange)) {\n            if (strategy.bodyFilter) {\n                const body = safeJsonParse(await clonedResponse.text());\n                if (!body) {\n                    continue;\n                }\n                if (eventFilterMatches(body, strategy.bodyFilter)) {\n                    return strategy;\n                }\n                else {\n                    continue;\n                }\n            }\n            return strategy;\n        }\n    }\n    return;\n};\n/**\n * Checks if a given status code falls within a given range.\n * The range can be a single status code (e.g. \"200\"),\n * a range of status codes (e.g. \"500-599\"),\n * a range of status codes with a wildcard (e.g. \"4xx\" for any 4xx status code),\n * or a list of status codes separated by commas (e.g. \"401,403,404,409-412,5xx\").\n * Returns `true` if the status code falls within the range, and `false` otherwise.\n */\nconst isStatusCodeInRange = (statusCode, statusRange) => {\n    if (statusRange === \"all\") {\n        return true;\n    }\n    if (statusRange.includes(\",\")) {\n        const statusCodes = statusRange.split(\",\").map((s) => s.trim());\n        return statusCodes.some((s) => isStatusCodeInRange(statusCode, s));\n    }\n    const [start, end] = statusRange.split(\"-\");\n    if (end) {\n        return statusCode >= parseInt(start ?? \"0\", 10) && statusCode <= parseInt(end, 10);\n    }\n    if (start?.endsWith(\"xx\")) {\n        const prefix = start.slice(0, -2);\n        const statusCodePrefix = Math.floor(statusCode / 100).toString();\n        return statusCodePrefix === prefix;\n    }\n    if (!start) {\n        return false;\n    }\n    const statusCodeString = statusCode.toString();\n    const rangePrefix = start.slice(0, -1);\n    if (start.endsWith(\"x\") && statusCodeString.startsWith(rangePrefix)) {\n        return true;\n    }\n    return statusCode === parseInt(start, 10);\n};\nconst createAttributesFromHeaders = (headers) => {\n    const attributes = {};\n    const normalizedHeaderKey = (key) => {\n        return key.toLowerCase();\n    };\n    headers.forEach((value, key) => {\n        attributes[`http.response.header.${normalizedHeaderKey(key)}`] = value;\n    });\n    return attributes;\n};\nconst safeJsonParse = (json) => {\n    try {\n        return JSON.parse(json);\n    }\n    catch (e) {\n        return null;\n    }\n};\n// This function will resolve the defaults of a property within an options object.\n// If the options object is undefined, it will return the defaults for that property (passed in as the 3rd arg).\n// if the options object is defined, and the property exists, then it will return the defaults if the value of the property is undefined or null\nconst resolveDefaults = (obj, key, defaults) => {\n    if (!obj) {\n        return defaults;\n    }\n    if (obj[key] === undefined || obj[key] === null) {\n        return defaults;\n    }\n    return obj[key];\n};\nconst createFetchAttributes = (input, init) => {\n    const url = normalizeUrlFromInput(input);\n    const httpMethod = normalizeHttpMethod(input, init);\n    return {\n        [SEMATTRS_HTTP_METHOD]: httpMethod,\n        [SEMATTRS_HTTP_URL]: url.href,\n        [SEMATTRS_HTTP_HOST]: url.hostname,\n        [\"server.host\"]: url.hostname,\n        [\"server.port\"]: url.port,\n        [SEMATTRS_HTTP_SCHEME]: url.protocol.replace(\":\", \"\"),\n        ...accessoryAttributes({\n            items: [\n                {\n                    text: url.hostname,\n                    variant: \"normal\",\n                },\n            ],\n            style: \"codepath\",\n        }),\n    };\n};\nconst createFetchResponseAttributes = (response) => {\n    return {\n        [SEMATTRS_HTTP_STATUS_CODE]: response.status,\n        \"http.status_text\": response.statusText,\n        [SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH]: response.headers.get(\"content-length\") || \"0\",\n        ...createAttributesFromHeaders(response.headers),\n    };\n};\nconst createFetchRetryOptionsAttributes = (retry) => {\n    const byStatus = resolveDefaults(retry, \"byStatus\", defaultFetchRetryOptions.byStatus);\n    const connectionError = resolveDefaults(retry, \"connectionError\", defaultFetchRetryOptions.connectionError);\n    const timeout = resolveDefaults(retry, \"timeout\", defaultFetchRetryOptions.timeout);\n    return {\n        ...flattenAttributes(byStatus, \"retry.byStatus\"),\n        ...flattenAttributes(connectionError, \"retry.connectionError\"),\n        ...flattenAttributes(timeout, \"retry.timeout\"),\n    };\n};\nexport const retry = {\n    onThrow,\n    fetch: retryFetch,\n};\n//# sourceMappingURL=retry.js.map","import { accessoryAttributes, apiClientManager, flattenAttributes, isRequestOptions, mergeRequestOptions, } from \"@trigger.dev/core/v3\";\nimport { resolvePresignedPacketUrl } from \"@trigger.dev/core/v3/utils/ioSerialization\";\nimport { tracer } from \"./tracer.js\";\nexport const runs = {\n    replay: replayRun,\n    cancel: cancelRun,\n    retrieve: retrieveRun,\n    list: listRuns,\n    reschedule: rescheduleRun,\n    poll,\n    subscribeToRun,\n    subscribeToRunsWithTag,\n    subscribeToBatch: subscribeToRunsInBatch,\n    fetchStream,\n};\nfunction listRuns(paramsOrProjectRef, paramsOrOptions, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions);\n    if (typeof paramsOrProjectRef === \"string\") {\n        if (isRequestOptions(paramsOrOptions)) {\n            return apiClient.listProjectRuns(paramsOrProjectRef, {}, $requestOptions);\n        }\n        else {\n            return apiClient.listProjectRuns(paramsOrProjectRef, paramsOrOptions, $requestOptions);\n        }\n    }\n    return apiClient.listRuns(paramsOrProjectRef, $requestOptions);\n}\nfunction listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions) {\n    if (typeof paramsOrProjectRef === \"string\") {\n        if (isRequestOptions(paramsOrOptions)) {\n            return mergeRequestOptions({\n                tracer,\n                name: \"runs.list()\",\n                icon: \"runs\",\n                attributes: {\n                    projectRef: paramsOrProjectRef,\n                    ...accessoryAttributes({\n                        items: [\n                            {\n                                text: paramsOrProjectRef,\n                                variant: \"normal\",\n                            },\n                        ],\n                        style: \"codepath\",\n                    }),\n                },\n            }, paramsOrOptions);\n        }\n        else {\n            return mergeRequestOptions({\n                tracer,\n                name: \"runs.list()\",\n                icon: \"runs\",\n                attributes: {\n                    projectRef: paramsOrProjectRef,\n                    ...flattenAttributes(paramsOrOptions, \"queryParams\"),\n                    ...accessoryAttributes({\n                        items: [\n                            {\n                                text: paramsOrProjectRef,\n                                variant: \"normal\",\n                            },\n                        ],\n                        style: \"codepath\",\n                    }),\n                },\n            }, requestOptions);\n        }\n    }\n    return mergeRequestOptions({\n        tracer,\n        name: \"runs.list()\",\n        icon: \"runs\",\n        attributes: {\n            ...flattenAttributes(paramsOrProjectRef, \"queryParams\"),\n        },\n    }, isRequestOptions(paramsOrOptions) ? paramsOrOptions : requestOptions);\n}\nfunction retrieveRun(runId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"runs.retrieve()\",\n        icon: \"runs\",\n        attributes: {\n            runId: typeof runId === \"string\" ? runId : runId.id,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: typeof runId === \"string\" ? runId : runId.id,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n        prepareData: resolvePayloadAndOutputUrls,\n    }, requestOptions);\n    const $runId = typeof runId === \"string\" ? runId : runId.id;\n    return apiClient.retrieveRun($runId, $requestOptions);\n}\nasync function resolvePayloadAndOutputUrls(run) {\n    const resolvedRun = { ...run };\n    if (run.payloadPresignedUrl && run.outputPresignedUrl) {\n        const [payload, output] = await Promise.all([\n            resolvePresignedPacketUrl(run.payloadPresignedUrl, tracer),\n            resolvePresignedPacketUrl(run.outputPresignedUrl, tracer),\n        ]);\n        resolvedRun.payload = payload;\n        resolvedRun.output = output;\n    }\n    else if (run.payloadPresignedUrl) {\n        resolvedRun.payload = await resolvePresignedPacketUrl(run.payloadPresignedUrl, tracer);\n    }\n    else if (run.outputPresignedUrl) {\n        resolvedRun.output = await resolvePresignedPacketUrl(run.outputPresignedUrl, tracer);\n    }\n    return resolvedRun;\n}\nfunction replayRun(runId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"runs.replay()\",\n        icon: \"runs\",\n        attributes: {\n            runId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: runId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.replayRun(runId, $requestOptions);\n}\nfunction cancelRun(runId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"runs.cancel()\",\n        icon: \"runs\",\n        attributes: {\n            runId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: runId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.cancelRun(runId, $requestOptions);\n}\nfunction rescheduleRun(runId, body, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"runs.reschedule()\",\n        icon: \"runs\",\n        attributes: {\n            runId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: runId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.rescheduleRun(runId, body, $requestOptions);\n}\nconst MAX_POLL_ATTEMPTS = 500;\nasync function poll(runId, options, requestOptions) {\n    let attempts = 0;\n    while (attempts++ < MAX_POLL_ATTEMPTS) {\n        const run = await runs.retrieve(runId, requestOptions);\n        if (run.isCompleted) {\n            return run;\n        }\n        await new Promise((resolve) => setTimeout(resolve, options?.pollIntervalMs ?? 1000));\n    }\n    throw new Error(`Run ${typeof runId === \"string\" ? runId : runId.id} did not complete after ${MAX_POLL_ATTEMPTS} attempts`);\n}\n/**\n * Subscribes to real-time updates for a specific run.\n *\n * This function allows you to receive real-time updates whenever a run changes, including:\n * - Status changes in the run lifecycle\n * - Tag additions or removals\n * - Metadata updates\n *\n * @template TRunId - The type parameter extending AnyRunHandle, AnyTask, or string\n * @param {RunId<TRunId>} runId - The ID of the run to subscribe to. Can be a string ID, RunHandle, or Task\n * @param {SubscribeToRunOptions} [options] - Optional configuration for the subscription\n * @param {boolean} [options.stopOnCompletion=true] - Whether to close the subscription when the run completes\n * @returns {RunSubscription<InferRunTypes<TRunId>>} An async iterator that yields updated run objects\n *\n * @example\n * ```ts\n * // Subscribe using a run handle\n * const handle = await tasks.trigger(\"my-task\", { some: \"data\" });\n * for await (const run of runs.subscribeToRun(handle.id)) {\n *   console.log(\"Run updated:\", run);\n * }\n *\n * // Subscribe with type safety\n * for await (const run of runs.subscribeToRun<typeof myTask>(runId)) {\n *   console.log(\"Payload:\", run.payload.some);\n *   if (run.output) {\n *     console.log(\"Output:\", run.output);\n *   }\n * }\n * ```\n */\nfunction subscribeToRun(runId, options) {\n    const $runId = typeof runId === \"string\" ? runId : runId.id;\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.subscribeToRun($runId, {\n        closeOnComplete: typeof options?.stopOnCompletion === \"boolean\" ? options.stopOnCompletion : true,\n    });\n}\n/**\n * Subscribes to real-time updates for all runs that have specific tags.\n *\n * This function allows you to monitor multiple runs simultaneously by filtering on tags.\n * You'll receive updates whenever any run with the specified tag(s) changes.\n *\n * @template TTasks - The type parameter extending AnyTask for type-safe payload and output\n * @param {string | string[]} tag - A single tag or array of tags to filter runs\n * @returns {RunSubscription<InferRunTypes<TTasks>>} An async iterator that yields updated run objects\n *\n * @example\n * ```ts\n * // Subscribe to runs with a single tag\n * for await (const run of runs.subscribeToRunsWithTag(\"user:1234\")) {\n *   console.log(\"Run updated:\", run);\n * }\n *\n * // Subscribe with multiple tags and type safety\n * for await (const run of runs.subscribeToRunsWithTag<typeof myTask | typeof otherTask>([\"tag1\", \"tag2\"])) {\n *   switch (run.taskIdentifier) {\n *     case \"my-task\":\n *       console.log(\"MyTask output:\", run.output.foo);\n *       break;\n *     case \"other-task\":\n *       console.log(\"OtherTask output:\", run.output.bar);\n *       break;\n *   }\n * }\n * ```\n */\nfunction subscribeToRunsWithTag(tag) {\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.subscribeToRunsWithTag(tag);\n}\n/**\n * Subscribes to real-time updates for all runs within a specific batch.\n *\n * Use this function when you've triggered multiple runs using `batchTrigger` and want\n * to monitor all runs in that batch. You'll receive updates whenever any run in the batch changes.\n *\n * @template TTasks - The type parameter extending AnyTask for type-safe payload and output\n * @param {string} batchId - The ID of the batch to subscribe to\n * @returns {RunSubscription<InferRunTypes<TTasks>>} An async iterator that yields updated run objects\n *\n * @example\n * ```ts\n * // Subscribe to all runs in a batch\n * for await (const run of runs.subscribeToRunsInBatch(\"batch-123\")) {\n *   console.log(\"Batch run updated:\", run);\n * }\n *\n * // Subscribe with type safety\n * for await (const run of runs.subscribeToRunsInBatch<typeof myTask>(\"batch-123\")) {\n *   console.log(\"Run payload:\", run.payload);\n *   if (run.output) {\n *     console.log(\"Run output:\", run.output);\n *   }\n * }\n * ```\n *\n * @note The run objects received will include standard fields like id, status, payload, output,\n * createdAt, updatedAt, tags, and more. See the Run object documentation for full details.\n */\nfunction subscribeToRunsInBatch(batchId) {\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.subscribeToBatch(batchId);\n}\n/**\n * Fetches a stream of data from a run's stream key.\n */\nasync function fetchStream(runId, streamKey) {\n    const apiClient = apiClientManager.clientOrThrow();\n    return await apiClient.fetchStream(runId, streamKey);\n}\n//# sourceMappingURL=runs.js.map","import { SpanKind } from \"@opentelemetry/api\";\nimport { accessoryAttributes, apiClientManager, conditionallyImportPacket, convertToolParametersToSchema, createErrorTaskError, defaultRetryOptions, getSchemaParseFn, makeIdempotencyKey, parsePacket, runtime, SemanticInternalAttributes, stringifyIO, SubtaskUnwrapError, taskCatalog, taskContext, TaskRunPromise, getEnvVar, } from \"@trigger.dev/core/v3\";\nimport { runs } from \"./runs.js\";\nimport { tracer } from \"./tracer.js\";\nexport { SubtaskUnwrapError, TaskRunPromise };\nexport function queue(options) {\n    return options;\n}\nexport function createTask(params) {\n    const customQueue = params.queue\n        ? queue({\n            name: params.queue?.name ?? `task/${params.id}`,\n            ...params.queue,\n        })\n        : undefined;\n    const task = {\n        id: params.id,\n        description: params.description,\n        trigger: async (payload, options) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return await trigger_internal(taskMetadata && taskMetadata.exportName\n                ? `${taskMetadata.exportName}.trigger()`\n                : `trigger()`, params.id, payload, undefined, {\n                queue: customQueue,\n                ...options,\n            });\n        },\n        batchTrigger: async (items, options) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return await batchTrigger_internal(taskMetadata && taskMetadata.exportName\n                ? `${taskMetadata.exportName}.batchTrigger()`\n                : `batchTrigger()`, params.id, items, options, undefined, undefined, customQueue);\n        },\n        triggerAndWait: (payload, options) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return new TaskRunPromise((resolve, reject) => {\n                triggerAndWait_internal(taskMetadata && taskMetadata.exportName\n                    ? `${taskMetadata.exportName}.triggerAndWait()`\n                    : `triggerAndWait()`, params.id, payload, undefined, {\n                    queue: customQueue,\n                    ...options,\n                })\n                    .then((result) => {\n                    resolve(result);\n                })\n                    .catch((error) => {\n                    reject(error);\n                });\n            }, params.id);\n        },\n        batchTriggerAndWait: async (items, options) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return await batchTriggerAndWait_internal(taskMetadata && taskMetadata.exportName\n                ? `${taskMetadata.exportName}.batchTriggerAndWait()`\n                : `batchTriggerAndWait()`, params.id, items, undefined, options, undefined, customQueue);\n        },\n    };\n    taskCatalog.registerTaskMetadata({\n        id: params.id,\n        description: params.description,\n        queue: params.queue,\n        retry: params.retry ? { ...defaultRetryOptions, ...params.retry } : undefined,\n        machine: typeof params.machine === \"string\" ? { preset: params.machine } : params.machine,\n        maxDuration: params.maxDuration,\n        fns: {\n            run: params.run,\n            init: params.init,\n            cleanup: params.cleanup,\n            middleware: params.middleware,\n            handleError: params.handleError,\n            onSuccess: params.onSuccess,\n            onFailure: params.onFailure,\n            onStart: params.onStart,\n        },\n    });\n    // @ts-expect-error\n    task[Symbol.for(\"trigger.dev/task\")] = true;\n    return task;\n}\nexport function createToolTask(params) {\n    const task = createSchemaTask({\n        ...params,\n        schema: convertToolParametersToSchema(params.parameters),\n    });\n    return {\n        ...task,\n        tool: {\n            parameters: params.parameters,\n            description: params.description,\n            execute: async (args) => {\n                return task.triggerAndWait(args).unwrap();\n            },\n        },\n    };\n}\nexport function createSchemaTask(params) {\n    const customQueue = params.queue\n        ? queue({\n            name: params.queue?.name ?? `task/${params.id}`,\n            ...params.queue,\n        })\n        : undefined;\n    const parsePayload = params.schema\n        ? getSchemaParseFn(params.schema)\n        : undefined;\n    const task = {\n        id: params.id,\n        description: params.description,\n        schema: params.schema,\n        trigger: async (payload, options, requestOptions) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return await trigger_internal(taskMetadata && taskMetadata.exportName\n                ? `${taskMetadata.exportName}.trigger()`\n                : `trigger()`, params.id, payload, parsePayload, {\n                queue: customQueue,\n                ...options,\n            }, requestOptions);\n        },\n        batchTrigger: async (items, options, requestOptions) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return await batchTrigger_internal(taskMetadata && taskMetadata.exportName\n                ? `${taskMetadata.exportName}.batchTrigger()`\n                : `batchTrigger()`, params.id, items, options, parsePayload, requestOptions, customQueue);\n        },\n        triggerAndWait: (payload, options) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return new TaskRunPromise((resolve, reject) => {\n                triggerAndWait_internal(taskMetadata && taskMetadata.exportName\n                    ? `${taskMetadata.exportName}.triggerAndWait()`\n                    : `triggerAndWait()`, params.id, payload, parsePayload, {\n                    queue: customQueue,\n                    ...options,\n                })\n                    .then((result) => {\n                    resolve(result);\n                })\n                    .catch((error) => {\n                    reject(error);\n                });\n            }, params.id);\n        },\n        batchTriggerAndWait: async (items, options) => {\n            const taskMetadata = taskCatalog.getTaskManifest(params.id);\n            return await batchTriggerAndWait_internal(taskMetadata && taskMetadata.exportName\n                ? `${taskMetadata.exportName}.batchTriggerAndWait()`\n                : `batchTriggerAndWait()`, params.id, items, parsePayload, options, undefined, customQueue);\n        },\n    };\n    taskCatalog.registerTaskMetadata({\n        id: params.id,\n        description: params.description,\n        queue: params.queue,\n        retry: params.retry ? { ...defaultRetryOptions, ...params.retry } : undefined,\n        machine: typeof params.machine === \"string\" ? { preset: params.machine } : params.machine,\n        maxDuration: params.maxDuration,\n        fns: {\n            run: params.run,\n            init: params.init,\n            cleanup: params.cleanup,\n            middleware: params.middleware,\n            handleError: params.handleError,\n            onSuccess: params.onSuccess,\n            onFailure: params.onFailure,\n            onStart: params.onStart,\n            parsePayload,\n        },\n    });\n    // @ts-expect-error\n    task[Symbol.for(\"trigger.dev/task\")] = true;\n    return task;\n}\n/**\n * Trigger a task by its identifier with the given payload. Returns a typesafe `RunHandle`.\n *\n * @example\n *\n * ```ts\n * import { tasks, runs } from \"@trigger.dev/sdk/v3\";\n * import type { myTask } from \"./myTasks\"; // Import just the type of the task\n *\n * const handle = await tasks.trigger<typeof myTask>(\"my-task\", { foo: \"bar\" }); // The id and payload are fully typesafe\n * const run = await runs.retrieve(handle);\n * console.log(run.output) // The output is also fully typed\n * ```\n *\n * @returns {RunHandle} An object with the `id` of the run. Can be used to retrieve the completed run output in a typesafe manner.\n */\nexport async function trigger(id, payload, options, requestOptions) {\n    return await trigger_internal(\"tasks.trigger()\", id, payload, undefined, options, requestOptions);\n}\n/**\n * Trigger a task with the given payload, and wait for the result. Returns the result of the task run\n * @param id - The id of the task to trigger\n * @param payload\n * @param options - Options for the task run\n * @returns TaskRunResult\n * @example\n * ```ts\n * import { tasks } from \"@trigger.dev/sdk/v3\";\n * const result = await tasks.triggerAndWait(\"my-task\", { foo: \"bar\" });\n *\n * if (result.ok) {\n *  console.log(result.output);\n * } else {\n *  console.error(result.error);\n * }\n * ```\n */\nexport function triggerAndWait(id, payload, options, requestOptions) {\n    return new TaskRunPromise((resolve, reject) => {\n        triggerAndWait_internal(\"tasks.triggerAndWait()\", id, payload, undefined, options, requestOptions)\n            .then((result) => {\n            resolve(result);\n        })\n            .catch((error) => {\n            reject(error);\n        });\n    }, id);\n}\n/**\n * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.\n * @param id - The id of the task to trigger\n * @param items\n * @returns BatchResult\n * @example\n *\n * ```ts\n * import { tasks } from \"@trigger.dev/sdk/v3\";\n *\n * const result = await tasks.batchTriggerAndWait(\"my-task\", [\n *  { payload: { foo: \"bar\" } },\n *  { payload: { foo: \"baz\" } },\n * ]);\n *\n * for (const run of result.runs) {\n *  if (run.ok) {\n *    console.log(run.output);\n *  } else {\n *    console.error(run.error);\n *  }\n * }\n * ```\n */\nexport async function batchTriggerAndWait(id, items, options, requestOptions) {\n    return await batchTriggerAndWait_internal(\"tasks.batchTriggerAndWait()\", id, items, undefined, options, requestOptions);\n}\n/**\n * Trigger a task by its identifier with the given payload and poll until the run is completed.\n *\n * @example\n *\n * ```ts\n * import { tasks, runs } from \"@trigger.dev/sdk/v3\";\n * import type { myTask } from \"./myTasks\"; // Import just the type of the task\n *\n * const run = await tasks.triggerAndPoll<typeof myTask>(\"my-task\", { foo: \"bar\" }); // The id and payload are fully typesafe\n * console.log(run.output) // The output is also fully typed\n * ```\n *\n * @returns {Run} The completed run, either successful or failed.\n */\nexport async function triggerAndPoll(id, payload, options, requestOptions) {\n    const handle = await trigger(id, payload, options, requestOptions);\n    return runs.poll(handle, options, requestOptions);\n}\nexport async function batchTrigger(id, items, options, requestOptions) {\n    return await batchTrigger_internal(\"tasks.batchTrigger()\", id, items, options, undefined, requestOptions);\n}\n/**\n * Triggers multiple runs of different tasks with specified payloads and options.\n *\n * @template TTask - The type of task(s) to be triggered, extends AnyTask\n *\n * @param {Array<BatchByIdItem<InferRunTypes<TTask>>>} items - Array of task items to trigger\n * @param {BatchTriggerOptions} [options] - Optional batch-level trigger options\n * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration\n *\n * @returns {Promise<BatchRunHandleFromTypes<InferRunTypes<TTask>>>} A promise that resolves with the batch run handle\n * containing batch ID, cached status, idempotency info, runs, and public access token\n *\n * @example\n * ```ts\n * import { batch } from \"@trigger.dev/sdk/v3\";\n * import type { myTask1, myTask2 } from \"~/trigger/myTasks\";\n *\n * // Trigger multiple tasks with different payloads\n * const result = await batch.trigger<typeof myTask1 | typeof myTask2>([\n *   {\n *     id: \"my-task-1\",\n *     payload: { some: \"data\" },\n *     options: {\n *       queue: \"default\",\n *       concurrencyKey: \"key\",\n *       idempotencyKey: \"unique-key\",\n *       delay: \"5m\",\n *       tags: [\"tag1\", \"tag2\"]\n *     }\n *   },\n *   {\n *     id: \"my-task-2\",\n *     payload: { other: \"data\" }\n *   }\n * ]);\n * ```\n *\n * @description\n * Each task item in the array can include:\n * - `id`: The unique identifier of the task\n * - `payload`: The data to pass to the task\n * - `options`: Optional task-specific settings including:\n *   - `queue`: Specify a queue for the task\n *   - `concurrencyKey`: Control concurrent execution\n *   - `idempotencyKey`: Prevent duplicate runs\n *   - `idempotencyKeyTTL`: Time-to-live for idempotency key\n *   - `delay`: Delay before task execution\n *   - `ttl`: Time-to-live for the task\n *   - `tags`: Array of tags for the task\n *   - `maxAttempts`: Maximum retry attempts\n *   - `metadata`: Additional metadata\n *   - `maxDuration`: Maximum execution duration\n */\nexport async function batchTriggerById(items, options, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const response = await apiClient.batchTriggerV2({\n        items: await Promise.all(items.map(async (item) => {\n            const taskMetadata = taskCatalog.getTask(item.id);\n            const parsedPayload = taskMetadata?.fns.parsePayload\n                ? await taskMetadata?.fns.parsePayload(item.payload)\n                : item.payload;\n            const payloadPacket = await stringifyIO(parsedPayload);\n            return {\n                task: item.id,\n                payload: payloadPacket.data,\n                options: {\n                    queue: item.options?.queue,\n                    concurrencyKey: item.options?.concurrencyKey,\n                    test: taskContext.ctx?.run.isTest,\n                    payloadType: payloadPacket.dataType,\n                    idempotencyKey: await makeIdempotencyKey(item.options?.idempotencyKey),\n                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL,\n                    delay: item.options?.delay,\n                    ttl: item.options?.ttl,\n                    tags: item.options?.tags,\n                    maxAttempts: item.options?.maxAttempts,\n                    parentAttempt: taskContext.ctx?.attempt.id,\n                    metadata: item.options?.metadata,\n                    maxDuration: item.options?.maxDuration,\n                    machine: item.options?.machine,\n                    lockToVersion: item.options?.version ?? getEnvVar(\"TRIGGER_VERSION\"),\n                },\n            };\n        })),\n    }, {\n        spanParentAsLink: true,\n        idempotencyKey: await makeIdempotencyKey(options?.idempotencyKey),\n        idempotencyKeyTTL: options?.idempotencyKeyTTL,\n        processingStrategy: options?.triggerSequentially ? \"sequential\" : undefined,\n    }, {\n        name: \"batch.trigger()\",\n        tracer,\n        icon: \"trigger\",\n        onResponseBody(body, span) {\n            if (body && typeof body === \"object\" && !Array.isArray(body)) {\n                if (\"id\" in body && typeof body.id === \"string\") {\n                    span.setAttribute(\"batchId\", body.id);\n                }\n                if (\"runs\" in body && Array.isArray(body.runs)) {\n                    span.setAttribute(\"runCount\", body.runs.length);\n                }\n                if (\"isCached\" in body && typeof body.isCached === \"boolean\") {\n                    if (body.isCached) {\n                        console.warn(`Result is a cached response because the request was idempotent.`);\n                    }\n                    span.setAttribute(\"isCached\", body.isCached);\n                }\n                if (\"idempotencyKey\" in body && typeof body.idempotencyKey === \"string\") {\n                    span.setAttribute(\"idempotencyKey\", body.idempotencyKey);\n                }\n            }\n        },\n        ...requestOptions,\n    });\n    const handle = {\n        batchId: response.id,\n        isCached: response.isCached,\n        idempotencyKey: response.idempotencyKey,\n        runs: response.runs,\n        publicAccessToken: response.publicAccessToken,\n    };\n    return handle;\n}\n/**\n * Triggers multiple tasks and waits for all of them to complete before returning their results.\n * This function must be called from within a task.run() context.\n *\n * @template TTask - Union type of tasks to be triggered, extends AnyTask\n *\n * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger\n * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration\n *\n * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including\n * success/failure status and strongly-typed outputs for each task\n *\n * @throws {Error} If called outside of a task.run() context\n * @throws {Error} If no API client is configured\n *\n * @example\n * ```ts\n * import { batch, task } from \"@trigger.dev/sdk/v3\";\n *\n * export const parentTask = task({\n *   id: \"parent-task\",\n *   run: async (payload: string) => {\n *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([\n *       {\n *         id: \"child-task-1\",\n *         payload: { foo: \"World\" },\n *         options: {\n *           queue: \"default\",\n *           delay: \"5m\",\n *           tags: [\"batch\", \"child1\"]\n *         }\n *       },\n *       {\n *         id: \"child-task-2\",\n *         payload: { bar: 42 }\n *       }\n *     ]);\n *\n *     // Type-safe result handling\n *     for (const result of results) {\n *       if (result.ok) {\n *         switch (result.taskIdentifier) {\n *           case \"child-task-1\":\n *             console.log(\"Child task 1 output:\", result.output); // string type\n *             break;\n *           case \"child-task-2\":\n *             console.log(\"Child task 2 output:\", result.output); // number type\n *             break;\n *         }\n *       } else {\n *         console.error(\"Task failed:\", result.error);\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @description\n * Each task item in the array can include:\n * - `id`: The task identifier (must match one of the tasks in the union type)\n * - `payload`: Strongly-typed payload matching the task's input type\n * - `options`: Optional task-specific settings including:\n *   - `queue`: Specify a queue for the task\n *   - `concurrencyKey`: Control concurrent execution\n *   - `delay`: Delay before task execution\n *   - `ttl`: Time-to-live for the task\n *   - `tags`: Array of tags for the task\n *   - `maxAttempts`: Maximum retry attempts\n *   - `metadata`: Additional metadata\n *   - `maxDuration`: Maximum execution duration\n *\n * The function provides full type safety for:\n * - Task IDs\n * - Payload types\n * - Return value types\n * - Error handling\n */\nexport async function batchTriggerByIdAndWait(items, options, requestOptions) {\n    const ctx = taskContext.ctx;\n    if (!ctx) {\n        throw new Error(\"batchTriggerAndWait can only be used from inside a task.run()\");\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return await tracer.startActiveSpan(\"batch.triggerAndWait()\", async (span) => {\n        const response = await apiClient.batchTriggerV2({\n            items: await Promise.all(items.map(async (item) => {\n                const taskMetadata = taskCatalog.getTask(item.id);\n                const parsedPayload = taskMetadata?.fns.parsePayload\n                    ? await taskMetadata?.fns.parsePayload(item.payload)\n                    : item.payload;\n                const payloadPacket = await stringifyIO(parsedPayload);\n                return {\n                    task: item.id,\n                    payload: payloadPacket.data,\n                    options: {\n                        lockToVersion: taskContext.worker?.version,\n                        queue: item.options?.queue,\n                        concurrencyKey: item.options?.concurrencyKey,\n                        test: taskContext.ctx?.run.isTest,\n                        payloadType: payloadPacket.dataType,\n                        delay: item.options?.delay,\n                        ttl: item.options?.ttl,\n                        tags: item.options?.tags,\n                        maxAttempts: item.options?.maxAttempts,\n                        metadata: item.options?.metadata,\n                        maxDuration: item.options?.maxDuration,\n                        machine: item.options?.machine,\n                    },\n                };\n            })),\n            dependentAttempt: ctx.attempt.id,\n        }, {\n            processingStrategy: options?.triggerSequentially ? \"sequential\" : undefined,\n        }, requestOptions);\n        span.setAttribute(\"batchId\", response.id);\n        span.setAttribute(\"runCount\", response.runs.length);\n        span.setAttribute(\"isCached\", response.isCached);\n        if (response.isCached) {\n            console.warn(`Result is a cached response because the request was idempotent.`);\n        }\n        if (response.idempotencyKey) {\n            span.setAttribute(\"idempotencyKey\", response.idempotencyKey);\n        }\n        const result = await runtime.waitForBatch({\n            id: response.id,\n            runs: response.runs.map((run) => run.id),\n            ctx,\n        });\n        const runs = await handleBatchTaskRunExecutionResultV2(result.items);\n        return {\n            id: result.id,\n            runs,\n        };\n    }, {\n        kind: SpanKind.PRODUCER,\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"trigger\",\n        },\n    });\n}\n/**\n * Triggers multiple tasks and waits for all of them to complete before returning their results.\n * This function must be called from within a task.run() context.\n *\n * @template TTask - Union type of tasks to be triggered, extends AnyTask\n *\n * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger\n * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration\n *\n * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including\n * success/failure status and strongly-typed outputs for each task\n *\n * @throws {Error} If called outside of a task.run() context\n * @throws {Error} If no API client is configured\n *\n * @example\n * ```ts\n * import { batch, task } from \"@trigger.dev/sdk/v3\";\n *\n * export const parentTask = task({\n *   id: \"parent-task\",\n *   run: async (payload: string) => {\n *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([\n *       {\n *         id: \"child-task-1\",\n *         payload: { foo: \"World\" },\n *         options: {\n *           queue: \"default\",\n *           delay: \"5m\",\n *           tags: [\"batch\", \"child1\"]\n *         }\n *       },\n *       {\n *         id: \"child-task-2\",\n *         payload: { bar: 42 }\n *       }\n *     ]);\n *\n *     // Type-safe result handling\n *     for (const result of results) {\n *       if (result.ok) {\n *         switch (result.taskIdentifier) {\n *           case \"child-task-1\":\n *             console.log(\"Child task 1 output:\", result.output); // string type\n *             break;\n *           case \"child-task-2\":\n *             console.log(\"Child task 2 output:\", result.output); // number type\n *             break;\n *         }\n *       } else {\n *         console.error(\"Task failed:\", result.error);\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @description\n * Each task item in the array can include:\n * - `id`: The task identifier (must match one of the tasks in the union type)\n * - `payload`: Strongly-typed payload matching the task's input type\n * - `options`: Optional task-specific settings including:\n *   - `queue`: Specify a queue for the task\n *   - `concurrencyKey`: Control concurrent execution\n *   - `delay`: Delay before task execution\n *   - `ttl`: Time-to-live for the task\n *   - `tags`: Array of tags for the task\n *   - `maxAttempts`: Maximum retry attempts\n *   - `metadata`: Additional metadata\n *   - `maxDuration`: Maximum execution duration\n *\n * The function provides full type safety for:\n * - Task IDs\n * - Payload types\n * - Return value types\n * - Error handling\n */\nexport async function batchTriggerTasks(items, options, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const response = await apiClient.batchTriggerV2({\n        items: await Promise.all(items.map(async (item) => {\n            const taskMetadata = taskCatalog.getTask(item.task.id);\n            const parsedPayload = taskMetadata?.fns.parsePayload\n                ? await taskMetadata?.fns.parsePayload(item.payload)\n                : item.payload;\n            const payloadPacket = await stringifyIO(parsedPayload);\n            return {\n                task: item.task.id,\n                payload: payloadPacket.data,\n                options: {\n                    queue: item.options?.queue,\n                    concurrencyKey: item.options?.concurrencyKey,\n                    test: taskContext.ctx?.run.isTest,\n                    payloadType: payloadPacket.dataType,\n                    idempotencyKey: await makeIdempotencyKey(item.options?.idempotencyKey),\n                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL,\n                    delay: item.options?.delay,\n                    ttl: item.options?.ttl,\n                    tags: item.options?.tags,\n                    maxAttempts: item.options?.maxAttempts,\n                    parentAttempt: taskContext.ctx?.attempt.id,\n                    metadata: item.options?.metadata,\n                    maxDuration: item.options?.maxDuration,\n                    machine: item.options?.machine,\n                    lockToVersion: item.options?.version ?? getEnvVar(\"TRIGGER_VERSION\"),\n                },\n            };\n        })),\n    }, {\n        spanParentAsLink: true,\n        idempotencyKey: await makeIdempotencyKey(options?.idempotencyKey),\n        idempotencyKeyTTL: options?.idempotencyKeyTTL,\n        processingStrategy: options?.triggerSequentially ? \"sequential\" : undefined,\n    }, {\n        name: \"batch.triggerByTask()\",\n        tracer,\n        icon: \"trigger\",\n        onResponseBody(body, span) {\n            if (body && typeof body === \"object\" && !Array.isArray(body)) {\n                if (\"id\" in body && typeof body.id === \"string\") {\n                    span.setAttribute(\"batchId\", body.id);\n                }\n                if (\"runs\" in body && Array.isArray(body.runs)) {\n                    span.setAttribute(\"runCount\", body.runs.length);\n                }\n                if (\"isCached\" in body && typeof body.isCached === \"boolean\") {\n                    if (body.isCached) {\n                        console.warn(`Result is a cached response because the request was idempotent.`);\n                    }\n                    span.setAttribute(\"isCached\", body.isCached);\n                }\n                if (\"idempotencyKey\" in body && typeof body.idempotencyKey === \"string\") {\n                    span.setAttribute(\"idempotencyKey\", body.idempotencyKey);\n                }\n            }\n        },\n        ...requestOptions,\n    });\n    const handle = {\n        batchId: response.id,\n        isCached: response.isCached,\n        idempotencyKey: response.idempotencyKey,\n        runs: response.runs,\n        publicAccessToken: response.publicAccessToken,\n    };\n    return handle;\n}\n/**\n * Triggers multiple tasks and waits for all of them to complete before returning their results.\n * This function must be called from within a task.run() context.\n *\n * @template TTask - Union type of tasks to be triggered, extends AnyTask\n *\n * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger\n * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration\n *\n * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including\n * success/failure status and strongly-typed outputs for each task\n *\n * @throws {Error} If called outside of a task.run() context\n * @throws {Error} If no API client is configured\n *\n * @example\n * ```ts\n * import { batch, task } from \"@trigger.dev/sdk/v3\";\n *\n * export const parentTask = task({\n *   id: \"parent-task\",\n *   run: async (payload: string) => {\n *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([\n *       {\n *         id: \"child-task-1\",\n *         payload: { foo: \"World\" },\n *         options: {\n *           queue: \"default\",\n *           delay: \"5m\",\n *           tags: [\"batch\", \"child1\"]\n *         }\n *       },\n *       {\n *         id: \"child-task-2\",\n *         payload: { bar: 42 }\n *       }\n *     ]);\n *\n *     // Type-safe result handling\n *     for (const result of results) {\n *       if (result.ok) {\n *         switch (result.taskIdentifier) {\n *           case \"child-task-1\":\n *             console.log(\"Child task 1 output:\", result.output); // string type\n *             break;\n *           case \"child-task-2\":\n *             console.log(\"Child task 2 output:\", result.output); // number type\n *             break;\n *         }\n *       } else {\n *         console.error(\"Task failed:\", result.error);\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @description\n * Each task item in the array can include:\n * - `id`: The task identifier (must match one of the tasks in the union type)\n * - `payload`: Strongly-typed payload matching the task's input type\n * - `options`: Optional task-specific settings including:\n *   - `queue`: Specify a queue for the task\n *   - `concurrencyKey`: Control concurrent execution\n *   - `delay`: Delay before task execution\n *   - `ttl`: Time-to-live for the task\n *   - `tags`: Array of tags for the task\n *   - `maxAttempts`: Maximum retry attempts\n *   - `metadata`: Additional metadata\n *   - `maxDuration`: Maximum execution duration\n *\n * The function provides full type safety for:\n * - Task IDs\n * - Payload types\n * - Return value types\n * - Error handling\n */\nexport async function batchTriggerAndWaitTasks(items, options, requestOptions) {\n    const ctx = taskContext.ctx;\n    if (!ctx) {\n        throw new Error(\"batchTriggerAndWait can only be used from inside a task.run()\");\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return await tracer.startActiveSpan(\"batch.triggerByTaskAndWait()\", async (span) => {\n        const response = await apiClient.batchTriggerV2({\n            items: await Promise.all(items.map(async (item) => {\n                const taskMetadata = taskCatalog.getTask(item.task.id);\n                const parsedPayload = taskMetadata?.fns.parsePayload\n                    ? await taskMetadata?.fns.parsePayload(item.payload)\n                    : item.payload;\n                const payloadPacket = await stringifyIO(parsedPayload);\n                return {\n                    task: item.task.id,\n                    payload: payloadPacket.data,\n                    options: {\n                        lockToVersion: taskContext.worker?.version,\n                        queue: item.options?.queue,\n                        concurrencyKey: item.options?.concurrencyKey,\n                        test: taskContext.ctx?.run.isTest,\n                        payloadType: payloadPacket.dataType,\n                        delay: item.options?.delay,\n                        ttl: item.options?.ttl,\n                        tags: item.options?.tags,\n                        maxAttempts: item.options?.maxAttempts,\n                        metadata: item.options?.metadata,\n                        maxDuration: item.options?.maxDuration,\n                        machine: item.options?.machine,\n                    },\n                };\n            })),\n            dependentAttempt: ctx.attempt.id,\n        }, {\n            processingStrategy: options?.triggerSequentially ? \"sequential\" : undefined,\n        }, requestOptions);\n        span.setAttribute(\"batchId\", response.id);\n        span.setAttribute(\"runCount\", response.runs.length);\n        span.setAttribute(\"isCached\", response.isCached);\n        if (response.isCached) {\n            console.warn(`Result is a cached response because the request was idempotent.`);\n        }\n        if (response.idempotencyKey) {\n            span.setAttribute(\"idempotencyKey\", response.idempotencyKey);\n        }\n        const result = await runtime.waitForBatch({\n            id: response.id,\n            runs: response.runs.map((run) => run.id),\n            ctx,\n        });\n        const runs = await handleBatchTaskRunExecutionResultV2(result.items);\n        return {\n            id: result.id,\n            runs,\n        };\n    }, {\n        kind: SpanKind.PRODUCER,\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"trigger\",\n        },\n    });\n}\nasync function trigger_internal(name, id, payload, parsePayload, options, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;\n    const payloadPacket = await stringifyIO(parsedPayload);\n    const handle = await apiClient.triggerTask(id, {\n        payload: payloadPacket.data,\n        options: {\n            queue: options?.queue,\n            concurrencyKey: options?.concurrencyKey,\n            test: taskContext.ctx?.run.isTest,\n            payloadType: payloadPacket.dataType,\n            idempotencyKey: await makeIdempotencyKey(options?.idempotencyKey),\n            idempotencyKeyTTL: options?.idempotencyKeyTTL,\n            delay: options?.delay,\n            ttl: options?.ttl,\n            tags: options?.tags,\n            maxAttempts: options?.maxAttempts,\n            parentAttempt: taskContext.ctx?.attempt.id,\n            metadata: options?.metadata,\n            maxDuration: options?.maxDuration,\n            machine: options?.machine,\n            lockToVersion: options?.version ?? getEnvVar(\"TRIGGER_VERSION\"),\n        },\n    }, {\n        spanParentAsLink: true,\n    }, {\n        name,\n        tracer,\n        icon: \"trigger\",\n        onResponseBody: (body, span) => {\n            if (body && typeof body === \"object\" && !Array.isArray(body)) {\n                if (\"id\" in body && typeof body.id === \"string\") {\n                    span.setAttribute(\"runId\", body.id);\n                }\n            }\n        },\n        ...requestOptions,\n    });\n    return handle;\n}\nasync function batchTrigger_internal(name, taskIdentifier, items, options, parsePayload, requestOptions, queue) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const response = await apiClient.batchTriggerV2({\n        items: await Promise.all(items.map(async (item) => {\n            const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;\n            const payloadPacket = await stringifyIO(parsedPayload);\n            return {\n                task: taskIdentifier,\n                payload: payloadPacket.data,\n                options: {\n                    queue: item.options?.queue ?? queue,\n                    concurrencyKey: item.options?.concurrencyKey,\n                    test: taskContext.ctx?.run.isTest,\n                    payloadType: payloadPacket.dataType,\n                    idempotencyKey: await makeIdempotencyKey(item.options?.idempotencyKey),\n                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL,\n                    delay: item.options?.delay,\n                    ttl: item.options?.ttl,\n                    tags: item.options?.tags,\n                    maxAttempts: item.options?.maxAttempts,\n                    parentAttempt: taskContext.ctx?.attempt.id,\n                    metadata: item.options?.metadata,\n                    maxDuration: item.options?.maxDuration,\n                    machine: item.options?.machine,\n                    lockToVersion: item.options?.version ?? getEnvVar(\"TRIGGER_VERSION\"),\n                },\n            };\n        })),\n    }, {\n        spanParentAsLink: true,\n        idempotencyKey: await makeIdempotencyKey(options?.idempotencyKey),\n        idempotencyKeyTTL: options?.idempotencyKeyTTL,\n        processingStrategy: options?.triggerSequentially ? \"sequential\" : undefined,\n    }, {\n        name,\n        tracer,\n        icon: \"trigger\",\n        onResponseBody(body, span) {\n            if (body && typeof body === \"object\" && !Array.isArray(body)) {\n                if (\"id\" in body && typeof body.id === \"string\") {\n                    span.setAttribute(\"batchId\", body.id);\n                }\n                if (\"runs\" in body && Array.isArray(body.runs)) {\n                    span.setAttribute(\"runCount\", body.runs.length);\n                }\n                if (\"isCached\" in body && typeof body.isCached === \"boolean\") {\n                    if (body.isCached) {\n                        console.warn(`Result is a cached response because the request was idempotent.`);\n                    }\n                    span.setAttribute(\"isCached\", body.isCached);\n                }\n                if (\"idempotencyKey\" in body && typeof body.idempotencyKey === \"string\") {\n                    span.setAttribute(\"idempotencyKey\", body.idempotencyKey);\n                }\n            }\n        },\n        ...requestOptions,\n    });\n    const handle = {\n        batchId: response.id,\n        isCached: response.isCached,\n        idempotencyKey: response.idempotencyKey,\n        runs: response.runs,\n        publicAccessToken: response.publicAccessToken,\n    };\n    return handle;\n}\nasync function triggerAndWait_internal(name, id, payload, parsePayload, options, requestOptions) {\n    const ctx = taskContext.ctx;\n    if (!ctx) {\n        throw new Error(\"triggerAndWait can only be used from inside a task.run()\");\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;\n    const payloadPacket = await stringifyIO(parsedPayload);\n    return await tracer.startActiveSpan(name, async (span) => {\n        const response = await apiClient.triggerTask(id, {\n            payload: payloadPacket.data,\n            options: {\n                dependentAttempt: ctx.attempt.id,\n                lockToVersion: taskContext.worker?.version, // Lock to current version because we're waiting for it to finish\n                queue: options?.queue,\n                concurrencyKey: options?.concurrencyKey,\n                test: taskContext.ctx?.run.isTest,\n                payloadType: payloadPacket.dataType,\n                delay: options?.delay,\n                ttl: options?.ttl,\n                tags: options?.tags,\n                maxAttempts: options?.maxAttempts,\n                metadata: options?.metadata,\n                maxDuration: options?.maxDuration,\n                machine: options?.machine,\n            },\n        }, {}, requestOptions);\n        span.setAttribute(\"runId\", response.id);\n        const result = await runtime.waitForTask({\n            id: response.id,\n            ctx,\n        });\n        return await handleTaskRunExecutionResult(result, id);\n    }, {\n        kind: SpanKind.PRODUCER,\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"trigger\",\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: id,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    });\n}\nasync function batchTriggerAndWait_internal(name, id, items, parsePayload, options, requestOptions, queue) {\n    const ctx = taskContext.ctx;\n    if (!ctx) {\n        throw new Error(\"batchTriggerAndWait can only be used from inside a task.run()\");\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return await tracer.startActiveSpan(name, async (span) => {\n        const response = await apiClient.batchTriggerV2({\n            items: await Promise.all(items.map(async (item) => {\n                const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;\n                const payloadPacket = await stringifyIO(parsedPayload);\n                return {\n                    task: id,\n                    payload: payloadPacket.data,\n                    options: {\n                        lockToVersion: taskContext.worker?.version,\n                        queue: item.options?.queue ?? queue,\n                        concurrencyKey: item.options?.concurrencyKey,\n                        test: taskContext.ctx?.run.isTest,\n                        payloadType: payloadPacket.dataType,\n                        delay: item.options?.delay,\n                        ttl: item.options?.ttl,\n                        tags: item.options?.tags,\n                        maxAttempts: item.options?.maxAttempts,\n                        metadata: item.options?.metadata,\n                        maxDuration: item.options?.maxDuration,\n                        machine: item.options?.machine,\n                    },\n                };\n            })),\n            dependentAttempt: ctx.attempt.id,\n        }, {\n            processingStrategy: options?.triggerSequentially ? \"sequential\" : undefined,\n        }, requestOptions);\n        span.setAttribute(\"batchId\", response.id);\n        span.setAttribute(\"runCount\", response.runs.length);\n        span.setAttribute(\"isCached\", response.isCached);\n        if (response.isCached) {\n            console.warn(`Result is a cached response because the request was idempotent.`);\n        }\n        if (response.idempotencyKey) {\n            span.setAttribute(\"idempotencyKey\", response.idempotencyKey);\n        }\n        const result = await runtime.waitForBatch({\n            id: response.id,\n            runs: response.runs.map((run) => run.id),\n            ctx,\n        });\n        const runs = await handleBatchTaskRunExecutionResult(result.items, id);\n        return {\n            id: result.id,\n            runs,\n        };\n    }, {\n        kind: SpanKind.PRODUCER,\n        attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"trigger\",\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: id,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    });\n}\nasync function handleBatchTaskRunExecutionResult(items, taskIdentifier) {\n    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === \"application/store\");\n    if (!someObjectStoreOutputs) {\n        const results = await Promise.all(items.map(async (item) => {\n            return await handleTaskRunExecutionResult(item, taskIdentifier);\n        }));\n        return results;\n    }\n    return await tracer.startActiveSpan(\"store.downloadPayloads\", async (span) => {\n        const results = await Promise.all(items.map(async (item) => {\n            return await handleTaskRunExecutionResult(item, taskIdentifier);\n        }));\n        return results;\n    }, {\n        kind: SpanKind.INTERNAL,\n        [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n    });\n}\nasync function handleBatchTaskRunExecutionResultV2(items) {\n    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === \"application/store\");\n    if (!someObjectStoreOutputs) {\n        const results = await Promise.all(items.map(async (item) => {\n            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? \"unknown\");\n        }));\n        return results;\n    }\n    return await tracer.startActiveSpan(\"store.downloadPayloads\", async (span) => {\n        const results = await Promise.all(items.map(async (item) => {\n            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? \"unknown\");\n        }));\n        return results;\n    }, {\n        kind: SpanKind.INTERNAL,\n        [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n    });\n}\nasync function handleTaskRunExecutionResult(execution, taskIdentifier) {\n    if (execution.ok) {\n        const outputPacket = { data: execution.output, dataType: execution.outputType };\n        const importedPacket = await conditionallyImportPacket(outputPacket, tracer);\n        return {\n            ok: true,\n            id: execution.id,\n            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),\n            output: await parsePacket(importedPacket),\n        };\n    }\n    else {\n        return {\n            ok: false,\n            id: execution.id,\n            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),\n            error: createErrorTaskError(execution.error),\n        };\n    }\n}\n//# sourceMappingURL=shared.js.map","import { batchTrigger, batchTriggerAndWait, createTask, createSchemaTask, createToolTask, SubtaskUnwrapError, trigger, triggerAndPoll, triggerAndWait, } from \"./shared.js\";\nexport { SubtaskUnwrapError };\n/** Creates a task that can be triggered\n * @param options - Task options\n * @example\n *\n * ```ts\n * import { task } from \"@trigger.dev/sdk/v3\";\n *\n * export const helloWorld = task({\n    id: \"hello-world\",\n *    run: async (payload: { url: string }) => {\n *    return { hello: \"world\" };\n *  },\n * });\n *\n * ```\n *\n * @returns A task that can be triggered\n */\nexport const task = createTask;\nexport const schemaTask = createSchemaTask;\nexport const toolTask = createToolTask;\nexport const tasks = {\n    trigger,\n    triggerAndPoll,\n    batchTrigger,\n    triggerAndWait,\n    batchTriggerAndWait,\n};\n//# sourceMappingURL=tasks.js.map","import { accessoryAttributes, apiClientManager, mergeRequestOptions, } from \"@trigger.dev/core/v3\";\nimport { batchTriggerById, batchTriggerByIdAndWait, batchTriggerTasks, batchTriggerAndWaitTasks, } from \"./shared.js\";\nimport { tracer } from \"./tracer.js\";\nexport const batch = {\n    trigger: batchTriggerById,\n    triggerAndWait: batchTriggerByIdAndWait,\n    triggerByTask: batchTriggerTasks,\n    triggerByTaskAndWait: batchTriggerAndWaitTasks,\n    retrieve: retrieveBatch,\n};\n/**\n * Retrieves details about a specific batch by its ID.\n *\n * @param {string} batchId - The unique identifier of the batch to retrieve\n * @param {ApiRequestOptions} [requestOptions] - Optional API request configuration options\n * @returns {ApiPromise<RetrieveBatchResponse>} A promise that resolves with the batch details\n *\n * @example\n * // First trigger a batch\n * const response = await batch.trigger([\n *   { id: \"simple-task\", payload: { message: \"Hello, World!\" } }\n * ]);\n *\n * // Then retrieve the batch details\n * const batchDetails = await batch.retrieve(response.batchId);\n * console.log(\"batch\", batchDetails);\n */\nfunction retrieveBatch(batchId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"batch.retrieve()\",\n        icon: \"batch\",\n        attributes: {\n            batchId: batchId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: batchId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.retrieveBatch(batchId, $requestOptions);\n}\n//# sourceMappingURL=batch.js.map","import { SemanticInternalAttributes, accessoryAttributes, runtime } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer.js\";\nexport const wait = {\n    for: async (options) => {\n        return tracer.startActiveSpan(`wait.for()`, async (span) => {\n            const start = Date.now();\n            const durationInMs = calculateDurationInMs(options);\n            await runtime.waitForDuration(durationInMs);\n        }, {\n            attributes: {\n                [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n                ...accessoryAttributes({\n                    items: [\n                        {\n                            text: nameForWaitOptions(options),\n                            variant: \"normal\",\n                        },\n                    ],\n                    style: \"codepath\",\n                }),\n            },\n        });\n    },\n    until: async (options) => {\n        return tracer.startActiveSpan(`wait.until()`, async (span) => {\n            const start = Date.now();\n            if (options.throwIfInThePast && options.date < new Date()) {\n                throw new Error(\"Date is in the past\");\n            }\n            const durationInMs = options.date.getTime() - start;\n            await runtime.waitForDuration(durationInMs);\n        }, {\n            attributes: {\n                [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n                ...accessoryAttributes({\n                    items: [\n                        {\n                            text: options.date.toISOString(),\n                            variant: \"normal\",\n                        },\n                    ],\n                    style: \"codepath\",\n                }),\n            },\n        });\n    },\n};\nfunction nameForWaitOptions(options) {\n    if (\"seconds\" in options) {\n        return options.seconds === 1 ? `1 second` : `${options.seconds} seconds`;\n    }\n    if (\"minutes\" in options) {\n        return options.minutes === 1 ? `1 minute` : `${options.minutes} minutes`;\n    }\n    if (\"hours\" in options) {\n        return options.hours === 1 ? `1 hour` : `${options.hours} hours`;\n    }\n    if (\"days\" in options) {\n        return options.days === 1 ? `1 day` : `${options.days} days`;\n    }\n    if (\"weeks\" in options) {\n        return options.weeks === 1 ? `1 week` : `${options.weeks} weeks`;\n    }\n    if (\"months\" in options) {\n        return options.months === 1 ? `1 month` : `${options.months} months`;\n    }\n    if (\"years\" in options) {\n        return options.years === 1 ? `1 year` : `${options.years} years`;\n    }\n    return \"NaN\";\n}\nfunction calculateDurationInMs(options) {\n    if (\"seconds\" in options) {\n        return options.seconds * 1000;\n    }\n    if (\"minutes\" in options) {\n        return options.minutes * 1000 * 60;\n    }\n    if (\"hours\" in options) {\n        return options.hours * 1000 * 60 * 60;\n    }\n    if (\"days\" in options) {\n        return options.days * 1000 * 60 * 60 * 24;\n    }\n    if (\"weeks\" in options) {\n        return options.weeks * 1000 * 60 * 60 * 24 * 7;\n    }\n    if (\"months\" in options) {\n        return options.months * 1000 * 60 * 60 * 24 * 30;\n    }\n    if (\"years\" in options) {\n        return options.years * 1000 * 60 * 60 * 24 * 365;\n    }\n    throw new Error(\"Invalid options\");\n}\n//# sourceMappingURL=wait.js.map","import { waitUntil as core_waitUntil } from \"@trigger.dev/core/v3\";\n/**\n * waitUntil extends the lifetime of a task run until the provided promise settles.\n * You can use this function to ensure that a task run does not complete until the promise resolves or rejects.\n *\n * Useful if you need to make sure something happens but you wait to continue doing other work in the task run.\n *\n * @param promise - The promise to wait for.\n */\nexport function waitUntil(promise) {\n    return core_waitUntil.register({ promise, requiresResolving: () => true });\n}\n//# sourceMappingURL=waitUntil.js.map","import { usage as usageApi, taskContext } from \"@trigger.dev/core/v3\";\nexport const usage = {\n    /**\n     * Get the current running usage of this task run.\n     *\n     * @example\n     *\n     * ```typescript\n     * import { usage, task } from \"@trigger.dev/sdk/v3\";\n     *\n     * export const myTask = task({\n     *  id: \"my-task\",\n     *  run: async (payload, { ctx }) => {\n     *   // ... Do a bunch of work\n     *\n     *   const currentUsage = usage.getCurrent();\n     *\n     *   // You have access to the current compute cost and duration up to this point\n     *   console.log(\"Current attempt compute cost and duration\", {\n     *     cost: currentUsage.compute.attempt.costInCents,\n     *     duration: currentUsage.compute.attempt.durationMs,\n     *   });\n     *\n     *   // You also can see the total compute cost and duration up to this point in the run, across all attempts\n     *   console.log(\"Current total compute cost and duration\", {\n     *     cost: currentUsage.compute.total.costInCents,\n     *     duration: currentUsage.compute.total.durationMs,\n     *   });\n     *\n     *   // You can see the base cost of the run, which is the cost of the run before any compute costs\n     *   console.log(\"Total cost\", {\n     *     cost: currentUsage.totalCostInCents,\n     *     baseCost: currentUsage.baseCostInCents,\n     *   });\n     *  },\n     * });\n     * ```\n     */\n    getCurrent: () => {\n        const sample = usageApi.sample();\n        const machine = taskContext.ctx?.machine;\n        const run = taskContext.ctx?.run;\n        if (!sample) {\n            return {\n                compute: {\n                    attempt: {\n                        costInCents: 0,\n                        durationMs: 0,\n                    },\n                    total: {\n                        costInCents: run?.costInCents ?? 0,\n                        durationMs: run?.durationMs ?? 0,\n                    },\n                },\n                baseCostInCents: run?.baseCostInCents ?? 0,\n                totalCostInCents: (run?.costInCents ?? 0) + (run?.baseCostInCents ?? 0),\n            };\n        }\n        const currentCostInCents = machine?.centsPerMs ? sample.cpuTime * machine.centsPerMs : 0;\n        return {\n            compute: {\n                attempt: {\n                    costInCents: currentCostInCents,\n                    durationMs: sample.cpuTime,\n                },\n                total: {\n                    costInCents: (run?.costInCents ?? 0) + currentCostInCents,\n                    durationMs: (run?.durationMs ?? 0) + sample.cpuTime,\n                },\n            },\n            baseCostInCents: run?.baseCostInCents ?? 0,\n            totalCostInCents: (run?.costInCents ?? 0) + currentCostInCents + (run?.baseCostInCents ?? 0),\n        };\n    },\n    /**\n     * Measure the cost and duration of a function.\n     *\n     * @example\n     *\n     * ```typescript\n     * import { usage } from \"@trigger.dev/sdk/v3\";\n     *\n     * export const myTask = task({\n     *  id: \"my-task\",\n     *  run: async (payload, { ctx }) => {\n     *    const { result, compute } = await usage.measure(async () => {\n     *      // Do some work\n     *      return \"result\";\n     *    });\n     *\n     *    console.log(\"Result\", result);\n     *    console.log(\"Cost and duration\", { cost: compute.costInCents, duration: compute.durationMs });\n     *  },\n     * });\n     * ```\n     */\n    measure: async (cb) => {\n        const measurement = usageApi.start();\n        const result = await cb();\n        const sample = usageApi.stop(measurement);\n        const machine = taskContext.ctx?.machine;\n        const costInCents = machine?.centsPerMs ? sample.cpuTime * machine.centsPerMs : 0;\n        return {\n            result,\n            compute: {\n                costInCents,\n                durationMs: sample.cpuTime,\n            },\n        };\n    },\n};\n//# sourceMappingURL=usage.js.map","import { createIdempotencyKey } from \"@trigger.dev/core/v3\";\nexport const idempotencyKeys = {\n    create: createIdempotencyKey,\n};\n//# sourceMappingURL=idempotencyKeys.js.map","import { UnprocessableEntityError, accessoryAttributes, apiClientManager, logger, mergeRequestOptions, taskContext, } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer.js\";\nexport const tags = {\n    add: addTags,\n};\nasync function addTags(tags, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const run = taskContext.ctx?.run;\n    if (!run) {\n        throw new Error(\"Can't set tags outside of a run. You can trigger a task and set tags in the options.\");\n    }\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"tags.set()\",\n        icon: \"tag\",\n        attributes: {\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: typeof tags === \"string\" ? tags : tags.join(\", \"),\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    try {\n        await apiClient.addTags(run.id, { tags }, $requestOptions);\n    }\n    catch (error) {\n        if (error instanceof UnprocessableEntityError) {\n            logger.error(error.message, {\n                existingTags: run.tags,\n                newTags: tags,\n            });\n            return;\n        }\n        logger.error(\"Failed to set tags\", { error });\n        throw error;\n    }\n}\n//# sourceMappingURL=tags.js.map","import { mergeRequestOptions, runMetadata, } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer.js\";\nconst parentMetadataUpdater = runMetadata.parent;\nconst rootMetadataUpdater = runMetadata.root;\n/**\n * Provides access to run metadata operations.\n * @namespace\n * @property {Function} current - Get the current run's metadata.\n * @property {Function} get - Get a specific key from the current run's metadata.\n * @property {Function} set - Set a key in the current run's metadata.\n * @property {Function} del - Delete a key from the current run's metadata.\n * @property {Function} save - Update the entire metadata object for the current run.\n */\nconst metadataUpdater = {\n    set: setMetadataKey,\n    del: deleteMetadataKey,\n    append: appendMetadataKey,\n    remove: removeMetadataKey,\n    increment: incrementMetadataKey,\n    decrement: decrementMetadataKey,\n    flush: flushMetadata,\n};\nexport const metadata = {\n    current: currentMetadata,\n    get: getMetadataKey,\n    save: saveMetadata,\n    replace: replaceMetadata,\n    stream: stream,\n    fetchStream: fetchStream,\n    parent: parentMetadataUpdater,\n    root: rootMetadataUpdater,\n    refresh: refreshMetadata,\n    ...metadataUpdater,\n};\n/**\n * Returns the metadata of the current run if inside a task run.\n * This function allows you to access the entire metadata object for the current run.\n *\n * @returns {RunMetadata | undefined} The current run's metadata or undefined if not in a run context.\n *\n * @example\n * const currentMetadata = metadata.current();\n * console.log(currentMetadata);\n */\nfunction currentMetadata() {\n    return runMetadata.current();\n}\n/**\n * Get a specific key from the metadata of the current run if inside a task run.\n *\n * @param {string} key - The key to retrieve from the metadata.\n * @returns {DeserializedJson | undefined} The value associated with the key, or undefined if not found or not in a run context.\n *\n * @example\n * const user = metadata.get(\"user\");\n * console.log(user.name); // \"Eric\"\n * console.log(user.id); // \"user_1234\"\n */\nfunction getMetadataKey(key) {\n    return runMetadata.getKey(key);\n}\n/**\n * Set a key in the metadata of the current run if inside a task run.\n * This function allows you to update or add a new key-value pair to the run's metadata.\n *\n * @param {string} key - The key to set in the metadata.\n * @param {DeserializedJson} value - The value to associate with the key.\n *\n * @example\n * metadata.set(\"progress\", 0.5);\n */\nfunction setMetadataKey(key, value) {\n    runMetadata.set(key, value);\n    return metadataUpdater;\n}\n/**\n * Delete a key from the metadata of the current run if inside a task run.\n *\n * @param {string} key - The key to delete from the metadata.\n *\n * @example\n * metadata.del(\"progress\");\n */\nfunction deleteMetadataKey(key) {\n    runMetadata.del(key);\n    return metadataUpdater;\n}\n/**\n * Update the entire metadata object for the current run if inside a task run.\n * This function allows you to replace the entire metadata object with a new one.\n *\n * @param {RunMetadata} metadata - The new metadata object to set for the run.\n * @returns {void}\n *\n * @example\n * metadata.replace({ progress: 0.6, user: { name: \"Alice\", id: \"user_5678\" } });\n */\nfunction replaceMetadata(metadata) {\n    runMetadata.update(metadata);\n}\n/**\n * @deprecated Use `metadata.replace()` instead.\n */\nfunction saveMetadata(metadata) {\n    runMetadata.update(metadata);\n}\n/**\n * Increments a numeric value in the metadata of the current run by the specified amount.\n * This function allows you to atomically increment a numeric metadata value.\n *\n * @param {string} key - The key of the numeric value to increment.\n * @param {number} value - The amount to increment the value by.\n *\n * @example\n * metadata.increment(\"counter\", 1); // Increments counter by 1\n * metadata.increment(\"score\", 10); // Increments score by 10\n */\nfunction incrementMetadataKey(key, value = 1) {\n    runMetadata.increment(key, value);\n    return metadataUpdater;\n}\n/**\n * Decrements a numeric value in the metadata of the current run by the specified amount.\n * This function allows you to atomically decrement a numeric metadata value.\n *\n * @param {string} key - The key of the numeric value to decrement.\n * @param {number} value - The amount to decrement the value by.\n *\n * @example\n * metadata.decrement(\"counter\", 1); // Decrements counter by 1\n * metadata.decrement(\"score\", 5); // Decrements score by 5\n */\nfunction decrementMetadataKey(key, value = 1) {\n    runMetadata.decrement(key, value);\n    return metadataUpdater;\n}\n/**\n * Appends a value to an array in the metadata of the current run.\n * If the key doesn't exist, it creates a new array with the value.\n * If the key exists but isn't an array, it converts the existing value to an array.\n *\n * @param {string} key - The key of the array in metadata.\n * @param {DeserializedJson} value - The value to append to the array.\n *\n * @example\n * metadata.append(\"logs\", \"User logged in\");\n * metadata.append(\"events\", { type: \"click\", timestamp: Date.now() });\n */\nfunction appendMetadataKey(key, value) {\n    runMetadata.append(key, value);\n    return metadataUpdater;\n}\n/**\n * Removes a value from an array in the metadata of the current run.\n *\n * @param {string} key - The key of the array in metadata.\n * @param {DeserializedJson} value - The value to remove from the array.\n *\n * @example\n *\n * metadata.remove(\"logs\", \"User logged in\");\n * metadata.remove(\"events\", { type: \"click\", timestamp: Date.now() });\n */\nfunction removeMetadataKey(key, value) {\n    runMetadata.remove(key, value);\n    return metadataUpdater;\n}\n/**\n * Flushes metadata to the Trigger.dev instance\n *\n * @param {ApiRequestOptions} [requestOptions] - Optional request options to customize the API request.\n * @returns {Promise<void>} A promise that resolves when the metadata flush operation is complete.\n */\nasync function flushMetadata(requestOptions) {\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"metadata.flush()\",\n        icon: \"code-plus\",\n    }, requestOptions);\n    await runMetadata.flush($requestOptions);\n}\n/**\n * Refreshes metadata from the Trigger.dev instance\n *\n * @param {ApiRequestOptions} [requestOptions] - Optional request options to customize the API request.\n * @returns {Promise<void>} A promise that resolves when the metadata refresh operation is complete.\n */\nasync function refreshMetadata(requestOptions) {\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"metadata.refresh()\",\n        icon: \"code-plus\",\n    }, requestOptions);\n    await runMetadata.refresh($requestOptions);\n}\nasync function stream(key, value, signal) {\n    return runMetadata.stream(key, value, signal);\n}\nasync function fetchStream(key, signal) {\n    return runMetadata.fetchStream(key, signal);\n}\n//# sourceMappingURL=metadata.js.map","import { timeout as timeoutApi } from \"@trigger.dev/core/v3\";\nconst MAXIMUM_MAX_DURATION = 2_147_483_647;\nexport const timeout = {\n    None: MAXIMUM_MAX_DURATION,\n    signal: timeoutApi.signal,\n};\n//# sourceMappingURL=timeout.js.map","import { Webhook } from \"@trigger.dev/core/v3\";\nimport { subtle } from \"../imports/uncrypto.js\";\n/**\n * The type of error thrown when a webhook fails to parse or verify\n */\nexport class WebhookError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"WebhookError\";\n    }\n}\n/** Header name used for webhook signatures */\nconst SIGNATURE_HEADER_NAME = \"x-trigger-signature-hmacsha256\";\n/**\n * Webhook utilities for handling incoming webhook requests\n */\nexport const webhooks = {\n    constructEvent,\n    SIGNATURE_HEADER_NAME,\n};\nasync function constructEvent(request, secret) {\n    let payload;\n    let signature;\n    if (request instanceof Request) {\n        if (!secret) {\n            throw new WebhookError(\"Secret is required when passing a Request object\");\n        }\n        const signatureHeader = request.headers.get(SIGNATURE_HEADER_NAME);\n        if (!signatureHeader) {\n            throw new WebhookError(\"No signature header found\");\n        }\n        signature = signatureHeader;\n        payload = await request.text();\n    }\n    else {\n        payload = request.payload.toString();\n        if (Array.isArray(request.header)) {\n            throw new WebhookError(\"Signature header cannot be an array\");\n        }\n        signature = request.header.toString();\n    }\n    // Verify the signature\n    const isValid = await verifySignature(payload, signature, secret);\n    if (!isValid) {\n        throw new WebhookError(\"Invalid signature\");\n    }\n    // Parse and validate the payload\n    try {\n        const jsonPayload = JSON.parse(payload);\n        const parsedPayload = Webhook.parse(jsonPayload);\n        return parsedPayload;\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            throw new WebhookError(`Webhook parsing failed: ${error.message}`);\n        }\n        throw new WebhookError(\"Webhook parsing failed\");\n    }\n}\n/**\n * Verifies the signature of a webhook payload\n * @param payload - Raw payload string to verify\n * @param signature - Expected signature to check against\n * @param secret - Secret key used to generate the signature\n * @returns Promise resolving to boolean indicating if signature is valid\n * @throws {WebhookError} If signature verification process fails\n *\n * @example\n * const isValid = await verifySignature(\n *   '{\"event\": \"test\"}',\n *   \"abc123signature\",\n *   \"webhook_secret\"\n * );\n */\nasync function verifySignature(payload, signature, secret) {\n    try {\n        if (!secret) {\n            throw new WebhookError(\"Secret is required for signature verification\");\n        }\n        // Convert the payload and secret to buffers\n        const hashPayload = Buffer.from(payload, \"utf-8\");\n        const hmacSecret = Buffer.from(secret, \"utf-8\");\n        // Import the secret key\n        const key = await subtle.importKey(\"raw\", hmacSecret, { name: \"HMAC\", hash: \"SHA-256\" }, false, [\"sign\", \"verify\"]);\n        // Calculate the expected signature\n        const actualSignature = await subtle.sign(\"HMAC\", key, hashPayload);\n        const actualSignatureHex = Buffer.from(actualSignature).toString(\"hex\");\n        // Compare signatures using timing-safe comparison\n        return timingSafeEqual(signature, actualSignatureHex);\n    }\n    catch (error) {\n        throw new WebhookError(\"Signature verification failed\");\n    }\n}\n// Timing-safe comparison to prevent timing attacks\nfunction timingSafeEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n        result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    }\n    return result === 0;\n}\n//# sourceMappingURL=webhooks.js.map","import { TimezonesResult, accessoryAttributes, apiClientManager, mergeRequestOptions, taskCatalog, } from \"@trigger.dev/core/v3\";\nimport { zodfetch } from \"@trigger.dev/core/v3/zodfetch\";\nimport { createTask } from \"../shared.js\";\nimport { tracer } from \"../tracer.js\";\nexport function task(params) {\n    const task = createTask(params);\n    const cron = params.cron\n        ? typeof params.cron === \"string\"\n            ? params.cron\n            : params.cron.pattern\n        : undefined;\n    const timezone = (params.cron && typeof params.cron !== \"string\" ? params.cron.timezone : \"UTC\") ?? \"UTC\";\n    taskCatalog.updateTaskMetadata(task.id, {\n        triggerSource: \"schedule\",\n        schedule: cron\n            ? {\n                cron: cron,\n                timezone,\n            }\n            : undefined,\n    });\n    return task;\n}\n/**\n * Creates a new schedule\n * @param options\n * @param options.task - The identifier of the task to be scheduled (Must already exist and be a scheduled task)\n * @param options.cron - The cron expression for the schedule (e.g. `0 0 * * *`)\n * @param options.timezone - An optional timezone for the schedule in the IANA format (e.g. `America/Los_Angeles`). Defaults to \"UTC\".\n * @param options.externalId - An optional external identifier for the schedule\n * @param options.deduplicationKey - An optional deduplication key for the schedule\n * @returns The created schedule\n */\nexport function create(options, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"schedules.create()\",\n        icon: \"clock\",\n        attributes: {\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: options.cron,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.createSchedule(options, $requestOptions);\n}\n/**\n * Retrieves a schedule\n * @param scheduleId - The ID of the schedule to retrieve\n * @returns The retrieved schedule\n */\nexport function retrieve(scheduleId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"schedules.retrieve()\",\n        icon: \"clock\",\n        attributes: {\n            scheduleId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: scheduleId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.retrieveSchedule(scheduleId, $requestOptions);\n}\n/**\n * Updates a schedule\n * @param scheduleId - The ID of the schedule to update\n * @param options - The updated schedule options\n * @param options.task - The identifier of the task to be scheduled (Must already exist and be a scheduled task)\n * @param options.cron - The cron expression for the schedule (e.g. `0 0 * * *`)\n * @param options.timezone - An optional timezone for the schedule in the IANA format (e.g. `America/Los_Angeles`). Defaults to \"UTC\".\n * @param options.externalId - An optional external identifier for the schedule\n * @returns The updated schedule\n */\nexport function update(scheduleId, options, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"schedules.update()\",\n        icon: \"clock\",\n        attributes: {\n            scheduleId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: scheduleId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.updateSchedule(scheduleId, options, $requestOptions);\n}\n/**\n * Deletes a schedule\n * @param scheduleId - The ID of the schedule to delete\n */\nexport function del(scheduleId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"schedules.delete()\",\n        icon: \"clock\",\n        attributes: {\n            scheduleId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: scheduleId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.deleteSchedule(scheduleId, $requestOptions);\n}\n/**\n * Deactivates a schedule\n * @param scheduleId - The ID of the schedule to deactivate\n */\nexport function deactivate(scheduleId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"schedules.deactivate()\",\n        icon: \"clock\",\n        attributes: {\n            scheduleId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: scheduleId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.deactivateSchedule(scheduleId, $requestOptions);\n}\n/**\n * Activates a schedule\n * @param scheduleId - The ID of the schedule to activate\n */\nexport function activate(scheduleId, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"schedules.activate()\",\n        icon: \"clock\",\n        attributes: {\n            scheduleId,\n            ...accessoryAttributes({\n                items: [\n                    {\n                        text: scheduleId,\n                        variant: \"normal\",\n                    },\n                ],\n                style: \"codepath\",\n            }),\n        },\n    }, requestOptions);\n    return apiClient.activateSchedule(scheduleId, $requestOptions);\n}\n/**\n * Lists schedules\n * @param options - The list options\n * @param options.page - The page number\n * @param options.perPage - The number of schedules per page\n * @returns The list of schedules\n */\nexport function list(options, requestOptions) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"schedules.list()\",\n        icon: \"clock\",\n    }, requestOptions);\n    return apiClient.listSchedules(options, $requestOptions);\n}\n/**\n * Lists the possible timezones we support\n * @param excludeUtc - By default \"UTC\" is included and is first. If true, \"UTC\" will be excluded.\n */\nexport function timezones(options) {\n    const baseUrl = apiClientManager.baseURL;\n    return zodfetch(TimezonesResult, `${baseUrl}/api/v1/timezones${options?.excludeUtc === true ? \"?excludeUtc=true\" : \"\"}`, {\n        method: \"GET\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n    });\n}\n//# sourceMappingURL=index.js.map","import { apiClientManager, isRequestOptions, mergeRequestOptions, taskContext, } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer.js\";\nexport function upload(projectRefOrParams, slugOrRequestOptions, params, requestOptions) {\n    let $projectRef;\n    let $params;\n    let $slug;\n    const $requestOptions = overloadRequestOptions(\"upload\", slugOrRequestOptions, requestOptions);\n    if (taskContext.ctx) {\n        if (typeof projectRefOrParams === \"string\") {\n            $projectRef = projectRefOrParams;\n            $slug =\n                typeof slugOrRequestOptions === \"string\"\n                    ? slugOrRequestOptions\n                    : taskContext.ctx.environment.slug;\n            if (!params) {\n                throw new Error(\"params is required\");\n            }\n            $params = params;\n        }\n        else {\n            $params = projectRefOrParams;\n            $projectRef = taskContext.ctx.project.ref;\n            $slug = taskContext.ctx.environment.slug;\n        }\n    }\n    else {\n        if (typeof projectRefOrParams !== \"string\") {\n            throw new Error(\"projectRef is required\");\n        }\n        if (!slugOrRequestOptions || typeof slugOrRequestOptions !== \"string\") {\n            throw new Error(\"slug is required\");\n        }\n        if (!params) {\n            throw new Error(\"params is required\");\n        }\n        $projectRef = projectRefOrParams;\n        $slug = slugOrRequestOptions;\n        $params = params;\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.importEnvVars($projectRef, $slug, $params, $requestOptions);\n}\nexport function list(projectRefOrRequestOptions, slug, requestOptions) {\n    const $projectRef = !isRequestOptions(projectRefOrRequestOptions)\n        ? projectRefOrRequestOptions\n        : taskContext.ctx?.project.ref;\n    const $slug = slug ?? taskContext.ctx?.environment.slug;\n    let $requestOptions = isRequestOptions(projectRefOrRequestOptions)\n        ? projectRefOrRequestOptions\n        : requestOptions;\n    if (!$projectRef) {\n        throw new Error(\"projectRef is required\");\n    }\n    if (!$slug) {\n        throw new Error(\"slug is required\");\n    }\n    $requestOptions = mergeRequestOptions({\n        tracer,\n        name: \"envvars.list()\",\n        icon: \"id-badge\",\n    }, $requestOptions);\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.listEnvVars($projectRef, $slug, $requestOptions);\n}\nexport function create(projectRefOrParams, slugOrRequestOptions, params, requestOptions) {\n    let $projectRef;\n    let $slug;\n    let $params;\n    const $requestOptions = overloadRequestOptions(\"create\", slugOrRequestOptions, requestOptions);\n    if (taskContext.ctx) {\n        if (typeof projectRefOrParams === \"string\") {\n            $projectRef = projectRefOrParams;\n            $slug =\n                typeof slugOrRequestOptions === \"string\"\n                    ? slugOrRequestOptions\n                    : taskContext.ctx.environment.slug;\n            if (!params) {\n                throw new Error(\"params is required\");\n            }\n            $params = params;\n        }\n        else {\n            $params = projectRefOrParams;\n            $projectRef = taskContext.ctx.project.ref;\n            $slug = taskContext.ctx.environment.slug;\n        }\n    }\n    else {\n        if (typeof projectRefOrParams !== \"string\") {\n            throw new Error(\"projectRef is required\");\n        }\n        if (!slugOrRequestOptions || typeof slugOrRequestOptions !== \"string\") {\n            throw new Error(\"slug is required\");\n        }\n        if (!params) {\n            throw new Error(\"params is required\");\n        }\n        $projectRef = projectRefOrParams;\n        $slug = slugOrRequestOptions;\n        $params = params;\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.createEnvVar($projectRef, $slug, $params, $requestOptions);\n}\nexport function retrieve(projectRefOrName, slugOrRequestOptions, name, requestOptions) {\n    let $projectRef;\n    let $slug;\n    let $name;\n    const $requestOptions = overloadRequestOptions(\"retrieve\", slugOrRequestOptions, requestOptions);\n    if (typeof name === \"string\") {\n        $projectRef = projectRefOrName;\n        $slug =\n            typeof slugOrRequestOptions === \"string\"\n                ? slugOrRequestOptions\n                : taskContext.ctx?.environment.slug;\n        $name = name;\n    }\n    else {\n        $projectRef = taskContext.ctx?.project.ref;\n        $slug = taskContext.ctx?.environment.slug;\n        $name = projectRefOrName;\n    }\n    if (!$projectRef) {\n        throw new Error(\"projectRef is required\");\n    }\n    if (!$slug) {\n        throw new Error(\"slug is required\");\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.retrieveEnvVar($projectRef, $slug, $name, $requestOptions);\n}\nexport function del(projectRefOrName, slugOrRequestOptions, name, requestOptions) {\n    let $projectRef;\n    let $slug;\n    let $name;\n    const $requestOptions = overloadRequestOptions(\"del\", slugOrRequestOptions, requestOptions);\n    if (typeof name === \"string\") {\n        $projectRef = projectRefOrName;\n        $slug =\n            typeof slugOrRequestOptions === \"string\"\n                ? slugOrRequestOptions\n                : taskContext.ctx?.environment.slug;\n        $name = name;\n    }\n    else {\n        $projectRef = taskContext.ctx?.project.ref;\n        $slug = taskContext.ctx?.environment.slug;\n        $name = projectRefOrName;\n    }\n    if (!$projectRef) {\n        throw new Error(\"projectRef is required\");\n    }\n    if (!$slug) {\n        throw new Error(\"slug is required\");\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.deleteEnvVar($projectRef, $slug, $name, $requestOptions);\n}\nexport function update(projectRefOrName, slugOrParams, nameOrRequestOptions, params, requestOptions) {\n    let $projectRef;\n    let $slug;\n    let $name;\n    let $params;\n    const $requestOptions = overloadRequestOptions(\"update\", nameOrRequestOptions, requestOptions);\n    if (taskContext.ctx) {\n        if (typeof slugOrParams === \"string\") {\n            $projectRef = slugOrParams;\n            $slug = slugOrParams ?? taskContext.ctx.environment.slug;\n            $name =\n                typeof nameOrRequestOptions === \"string\"\n                    ? nameOrRequestOptions\n                    : taskContext.ctx.environment.slug;\n            if (!params) {\n                throw new Error(\"params is required\");\n            }\n            $params = params;\n        }\n        else {\n            $params = slugOrParams;\n            $projectRef = taskContext.ctx.project.ref;\n            $slug = taskContext.ctx.environment.slug;\n            $name = projectRefOrName;\n        }\n    }\n    else {\n        if (typeof slugOrParams !== \"string\") {\n            throw new Error(\"slug is required\");\n        }\n        if (!projectRefOrName) {\n            throw new Error(\"projectRef is required\");\n        }\n        if (!params) {\n            throw new Error(\"params is required\");\n        }\n        $projectRef = projectRefOrName;\n        $slug = slugOrParams;\n        $name = name;\n        $params = params;\n    }\n    const apiClient = apiClientManager.clientOrThrow();\n    return apiClient.updateEnvVar($projectRef, $slug, $name, $params, $requestOptions);\n}\nfunction overloadRequestOptions(name, slugOrRequestOptions, requestOptions) {\n    if (isRequestOptions(slugOrRequestOptions)) {\n        return mergeRequestOptions({\n            tracer,\n            name: `envvars.${name}()`,\n            icon: \"id-badge\",\n        }, slugOrRequestOptions);\n    }\n    else {\n        return mergeRequestOptions({\n            tracer,\n            name: `envvars.${name}()`,\n            icon: \"id-badge\",\n        }, requestOptions);\n    }\n}\n//# sourceMappingURL=envvars.js.map","import { apiClientManager } from \"@trigger.dev/core/v3\";\nimport { generateJWT as internal_generateJWT } from \"@trigger.dev/core/v3\";\n/**\n * Register the global API client configuration. Alternatively, you can set the `TRIGGER_SECRET_KEY` and `TRIGGER_API_URL` environment variables.\n * @param options The API client configuration.\n * @param options.baseURL The base URL of the Trigger API. (default: `https://api.trigger.dev`)\n * @param options.accessToken The accessToken to authenticate with the Trigger API. (default: `process.env.TRIGGER_SECRET_KEY`) This can be found in your Trigger.dev project \"API Keys\" settings.\n *\n * @example\n *\n * ```typescript\n * import { configure } from \"@trigger.dev/sdk/v3\";\n *\n * configure({\n *  baseURL: \"https://api.trigger.dev\",\n *  accessToken: \"tr_dev_1234567890\"\n * });\n * ```\n */\nexport function configure(options) {\n    apiClientManager.setGlobalAPIClientConfiguration(options);\n}\nexport const auth = {\n    configure,\n    createPublicToken,\n    createTriggerPublicToken,\n    createBatchTriggerPublicToken,\n    withAuth,\n    withPublicToken,\n    withTriggerPublicToken,\n    withBatchTriggerPublicToken,\n};\n/**\n * Creates a public token using the provided options.\n *\n * @param options - Optional parameters for creating the public token.\n * @param options.scopes - An array of permission scopes to be included in the token.\n * @param options.expirationTime - The expiration time for the token.\n * @returns A promise that resolves to a string representing the generated public token.\n *\n * @example\n *\n * ```typescript\n * import { auth } from \"@trigger.dev/sdk/v3\";\n *\n * const publicToken = await auth.createPublicToken({\n *  scopes: {\n *   read: {\n *     tags: [\"file:1234\"]\n *   }\n * });\n * ```\n */\nasync function createPublicToken(options) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const claims = await apiClient.generateJWTClaims();\n    return await internal_generateJWT({\n        secretKey: apiClient.accessToken,\n        payload: {\n            ...claims,\n            scopes: options?.scopes ? flattenScopes(options.scopes) : undefined,\n        },\n        expirationTime: options?.expirationTime,\n    });\n}\n/**\n * Executes a function with a public token, providing temporary access permissions.\n *\n * @param options - Options for creating the public token.\n * @param fn - The asynchronous function to be executed with the public token.\n */\nasync function withPublicToken(options, fn) {\n    const token = await createPublicToken(options);\n    await withAuth({ accessToken: token }, fn);\n}\n/**\n * Creates a one-time use token to trigger a specific task.\n *\n * @param task - The task ID or an array of task IDs that the token should allow triggering.\n * @param options - Options for creating the one-time use token.\n * @returns A promise that resolves to a string representing the generated one-time use token.\n *\n * @example\n * Create a one-time use public token that allows triggering a specific task:\n *\n * ```ts\n * import { auth } from \"@trigger.dev/sdk/v3\";\n *\n * const token = await auth.createTriggerPublicToken(\"my-task\");\n * ```\n *\n * @example You can also create a one-time use token that allows triggering multiple tasks:\n *\n * ```ts\n * import { auth } from \"@trigger.dev/sdk/v3\";\n *\n * const token = await auth.createTriggerPublicToken([\"task1\", \"task2\"]);\n * ```\n *\n * @example You can also create a one-time use token that allows triggering a task with a specific expiration time:\n *\n * ```ts\n * import { auth } from \"@trigger.dev/sdk/v3\";\n *\n * const token = await auth.createTriggerPublicToken(\"my-task\", { expirationTime: \"1h\" });\n * ```\n */\nasync function createTriggerPublicToken(task, options) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const claims = await apiClient.generateJWTClaims();\n    return await internal_generateJWT({\n        secretKey: apiClient.accessToken,\n        payload: {\n            ...claims,\n            otu: typeof options?.multipleUse === \"boolean\" ? !options.multipleUse : true,\n            scopes: flattenScopes({\n                trigger: {\n                    tasks: task,\n                },\n            }),\n        },\n        expirationTime: options?.expirationTime,\n    });\n}\n/**\n * Executes a function with a one-time use token that allows triggering a specific task.\n *\n * @param task - The task ID or an array of task IDs that the token should allow triggering.\n * @param options - Options for creating the one-time use token.\n * @param fn - The asynchronous function to be executed with the one-time use token.\n */\nasync function withTriggerPublicToken(task, options = {}, fn) {\n    const token = await createTriggerPublicToken(task, options);\n    await withAuth({ accessToken: token }, fn);\n}\n/**\n * Creates a one-time use token to batch trigger a specific task or tasks.\n *\n * @param task - The task ID or an array of task IDs that the token should allow triggering.\n * @param options - Options for creating the one-time use token.\n * @returns A promise that resolves to a string representing the generated one-time use token.\n *\n * @example\n *\n * ```ts\n * import { auth } from \"@trigger.dev/sdk/v3\";\n *\n * const token = await auth.createBatchTriggerPublicToken(\"my-task\");\n * ```\n *\n * @example You can also create a one-time use token that allows batch triggering multiple tasks:\n *\n * ```ts\n * import { auth } from \"@trigger.dev/sdk/v3\";\n *\n * const token = await auth.createBatchTriggerPublicToken([\"task1\", \"task2\"]);\n * ```\n *\n * @example You can also create a one-time use token that allows batch triggering a task with a specific expiration time:\n *\n * ```ts\n * import { auth } from \"@trigger.dev/sdk/v3\";\n *\n * const token = await auth.createBatchTriggerPublicToken(\"my-task\", { expirationTime: \"1h\" });\n * ```\n */\nasync function createBatchTriggerPublicToken(task, options) {\n    const apiClient = apiClientManager.clientOrThrow();\n    const claims = await apiClient.generateJWTClaims();\n    return await internal_generateJWT({\n        secretKey: apiClient.accessToken,\n        payload: {\n            ...claims,\n            otu: typeof options?.multipleUse === \"boolean\" ? !options.multipleUse : true,\n            scopes: flattenScopes({\n                batchTrigger: {\n                    tasks: task,\n                },\n            }),\n        },\n        expirationTime: options?.expirationTime,\n    });\n}\n/**\n * Executes a function with a one-time use token that allows triggering a specific task.\n *\n * @param task - The task ID or an array of task IDs that the token should allow triggering.\n * @param options - Options for creating the one-time use token.\n * @param fn - The asynchronous function to be executed with the one-time use token.\n */\nasync function withBatchTriggerPublicToken(task, options = {}, fn) {\n    const token = await createBatchTriggerPublicToken(task, options);\n    await withAuth({ accessToken: token }, fn);\n}\n/**\n * Executes a provided asynchronous function with a specified API client configuration.\n *\n * @template R - The type of the asynchronous function to be executed.\n * @param {ApiClientConfiguration} config - The configuration for the API client.\n * @param {R} fn - The asynchronous function to be executed.\n * @returns {Promise<ReturnType<R>>} A promise that resolves to the return type of the provided function.\n */\nasync function withAuth(config, fn) {\n    return apiClientManager.runWithConfig(config, fn);\n}\nfunction flattenScopes(permissions) {\n    const flattenedPermissions = [];\n    for (const [action, properties] of Object.entries(permissions)) {\n        if (properties) {\n            if (typeof properties === \"boolean\" && properties) {\n                flattenedPermissions.push(action);\n            }\n            else if (typeof properties === \"object\") {\n                for (const [property, value] of Object.entries(properties)) {\n                    if (Array.isArray(value)) {\n                        for (const item of value) {\n                            flattenedPermissions.push(`${action}:${property}:${item}`);\n                        }\n                    }\n                    else if (typeof value === \"string\") {\n                        flattenedPermissions.push(`${action}:${property}:${value}`);\n                    }\n                    else if (typeof value === \"boolean\" && value) {\n                        flattenedPermissions.push(`${action}:${property}`);\n                    }\n                }\n            }\n        }\n    }\n    return flattenedPermissions;\n}\n//# sourceMappingURL=auth.js.map","export * from \"./cache.js\";\nexport * from \"./config.js\";\nexport { retry } from \"./retry.js\";\nexport { queue } from \"./shared.js\";\nexport * from \"./tasks.js\";\nexport * from \"./batch.js\";\nexport * from \"./wait.js\";\nexport * from \"./waitUntil.js\";\nexport * from \"./usage.js\";\nexport * from \"./idempotencyKeys.js\";\nexport * from \"./tags.js\";\nexport * from \"./metadata.js\";\nexport * from \"./timeout.js\";\nexport * from \"./webhooks.js\";\nexport { ApiError, AuthenticationError, BadRequestError, ConflictError, InternalServerError, NotFoundError, PermissionDeniedError, RateLimitError, UnprocessableEntityError, AbortTaskRunError, OutOfMemoryError, logger, } from \"@trigger.dev/core/v3\";\nexport { runs, } from \"./runs.js\";\nexport * as schedules from \"./schedules/index.js\";\nexport * as envvars from \"./envvars.js\";\nexport { configure, auth } from \"./auth.js\";\n//# sourceMappingURL=index.js.map","// HumanizeDuration.js - https://git.io/j0HgmQ\n\n// @ts-check\n\n/**\n * @typedef {string | ((unitCount: number) => string)} Unit\n */\n\n/**\n * @typedef {\"y\" | \"mo\" | \"w\" | \"d\" | \"h\" | \"m\" | \"s\" | \"ms\"} UnitName\n */\n\n/**\n * @typedef {Object} UnitMeasures\n * @prop {number} y\n * @prop {number} mo\n * @prop {number} w\n * @prop {number} d\n * @prop {number} h\n * @prop {number} m\n * @prop {number} s\n * @prop {number} ms\n */\n\n/**\n * @internal\n * @typedef {[string, string, string, string, string, string, string, string, string, string]} DigitReplacements\n */\n\n/**\n * @typedef {Object} Language\n * @prop {Unit} y\n * @prop {Unit} mo\n * @prop {Unit} w\n * @prop {Unit} d\n * @prop {Unit} h\n * @prop {Unit} m\n * @prop {Unit} s\n * @prop {Unit} ms\n * @prop {string} [decimal]\n * @prop {string} [delimiter]\n * @prop {DigitReplacements} [_digitReplacements]\n * @prop {boolean} [_numberFirst]\n * @prop {boolean} [_hideCountIf2]\n */\n\n/**\n * @typedef {Object} Options\n * @prop {string} [language]\n * @prop {Record<string, Language>} [languages]\n * @prop {string[]} [fallbacks]\n * @prop {string} [delimiter]\n * @prop {string} [spacer]\n * @prop {boolean} [round]\n * @prop {number} [largest]\n * @prop {UnitName[]} [units]\n * @prop {string} [decimal]\n * @prop {string} [conjunction]\n * @prop {number} [maxDecimalPoints]\n * @prop {UnitMeasures} [unitMeasures]\n * @prop {boolean} [serialComma]\n * @prop {DigitReplacements} [digitReplacements]\n */\n\n/**\n * @internal\n * @typedef {Required<Options>} NormalizedOptions\n */\n\n(function () {\n  // Fallback for `Object.assign` if relevant.\n  var assign =\n    Object.assign ||\n    /** @param {...any} destination */\n    function (destination) {\n      var source;\n      for (var i = 1; i < arguments.length; i++) {\n        source = arguments[i];\n        for (var prop in source) {\n          if (has(source, prop)) {\n            destination[prop] = source[prop];\n          }\n        }\n      }\n      return destination;\n    };\n\n  // Fallback for `Array.isArray` if relevant.\n  var isArray =\n    Array.isArray ||\n    function (arg) {\n      return Object.prototype.toString.call(arg) === \"[object Array]\";\n    };\n\n  // This has to be defined separately because of a bug: we want to alias\n  // `gr` and `el` for backwards-compatiblity. In a breaking change, we can\n  // remove `gr` entirely.\n  // See https://github.com/EvanHahn/HumanizeDuration.js/issues/143 for more.\n  var GREEK = language(\n    function (c) {\n      return c === 1 ? \"\" : \"\";\n    },\n    function (c) {\n      return c === 1 ? \"\" : \"\";\n    },\n    function (c) {\n      return c === 1 ? \"\" : \"\";\n    },\n    function (c) {\n      return c === 1 ? \"\" : \"\";\n    },\n    function (c) {\n      return c === 1 ? \"\" : \"\";\n    },\n    function (c) {\n      return c === 1 ? \"\" : \"\";\n    },\n    function (c) {\n      return c === 1 ? \"\" : \"\";\n    },\n    function (c) {\n      return (c === 1 ? \"\" : \"\") + \"  \";\n    },\n    \",\"\n  );\n\n  /**\n   * @internal\n   * @type {Record<string, Language>}\n   */\n  var LANGUAGES = {\n    af: language(\n      \"jaar\",\n      function (c) {\n        return \"maand\" + (c === 1 ? \"\" : \"e\");\n      },\n      function (c) {\n        return c === 1 ? \"week\" : \"weke\";\n      },\n      function (c) {\n        return c === 1 ? \"dag\" : \"dae\";\n      },\n      function (c) {\n        return c === 1 ? \"uur\" : \"ure\";\n      },\n      function (c) {\n        return c === 1 ? \"minuut\" : \"minute\";\n      },\n      function (c) {\n        return \"sekonde\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"millisekonde\" + (c === 1 ? \"\" : \"s\");\n      },\n      \",\"\n    ),\n    am: language(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"),\n    ar: assign(\n      language(\n        function (c) {\n          return [\"\", \"\", \"\"][getArabicForm(c)];\n        },\n        function (c) {\n          return [\"\", \"\", \"\"][getArabicForm(c)];\n        },\n        function (c) {\n          return [\"\", \"\", \"\"][getArabicForm(c)];\n        },\n        function (c) {\n          return [\"\", \"\", \"\"][getArabicForm(c)];\n        },\n        function (c) {\n          return [\"\", \"\", \"\"][getArabicForm(c)];\n        },\n        function (c) {\n          return [\"\", \"\", \"\"][getArabicForm(c)];\n        },\n        function (c) {\n          return [\"\", \"\", \"\"][getArabicForm(c)];\n        },\n        function (c) {\n          return [\"  \", \"  \", \"  \"][\n            getArabicForm(c)\n          ];\n        },\n        \",\"\n      ),\n      {\n        delimiter: \"  \",\n        _hideCountIf2: true,\n        _digitReplacements: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n      }\n    ),\n    bg: language(\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      \",\"\n    ),\n    bn: language(\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\"\n    ),\n    ca: language(\n      function (c) {\n        return \"any\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"mes\" + (c === 1 ? \"\" : \"os\");\n      },\n      function (c) {\n        return \"setman\" + (c === 1 ? \"a\" : \"es\");\n      },\n      function (c) {\n        return \"di\" + (c === 1 ? \"a\" : \"es\");\n      },\n      function (c) {\n        return \"hor\" + (c === 1 ? \"a\" : \"es\");\n      },\n      function (c) {\n        return \"minut\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"segon\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"milisegon\" + (c === 1 ? \"\" : \"s\");\n      },\n      \",\"\n    ),\n    ckb: language(\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \" \",\n      \".\"\n    ),\n    cs: language(\n      function (c) {\n        return [\"rok\", \"roku\", \"roky\", \"let\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"msc\", \"msce\", \"msce\", \"msc\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"tden\", \"tdne\", \"tdny\", \"tdn\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"den\", \"dne\", \"dny\", \"dn\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"hodina\", \"hodiny\", \"hodiny\", \"hodin\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"minuta\", \"minuty\", \"minuty\", \"minut\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"sekunda\", \"sekundy\", \"sekundy\", \"sekund\"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      function (c) {\n        return [\"milisekunda\", \"milisekundy\", \"milisekundy\", \"milisekund\"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      \",\"\n    ),\n    cy: language(\n      \"flwyddyn\",\n      \"mis\",\n      \"wythnos\",\n      \"diwrnod\",\n      \"awr\",\n      \"munud\",\n      \"eiliad\",\n      \"milieiliad\"\n    ),\n    da: language(\n      \"r\",\n      function (c) {\n        return \"mned\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"uge\" + (c === 1 ? \"\" : \"r\");\n      },\n      function (c) {\n        return \"dag\" + (c === 1 ? \"\" : \"e\");\n      },\n      function (c) {\n        return \"time\" + (c === 1 ? \"\" : \"r\");\n      },\n      function (c) {\n        return \"minut\" + (c === 1 ? \"\" : \"ter\");\n      },\n      function (c) {\n        return \"sekund\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"millisekund\" + (c === 1 ? \"\" : \"er\");\n      },\n      \",\"\n    ),\n    de: language(\n      function (c) {\n        return \"Jahr\" + (c === 1 ? \"\" : \"e\");\n      },\n      function (c) {\n        return \"Monat\" + (c === 1 ? \"\" : \"e\");\n      },\n      function (c) {\n        return \"Woche\" + (c === 1 ? \"\" : \"n\");\n      },\n      function (c) {\n        return \"Tag\" + (c === 1 ? \"\" : \"e\");\n      },\n      function (c) {\n        return \"Stunde\" + (c === 1 ? \"\" : \"n\");\n      },\n      function (c) {\n        return \"Minute\" + (c === 1 ? \"\" : \"n\");\n      },\n      function (c) {\n        return \"Sekunde\" + (c === 1 ? \"\" : \"n\");\n      },\n      function (c) {\n        return \"Millisekunde\" + (c === 1 ? \"\" : \"n\");\n      },\n      \",\"\n    ),\n    el: GREEK,\n    en: language(\n      function (c) {\n        return \"year\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"month\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"week\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"day\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"hour\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"minute\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"second\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"millisecond\" + (c === 1 ? \"\" : \"s\");\n      }\n    ),\n    eo: language(\n      function (c) {\n        return \"jaro\" + (c === 1 ? \"\" : \"j\");\n      },\n      function (c) {\n        return \"monato\" + (c === 1 ? \"\" : \"j\");\n      },\n      function (c) {\n        return \"semajno\" + (c === 1 ? \"\" : \"j\");\n      },\n      function (c) {\n        return \"tago\" + (c === 1 ? \"\" : \"j\");\n      },\n      function (c) {\n        return \"horo\" + (c === 1 ? \"\" : \"j\");\n      },\n      function (c) {\n        return \"minuto\" + (c === 1 ? \"\" : \"j\");\n      },\n      function (c) {\n        return \"sekundo\" + (c === 1 ? \"\" : \"j\");\n      },\n      function (c) {\n        return \"milisekundo\" + (c === 1 ? \"\" : \"j\");\n      },\n      \",\"\n    ),\n    es: language(\n      function (c) {\n        return \"ao\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"mes\" + (c === 1 ? \"\" : \"es\");\n      },\n      function (c) {\n        return \"semana\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"da\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"hora\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"minuto\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"segundo\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"milisegundo\" + (c === 1 ? \"\" : \"s\");\n      },\n      \",\"\n    ),\n    et: language(\n      function (c) {\n        return \"aasta\" + (c === 1 ? \"\" : \"t\");\n      },\n      function (c) {\n        return \"kuu\" + (c === 1 ? \"\" : \"d\");\n      },\n      function (c) {\n        return \"ndal\" + (c === 1 ? \"\" : \"at\");\n      },\n      function (c) {\n        return \"pev\" + (c === 1 ? \"\" : \"a\");\n      },\n      function (c) {\n        return \"tund\" + (c === 1 ? \"\" : \"i\");\n      },\n      function (c) {\n        return \"minut\" + (c === 1 ? \"\" : \"it\");\n      },\n      function (c) {\n        return \"sekund\" + (c === 1 ? \"\" : \"it\");\n      },\n      function (c) {\n        return \"millisekund\" + (c === 1 ? \"\" : \"it\");\n      },\n      \",\"\n    ),\n    eu: language(\n      \"urte\",\n      \"hilabete\",\n      \"aste\",\n      \"egun\",\n      \"ordu\",\n      \"minutu\",\n      \"segundo\",\n      \"milisegundo\",\n      \",\"\n    ),\n    fa: language(\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \" \"\n    ),\n    fi: language(\n      function (c) {\n        return c === 1 ? \"vuosi\" : \"vuotta\";\n      },\n      function (c) {\n        return c === 1 ? \"kuukausi\" : \"kuukautta\";\n      },\n      function (c) {\n        return \"viikko\" + (c === 1 ? \"\" : \"a\");\n      },\n      function (c) {\n        return \"piv\" + (c === 1 ? \"\" : \"\");\n      },\n      function (c) {\n        return \"tunti\" + (c === 1 ? \"\" : \"a\");\n      },\n      function (c) {\n        return \"minuutti\" + (c === 1 ? \"\" : \"a\");\n      },\n      function (c) {\n        return \"sekunti\" + (c === 1 ? \"\" : \"a\");\n      },\n      function (c) {\n        return \"millisekunti\" + (c === 1 ? \"\" : \"a\");\n      },\n      \",\"\n    ),\n    fo: language(\n      \"r\",\n      function (c) {\n        return c === 1 ? \"mnaur\" : \"mnair\";\n      },\n      function (c) {\n        return c === 1 ? \"vika\" : \"vikur\";\n      },\n      function (c) {\n        return c === 1 ? \"dagur\" : \"dagar\";\n      },\n      function (c) {\n        return c === 1 ? \"tmi\" : \"tmar\";\n      },\n      function (c) {\n        return c === 1 ? \"minuttur\" : \"minuttir\";\n      },\n      \"sekund\",\n      \"millisekund\",\n      \",\"\n    ),\n    fr: language(\n      function (c) {\n        return \"an\" + (c >= 2 ? \"s\" : \"\");\n      },\n      \"mois\",\n      function (c) {\n        return \"semaine\" + (c >= 2 ? \"s\" : \"\");\n      },\n      function (c) {\n        return \"jour\" + (c >= 2 ? \"s\" : \"\");\n      },\n      function (c) {\n        return \"heure\" + (c >= 2 ? \"s\" : \"\");\n      },\n      function (c) {\n        return \"minute\" + (c >= 2 ? \"s\" : \"\");\n      },\n      function (c) {\n        return \"seconde\" + (c >= 2 ? \"s\" : \"\");\n      },\n      function (c) {\n        return \"milliseconde\" + (c >= 2 ? \"s\" : \"\");\n      },\n      \",\"\n    ),\n    gr: GREEK,\n    he: language(\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      }\n    ),\n    hr: language(\n      function (c) {\n        if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {\n          return \"godine\";\n        }\n        return \"godina\";\n      },\n      function (c) {\n        if (c === 1) {\n          return \"mjesec\";\n        } else if (c === 2 || c === 3 || c === 4) {\n          return \"mjeseca\";\n        }\n        return \"mjeseci\";\n      },\n      function (c) {\n        if (c % 10 === 1 && c !== 11) {\n          return \"tjedan\";\n        }\n        return \"tjedna\";\n      },\n      function (c) {\n        return c === 1 ? \"dan\" : \"dana\";\n      },\n      function (c) {\n        if (c === 1) {\n          return \"sat\";\n        } else if (c === 2 || c === 3 || c === 4) {\n          return \"sata\";\n        }\n        return \"sati\";\n      },\n      function (c) {\n        var mod10 = c % 10;\n        if ((mod10 === 2 || mod10 === 3 || mod10 === 4) && (c < 10 || c > 14)) {\n          return \"minute\";\n        }\n        return \"minuta\";\n      },\n      function (c) {\n        var mod10 = c % 10;\n        if (mod10 === 5 || (Math.floor(c) === c && c >= 10 && c <= 19)) {\n          return \"sekundi\";\n        } else if (mod10 === 1) {\n          return \"sekunda\";\n        } else if (mod10 === 2 || mod10 === 3 || mod10 === 4) {\n          return \"sekunde\";\n        }\n        return \"sekundi\";\n      },\n      function (c) {\n        if (c === 1) {\n          return \"milisekunda\";\n        } else if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {\n          return \"milisekunde\";\n        }\n        return \"milisekundi\";\n      },\n      \",\"\n    ),\n    hi: language(\n      \"\",\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      \"\",\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      \"\",\n      \"\",\n      \"\"\n    ),\n    hu: language(\n      \"v\",\n      \"hnap\",\n      \"ht\",\n      \"nap\",\n      \"ra\",\n      \"perc\",\n      \"msodperc\",\n      \"ezredmsodperc\",\n      \",\"\n    ),\n    id: language(\n      \"tahun\",\n      \"bulan\",\n      \"minggu\",\n      \"hari\",\n      \"jam\",\n      \"menit\",\n      \"detik\",\n      \"milidetik\"\n    ),\n    is: language(\n      \"r\",\n      function (c) {\n        return \"mnu\" + (c === 1 ? \"ur\" : \"ir\");\n      },\n      function (c) {\n        return \"vik\" + (c === 1 ? \"a\" : \"ur\");\n      },\n      function (c) {\n        return \"dag\" + (c === 1 ? \"ur\" : \"ar\");\n      },\n      function (c) {\n        return \"klukkutm\" + (c === 1 ? \"i\" : \"ar\");\n      },\n      function (c) {\n        return \"mnt\" + (c === 1 ? \"a\" : \"ur\");\n      },\n      function (c) {\n        return \"seknd\" + (c === 1 ? \"a\" : \"ur\");\n      },\n      function (c) {\n        return \"milliseknd\" + (c === 1 ? \"a\" : \"ur\");\n      }\n    ),\n    it: language(\n      function (c) {\n        return \"ann\" + (c === 1 ? \"o\" : \"i\");\n      },\n      function (c) {\n        return \"mes\" + (c === 1 ? \"e\" : \"i\");\n      },\n      function (c) {\n        return \"settiman\" + (c === 1 ? \"a\" : \"e\");\n      },\n      function (c) {\n        return \"giorn\" + (c === 1 ? \"o\" : \"i\");\n      },\n      function (c) {\n        return \"or\" + (c === 1 ? \"a\" : \"e\");\n      },\n      function (c) {\n        return \"minut\" + (c === 1 ? \"o\" : \"i\");\n      },\n      function (c) {\n        return \"second\" + (c === 1 ? \"o\" : \"i\");\n      },\n      function (c) {\n        return \"millisecond\" + (c === 1 ? \"o\" : \"i\");\n      },\n      \",\"\n    ),\n    ja: language(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"),\n    km: language(\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\"\n    ),\n    kn: language(\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      }\n    ),\n    ko: language(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \" \"),\n    ku: language(\n      \"sal\",\n      \"meh\",\n      \"hefte\",\n      \"roj\",\n      \"seet\",\n      \"deqe\",\n      \"saniye\",\n      \"mlirk\",\n      \",\"\n    ),\n    lo: language(\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \",\"\n    ),\n    lt: language(\n      function (c) {\n        return c % 10 === 0 || (c % 100 >= 10 && c % 100 <= 20)\n          ? \"met\"\n          : \"metai\";\n      },\n      function (c) {\n        return [\"mnuo\", \"mnesiai\", \"mnesi\"][getLithuanianForm(c)];\n      },\n      function (c) {\n        return [\"savait\", \"savaits\", \"savaii\"][getLithuanianForm(c)];\n      },\n      function (c) {\n        return [\"diena\", \"dienos\", \"dien\"][getLithuanianForm(c)];\n      },\n      function (c) {\n        return [\"valanda\", \"valandos\", \"valand\"][getLithuanianForm(c)];\n      },\n      function (c) {\n        return [\"minut\", \"minuts\", \"minui\"][getLithuanianForm(c)];\n      },\n      function (c) {\n        return [\"sekund\", \"sekunds\", \"sekundi\"][getLithuanianForm(c)];\n      },\n      function (c) {\n        return [\"milisekund\", \"milisekunds\", \"milisekundi\"][\n          getLithuanianForm(c)\n        ];\n      },\n      \",\"\n    ),\n    lv: language(\n      function (c) {\n        return getLatvianForm(c) ? \"gads\" : \"gadi\";\n      },\n      function (c) {\n        return getLatvianForm(c) ? \"mnesis\" : \"mnei\";\n      },\n      function (c) {\n        return getLatvianForm(c) ? \"neda\" : \"nedas\";\n      },\n      function (c) {\n        return getLatvianForm(c) ? \"diena\" : \"dienas\";\n      },\n      function (c) {\n        return getLatvianForm(c) ? \"stunda\" : \"stundas\";\n      },\n      function (c) {\n        return getLatvianForm(c) ? \"minte\" : \"mintes\";\n      },\n      function (c) {\n        return getLatvianForm(c) ? \"sekunde\" : \"sekundes\";\n      },\n      function (c) {\n        return getLatvianForm(c) ? \"milisekunde\" : \"milisekundes\";\n      },\n      \",\"\n    ),\n    mk: language(\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      \",\"\n    ),\n    mn: language(\n      \"\",\n      \"\",\n      \" \",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\"\n    ),\n    mr: language(\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      \"\",\n      \"\",\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      \"\",\n      \"\"\n    ),\n    ms: language(\n      \"tahun\",\n      \"bulan\",\n      \"minggu\",\n      \"hari\",\n      \"jam\",\n      \"minit\",\n      \"saat\",\n      \"milisaat\"\n    ),\n    nl: language(\n      \"jaar\",\n      function (c) {\n        return c === 1 ? \"maand\" : \"maanden\";\n      },\n      function (c) {\n        return c === 1 ? \"week\" : \"weken\";\n      },\n      function (c) {\n        return c === 1 ? \"dag\" : \"dagen\";\n      },\n      \"uur\",\n      function (c) {\n        return c === 1 ? \"minuut\" : \"minuten\";\n      },\n      function (c) {\n        return c === 1 ? \"seconde\" : \"seconden\";\n      },\n      function (c) {\n        return c === 1 ? \"milliseconde\" : \"milliseconden\";\n      },\n      \",\"\n    ),\n    no: language(\n      \"r\",\n      function (c) {\n        return \"mned\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"uke\" + (c === 1 ? \"\" : \"r\");\n      },\n      function (c) {\n        return \"dag\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"time\" + (c === 1 ? \"\" : \"r\");\n      },\n      function (c) {\n        return \"minutt\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"sekund\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"millisekund\" + (c === 1 ? \"\" : \"er\");\n      },\n      \",\"\n    ),\n    pl: language(\n      function (c) {\n        return [\"rok\", \"roku\", \"lata\", \"lat\"][getPolishForm(c)];\n      },\n      function (c) {\n        return [\"miesic\", \"miesica\", \"miesice\", \"miesicy\"][\n          getPolishForm(c)\n        ];\n      },\n      function (c) {\n        return [\"tydzie\", \"tygodnia\", \"tygodnie\", \"tygodni\"][getPolishForm(c)];\n      },\n      function (c) {\n        return [\"dzie\", \"dnia\", \"dni\", \"dni\"][getPolishForm(c)];\n      },\n      function (c) {\n        return [\"godzina\", \"godziny\", \"godziny\", \"godzin\"][getPolishForm(c)];\n      },\n      function (c) {\n        return [\"minuta\", \"minuty\", \"minuty\", \"minut\"][getPolishForm(c)];\n      },\n      function (c) {\n        return [\"sekunda\", \"sekundy\", \"sekundy\", \"sekund\"][getPolishForm(c)];\n      },\n      function (c) {\n        return [\"milisekunda\", \"milisekundy\", \"milisekundy\", \"milisekund\"][\n          getPolishForm(c)\n        ];\n      },\n      \",\"\n    ),\n    pt: language(\n      function (c) {\n        return \"ano\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return c === 1 ? \"ms\" : \"meses\";\n      },\n      function (c) {\n        return \"semana\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"dia\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"hora\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"minuto\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"segundo\" + (c === 1 ? \"\" : \"s\");\n      },\n      function (c) {\n        return \"milissegundo\" + (c === 1 ? \"\" : \"s\");\n      },\n      \",\"\n    ),\n    ro: language(\n      function (c) {\n        return c === 1 ? \"an\" : \"ani\";\n      },\n      function (c) {\n        return c === 1 ? \"lun\" : \"luni\";\n      },\n      function (c) {\n        return c === 1 ? \"sptmn\" : \"sptmni\";\n      },\n      function (c) {\n        return c === 1 ? \"zi\" : \"zile\";\n      },\n      function (c) {\n        return c === 1 ? \"or\" : \"ore\";\n      },\n      function (c) {\n        return c === 1 ? \"minut\" : \"minute\";\n      },\n      function (c) {\n        return c === 1 ? \"secund\" : \"secunde\";\n      },\n      function (c) {\n        return c === 1 ? \"milisecund\" : \"milisecunde\";\n      },\n      \",\"\n    ),\n    ru: language(\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][\n          getSlavicForm(c)\n        ];\n      },\n      \",\"\n    ),\n    sq: language(\n      function (c) {\n        return c === 1 ? \"vit\" : \"vjet\";\n      },\n      \"muaj\",\n      \"jav\",\n      \"dit\",\n      \"or\",\n      function (c) {\n        return \"minut\" + (c === 1 ? \"\" : \"a\");\n      },\n      function (c) {\n        return \"sekond\" + (c === 1 ? \"\" : \"a\");\n      },\n      function (c) {\n        return \"milisekond\" + (c === 1 ? \"\" : \"a\");\n      },\n      \",\"\n    ),\n    sr: language(\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      \",\"\n    ),\n    sr_Latn: language(\n      function (c) {\n        return [\"godini\", \"godina\", \"godine\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"meseci\", \"mesec\", \"meseca\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"nedelji\", \"nedelja\", \"nedelje\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"dani\", \"dan\", \"dana\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"sati\", \"sat\", \"sata\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"minuta\", \"minut\", \"minuta\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"sekundi\", \"sekunda\", \"sekunde\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"milisekundi\", \"milisekunda\", \"milisekunde\"][getSlavicForm(c)];\n      },\n      \",\"\n    ),\n    ta: language(\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return \"\" + (c === 1 ? \"\" : \"\");\n      },\n      function (c) {\n        return \"\" + (c === 1 ? \"\" : \"\");\n      },\n      function (c) {\n        return \" \" + (c === 1 ? \"\" : \"\");\n      }\n    ),\n    te: language(\n      function (c) {\n        return \"\" + (c === 1 ? \"\" : \"\");\n      },\n      function (c) {\n        return \"\" + (c === 1 ? \"\" : \"\");\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return \"\" + (c === 1 ? \"\" : \"\");\n      },\n      function (c) {\n        return \"\" + (c === 1 ? \"\" : \"\");\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      }\n    ),\n    uk: language(\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      function (c) {\n        return [\"\", \"\", \"\"][getSlavicForm(c)];\n      },\n      \",\"\n    ),\n    ur: language(\n      \"\",\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      \"\",\n      function (c) {\n        return c === 1 ? \"\" : \"\";\n      },\n      \"\",\n      \"\",\n      \" \"\n    ),\n    sk: language(\n      function (c) {\n        return [\"rok\", \"roky\", \"roky\", \"rokov\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"mesiac\", \"mesiace\", \"mesiace\", \"mesiacov\"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      function (c) {\n        return [\"tde\", \"tdne\", \"tdne\", \"tdov\"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      function (c) {\n        return [\"de\", \"dni\", \"dni\", \"dn\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"hodina\", \"hodiny\", \"hodiny\", \"hodn\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"minta\", \"minty\", \"minty\", \"mint\"][getCzechOrSlovakForm(c)];\n      },\n      function (c) {\n        return [\"sekunda\", \"sekundy\", \"sekundy\", \"seknd\"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      function (c) {\n        return [\"milisekunda\", \"milisekundy\", \"milisekundy\", \"miliseknd\"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      \",\"\n    ),\n    sl: language(\n      function (c) {\n        if (c % 10 === 1) {\n          return \"leto\";\n        } else if (c % 100 === 2) {\n          return \"leti\";\n        } else if (\n          c % 100 === 3 ||\n          c % 100 === 4 ||\n          (Math.floor(c) !== c && c % 100 <= 5)\n        ) {\n          return \"leta\";\n        } else {\n          return \"let\";\n        }\n      },\n      function (c) {\n        if (c % 10 === 1) {\n          return \"mesec\";\n        } else if (c % 100 === 2 || (Math.floor(c) !== c && c % 100 <= 5)) {\n          return \"meseca\";\n        } else if (c % 10 === 3 || c % 10 === 4) {\n          return \"mesece\";\n        } else {\n          return \"mesecev\";\n        }\n      },\n      function (c) {\n        if (c % 10 === 1) {\n          return \"teden\";\n        } else if (c % 10 === 2 || (Math.floor(c) !== c && c % 100 <= 4)) {\n          return \"tedna\";\n        } else if (c % 10 === 3 || c % 10 === 4) {\n          return \"tedne\";\n        } else {\n          return \"tednov\";\n        }\n      },\n      function (c) {\n        return c % 100 === 1 ? \"dan\" : \"dni\";\n      },\n      function (c) {\n        if (c % 10 === 1) {\n          return \"ura\";\n        } else if (c % 100 === 2) {\n          return \"uri\";\n        } else if (c % 10 === 3 || c % 10 === 4 || Math.floor(c) !== c) {\n          return \"ure\";\n        } else {\n          return \"ur\";\n        }\n      },\n      function (c) {\n        if (c % 10 === 1) {\n          return \"minuta\";\n        } else if (c % 10 === 2) {\n          return \"minuti\";\n        } else if (\n          c % 10 === 3 ||\n          c % 10 === 4 ||\n          (Math.floor(c) !== c && c % 100 <= 4)\n        ) {\n          return \"minute\";\n        } else {\n          return \"minut\";\n        }\n      },\n      function (c) {\n        if (c % 10 === 1) {\n          return \"sekunda\";\n        } else if (c % 100 === 2) {\n          return \"sekundi\";\n        } else if (c % 100 === 3 || c % 100 === 4 || Math.floor(c) !== c) {\n          return \"sekunde\";\n        } else {\n          return \"sekund\";\n        }\n      },\n      function (c) {\n        if (c % 10 === 1) {\n          return \"milisekunda\";\n        } else if (c % 100 === 2) {\n          return \"milisekundi\";\n        } else if (c % 100 === 3 || c % 100 === 4 || Math.floor(c) !== c) {\n          return \"milisekunde\";\n        } else {\n          return \"milisekund\";\n        }\n      },\n      \",\"\n    ),\n    sv: language(\n      \"r\",\n      function (c) {\n        return \"mnad\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"veck\" + (c === 1 ? \"a\" : \"or\");\n      },\n      function (c) {\n        return \"dag\" + (c === 1 ? \"\" : \"ar\");\n      },\n      function (c) {\n        return \"timm\" + (c === 1 ? \"e\" : \"ar\");\n      },\n      function (c) {\n        return \"minut\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"sekund\" + (c === 1 ? \"\" : \"er\");\n      },\n      function (c) {\n        return \"millisekund\" + (c === 1 ? \"\" : \"er\");\n      },\n      \",\"\n    ),\n    sw: assign(\n      language(\n        function (c) {\n          return c === 1 ? \"mwaka\" : \"miaka\";\n        },\n        function (c) {\n          return c === 1 ? \"mwezi\" : \"miezi\";\n        },\n        \"wiki\",\n        function (c) {\n          return c === 1 ? \"siku\" : \"masiku\";\n        },\n        function (c) {\n          return c === 1 ? \"saa\" : \"masaa\";\n        },\n        \"dakika\",\n        \"sekunde\",\n        \"milisekunde\"\n      ),\n      { _numberFirst: true }\n    ),\n    tr: language(\n      \"yl\",\n      \"ay\",\n      \"hafta\",\n      \"gn\",\n      \"saat\",\n      \"dakika\",\n      \"saniye\",\n      \"milisaniye\",\n      \",\"\n    ),\n    th: language(\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\"\n    ),\n    uz: language(\n      \"yil\",\n      \"oy\",\n      \"hafta\",\n      \"kun\",\n      \"soat\",\n      \"minut\",\n      \"sekund\",\n      \"millisekund\"\n    ),\n    uz_CYR: language(\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\",\n      \"\"\n    ),\n    vi: language(\n      \"nm\",\n      \"thng\",\n      \"tun\",\n      \"ngy\",\n      \"gi\",\n      \"pht\",\n      \"giy\",\n      \"mili giy\",\n      \",\"\n    ),\n    zh_CN: language(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"),\n    zh_TW: language(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\")\n  };\n\n  /**\n   * Helper function for creating language definitions.\n   *\n   * @internal\n   * @param {Unit} y\n   * @param {Unit} mo\n   * @param {Unit} w\n   * @param {Unit} d\n   * @param {Unit} h\n   * @param {Unit} m\n   * @param {Unit} s\n   * @param {Unit} ms\n   * @param {string} [decimal]\n   * @returns {Language}\n   */\n  function language(y, mo, w, d, h, m, s, ms, decimal) {\n    /** @type {Language} */\n    var result = { y: y, mo: mo, w: w, d: d, h: h, m: m, s: s, ms: ms };\n    if (typeof decimal !== \"undefined\") {\n      result.decimal = decimal;\n    }\n    return result;\n  }\n\n  /**\n   * Helper function for Arabic.\n   *\n   * @internal\n   * @param {number} c\n   * @returns {0 | 1 | 2}\n   */\n  function getArabicForm(c) {\n    if (c === 2) {\n      return 1;\n    }\n    if (c > 2 && c < 11) {\n      return 2;\n    }\n    return 0;\n  }\n\n  /**\n   * Helper function for Polish.\n   *\n   * @internal\n   * @param {number} c\n   * @returns {0 | 1 | 2 | 3}\n   */\n  function getPolishForm(c) {\n    if (c === 1) {\n      return 0;\n    }\n    if (Math.floor(c) !== c) {\n      return 1;\n    }\n    if (c % 10 >= 2 && c % 10 <= 4 && !(c % 100 > 10 && c % 100 < 20)) {\n      return 2;\n    }\n    return 3;\n  }\n\n  /**\n   * Helper function for Slavic languages.\n   *\n   * @internal\n   * @param {number} c\n   * @returns {0 | 1 | 2 | 3}\n   */\n  function getSlavicForm(c) {\n    if (Math.floor(c) !== c) {\n      return 2;\n    }\n    if (\n      (c % 100 >= 5 && c % 100 <= 20) ||\n      (c % 10 >= 5 && c % 10 <= 9) ||\n      c % 10 === 0\n    ) {\n      return 0;\n    }\n    if (c % 10 === 1) {\n      return 1;\n    }\n    if (c > 1) {\n      return 2;\n    }\n    return 0;\n  }\n\n  /**\n   * Helper function for Czech or Slovak.\n   *\n   * @internal\n   * @param {number} c\n   * @returns {0 | 1 | 2 | 3}\n   */\n  function getCzechOrSlovakForm(c) {\n    if (c === 1) {\n      return 0;\n    }\n    if (Math.floor(c) !== c) {\n      return 1;\n    }\n    if (c % 10 >= 2 && c % 10 <= 4 && c % 100 < 10) {\n      return 2;\n    }\n    return 3;\n  }\n\n  /**\n   * Helper function for Lithuanian.\n   *\n   * @internal\n   * @param {number} c\n   * @returns {0 | 1 | 2}\n   */\n  function getLithuanianForm(c) {\n    if (c === 1 || (c % 10 === 1 && c % 100 > 20)) {\n      return 0;\n    }\n    if (\n      Math.floor(c) !== c ||\n      (c % 10 >= 2 && c % 100 > 20) ||\n      (c % 10 >= 2 && c % 100 < 10)\n    ) {\n      return 1;\n    }\n    return 2;\n  }\n\n  /**\n   * Helper function for Latvian.\n   *\n   * @internal\n   * @param {number} c\n   * @returns {boolean}\n   */\n  function getLatvianForm(c) {\n    return c % 10 === 1 && c % 100 !== 11;\n  }\n\n  /**\n   * @internal\n   * @template T\n   * @param {T} obj\n   * @param {keyof T} key\n   * @returns {boolean}\n   */\n  function has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * @internal\n   * @param {Pick<Required<Options>, \"language\" | \"fallbacks\" | \"languages\">} options\n   * @throws {Error} Throws an error if language is not found.\n   * @returns {Language}\n   */\n  function getLanguage(options) {\n    var possibleLanguages = [options.language];\n\n    if (has(options, \"fallbacks\")) {\n      if (isArray(options.fallbacks) && options.fallbacks.length) {\n        possibleLanguages = possibleLanguages.concat(options.fallbacks);\n      } else {\n        throw new Error(\"fallbacks must be an array with at least one element\");\n      }\n    }\n\n    for (var i = 0; i < possibleLanguages.length; i++) {\n      var languageToTry = possibleLanguages[i];\n      if (has(options.languages, languageToTry)) {\n        return options.languages[languageToTry];\n      }\n      if (has(LANGUAGES, languageToTry)) {\n        return LANGUAGES[languageToTry];\n      }\n    }\n\n    throw new Error(\"No language found.\");\n  }\n\n  /**\n   * @internal\n   * @param {Piece} piece\n   * @param {Language} language\n   * @param {Pick<Required<Options>, \"decimal\" | \"spacer\" | \"maxDecimalPoints\" | \"digitReplacements\">} options\n   */\n  function renderPiece(piece, language, options) {\n    var unitName = piece.unitName;\n    var unitCount = piece.unitCount;\n\n    var spacer = options.spacer;\n    var maxDecimalPoints = options.maxDecimalPoints;\n\n    /** @type {string} */\n    var decimal;\n    if (has(options, \"decimal\")) {\n      decimal = options.decimal;\n    } else if (has(language, \"decimal\")) {\n      decimal = language.decimal;\n    } else {\n      decimal = \".\";\n    }\n\n    /** @type {undefined | DigitReplacements} */\n    var digitReplacements;\n    if (\"digitReplacements\" in options) {\n      digitReplacements = options.digitReplacements;\n    } else if (\"_digitReplacements\" in language) {\n      digitReplacements = language._digitReplacements;\n    }\n\n    /** @type {string} */\n    var formattedCount;\n    var normalizedUnitCount =\n      maxDecimalPoints === void 0\n        ? unitCount\n        : Math.floor(unitCount * Math.pow(10, maxDecimalPoints)) /\n          Math.pow(10, maxDecimalPoints);\n    var countStr = normalizedUnitCount.toString();\n\n    if (language._hideCountIf2 && unitCount === 2) {\n      formattedCount = \"\";\n      spacer = \"\";\n    } else {\n      if (digitReplacements) {\n        formattedCount = \"\";\n        for (var i = 0; i < countStr.length; i++) {\n          var character = countStr[i];\n          if (character === \".\") {\n            formattedCount += decimal;\n          } else {\n            formattedCount +=\n              digitReplacements[\n                /** @type {\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"} */ (\n                  character\n                )\n              ];\n          }\n        }\n      } else {\n        formattedCount = countStr.replace(\".\", decimal);\n      }\n    }\n\n    var languageWord = language[unitName];\n    var word;\n    if (typeof languageWord === \"function\") {\n      word = languageWord(unitCount);\n    } else {\n      word = languageWord;\n    }\n\n    if (language._numberFirst) {\n      return word + spacer + formattedCount;\n    }\n    return formattedCount + spacer + word;\n  }\n\n  /**\n   * @internal\n   * @typedef {Object} Piece\n   * @prop {UnitName} unitName\n   * @prop {number} unitCount\n   */\n\n  /**\n   * @internal\n   * @param {number} ms\n   * @param {Pick<Required<Options>, \"units\" | \"unitMeasures\" | \"largest\" | \"round\">} options\n   * @returns {Piece[]}\n   */\n  function getPieces(ms, options) {\n    /** @type {UnitName} */\n    var unitName;\n\n    /** @type {number} */\n    var i;\n\n    /** @type {number} */\n    var unitCount;\n\n    /** @type {number} */\n    var msRemaining;\n\n    var units = options.units;\n    var unitMeasures = options.unitMeasures;\n    var largest = \"largest\" in options ? options.largest : Infinity;\n\n    if (!units.length) return [];\n\n    // Get the counts for each unit. Doesn't round or truncate anything.\n    // For example, might create an object like `{ y: 7, m: 6, w: 0, d: 5, h: 23.99 }`.\n    /** @type {Partial<Record<UnitName, number>>} */\n    var unitCounts = {};\n    msRemaining = ms;\n    for (i = 0; i < units.length; i++) {\n      unitName = units[i];\n      var unitMs = unitMeasures[unitName];\n\n      var isLast = i === units.length - 1;\n      unitCount = isLast\n        ? msRemaining / unitMs\n        : Math.floor(msRemaining / unitMs);\n      unitCounts[unitName] = unitCount;\n\n      msRemaining -= unitCount * unitMs;\n    }\n\n    if (options.round) {\n      // Update counts based on the `largest` option.\n      // For example, if `largest === 2` and `unitCount` is `{ y: 7, m: 6, w: 0, d: 5, h: 23.99 }`,\n      // updates to something like `{ y: 7, m: 6.2 }`.\n      var unitsRemainingBeforeRound = largest;\n      for (i = 0; i < units.length; i++) {\n        unitName = units[i];\n        unitCount = unitCounts[unitName];\n\n        if (unitCount === 0) continue;\n\n        unitsRemainingBeforeRound--;\n\n        // \"Take\" the rest of the units into this one.\n        if (unitsRemainingBeforeRound === 0) {\n          for (var j = i + 1; j < units.length; j++) {\n            var smallerUnitName = units[j];\n            var smallerUnitCount = unitCounts[smallerUnitName];\n            unitCounts[unitName] +=\n              (smallerUnitCount * unitMeasures[smallerUnitName]) /\n              unitMeasures[unitName];\n            unitCounts[smallerUnitName] = 0;\n          }\n          break;\n        }\n      }\n\n      // Round the last piece (which should be the only non-integer).\n      //\n      // This can be a little tricky if the last piece \"bubbles up\" to a larger\n      // unit. For example, \"3 days, 23.99 hours\" should be rounded to \"4 days\".\n      // It can also require multiple passes. For example, \"6 days, 23.99 hours\"\n      // should become \"1 week\".\n      for (i = units.length - 1; i >= 0; i--) {\n        unitName = units[i];\n        unitCount = unitCounts[unitName];\n\n        if (unitCount === 0) continue;\n\n        var rounded = Math.round(unitCount);\n        unitCounts[unitName] = rounded;\n\n        if (i === 0) break;\n\n        var previousUnitName = units[i - 1];\n        var previousUnitMs = unitMeasures[previousUnitName];\n        var amountOfPreviousUnit = Math.floor(\n          (rounded * unitMeasures[unitName]) / previousUnitMs\n        );\n        if (amountOfPreviousUnit) {\n          unitCounts[previousUnitName] += amountOfPreviousUnit;\n          unitCounts[unitName] = 0;\n        } else {\n          break;\n        }\n      }\n    }\n\n    /** @type {Piece[]} */\n    var result = [];\n    for (i = 0; i < units.length && result.length < largest; i++) {\n      unitName = units[i];\n      unitCount = unitCounts[unitName];\n      if (unitCount) {\n        result.push({ unitName: unitName, unitCount: unitCount });\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @internal\n   * @param {Piece[]} pieces\n   * @param {Pick<Required<Options>, \"units\" | \"language\" | \"languages\" | \"fallbacks\" | \"delimiter\" | \"spacer\" | \"decimal\" | \"conjunction\" | \"maxDecimalPoints\" | \"serialComma\" | \"digitReplacements\">} options\n   * @returns {string}\n   */\n  function formatPieces(pieces, options) {\n    var language = getLanguage(options);\n\n    if (!pieces.length) {\n      var units = options.units;\n      var smallestUnitName = units[units.length - 1];\n      return renderPiece(\n        { unitName: smallestUnitName, unitCount: 0 },\n        language,\n        options\n      );\n    }\n\n    var conjunction = options.conjunction;\n    var serialComma = options.serialComma;\n\n    var delimiter;\n    if (has(options, \"delimiter\")) {\n      delimiter = options.delimiter;\n    } else if (has(language, \"delimiter\")) {\n      delimiter = language.delimiter;\n    } else {\n      delimiter = \", \";\n    }\n\n    /** @type {string[]} */\n    var renderedPieces = [];\n    for (var i = 0; i < pieces.length; i++) {\n      renderedPieces.push(renderPiece(pieces[i], language, options));\n    }\n\n    if (!conjunction || pieces.length === 1) {\n      return renderedPieces.join(delimiter);\n    }\n\n    if (pieces.length === 2) {\n      return renderedPieces.join(conjunction);\n    }\n\n    return (\n      renderedPieces.slice(0, -1).join(delimiter) +\n      (serialComma ? \",\" : \"\") +\n      conjunction +\n      renderedPieces.slice(-1)\n    );\n  }\n\n  /**\n   * Create a humanizer, which lets you change the default options.\n   *\n   * @param {Options} [passedOptions]\n   */\n  function humanizer(passedOptions) {\n    /**\n     * @param {number} ms\n     * @param {Options} [humanizerOptions]\n     * @returns {string}\n     */\n    var result = function humanizer(ms, humanizerOptions) {\n      // Make sure we have a positive number.\n      //\n      // Has the nice side-effect of converting things to numbers. For example,\n      // converts `\"123\"` and `Number(123)` to `123`.\n      ms = Math.abs(ms);\n\n      var options = assign({}, result, humanizerOptions || {});\n\n      var pieces = getPieces(ms, options);\n\n      return formatPieces(pieces, options);\n    };\n\n    return assign(\n      result,\n      {\n        language: \"en\",\n        spacer: \" \",\n        conjunction: \"\",\n        serialComma: true,\n        units: [\"y\", \"mo\", \"w\", \"d\", \"h\", \"m\", \"s\"],\n        languages: {},\n        round: false,\n        unitMeasures: {\n          y: 31557600000,\n          mo: 2629800000,\n          w: 604800000,\n          d: 86400000,\n          h: 3600000,\n          m: 60000,\n          s: 1000,\n          ms: 1\n        }\n      },\n      passedOptions\n    );\n  }\n\n  /**\n   * Humanize a duration.\n   *\n   * This is a wrapper around the default humanizer.\n   */\n  var humanizeDuration = assign(humanizer({}), {\n    getSupportedLanguages: function getSupportedLanguages() {\n      var result = [];\n      for (var language in LANGUAGES) {\n        if (has(LANGUAGES, language) && language !== \"gr\") {\n          result.push(language);\n        }\n      }\n      return result;\n    },\n    humanizer: humanizer\n  });\n\n  // @ts-ignore\n  if (typeof define === \"function\" && define.amd) {\n    // @ts-ignore\n    define(function () {\n      return humanizeDuration;\n    });\n  } else if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = humanizeDuration;\n  } else {\n    this.humanizeDuration = humanizeDuration;\n  }\n})();\n","\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PreciseDate = void 0;\nconst FULL_ISO_REG = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d{4,9}Z/;\nconst NO_BIG_INT = 'BigInt only available in Node >= v10.7. Consider using getFullTimeString instead.';\nvar Sign;\n(function (Sign) {\n    Sign[Sign[\"NEGATIVE\"] = -1] = \"NEGATIVE\";\n    Sign[Sign[\"POSITIVE\"] = 1] = \"POSITIVE\";\n    Sign[Sign[\"ZERO\"] = 0] = \"ZERO\";\n})(Sign || (Sign = {}));\n/**\n * The native Date object.\n * @external Date\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date}\n */\n/**\n * @typedef {array} DateTuple\n * @property {number} 0 Represents seconds of UTC time since Unix epoch\n *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n *     9999-12-31T23:59:59Z inclusive.\n * @property {number} 1 Non-negative fractions of a second at nanosecond\n *     resolution. Negative second values with fractions must still have\n *     non-negative nanos values that count forward in time. Must be from 0 to\n *     999,999,999 inclusive.\n */\n/**\n * @typedef {object} DateStruct\n * @property {number} seconds Represents seconds of UTC time since Unix epoch\n *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n *     9999-12-31T23:59:59Z inclusive.\n * @property {number} nanos Non-negative fractions of a second at nanosecond\n *     resolution. Negative second values with fractions must still have\n *     non-negative nanos values that count forward in time. Must be from 0 to\n *     999,999,999 inclusive.\n */\n/**\n * Date object with nanosecond precision. Supports all standard Date arguments\n * in addition to several custom types as noted below.\n *\n * @class\n * @extends external:Date\n *\n * @param {number|string|bigint|Date|DateTuple|DateStruct} [time] The time\n *     value.\n * @param {...number} [dateFields] Additional date fields (month, date, hours,\n *     minutes, seconds, milliseconds, microseconds, nanoseconds).\n *\n * @example <caption>With a RFC 3339 formatted string.</caption>\n * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n *\n * @example <caption>With a nanosecond timestamp string.</caption>\n * const date = new PreciseDate('1549622069481320032');\n *\n * @example <caption>With a BigInt (requires Node >= v10.7)</caption>\n * const date = new PreciseDate(1549622069481320032n);\n *\n * @example <caption>With a tuple containing seconds and nanoseconds.</caption>\n * const date = new PreciseDate([1549622069, 481320032]);\n *\n * @example <caption>With an object containing `seconds` and `nanos`</caption>\n * const date = new PreciseDate({seconds: 1549622069, nanos: 481320032});\n *\n * @example <caption>Specifiying date fields</caption>\n * const date = new PreciseDate(2018, 5, 14, 41, 11, 34, 123, 874, 321);\n */\nclass PreciseDate extends Date {\n    constructor(time) {\n        super();\n        this._micros = 0;\n        this._nanos = 0;\n        if (time && typeof time !== 'number' && !(time instanceof Date)) {\n            this.setFullTime(PreciseDate.parseFull(time));\n            return;\n        }\n        // eslint-disable-next-line prefer-rest-params\n        const args = Array.from(arguments);\n        const dateFields = args.slice(0, 7);\n        const date = new Date(...dateFields);\n        const nanos = args.length === 9 ? args.pop() : 0;\n        const micros = args.length === 8 ? args.pop() : 0;\n        this.setTime(date.getTime());\n        this.setMicroseconds(micros);\n        this.setNanoseconds(nanos);\n    }\n    /**\n     * Returns the specified date represented in nanoseconds according to\n     * universal time.\n     *\n     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.\n     * Use {@link PreciseDate#getFullTimeString} to get the time as a string.\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @throws {error} If `BigInt` is unavailable.\n     * @returns {bigint}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getFullTime());\n     * // expected output: 1549622069481145231n\n     */\n    getFullTime() {\n        if (typeof BigInt !== 'function') {\n            throw new Error(NO_BIG_INT);\n        }\n        return BigInt(this.getFullTimeString());\n    }\n    /**\n     * Returns a string of the specified date represented in nanoseconds according\n     * to universal time.\n     *\n     * @returns {string}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getFullTimeString());\n     * // expected output: \"1549622069481145231\"\n     */\n    getFullTimeString() {\n        const seconds = this._getSeconds();\n        let nanos = this._getNanos();\n        if (nanos && Math.sign(seconds) === Sign.NEGATIVE) {\n            nanos = 1e9 - nanos;\n        }\n        return `${seconds}${padLeft(nanos, 9)}`;\n    }\n    /**\n     * Returns the microseconds in the specified date according to universal time.\n     *\n     * @returns {number}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145Z');\n     *\n     * console.log(date.getMicroseconds());\n     * // expected output: 145\n     */\n    getMicroseconds() {\n        return this._micros;\n    }\n    /**\n     * Returns the nanoseconds in the specified date according to universal time.\n     *\n     * @returns {number}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getNanoseconds());\n     * // expected output: 231\n     */\n    getNanoseconds() {\n        return this._nanos;\n    }\n    /**\n     * Sets the microseconds for a specified date according to universal time.\n     *\n     * @param {number} microseconds A number representing the microseconds.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example\n     * const date = new PreciseDate();\n     *\n     * date.setMicroseconds(149);\n     *\n     * console.log(date.getMicroseconds());\n     * // expected output: 149\n     */\n    setMicroseconds(micros) {\n        const abs = Math.abs(micros);\n        let millis = this.getUTCMilliseconds();\n        if (abs >= 1000) {\n            millis += Math.floor(abs / 1000) * Math.sign(micros);\n            micros %= 1000;\n        }\n        if (Math.sign(micros) === Sign.NEGATIVE) {\n            millis -= 1;\n            micros += 1000;\n        }\n        this._micros = micros;\n        this.setUTCMilliseconds(millis);\n        return this.getFullTimeString();\n    }\n    /**\n     * Sets the nanoseconds for a specified date according to universal time.\n     *\n     * @param {number} nanoseconds A number representing the nanoseconds.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example\n     * const date = new PreciseDate();\n     *\n     * date.setNanoseconds(231);\n     *\n     * console.log(date.getNanoseconds());\n     * // expected output: 231\n     */\n    setNanoseconds(nanos) {\n        const abs = Math.abs(nanos);\n        let micros = this._micros;\n        if (abs >= 1000) {\n            micros += Math.floor(abs / 1000) * Math.sign(nanos);\n            nanos %= 1000;\n        }\n        if (Math.sign(nanos) === Sign.NEGATIVE) {\n            micros -= 1;\n            nanos += 1000;\n        }\n        this._nanos = nanos;\n        return this.setMicroseconds(micros);\n    }\n    /**\n     * Sets the PreciseDate object to the time represented by a number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * @param {bigint|number|string} time Value representing the number of\n     *     nanoseconds since January 1, 1970, 00:00:00 UTC.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time (effectively, the value of\n     *     the argument).\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @example <caption>With a nanosecond string.</caption>\n     * const date = new PreciseDate();\n     * date.setFullTime('1549622069481145231');\n     *\n     * @example <caption>With a BigInt</caption>\n     * date.setFullTime(1549622069481145231n);\n     */\n    setFullTime(time) {\n        if (typeof time !== 'string') {\n            time = time.toString();\n        }\n        const sign = Math.sign(Number(time));\n        time = time.replace(/^-/, '');\n        const seconds = Number(time.substr(0, time.length - 9)) * sign;\n        const nanos = Number(time.substr(-9)) * sign;\n        this.setTime(seconds * 1000);\n        return this.setNanoseconds(nanos);\n    }\n    /**\n     * Sets the PreciseDate object to the time represented by a number of\n     * milliseconds since January 1, 1970, 00:00:00 UTC. Calling this method will\n     * reset both the microseconds and nanoseconds to 0.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime|Date#setTime}\n     *\n     * @param {number} time Value representing the number of milliseconds since\n     *     January 1, 1970, 00:00:00 UTC.\n     * @returns {string} The number of milliseconds between January 1, 1970,\n     *     00:00:00 UTC and the updated date (effectively, the value of the\n     *     argument).\n     */\n    setTime(time) {\n        this._micros = 0;\n        this._nanos = 0;\n        return super.setTime(time);\n    }\n    /**\n     * Returns a string in RFC 3339 format. Unlike the native `Date#toISOString`,\n     * this will return 9 digits to represent sub-second precision.\n     *\n     * @see {@link https://tools.ietf.org/html/rfc3339|RFC 3339}\n     *\n     * @returns {string}\n     *\n     * @example\n     * const date = new PreciseDate(1549622069481145231n);\n     *\n     * console.log(date.toISOString());\n     * // expected output: \"2019-02-08T10:34:29.481145231Z\"\n     */\n    toISOString() {\n        const micros = padLeft(this._micros, 3);\n        const nanos = padLeft(this._nanos, 3);\n        return super.toISOString().replace(/z$/i, `${micros}${nanos}Z`);\n    }\n    /**\n     * Returns an object representing the specified date according to universal\n     * time.\n     *\n     * @see {@link https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#timestamp|google.protobuf.Timestamp}\n     *\n     * @returns {DateStruct}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.toStruct());\n     * // expected output: {seconds: 1549622069, nanos: 481145231}\n     */\n    toStruct() {\n        let seconds = this._getSeconds();\n        const nanos = this._getNanos();\n        const sign = Math.sign(seconds);\n        // These objects are essentially a mirror of protobuf timestamps.\n        // `nanos` must always count forward in time, even if the date is <= Unix\n        // epoch. To do this we just need to count backwards 1 second and return the\n        // nanoseconds as is.\n        if (sign === Sign.NEGATIVE && nanos) {\n            seconds -= 1;\n        }\n        return { seconds, nanos };\n    }\n    /**\n     * Returns a tuple representing the specified date according to universal\n     * time.\n     *\n     * @returns {DateTuple}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.toTuple());\n     * // expected output: [1549622069, 481145231]\n     */\n    toTuple() {\n        const { seconds, nanos } = this.toStruct();\n        return [seconds, nanos];\n    }\n    /**\n     * Returns the total number of seconds in the specified date since Unix epoch.\n     * Numbers representing < epoch will be negative.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n    _getSeconds() {\n        const time = this.getTime();\n        const sign = Math.sign(time);\n        return Math.floor(Math.abs(time) / 1000) * sign;\n    }\n    /**\n     * Returns the sub-second precision of the specified date. This will always be\n     * a positive number.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n    _getNanos() {\n        const msInNanos = this.getUTCMilliseconds() * 1e6;\n        const microsInNanos = this._micros * 1000;\n        return this._nanos + msInNanos + microsInNanos;\n    }\n    /**\n     * Parses a precise time.\n     *\n     * @static\n     *\n     * @param {string|bigint|DateTuple|DateStruct} time The precise time value.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example <caption>From a RFC 3339 formatted string.</caption>\n     * const time = PreciseDate.parseFull('2019-02-08T10:34:29.481145231Z');\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a nanosecond timestamp string.</caption>\n     * const time = PreciseDate.parseFull('1549622069481145231');\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a BigInt (requires Node >= v10.7)</caption>\n     * const time = PreciseDate.parseFull(1549622069481145231n);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a tuple.</caption>\n     * const time = PreciseDate.parseFull([1549622069, 481145231]);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From an object.</caption>\n     * const struct = {seconds: 1549622069, nanos: 481145231};\n     * const time = PreciseDate.parseFull(struct);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     */\n    static parseFull(time) {\n        const date = new PreciseDate();\n        if (Array.isArray(time)) {\n            const [seconds, nanos] = time;\n            time = { seconds, nanos };\n        }\n        if (isFullTime(time)) {\n            date.setFullTime(time);\n        }\n        else if (isStruct(time)) {\n            const { seconds, nanos } = parseProto(time);\n            date.setTime(seconds * 1000);\n            date.setNanoseconds(nanos);\n        }\n        else if (isFullISOString(time)) {\n            date.setFullTime(parseFullISO(time));\n        }\n        else {\n            date.setTime(new Date(time).getTime());\n        }\n        return date.getFullTimeString();\n    }\n    /**\n     * Accepts the same number parameters as the PreciseDate constructor, but\n     * treats them as UTC. It returns a string that represents the number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @static\n     *\n     * @throws {error} If `BigInt` is unavailable.\n     *\n     * @param {...number} [dateFields] The date fields.\n     * @returns {bigint}\n     *\n     * @example\n     * const time = PreciseDate.fullUTC(2019, 1, 8, 10, 34, 29, 481, 145, 231);\n     * console.log(time); // expected output: 1549622069481145231n\n     */\n    static fullUTC(...args) {\n        if (typeof BigInt !== 'function') {\n            throw new Error(NO_BIG_INT);\n        }\n        return BigInt(PreciseDate.fullUTCString(...args));\n    }\n    /**\n     * Accepts the same number parameters as the PreciseDate constructor, but\n     * treats them as UTC. It returns a string that represents the number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * @static\n     *\n     * @param {...number} [dateFields] The date fields.\n     * @returns {string}\n     *\n     * @example\n     * const time = PreciseDate.fullUTCString(2019, 1, 8, 10, 34, 29, 481, 145,\n     * 231); console.log(time); // expected output: '1549622069481145231'\n     */\n    static fullUTCString(...args) {\n        const milliseconds = Date.UTC(...args.slice(0, 7));\n        const date = new PreciseDate(milliseconds);\n        if (args.length === 9) {\n            date.setNanoseconds(args.pop());\n        }\n        if (args.length === 8) {\n            date.setMicroseconds(args.pop());\n        }\n        return date.getFullTimeString();\n    }\n}\nexports.PreciseDate = PreciseDate;\n/**\n * Parses a RFC 3339 formatted string representation of the date, and returns\n * a string representing the nanoseconds since January 1, 1970, 00:00:00.\n *\n * @private\n *\n * @param {string} time The RFC 3339 formatted string.\n * @returns {string}\n */\nfunction parseFullISO(time) {\n    let digits = '0';\n    time = time.replace(/\\.(\\d+)/, ($0, $1) => {\n        digits = $1;\n        return '.000';\n    });\n    const nanos = Number(padRight(digits, 9));\n    const date = new PreciseDate(time);\n    return date.setNanoseconds(nanos);\n}\n/**\n * Normalizes a {@link google.protobuf.Timestamp} object.\n *\n * @private\n *\n * @param {google.protobuf.Timestamp} timestamp The timestamp object.\n * @returns {DateStruct}\n */\nfunction parseProto({ seconds = 0, nanos = 0 }) {\n    if (typeof seconds.toNumber === 'function') {\n        seconds = seconds.toNumber();\n    }\n    seconds = Number(seconds);\n    nanos = Number(nanos);\n    return { seconds, nanos };\n}\n/**\n * Checks to see if time value is specified in nanoseconds. We assume that all\n * BigInt and string timestamps represent nanoseconds.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isFullTime(time) {\n    return (typeof time === 'bigint' || (typeof time === 'string' && /^\\d+$/.test(time)));\n}\n/**\n * Checks to see if time value is a {@link DateStruct}.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isStruct(time) {\n    return ((typeof time === 'object' &&\n        typeof time.seconds !== 'undefined') ||\n        typeof time.nanos === 'number');\n}\n/**\n * Checks to see if the time value is a RFC 3339 formatted string.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isFullISOString(time) {\n    return typeof time === 'string' && FULL_ISO_REG.test(time);\n}\n/**\n * Pads a number/string with \"0\" to the left.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} min The min size of the padded string.\n * @returns {string}\n */\nfunction padLeft(n, min) {\n    const padding = getPadding(n, min);\n    return `${padding}${n}`;\n}\n/**\n * Pads a number/string with \"0\" to the right.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} min The min size of the padded string.\n * @returns {string}\n */\nfunction padRight(n, min) {\n    const padding = getPadding(n, min);\n    return `${n}${padding}`;\n}\n/**\n * Creates padding based on current size and min size needed.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} [min=3] The min size of the padded string.\n * @returns {string}\n */\nfunction getPadding(n, min) {\n    const size = Math.max(min - n.toString().length, 0);\n    return '0'.repeat(size);\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar simple_key_path_component_1 = require(\"./simple-key-path-component\");\nvar wildcard_path_component_1 = require(\"./wildcard-path-component\");\nvar start_path_component_1 = require(\"./start-path-component\");\nvar slice_path_component_1 = require(\"./slice-path-component\");\nvar PathBuilder = /** @class */ (function () {\n    function PathBuilder() {\n    }\n    PathBuilder.prototype.parse = function (path) {\n        PathBuilder.pathPattern.lastIndex = 0;\n        var subPaths = path.match(PathBuilder.pathPattern);\n        var components = [new start_path_component_1.default()];\n        if (subPaths == null || subPaths.length == 0 || (subPaths.length == 1 && subPaths[0] == '')) {\n            return components;\n        }\n        //if there's a $ at the start we want to skip adding another StartPathComponent()\n        var startIndex = 0;\n        if (subPaths[0] == '$') {\n            startIndex = 1;\n        }\n        for (var i = startIndex; i < subPaths.length; i++) {\n            var subPath = subPaths[i];\n            var pathComponent = this.parseComponent(subPath);\n            components.push(pathComponent);\n        }\n        return components;\n    };\n    PathBuilder.prototype.parsePointer = function (pointer) {\n        PathBuilder.pathPattern.lastIndex = 0;\n        var subPaths = pointer.match(PathBuilder.pointerPattern);\n        var components = [new start_path_component_1.default()];\n        if (subPaths == null || subPaths.length == 0 || (subPaths.length == 1 && subPaths[0] == '')) {\n            return components;\n        }\n        for (var _i = 0, subPaths_1 = subPaths; _i < subPaths_1.length; _i++) {\n            var subPath = subPaths_1[_i];\n            components.push(this.parseComponent(subPath));\n        }\n        return components;\n    };\n    PathBuilder.prototype.parseComponent = function (string) {\n        var wildcardComponent = wildcard_path_component_1.WildcardPathComponent.fromString(string);\n        if (wildcardComponent != null) {\n            return wildcardComponent;\n        }\n        if (string == null) {\n            throw new SyntaxError('Cannot create a path from null');\n        }\n        if (string == '') {\n            throw new SyntaxError('Cannot create a path from an empty string');\n        }\n        var sliceComponent = slice_path_component_1.SlicePathComponent.fromString(string);\n        if (sliceComponent != null) {\n            return sliceComponent;\n        }\n        return simple_key_path_component_1.SimpleKeyPathComponent.fromString(string);\n    };\n    //Match a dot but not if preceeded by a backslash\n    PathBuilder.pathPattern = /(?:[^\\.\\\\]|\\\\.)+/g;\n    PathBuilder.pointerPattern = /(?:[^\\/\\\\]|\\\\\\/)+/g;\n    return PathBuilder;\n}());\nexports.default = PathBuilder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleKeyPathComponent = void 0;\nvar query_result_1 = require(\"./query-result\");\nvar SimpleKeyPathComponent = /** @class */ (function () {\n    function SimpleKeyPathComponent(keyName) {\n        this.isArray = false;\n        this.keyName = keyName;\n        var keyAsInteger = parseInt(this.keyName, 10);\n        if (isNaN(keyAsInteger)) {\n            return;\n        }\n        var isInteger = Number.isInteger(keyAsInteger);\n        if (!isInteger) {\n            return;\n        }\n        if (keyAsInteger < 0) {\n            return;\n        }\n        this.isArray = true;\n    }\n    SimpleKeyPathComponent.fromString = function (string) {\n        var keyName = string;\n        SimpleKeyPathComponent.unescapeExpressions.forEach(function (unescapePair) {\n            keyName = keyName.replace(unescapePair.search, unescapePair.replacement);\n        });\n        return new SimpleKeyPathComponent(keyName);\n    };\n    SimpleKeyPathComponent.prototype.toString = function () {\n        var escapedString = this.keyName;\n        SimpleKeyPathComponent.escapeExpressions.forEach(function (escapePair) {\n            escapedString = escapedString.replace(escapePair.search, escapePair.replacement);\n        });\n        return escapedString;\n    };\n    SimpleKeyPathComponent.prototype.jsonPointer = function () {\n        var escapedString = this.keyName;\n        //replace ~ with ~0\n        escapedString = escapedString.replace(/(\\~)/g, '~0');\n        //replace / with ~1\n        escapedString = escapedString.replace(/(\\/)/g, '~1');\n        return escapedString;\n    };\n    SimpleKeyPathComponent.prototype.query = function (results) {\n        var newResults = [];\n        for (var i = 0; i < results.length; i++) {\n            var result = results[i];\n            var object = result.object;\n            if (typeof object !== 'object') {\n                continue;\n            }\n            var newObject = object[this.keyName];\n            if (newObject === null) {\n                continue;\n            }\n            var newResult = new query_result_1.default(result.depth, result.path.child(this.keyName), newObject);\n            newResults.push(newResult);\n        }\n        return newResults;\n    };\n    SimpleKeyPathComponent.escapeExpressions = [\n        { search: new RegExp(/(\\\\)/g), replacement: '\\\\' },\n        { search: new RegExp(/(\\.)/g), replacement: '\\\\.' },\n    ];\n    SimpleKeyPathComponent.unescapeExpressions = [\n        { search: new RegExp(/(\\\\\\.)/g), replacement: '.' },\n        { search: new RegExp(/(\\\\\\\\)/g), replacement: '\\\\' },\n        { search: '~1', replacement: '/' },\n    ];\n    return SimpleKeyPathComponent;\n}());\nexports.SimpleKeyPathComponent = SimpleKeyPathComponent;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WildcardPathComponent = void 0;\nvar query_result_1 = require(\"./query-result\");\nvar WildcardPathComponent = /** @class */ (function () {\n    function WildcardPathComponent() {\n        this.keyName = '*';\n        this.isArray = true;\n    }\n    WildcardPathComponent.fromString = function (string) {\n        if (string === '*') {\n            return new WildcardPathComponent();\n        }\n        return null;\n    };\n    WildcardPathComponent.prototype.toString = function () {\n        return this.keyName;\n    };\n    WildcardPathComponent.prototype.jsonPointer = function () {\n        throw Error(\"JSON Pointers don't work with wildcards\");\n    };\n    WildcardPathComponent.prototype.query = function (results) {\n        var newResults = [];\n        for (var i = 0; i < results.length; i++) {\n            var result = results[i];\n            var object = result.object;\n            if (typeof object !== 'object') {\n                continue;\n            }\n            for (var key in object) {\n                var newObject = object[key];\n                var newResult = new query_result_1.default(result.depth + 1, result.path.child(key), newObject);\n                newResults.push(newResult);\n            }\n        }\n        return newResults;\n    };\n    return WildcardPathComponent;\n}());\nexports.WildcardPathComponent = WildcardPathComponent;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StartPathComponent = /** @class */ (function () {\n    function StartPathComponent() {\n        this.keyName = '$';\n        this.isArray = false;\n    }\n    StartPathComponent.fromString = function (string) {\n        if (string === '$') {\n            return new StartPathComponent();\n        }\n        return null;\n    };\n    StartPathComponent.prototype.toString = function () {\n        return this.keyName;\n    };\n    StartPathComponent.prototype.jsonPointer = function () {\n        return '';\n    };\n    StartPathComponent.prototype.query = function (objects) {\n        //we don't want to actually do anything, this is just a marker for the start\n        return objects;\n    };\n    return StartPathComponent;\n}());\nexports.default = StartPathComponent;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar QueryResult = /** @class */ (function () {\n    function QueryResult(depth, path, object) {\n        this.depth = 0;\n        this.depth = depth;\n        this.path = path;\n        this.object = object;\n    }\n    QueryResult.prototype.flatten = function () {\n        var flattenedObject = this.object;\n        if (typeof this.object === 'object' && Array.isArray(this.object) && this.depth > 0) {\n            flattenedObject = this.object.flat(this.depth);\n        }\n        return new QueryResult(0, this.path, flattenedObject);\n    };\n    return QueryResult;\n}());\nexports.default = QueryResult;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    isRequestAPICallableInsideAfter: null,\n    throwForSearchParamsAccessInUseCache: null,\n    throwWithStaticGenerationBailoutError: null,\n    throwWithStaticGenerationBailoutErrorWithDynamicError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isRequestAPICallableInsideAfter: function() {\n        return isRequestAPICallableInsideAfter;\n    },\n    throwForSearchParamsAccessInUseCache: function() {\n        return throwForSearchParamsAccessInUseCache;\n    },\n    throwWithStaticGenerationBailoutError: function() {\n        return throwWithStaticGenerationBailoutError;\n    },\n    throwWithStaticGenerationBailoutErrorWithDynamicError: function() {\n        return throwWithStaticGenerationBailoutErrorWithDynamicError;\n    }\n});\nconst _staticgenerationbailout = require(\"../../client/components/static-generation-bailout\");\nconst _aftertaskasyncstorageexternal = require(\"../app-render/after-task-async-storage.external\");\nfunction throwWithStaticGenerationBailoutError(route, expression) {\n    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E576\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\n    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E543\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction throwForSearchParamsAccessInUseCache(route) {\n    throw Object.defineProperty(new Error(`Route ${route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n        value: \"E634\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction isRequestAPICallableInsideAfter() {\n    const afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();\n    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';\n}\n\n//# sourceMappingURL=utils.js.map"],"names":[],"sourceRoot":""}