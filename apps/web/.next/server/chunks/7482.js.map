{"version":3,"file":"7482.js","mappings":"2eAGA,WAEE,OAAS,gBACX,QACA,8BAAiD,IAAS,EAE1D,yBACA,OAFA,cAEA,6BAEA,qBACA,4CAEA,CACA,gCACA,MACA,eAAsC,qBAAyC,IAC/E,MACA,yBACA,SAEA,kBACA,kBAGA,QACA,UAGA,OAFA,aAGA,CAAG,8DCIH,SAMA,IALA,YACA,SACA,gBACA,CACA,CAAG,EACH,WCtCA,qCAAmD,uBAAuB,QAC1E,0BAA6C,2CAC7C,wCAA4D,uBAAuB,QACnF,SACA,aACA,SACA,+BACA,UACA,WACA,kBACA,MAEA,IACA,oBACA,CAAU,MAEV,UAAoB,GAAa,MAAQ,QADzC,gCACyC,CAAS,CAClD,CACA,KACA,iBAIA,EAHA,+BACA,MAGA,4BACA,sCAEA,IACA,gCACA,QAA6B,EAAgB,KAC7C,SAD6C,MAC7C,WACA,CAAY,SACZ,mCAEA,OADA,0BAAgD,UAAU,MAAQ,UAAU,EAC5E,IAAsB,GAAa,cAAQ,EAAS,CACpD,CAEA,SACA,kBACA,iBAEA,oBACY,oBAEZ,aACY,OACZ,cAEA,MAEA,CAAS,EACT,IACA,KACA,CACA,YACA,qBACA,6CACA,8BAGA,KACA,aACA,gBACA,KACA,cACA,iBACA,KACA,cACA,EAAgB,QAAS,GAEzB,CACA,mBACA,yBACA,SAEA,4BACA,SACA,oCEhFA,0BACA,IACA,mBACA,SACA,kBAA8B,eAAuB,EACrD,gBACA,aACA,CACA,qBACA,SACA,4BACA,mBACA,yBACO,EAGP,2BACA,kBACA,CAAK,CACL,CACA,sECnBA,GAAkB,4BAClB,YACA,uDACA,oEACA,EAkBA,0BACA,sBACA,UACA,wBACA,SAEA,uBAAsC,GACtC,KACA,gBAEA,OADA,YACA,aACA,UACA,SAEA,8BACA,wBACA,SAEA,8BAIA,GAHA,oCACA,kBAEA,YACA,KAAiC,QAAmB,IACpD,GACA,KAGA,CACA,QACA,EAmBA,WAAuC,IACvC,SAAkB,EAAK,GAAG,EAAM,EAChC,wCACA,4DAEA,4BACA,aACA,0DAEA,gBACA,iEAEA,YACA,6DAEA,CACA,8CACA,mBACA,YACA,uFAGA,MAAiB,UAAU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","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/@hono+zod-validator@0.4.3_hono@4.8.2_zod@3.25.67/node_modules/@hono/zod-validator/dist/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/buffer.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/validator.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/http-exception.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/cookie.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/helper/cookie/index.js","webpack://@hijraah/web/./src/_core/immigration/entities/case.ts","webpack://@hijraah/web/./src/_core/immigration/services/case-service.ts"],"sourcesContent":["// src/index.ts\nimport { validator } from \"hono/validator\";\nimport { ZodObject } from \"zod\";\nvar zValidator = (target, schema, hook) => (\n  // @ts-expect-error not typed well\n  validator(target, async (value, c) => {\n    let validatorValue = value;\n    if (target === \"header\" && schema instanceof ZodObject) {\n      const schemaKeys = Object.keys(schema.shape);\n      const caseInsensitiveKeymap = Object.fromEntries(\n        schemaKeys.map((key) => [key.toLowerCase(), key])\n      );\n      validatorValue = Object.fromEntries(\n        Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2])\n      );\n    }\n    const result = await schema.safeParseAsync(validatorValue);\n    if (hook) {\n      const hookResult = await hook({ data: validatorValue, ...result, target }, c);\n      if (hookResult) {\n        if (hookResult instanceof Response) {\n          return hookResult;\n        }\n        if (\"response\" in hookResult) {\n          return hookResult.response;\n        }\n      }\n    }\n    if (!result.success) {\n      return c.json(result, 400);\n    }\n    return result.data;\n  })\n);\nexport {\n  zValidator\n};\n","// src/utils/buffer.ts\nimport { sha256 } from \"./crypto.js\";\nvar equal = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const va = new DataView(a);\n  const vb = new DataView(b);\n  let i = va.byteLength;\n  while (i--) {\n    if (va.getUint8(i) !== vb.getUint8(i)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar timingSafeEqual = async (a, b, hashFunction) => {\n  if (!hashFunction) {\n    hashFunction = sha256;\n  }\n  const [sa, sb] = await Promise.all([hashFunction(a), hashFunction(b)]);\n  if (!sa || !sb) {\n    return false;\n  }\n  return sa === sb && a === b;\n};\nvar bufferToString = (buffer) => {\n  if (buffer instanceof ArrayBuffer) {\n    const enc = new TextDecoder(\"utf-8\");\n    return enc.decode(buffer);\n  }\n  return buffer;\n};\nvar bufferToFormData = (arrayBuffer, contentType) => {\n  const response = new Response(arrayBuffer, {\n    headers: {\n      \"Content-Type\": contentType\n    }\n  });\n  return response.formData();\n};\nexport {\n  bufferToFormData,\n  bufferToString,\n  equal,\n  timingSafeEqual\n};\n","// src/validator/validator.ts\nimport { getCookie } from \"../helper/cookie/index.js\";\nimport { HTTPException } from \"../http-exception.js\";\nimport { bufferToFormData } from \"../utils/buffer.js\";\nvar jsonRegex = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar multipartRegex = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9'\"()+_,\\-./:=?]+)?$/;\nvar urlencodedRegex = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar validator = (target, validationFunc) => {\n  return async (c, next) => {\n    let value = {};\n    const contentType = c.req.header(\"Content-Type\");\n    switch (target) {\n      case \"json\":\n        if (!contentType || !jsonRegex.test(contentType)) {\n          break;\n        }\n        try {\n          value = await c.req.json();\n        } catch {\n          const message = \"Malformed JSON in request body\";\n          throw new HTTPException(400, { message });\n        }\n        break;\n      case \"form\": {\n        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {\n          break;\n        }\n        let formData;\n        if (c.req.bodyCache.formData) {\n          formData = await c.req.bodyCache.formData;\n        } else {\n          try {\n            const arrayBuffer = await c.req.arrayBuffer();\n            formData = await bufferToFormData(arrayBuffer, contentType);\n            c.req.bodyCache.formData = formData;\n          } catch (e) {\n            let message = \"Malformed FormData request.\";\n            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;\n            throw new HTTPException(400, { message });\n          }\n        }\n        const form = {};\n        formData.forEach((value2, key) => {\n          if (key.endsWith(\"[]\")) {\n            ;\n            (form[key] ??= []).push(value2);\n          } else if (Array.isArray(form[key])) {\n            ;\n            form[key].push(value2);\n          } else if (key in form) {\n            form[key] = [form[key], value2];\n          } else {\n            form[key] = value2;\n          }\n        });\n        value = form;\n        break;\n      }\n      case \"query\":\n        value = Object.fromEntries(\n          Object.entries(c.req.queries()).map(([k, v]) => {\n            return v.length === 1 ? [k, v[0]] : [k, v];\n          })\n        );\n        break;\n      case \"param\":\n        value = c.req.param();\n        break;\n      case \"header\":\n        value = c.req.header();\n        break;\n      case \"cookie\":\n        value = getCookie(c);\n        break;\n    }\n    const res = await validationFunc(value, c);\n    if (res instanceof Response) {\n      return res;\n    }\n    c.req.addValidatedData(target, res);\n    await next();\n  };\n};\nexport {\n  validator\n};\n","// src/validator/index.ts\nimport { validator } from \"./validator.js\";\nexport {\n  validator\n};\n","// src/http-exception.ts\nvar HTTPException = class extends Error {\n  res;\n  status;\n  constructor(status = 500, options) {\n    super(options?.message, { cause: options?.cause });\n    this.res = options?.res;\n    this.status = status;\n  }\n  getResponse() {\n    if (this.res) {\n      const newResponse = new Response(this.res.body, {\n        status: this.status,\n        headers: this.res.headers\n      });\n      return newResponse;\n    }\n    return new Response(this.message, {\n      status: this.status\n    });\n  }\n};\nexport {\n  HTTPException\n};\n","// src/utils/cookie.ts\nimport { decodeURIComponent_ } from \"./url.js\";\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  if (name && cookie.indexOf(name) === -1) {\n    return {};\n  }\n  const pairs = cookie.trim().split(\";\");\n  const parsedCookie = {};\n  for (let pairStr of pairs) {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      continue;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      continue;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);\n      if (name) {\n        break;\n      }\n    }\n  }\n  return parsedCookie;\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    throw new Error(\"__Secure- Cookie must have Secure attributes\");\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      throw new Error(\"__Host- Cookie must have Secure attributes\");\n    }\n    if (opt.path !== \"/\") {\n      throw new Error('__Host- Cookie must have Path attributes with \"/\"');\n    }\n    if (opt.domain) {\n      throw new Error(\"__Host- Cookie must not have Domain attributes\");\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${opt.maxAge | 0}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.priority) {\n    cookie += `; Priority=${opt.priority}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nexport {\n  parse,\n  parseSigned,\n  serialize,\n  serializeSigned\n};\n","// src/helper/cookie/index.ts\nimport { parse, parseSigned, serialize, serializeSigned } from \"../../utils/cookie.js\";\nvar getCookie = (c, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = parse(cookie, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = parse(cookie);\n  return obj;\n};\nvar getSignedCookie = async (c, secret, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = await parseSigned(cookie, secret, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = await parseSigned(cookie, secret);\n  return obj;\n};\nvar setCookie = (c, name, value, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  c.header(\"Set-Cookie\", cookie, { append: true });\n};\nvar setSignedCookie = async (c, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  c.header(\"set-cookie\", cookie, { append: true });\n};\nvar deleteCookie = (c, name, opt) => {\n  const deletedCookie = getCookie(c, name, opt?.prefix);\n  setCookie(c, name, \"\", { ...opt, maxAge: 0 });\n  return deletedCookie;\n};\nexport {\n  deleteCookie,\n  getCookie,\n  getSignedCookie,\n  setCookie,\n  setSignedCookie\n};\n","/**\r\n * Case domain entity\r\n * \r\n * This entity represents an immigration case in the domain model.\r\n */\r\n\r\n/**\r\n * Case Status enum\r\n */\r\nexport enum CaseStatus {\r\n  DRAFT = 'draft',\r\n  SUBMITTED = 'submitted',\r\n  IN_REVIEW = 'in_review',\r\n  ADDITIONAL_INFO_REQUIRED = 'additional_info_required',\r\n  APPROVED = 'approved',\r\n  REJECTED = 'rejected',\r\n  COMPLETED = 'completed',\r\n  CANCELLED = 'cancelled'\r\n}\r\n\r\n/**\r\n * Case Type enum\r\n */\r\nexport enum CaseType {\r\n  ASYLUM = 'asylum',\r\n  VISA_APPLICATION = 'visa_application',\r\n  WORK_PERMIT = 'work_permit',\r\n  FAMILY_SPONSORSHIP = 'family_sponsorship',\r\n  CITIZENSHIP = 'citizenship',\r\n  RESIDENCY = 'residency',\r\n  REFUGEE = 'refugee',\r\n  OTHER = 'other'\r\n}\r\n\r\n/**\r\n * Timeline Event interface\r\n */\r\nexport interface TimelineEvent {\r\n  id: string;\r\n  eventType: string;\r\n  title: string;\r\n  description: string;\r\n  createdBy: string;\r\n  timestamp: Date;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Assignment interface\r\n */\r\nexport interface CaseAssignment {\r\n  userId: string;\r\n  role: 'owner' | 'collaborator' | 'reviewer' | 'client';\r\n  assignedAt: Date;\r\n  assignedBy: string;\r\n}\r\n\r\n/**\r\n * Case entity\r\n */\r\nexport class Case {\r\n  readonly id: string;\r\n  readonly caseNumber: string;\r\n  readonly title: string;\r\n  readonly description: string | null;\r\n  readonly status: CaseStatus;\r\n  readonly caseType: CaseType;\r\n  readonly clientId: string;\r\n  readonly timeline: TimelineEvent[];\r\n  readonly assignments: CaseAssignment[];\r\n  readonly priority: 'low' | 'medium' | 'high' | 'urgent';\r\n  readonly dueDate: Date | null;\r\n  readonly tags: string[];\r\n  readonly metadata: Record<string, any>;\r\n  readonly createdAt: Date;\r\n  readonly updatedAt: Date;\r\n\r\n  constructor(props: {\r\n    id: string;\r\n    caseNumber: string;\r\n    title: string;\r\n    description?: string | null;\r\n    status?: CaseStatus;\r\n    caseType: CaseType;\r\n    clientId: string;\r\n    timeline?: TimelineEvent[];\r\n    assignments?: CaseAssignment[];\r\n    priority?: 'low' | 'medium' | 'high' | 'urgent';\r\n    dueDate?: Date | string | null;\r\n    tags?: string[];\r\n    metadata?: Record<string, any>;\r\n    createdAt?: string | Date;\r\n    updatedAt?: string | Date;\r\n  }) {\r\n    this.id = props.id;\r\n    this.caseNumber = props.caseNumber;\r\n    this.title = props.title;\r\n    this.description = props.description ?? null;\r\n    this.status = props.status ?? CaseStatus.DRAFT;\r\n    this.caseType = props.caseType;\r\n    this.clientId = props.clientId;\r\n    this.timeline = props.timeline ?? [];\r\n    this.assignments = props.assignments ?? [];\r\n    this.priority = props.priority ?? 'medium';\r\n    this.dueDate = props.dueDate ? new Date(props.dueDate) : null;\r\n    this.tags = props.tags ?? [];\r\n    this.metadata = props.metadata ?? {};\r\n    this.createdAt = props.createdAt ? new Date(props.createdAt) : new Date();\r\n    this.updatedAt = props.updatedAt ? new Date(props.updatedAt) : new Date();\r\n  }\r\n  \r\n  /**\r\n   * Check if a user is assigned to this case\r\n   */\r\n  isUserAssigned(userId: string): boolean {\r\n    return this.assignments.some(assignment => assignment.userId === userId);\r\n  }\r\n  \r\n  /**\r\n   * Get a user's role in this case\r\n   */\r\n  getUserRole(userId: string): string | null {\r\n    const assignment = this.assignments.find(a => a.userId === userId);\r\n    return assignment ? assignment.role : null;\r\n  }\r\n  \r\n  /**\r\n   * Check if a user has a specific role in this case\r\n   */\r\n  userHasRole(userId: string, role: string | string[]): boolean {\r\n    const userRole = this.getUserRole(userId);\r\n    if (!userRole) return false;\r\n    \r\n    if (Array.isArray(role)) {\r\n      return role.includes(userRole);\r\n    }\r\n    \r\n    return userRole === role;\r\n  }\r\n  \r\n  /**\r\n   * Change the status of the case\r\n   */\r\n  changeStatus(newStatus: CaseStatus, userId: string, reason?: string): Case {\r\n    // Create a timeline event for the status change\r\n    const event: TimelineEvent = {\r\n      id: crypto.randomUUID(),\r\n      eventType: 'status_change',\r\n      title: `Status changed to ${newStatus}`,\r\n      description: reason || `Case status was changed from ${this.status} to ${newStatus}`,\r\n      createdBy: userId,\r\n      timestamp: new Date(),\r\n      metadata: {\r\n        previousStatus: this.status,\r\n        newStatus: newStatus\r\n      }\r\n    };\r\n    \r\n    return new Case({\r\n      ...this,\r\n      status: newStatus,\r\n      timeline: [...this.timeline, event],\r\n      updatedAt: new Date()\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Assign a user to this case\r\n   */\r\n  assignUser(userId: string, role: 'owner' | 'collaborator' | 'reviewer' | 'client', assignedBy: string): Case {\r\n    // Check if user is already assigned with this role\r\n    const existingAssignment = this.assignments.find(\r\n      a => a.userId === userId && a.role === role\r\n    );\r\n    \r\n    if (existingAssignment) {\r\n      return this; // No change needed\r\n    }\r\n    \r\n    // Create new assignment\r\n    const newAssignment: CaseAssignment = {\r\n      userId,\r\n      role,\r\n      assignedAt: new Date(),\r\n      assignedBy\r\n    };\r\n    \r\n    // Create a timeline event for the assignment\r\n    const event: TimelineEvent = {\r\n      id: crypto.randomUUID(),\r\n      eventType: 'user_assigned',\r\n      title: `User assigned as ${role}`,\r\n      description: `User ${userId} was assigned to the case as ${role}`,\r\n      createdBy: assignedBy,\r\n      timestamp: new Date(),\r\n      metadata: {\r\n        userId,\r\n        role\r\n      }\r\n    };\r\n    \r\n    return new Case({\r\n      ...this,\r\n      assignments: [...this.assignments, newAssignment],\r\n      timeline: [...this.timeline, event],\r\n      updatedAt: new Date()\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Remove a user assignment from this case\r\n   */\r\n  removeAssignment(userId: string, removedBy: string, reason?: string): Case {\r\n    // Check if user is assigned\r\n    const assignment = this.assignments.find(a => a.userId === userId);\r\n    \r\n    if (!assignment) {\r\n      return this; // No change needed\r\n    }\r\n    \r\n    // Create a timeline event for the removal\r\n    const event: TimelineEvent = {\r\n      id: crypto.randomUUID(),\r\n      eventType: 'user_unassigned',\r\n      title: `User unassigned`,\r\n      description: reason || `User ${userId} was removed from the case`,\r\n      createdBy: removedBy,\r\n      timestamp: new Date(),\r\n      metadata: {\r\n        userId,\r\n        previousRole: assignment.role\r\n      }\r\n    };\r\n    \r\n    return new Case({\r\n      ...this,\r\n      assignments: this.assignments.filter(a => a.userId !== userId),\r\n      timeline: [...this.timeline, event],\r\n      updatedAt: new Date()\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Add a timeline event to the case\r\n   */\r\n  addTimelineEvent(event: Omit<TimelineEvent, 'id' | 'timestamp'>): Case {\r\n    const newEvent: TimelineEvent = {\r\n      ...event,\r\n      id: crypto.randomUUID(),\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    return new Case({\r\n      ...this,\r\n      timeline: [...this.timeline, newEvent],\r\n      updatedAt: new Date()\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Update case details\r\n   */\r\n  update(data: {\r\n    title?: string;\r\n    description?: string | null;\r\n    priority?: 'low' | 'medium' | 'high' | 'urgent';\r\n    dueDate?: Date | null;\r\n    tags?: string[];\r\n    metadata?: Record<string, any>;\r\n  }, updatedBy: string): Case {\r\n    // Create a timeline event for the update\r\n    const event: TimelineEvent = {\r\n      id: crypto.randomUUID(),\r\n      eventType: 'case_updated',\r\n      title: 'Case details updated',\r\n      description: 'Case details were updated',\r\n      createdBy: updatedBy,\r\n      timestamp: new Date(),\r\n      metadata: {\r\n        updatedFields: Object.keys(data)\r\n      }\r\n    };\r\n    \r\n    return new Case({\r\n      ...this,\r\n      ...data,\r\n      timeline: [...this.timeline, event],\r\n      updatedAt: new Date()\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Convert to a plain object representation\r\n   */\r\n  toObject() {\r\n    return {\r\n      id: this.id,\r\n      caseNumber: this.caseNumber,\r\n      title: this.title,\r\n      description: this.description,\r\n      status: this.status,\r\n      caseType: this.caseType,\r\n      clientId: this.clientId,\r\n      timeline: this.timeline.map(event => ({\r\n        ...event,\r\n        timestamp: event.timestamp.toISOString()\r\n      })),\r\n      assignments: this.assignments.map(assignment => ({\r\n        ...assignment,\r\n        assignedAt: assignment.assignedAt.toISOString()\r\n      })),\r\n      priority: this.priority,\r\n      dueDate: this.dueDate?.toISOString() || null,\r\n      tags: this.tags,\r\n      metadata: this.metadata,\r\n      createdAt: this.createdAt.toISOString(),\r\n      updatedAt: this.updatedAt.toISOString()\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Factory method to create a Case from database record\r\n   */\r\n  static fromDatabase(data: {\r\n    id: string;\r\n    case_number: string;\r\n    title: string;\r\n    description: string | null;\r\n    status: string;\r\n    case_type: string;\r\n    client_id: string;\r\n    timeline: any[];\r\n    assignments: any[];\r\n    priority: string;\r\n    due_date: string | null;\r\n    tags: string[];\r\n    metadata: Record<string, any>;\r\n    created_at: string;\r\n    updated_at: string;\r\n  }): Case {\r\n    return new Case({\r\n      id: data.id,\r\n      caseNumber: data.case_number,\r\n      title: data.title,\r\n      description: data.description,\r\n      status: data.status as CaseStatus,\r\n      caseType: data.case_type as CaseType,\r\n      clientId: data.client_id,\r\n      timeline: data.timeline.map(event => ({\r\n        ...event,\r\n        timestamp: new Date(event.timestamp)\r\n      })),\r\n      assignments: data.assignments.map(assignment => ({\r\n        ...assignment,\r\n        assignedAt: new Date(assignment.assigned_at)\r\n      })),\r\n      priority: data.priority as 'low' | 'medium' | 'high' | 'urgent',\r\n      dueDate: data.due_date,\r\n      tags: data.tags,\r\n      metadata: data.metadata,\r\n      createdAt: data.created_at,\r\n      updatedAt: data.updated_at\r\n    });\r\n  }\r\n} ","import { Case, CaseStatus, CaseType, TimelineEvent } from '../entities/case';\r\n\r\n/**\r\n * Case Service domain service\r\n * \r\n * Handles case-related business logic that doesn't naturally\r\n * fit within the Case entity itself.\r\n */\r\nexport class CaseService {\r\n  /**\r\n   * Generate a unique case number based on case type and current date\r\n   */\r\n  generateCaseNumber(caseType: CaseType): string {\r\n    // Get current date components\r\n    const date = new Date();\r\n    const year = date.getFullYear().toString().slice(2); // 2-digit year\r\n    const month = (date.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = date.getDate().toString().padStart(2, '0');\r\n    \r\n    // Create a timestamp-based unique identifier\r\n    const timestamp = Date.now().toString().slice(-6);\r\n    \r\n    // Get prefix based on case type\r\n    const prefix = this.getCaseTypePrefix(caseType);\r\n    \r\n    // Combine components: PREFIX-YYMMDD-XXXXXX\r\n    return `${prefix}-${year}${month}${day}-${timestamp}`;\r\n  }\r\n  \r\n  /**\r\n   * Get a prefix for the case type\r\n   */\r\n  private getCaseTypePrefix(caseType: CaseType): string {\r\n    switch (caseType) {\r\n      case CaseType.ASYLUM:\r\n        return 'ASY';\r\n      case CaseType.VISA_APPLICATION:\r\n        return 'VISA';\r\n      case CaseType.WORK_PERMIT:\r\n        return 'WORK';\r\n      case CaseType.FAMILY_SPONSORSHIP:\r\n        return 'FAM';\r\n      case CaseType.CITIZENSHIP:\r\n        return 'CIT';\r\n      case CaseType.RESIDENCY:\r\n        return 'RES';\r\n      case CaseType.REFUGEE:\r\n        return 'REF';\r\n      case CaseType.OTHER:\r\n        return 'OTH';\r\n      default:\r\n        return 'CASE';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Validate case status transition\r\n   * Returns true if the transition is valid, false otherwise\r\n   */\r\n  isValidStatusTransition(currentStatus: CaseStatus, newStatus: CaseStatus): boolean {\r\n    // Define valid transitions for each status\r\n    const validTransitions: Record<CaseStatus, CaseStatus[]> = {\r\n      [CaseStatus.DRAFT]: [\r\n        CaseStatus.SUBMITTED,\r\n        CaseStatus.CANCELLED\r\n      ],\r\n      [CaseStatus.SUBMITTED]: [\r\n        CaseStatus.IN_REVIEW,\r\n        CaseStatus.CANCELLED\r\n      ],\r\n      [CaseStatus.IN_REVIEW]: [\r\n        CaseStatus.ADDITIONAL_INFO_REQUIRED,\r\n        CaseStatus.APPROVED,\r\n        CaseStatus.REJECTED,\r\n        CaseStatus.CANCELLED\r\n      ],\r\n      [CaseStatus.ADDITIONAL_INFO_REQUIRED]: [\r\n        CaseStatus.IN_REVIEW,\r\n        CaseStatus.CANCELLED\r\n      ],\r\n      [CaseStatus.APPROVED]: [\r\n        CaseStatus.COMPLETED,\r\n        CaseStatus.CANCELLED\r\n      ],\r\n      [CaseStatus.REJECTED]: [\r\n        CaseStatus.DRAFT, // Allow reopening rejected cases\r\n        CaseStatus.CANCELLED\r\n      ],\r\n      [CaseStatus.COMPLETED]: [\r\n        CaseStatus.CANCELLED\r\n      ],\r\n      [CaseStatus.CANCELLED]: [\r\n        CaseStatus.DRAFT // Allow reopening cancelled cases\r\n      ]\r\n    };\r\n    \r\n    // Check if the transition is valid\r\n    return validTransitions[currentStatus]?.includes(newStatus) || false;\r\n  }\r\n  \r\n  /**\r\n   * Check if a user can perform an action on a case based on their role\r\n   */\r\n  canPerformAction(\r\n    userRole: string | null,\r\n    action: 'view' | 'edit' | 'delete' | 'assign' | 'change_status' | 'add_document' | 'add_comment'\r\n  ): boolean {\r\n    if (!userRole) return false;\r\n    \r\n    // Define permissions for each role\r\n    const rolePermissions: Record<string, string[]> = {\r\n      'owner': [\r\n        'view', 'edit', 'delete', 'assign', 'change_status', 'add_document', 'add_comment'\r\n      ],\r\n      'collaborator': [\r\n        'view', 'edit', 'assign', 'change_status', 'add_document', 'add_comment'\r\n      ],\r\n      'reviewer': [\r\n        'view', 'change_status', 'add_comment'\r\n      ],\r\n      'client': [\r\n        'view', 'add_document', 'add_comment'\r\n      ]\r\n    };\r\n    \r\n    // Check if the role has permission for the action\r\n    return rolePermissions[userRole]?.includes(action) || false;\r\n  }\r\n  \r\n  /**\r\n   * Get required documents for a case type\r\n   */\r\n  getRequiredDocuments(caseType: CaseType): string[] {\r\n    // Define required documents for each case type\r\n    const requiredDocuments: Record<CaseType, string[]> = {\r\n      [CaseType.ASYLUM]: [\r\n        'Asylum Application (Form I-589)',\r\n        'Identity Documents',\r\n        'Evidence of Persecution',\r\n        'Country Conditions Reports'\r\n      ],\r\n      [CaseType.VISA_APPLICATION]: [\r\n        'Visa Application Form',\r\n        'Passport',\r\n        'Photographs',\r\n        'Financial Documents',\r\n        'Invitation Letter'\r\n      ],\r\n      [CaseType.WORK_PERMIT]: [\r\n        'Employment Authorization (Form I-765)',\r\n        'Identity Documents',\r\n        'Evidence of Eligibility'\r\n      ],\r\n      [CaseType.FAMILY_SPONSORSHIP]: [\r\n        'Petition for Relative (Form I-130)',\r\n        'Birth Certificates',\r\n        'Marriage Certificate',\r\n        'Financial Support Evidence'\r\n      ],\r\n      [CaseType.CITIZENSHIP]: [\r\n        'Naturalization Application (Form N-400)',\r\n        'Permanent Resident Card',\r\n        'Tax Returns',\r\n        'Travel History'\r\n      ],\r\n      [CaseType.RESIDENCY]: [\r\n        'Green Card Application (Form I-485)',\r\n        'Medical Examination',\r\n        'Birth Certificate',\r\n        'Financial Support Evidence'\r\n      ],\r\n      [CaseType.REFUGEE]: [\r\n        'Refugee Application',\r\n        'Identity Documents',\r\n        'Evidence of Refugee Status'\r\n      ],\r\n      [CaseType.OTHER]: []\r\n    };\r\n    \r\n    return requiredDocuments[caseType] || [];\r\n  }\r\n  \r\n  /**\r\n   * Calculate case completion percentage based on required documents and status\r\n   */\r\n  calculateCompletionPercentage(caseInstance: Case, uploadedDocuments: string[]): number {\r\n    // Define status weights for completion calculation\r\n    const statusWeight: Record<CaseStatus, number> = {\r\n      [CaseStatus.DRAFT]: 0.2,\r\n      [CaseStatus.SUBMITTED]: 0.4,\r\n      [CaseStatus.IN_REVIEW]: 0.6,\r\n      [CaseStatus.ADDITIONAL_INFO_REQUIRED]: 0.7,\r\n      [CaseStatus.APPROVED]: 0.9,\r\n      [CaseStatus.REJECTED]: 1.0,\r\n      [CaseStatus.COMPLETED]: 1.0,\r\n      [CaseStatus.CANCELLED]: 0.0\r\n    };\r\n    \r\n    // Calculate document completion\r\n    const requiredDocuments = this.getRequiredDocuments(caseInstance.caseType);\r\n    const documentPercentage = requiredDocuments.length > 0\r\n      ? (uploadedDocuments.length / requiredDocuments.length) * 0.5\r\n      : 0.5; // If no required documents, assume 50% completion\r\n    \r\n    // Calculate status-based completion\r\n    const statusPercentage = statusWeight[caseInstance.status] * 0.5;\r\n    \r\n    // Combine document and status percentages\r\n    return Math.min(Math.round((documentPercentage + statusPercentage) * 100), 100);\r\n  }\r\n  \r\n  /**\r\n   * Create a standard timeline event for document upload\r\n   */\r\n  createDocumentEvent(documentId: string, documentName: string, uploadedBy: string): TimelineEvent {\r\n    return {\r\n      id: crypto.randomUUID(),\r\n      eventType: 'document_uploaded',\r\n      title: 'Document uploaded',\r\n      description: `Document \"${documentName}\" was uploaded`,\r\n      createdBy: uploadedBy,\r\n      timestamp: new Date(),\r\n      metadata: {\r\n        documentId,\r\n        documentName\r\n      }\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Estimate case processing time based on case type and current data\r\n   */\r\n  estimateProcessingTime(caseType: CaseType): {\r\n    minDays: number;\r\n    maxDays: number;\r\n    averageDays: number;\r\n  } {\r\n    // Define processing time estimates (in days) for each case type\r\n    const processingTimeEstimates: Record<CaseType, {\r\n      minDays: number;\r\n      maxDays: number;\r\n      averageDays: number;\r\n    }> = {\r\n      [CaseType.ASYLUM]: {\r\n        minDays: 180,\r\n        maxDays: 730,\r\n        averageDays: 365\r\n      },\r\n      [CaseType.VISA_APPLICATION]: {\r\n        minDays: 30,\r\n        maxDays: 180,\r\n        averageDays: 90\r\n      },\r\n      [CaseType.WORK_PERMIT]: {\r\n        minDays: 90,\r\n        maxDays: 180,\r\n        averageDays: 120\r\n      },\r\n      [CaseType.FAMILY_SPONSORSHIP]: {\r\n        minDays: 180,\r\n        maxDays: 730,\r\n        averageDays: 365\r\n      },\r\n      [CaseType.CITIZENSHIP]: {\r\n        minDays: 180,\r\n        maxDays: 365,\r\n        averageDays: 240\r\n      },\r\n      [CaseType.RESIDENCY]: {\r\n        minDays: 180,\r\n        maxDays: 730,\r\n        averageDays: 365\r\n      },\r\n      [CaseType.REFUGEE]: {\r\n        minDays: 180,\r\n        maxDays: 730,\r\n        averageDays: 365\r\n      },\r\n      [CaseType.OTHER]: {\r\n        minDays: 90,\r\n        maxDays: 365,\r\n        averageDays: 180\r\n      }\r\n    };\r\n    \r\n    return processingTimeEstimates[caseType];\r\n  }\r\n} "],"names":["CaseStatus","CaseType","Case","constructor","props","id","caseNumber","title","description","status","caseType","clientId","timeline","assignments","priority","dueDate","Date","tags","metadata","createdAt","updatedAt","isUserAssigned","userId","some","assignment","getUserRole","find","a","role","userHasRole","userRole","Array","isArray","includes","changeStatus","newStatus","reason","event","crypto","randomUUID","eventType","createdBy","timestamp","previousStatus","assignUser","assignedBy","existingAssignment","newAssignment","assignedAt","removeAssignment","removedBy","previousRole","filter","addTimelineEvent","newEvent","update","data","updatedBy","updatedFields","Object","keys","toObject","map","toISOString","fromDatabase","case_number","case_type","client_id","assigned_at","due_date","created_at","updated_at","CaseService","generateCaseNumber","date","year","getFullYear","toString","slice","month","getMonth","padStart","day","getDate","now","prefix","getCaseTypePrefix","ASYLUM","VISA_APPLICATION","WORK_PERMIT","FAMILY_SPONSORSHIP","CITIZENSHIP","RESIDENCY","REFUGEE","OTHER","isValidStatusTransition","currentStatus","validTransitions","DRAFT","SUBMITTED","CANCELLED","IN_REVIEW","ADDITIONAL_INFO_REQUIRED","APPROVED","REJECTED","COMPLETED","canPerformAction","action","rolePermissions","getRequiredDocuments","requiredDocuments","calculateCompletionPercentage","caseInstance","uploadedDocuments","statusWeight","Math","min","round","length","statusPercentage","createDocumentEvent","documentId","documentName","uploadedBy","estimateProcessingTime","processingTimeEstimates","minDays","maxDays","averageDays"],"sourceRoot":""}