{"version":3,"file":"../app/api/search/route.js","mappings":"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","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/@hono+zod-validator@0.4.3_hono@4.8.2_zod@3.25.67/node_modules/@hono/zod-validator/dist/index.js","webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+instrumentat_04f370d515cee0be955272f826166073/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/external commonjs2 \"punycode\"","webpack://@hijraah/web/external commonjs2 \"assert\"","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/buffer.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/validator.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/index.js","webpack://@hijraah/web/external commonjs2 \"stream\"","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/middleware/cors/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/adapter/vercel/handler.js","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"tls\"","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/external node-commonjs \"node:stream/web\"","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/./src/lib/openai.ts","webpack://@hijraah/web/src/app/api/search/route.ts","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/?15be","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/http-exception.js","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external commonjs2 \"https\"","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/ignored|E:\\downloads\\Hijraah\\node_modules\\.pnpm\\ws@8.18.2_bufferutil@4.0.9\\node_modules\\ws\\lib|utf-8-validate","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/cookie.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/helper/cookie/index.js","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/external commonjs2 \"zlib\"","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external commonjs2 \"buffer\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/external commonjs2 \"http\"","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/external commonjs2 \"net\"","webpack://@hijraah/web/external commonjs2 \"events\"","webpack://@hijraah/web/../../node_modules/.pnpm/require-in-the-middle@7.5.2/node_modules/require-in-the-middle/ sync","webpack://@hijraah/web/../../node_modules/.pnpm/@supabase+realtime-js@2.11.10_bufferutil@4.0.9/node_modules/@supabase/realtime-js/dist/main/ sync"],"sourcesContent":["// src/index.ts\nimport { validator } from \"hono/validator\";\nimport { ZodObject } from \"zod\";\nvar zValidator = (target, schema, hook) => (\n  // @ts-expect-error not typed well\n  validator(target, async (value, c) => {\n    let validatorValue = value;\n    if (target === \"header\" && schema instanceof ZodObject) {\n      const schemaKeys = Object.keys(schema.shape);\n      const caseInsensitiveKeymap = Object.fromEntries(\n        schemaKeys.map((key) => [key.toLowerCase(), key])\n      );\n      validatorValue = Object.fromEntries(\n        Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2])\n      );\n    }\n    const result = await schema.safeParseAsync(validatorValue);\n    if (hook) {\n      const hookResult = await hook({ data: validatorValue, ...result, target }, c);\n      if (hookResult) {\n        if (hookResult instanceof Response) {\n          return hookResult;\n        }\n        if (\"response\" in hookResult) {\n          return hookResult.response;\n        }\n      }\n    }\n    if (!result.success) {\n      return c.json(result, 400);\n    }\n    return result.data;\n  })\n);\nexport {\n  zValidator\n};\n","module.exports = require(\"module\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 8963;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","module.exports = require(\"punycode\");","module.exports = require(\"assert\");","module.exports = require(\"process\");","module.exports = require(\"os\");","// src/utils/buffer.ts\nimport { sha256 } from \"./crypto.js\";\nvar equal = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const va = new DataView(a);\n  const vb = new DataView(b);\n  let i = va.byteLength;\n  while (i--) {\n    if (va.getUint8(i) !== vb.getUint8(i)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar timingSafeEqual = async (a, b, hashFunction) => {\n  if (!hashFunction) {\n    hashFunction = sha256;\n  }\n  const [sa, sb] = await Promise.all([hashFunction(a), hashFunction(b)]);\n  if (!sa || !sb) {\n    return false;\n  }\n  return sa === sb && a === b;\n};\nvar bufferToString = (buffer) => {\n  if (buffer instanceof ArrayBuffer) {\n    const enc = new TextDecoder(\"utf-8\");\n    return enc.decode(buffer);\n  }\n  return buffer;\n};\nvar bufferToFormData = (arrayBuffer, contentType) => {\n  const response = new Response(arrayBuffer, {\n    headers: {\n      \"Content-Type\": contentType\n    }\n  });\n  return response.formData();\n};\nexport {\n  bufferToFormData,\n  bufferToString,\n  equal,\n  timingSafeEqual\n};\n","// src/validator/validator.ts\nimport { getCookie } from \"../helper/cookie/index.js\";\nimport { HTTPException } from \"../http-exception.js\";\nimport { bufferToFormData } from \"../utils/buffer.js\";\nvar jsonRegex = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar multipartRegex = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9'\"()+_,\\-./:=?]+)?$/;\nvar urlencodedRegex = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar validator = (target, validationFunc) => {\n  return async (c, next) => {\n    let value = {};\n    const contentType = c.req.header(\"Content-Type\");\n    switch (target) {\n      case \"json\":\n        if (!contentType || !jsonRegex.test(contentType)) {\n          break;\n        }\n        try {\n          value = await c.req.json();\n        } catch {\n          const message = \"Malformed JSON in request body\";\n          throw new HTTPException(400, { message });\n        }\n        break;\n      case \"form\": {\n        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {\n          break;\n        }\n        let formData;\n        if (c.req.bodyCache.formData) {\n          formData = await c.req.bodyCache.formData;\n        } else {\n          try {\n            const arrayBuffer = await c.req.arrayBuffer();\n            formData = await bufferToFormData(arrayBuffer, contentType);\n            c.req.bodyCache.formData = formData;\n          } catch (e) {\n            let message = \"Malformed FormData request.\";\n            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;\n            throw new HTTPException(400, { message });\n          }\n        }\n        const form = {};\n        formData.forEach((value2, key) => {\n          if (key.endsWith(\"[]\")) {\n            ;\n            (form[key] ??= []).push(value2);\n          } else if (Array.isArray(form[key])) {\n            ;\n            form[key].push(value2);\n          } else if (key in form) {\n            form[key] = [form[key], value2];\n          } else {\n            form[key] = value2;\n          }\n        });\n        value = form;\n        break;\n      }\n      case \"query\":\n        value = Object.fromEntries(\n          Object.entries(c.req.queries()).map(([k, v]) => {\n            return v.length === 1 ? [k, v[0]] : [k, v];\n          })\n        );\n        break;\n      case \"param\":\n        value = c.req.param();\n        break;\n      case \"header\":\n        value = c.req.header();\n        break;\n      case \"cookie\":\n        value = getCookie(c);\n        break;\n    }\n    const res = await validationFunc(value, c);\n    if (res instanceof Response) {\n      return res;\n    }\n    c.req.addValidatedData(target, res);\n    await next();\n  };\n};\nexport {\n  validator\n};\n","// src/validator/index.ts\nimport { validator } from \"./validator.js\";\nexport {\n  validator\n};\n","module.exports = require(\"stream\");","module.exports = require(\"util\");","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","// src/middleware/cors/index.ts\nvar cors = (options) => {\n  const defaults = {\n    origin: \"*\",\n    allowMethods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\"],\n    allowHeaders: [],\n    exposeHeaders: []\n  };\n  const opts = {\n    ...defaults,\n    ...options\n  };\n  const findAllowOrigin = ((optsOrigin) => {\n    if (typeof optsOrigin === \"string\") {\n      if (optsOrigin === \"*\") {\n        return () => optsOrigin;\n      } else {\n        return (origin) => optsOrigin === origin ? origin : null;\n      }\n    } else if (typeof optsOrigin === \"function\") {\n      return optsOrigin;\n    } else {\n      return (origin) => optsOrigin.includes(origin) ? origin : null;\n    }\n  })(opts.origin);\n  const findAllowMethods = ((optsAllowMethods) => {\n    if (typeof optsAllowMethods === \"function\") {\n      return optsAllowMethods;\n    } else if (Array.isArray(optsAllowMethods)) {\n      return () => optsAllowMethods;\n    } else {\n      return () => [];\n    }\n  })(opts.allowMethods);\n  return async function cors2(c, next) {\n    function set(key, value) {\n      c.res.headers.set(key, value);\n    }\n    const allowOrigin = findAllowOrigin(c.req.header(\"origin\") || \"\", c);\n    if (allowOrigin) {\n      set(\"Access-Control-Allow-Origin\", allowOrigin);\n    }\n    if (opts.origin !== \"*\") {\n      const existingVary = c.req.header(\"Vary\");\n      if (existingVary) {\n        set(\"Vary\", existingVary);\n      } else {\n        set(\"Vary\", \"Origin\");\n      }\n    }\n    if (opts.credentials) {\n      set(\"Access-Control-Allow-Credentials\", \"true\");\n    }\n    if (opts.exposeHeaders?.length) {\n      set(\"Access-Control-Expose-Headers\", opts.exposeHeaders.join(\",\"));\n    }\n    if (c.req.method === \"OPTIONS\") {\n      if (opts.maxAge != null) {\n        set(\"Access-Control-Max-Age\", opts.maxAge.toString());\n      }\n      const allowMethods = findAllowMethods(c.req.header(\"origin\") || \"\", c);\n      if (allowMethods.length) {\n        set(\"Access-Control-Allow-Methods\", allowMethods.join(\",\"));\n      }\n      let headers = opts.allowHeaders;\n      if (!headers?.length) {\n        const requestHeaders = c.req.header(\"Access-Control-Request-Headers\");\n        if (requestHeaders) {\n          headers = requestHeaders.split(/\\s*,\\s*/);\n        }\n      }\n      if (headers?.length) {\n        set(\"Access-Control-Allow-Headers\", headers.join(\",\"));\n        c.res.headers.append(\"Vary\", \"Access-Control-Request-Headers\");\n      }\n      c.res.headers.delete(\"Content-Length\");\n      c.res.headers.delete(\"Content-Type\");\n      return new Response(null, {\n        headers: c.res.headers,\n        status: 204,\n        statusText: \"No Content\"\n      });\n    }\n    await next();\n  };\n};\nexport {\n  cors\n};\n","// src/adapter/vercel/handler.ts\nvar handle = (app) => (req) => {\n  return app.fetch(req);\n};\nexport {\n  handle\n};\n","module.exports = require(\"node:child_process\");","module.exports = require(\"path\");","module.exports = require(\"tls\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:stream/web\");","module.exports = require(\"node:zlib\");","module.exports = require(\"node:tls\");","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","module.exports = require(\"node:os\");","import OpenAI from 'openai';\r\n\r\n// Initialize the OpenAI client\r\nexport const openai = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\n/**\r\n * Generate an embedding for a given text\r\n * @param text - The text to generate an embedding for\r\n * @returns A vector of floating point numbers\r\n */\r\nexport async function generateEmbedding(text: string): Promise<number[]> {\r\n  try {\r\n    // Clean and prepare the text\r\n    const input = text.replace(/\\n/g, ' ').trim();\r\n    \r\n    // Generate embedding with text-embedding-3-small model\r\n    const response = await openai.embeddings.create({\r\n      model: 'text-embedding-3-small',\r\n      input,\r\n      dimensions: 1536,\r\n    });\r\n\r\n    // Return the embedding vector\r\n    return response.data[0].embedding;\r\n  } catch (error) {\r\n    console.error('Error generating embedding:', error);\r\n    throw new Error('Failed to generate text embedding');\r\n  }\r\n}\r\n\r\n/**\r\n * Extract content from an artifact for embedding purposes\r\n * @param artifact - The document artifact \r\n * @returns Processed text suitable for embedding\r\n */\r\nexport function getTextForEmbedding(artifact: any): string {\r\n  const content = artifact.content?.text || '';\r\n  const title = artifact.title || '';\r\n  const description = artifact.description || '';\r\n  \r\n  // Combine the title, description, and content for a comprehensive embedding\r\n  return `Title: ${title}\\nDescription: ${description}\\nContent: ${content}`;\r\n} ","import { zValidator } from \"@hono/zod-validator\";\r\nimport { createClient } from \"@supabase/supabase-js\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { handle } from \"hono/vercel\";\r\nimport { z } from \"zod\";\r\n\r\nimport { generateEmbedding } from \"@/lib/openai\"; // Used for internal search\r\nimport { getSupabaseClient } from \"@/lib/supabase/client\"; // Used for Firecrawl logging\r\n\r\n// --- Hono App Setup --- //\r\nconst app = new Hono().basePath(\"/api/search\");\r\n\r\n// --- Middleware --- //\r\napp.use(\"*\", cors());\r\n// TODO: Add authentication middleware if needed, especially if logging user searches\r\n\r\n// --- Supabase Clients --- //\r\n// Client for semantic search RPC\r\nconst supabaseAdmin = createClient(\r\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY!\r\n);\r\n\r\n// --- Schemas --- //\r\nconst internalSearchSchema = z.object({\r\n  query: z.string().min(1, \"Query parameter is required\"),\r\n  limit: z.coerce.number().int().positive().optional().default(5), // Coerce to number\r\n  threshold: z.coerce.number().min(0).max(1).optional().default(0.7), // Coerce to number\r\n  visibility: z.string().optional(), // Keep as string for flexibility\r\n});\r\n\r\nconst webSearchSchema = z.object({\r\n  query: z.string().min(1, \"Query cannot be empty\"),\r\n  maxResults: z.coerce.number().int().positive().optional().default(5), // Coerce to number\r\n});\r\n\r\n// Define an interface for the Firecrawl search results\r\n// Adjusted based on assumed structure from firecrawl.search()\r\ninterface FirecrawlSearchResult {\r\n  success: boolean;\r\n  data: Array<{\r\n    url: string;\r\n    title: string;\r\n    snippet?: string; // Make snippet optional or check library type\r\n    content?: string; // Firecrawl might return content or markdown\r\n    markdown?: string;\r\n    metadata?: Record<string, any>; // Include metadata\r\n    [key: string]: any; // Allow other potential fields\r\n  }>;\r\n  error?: string;\r\n}\r\n\r\n// --- Internal Semantic Search Route --- //\r\napp.get(\"/internal\", zValidator(\"query\", internalSearchSchema), async (c) => {\r\n  const { query, limit, threshold, visibility } = c.req.valid(\"query\");\r\n\r\n  try {\r\n    // Generate embedding for the search query\r\n    const embedding = await generateEmbedding(query);\r\n\r\n    // Perform similarity search using the match_artifacts function\r\n    const { data: results, error } = await supabaseAdmin.rpc(\r\n      \"match_artifacts\",\r\n      {\r\n        query_embedding: embedding,\r\n        match_threshold: threshold,\r\n        match_count: limit,\r\n        filter_visibility: visibility, // Pass visibility directly\r\n      }\r\n    );\r\n\r\n    if (error) {\r\n      console.error(\"Error performing semantic search:\", error);\r\n      return c.json(\r\n        { error: \"Error during semantic search\", details: error.message },\r\n        500\r\n      );\r\n    }\r\n\r\n    return c.json({\r\n      query,\r\n      results: results || [],\r\n    });\r\n  } catch (error: any) {\r\n    console.error(\"Error in internal search API:\", error);\r\n    return c.json(\r\n      { error: \"Internal server error\", details: error.message },\r\n      500\r\n    );\r\n  }\r\n});\r\n\r\n// --- External Web Search Route --- //\r\napp.get(\"/web\", zValidator(\"query\", webSearchSchema), async (c) => {\r\n  const { query, maxResults } = c.req.valid(\"query\");\r\n  // const userId = c.get('userId'); // Get userId from auth middleware if implemented\r\n\r\n  try {\r\n    // Dynamically import Firecrawl ONLY if the API key is present\r\n    if (process.env.FIRECRAWL_API_KEY) {\r\n      try {\r\n        const firecrawlImport = await import(\"@mendable/firecrawl-js\");\r\n        const FirecrawlApp = firecrawlImport.default;\r\n\r\n        const firecrawl = new FirecrawlApp({\r\n          apiKey: process.env.FIRECRAWL_API_KEY,\r\n        });\r\n\r\n        // Perform the search using Firecrawl\r\n        // Using `any` temporarily to bypass strict type checking until library types are fully resolved\r\n        const searchResult: any = await firecrawl.search(query);\r\n\r\n        // Robust check for success and data presence\r\n        if (\r\n          !searchResult ||\r\n          !searchResult.success ||\r\n          !Array.isArray(searchResult.data)\r\n        ) {\r\n          console.error(\r\n            \"Firecrawl search failed or returned unexpected format:\",\r\n            searchResult?.error\r\n          );\r\n          return c.json(\r\n            {\r\n              error: \"Web search failed\",\r\n              details:\r\n                searchResult?.error ||\r\n                \"Unknown Firecrawl error or invalid format\",\r\n            },\r\n            502\r\n          );\r\n        }\r\n\r\n        // Format results - adapt based on actual Firecrawl response structure\r\n        const formattedResults = searchResult.data\r\n          .slice(0, maxResults)\r\n          .map((item: any) => ({\r\n            url: item.url,\r\n            title: item.title,\r\n            snippet:\r\n              item.snippet ||\r\n              item.markdown?.substring(0, 200) ||\r\n              item.content?.substring(0, 200) ||\r\n              \"\", // Prioritize snippet, then markdown/content excerpt\r\n            // Include other relevant fields if needed\r\n          }));\r\n\r\n        // Log the search for analytics (Optional: Requires user context)\r\n        // if (userId) {\r\n        //   try {\r\n        //     const supabaseLogger = getSupabaseClient(); // Use appropriate client\r\n        //     await supabaseLogger.from('user_searches').insert({\r\n        //       query,\r\n        //       result_count: formattedResults.length,\r\n        //       timestamp: new Date().toISOString(),\r\n        //       user_id: userId, // Include user ID if available\r\n        //       search_type: 'web' // Add type for clarity\r\n        //     });\r\n        //   } catch (logError) {\r\n        //     console.error('Failed to log web search:', logError); // Log but don't fail request\r\n        //   }\r\n        // }\r\n\r\n        return c.json({\r\n          success: true,\r\n          query,\r\n          data: formattedResults,\r\n        });\r\n      } catch (importError) {\r\n        console.error(\"Failed to import or use Firecrawl:\", importError);\r\n        return c.json(\r\n          {\r\n            success: false,\r\n            error: \"Web search service unavailable\",\r\n            details: (importError as Error).message,\r\n          },\r\n          503\r\n        ); // 503 Service Unavailable\r\n      }\r\n    } else {\r\n      // Fallback if Firecrawl is not configured\r\n      console.warn(\r\n        \"Firecrawl API key not configured. Returning fallback web search result.\"\r\n      );\r\n      return c.json({\r\n        success: true,\r\n        query,\r\n        data: [\r\n          {\r\n            url: \"https://example.com/fallback\",\r\n            title: \"Fallback Result (Firecrawl not configured)\",\r\n            snippet: `This is a fallback result because Firecrawl is not configured. Your query was: \"${query}\"`,\r\n          },\r\n        ],\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Web search API error:\", error);\r\n    // Distinguish Zod errors (Bad Request) from others (Internal Server Error)\r\n    const status = error instanceof z.ZodError ? 400 : 500;\r\n    const message =\r\n      error instanceof z.ZodError\r\n        ? \"Invalid query parameters\"\r\n        : \"Internal server error\";\r\n    return c.json(\r\n      {\r\n        success: false,\r\n        error: message,\r\n        details:\r\n          error instanceof Error ? error.message : \"An unknown error occurred\",\r\n      },\r\n      { status }\r\n    );\r\n  }\r\n});\r\n\r\n// --- Export Hono App --- //\r\nexport const GET = handle(app);\r\n// Removed POST as both searches are now GET\r\n\r\n// Optional: Specify runtime if needed\r\n// export const runtime = 'edge'; // Or 'nodejs' if libraries require it\r\n","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/search',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\search\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/search/route\",\n        pathname: \"/api/search\",\n        filename: \"route\",\n        bundlePath: \"app/api/search/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\search\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","module.exports = require(\"node:diagnostics_channel\");","// src/http-exception.ts\nvar HTTPException = class extends Error {\n  res;\n  status;\n  constructor(status = 500, options) {\n    super(options?.message, { cause: options?.cause });\n    this.res = options?.res;\n    this.status = status;\n  }\n  getResponse() {\n    if (this.res) {\n      const newResponse = new Response(this.res.body, {\n        status: this.status,\n        headers: this.res.headers\n      });\n      return newResponse;\n    }\n    return new Response(this.message, {\n      status: this.status\n    });\n  }\n};\nexport {\n  HTTPException\n};\n","module.exports = require(\"crypto\");","module.exports = require(\"https\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","/* (ignored) */","// src/utils/cookie.ts\nimport { decodeURIComponent_ } from \"./url.js\";\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  if (name && cookie.indexOf(name) === -1) {\n    return {};\n  }\n  const pairs = cookie.trim().split(\";\");\n  const parsedCookie = {};\n  for (let pairStr of pairs) {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      continue;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      continue;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);\n      if (name) {\n        break;\n      }\n    }\n  }\n  return parsedCookie;\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    throw new Error(\"__Secure- Cookie must have Secure attributes\");\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      throw new Error(\"__Host- Cookie must have Secure attributes\");\n    }\n    if (opt.path !== \"/\") {\n      throw new Error('__Host- Cookie must have Path attributes with \"/\"');\n    }\n    if (opt.domain) {\n      throw new Error(\"__Host- Cookie must not have Domain attributes\");\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${opt.maxAge | 0}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.priority) {\n    cookie += `; Priority=${opt.priority}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nexport {\n  parse,\n  parseSigned,\n  serialize,\n  serializeSigned\n};\n","// src/helper/cookie/index.ts\nimport { parse, parseSigned, serialize, serializeSigned } from \"../../utils/cookie.js\";\nvar getCookie = (c, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = parse(cookie, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = parse(cookie);\n  return obj;\n};\nvar getSignedCookie = async (c, secret, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = await parseSigned(cookie, secret, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = await parseSigned(cookie, secret);\n  return obj;\n};\nvar setCookie = (c, name, value, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  c.header(\"Set-Cookie\", cookie, { append: true });\n};\nvar setSignedCookie = async (c, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  c.header(\"set-cookie\", cookie, { append: true });\n};\nvar deleteCookie = (c, name, opt) => {\n  const deletedCookie = getCookie(c, name, opt?.prefix);\n  setCookie(c, name, \"\", { ...opt, maxAge: 0 });\n  return deletedCookie;\n};\nexport {\n  deleteCookie,\n  getCookie,\n  getSignedCookie,\n  setCookie,\n  setSignedCookie\n};\n","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"buffer\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","module.exports = require(\"http\");","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","module.exports = require(\"node:inspector\");","module.exports = require(\"net\");","module.exports = require(\"events\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 96708;\nmodule.exports = webpackEmptyContext;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 97108;\nmodule.exports = webpackEmptyContext;"],"names":["openai","OpenAI","apiKey","process","env","OPENAI_API_KEY","generateEmbedding","text","input","replace","trim","response","embeddings","model","dimensions","data","embedding","error","console","app","Hono","basePath","use","cors","supabaseAdmin","createClient","SUPABASE_SERVICE_ROLE_KEY","internalSearchSchema","z","query","min","limit","number","int","positive","optional","default","threshold","max","visibility","webSearchSchema","maxResults","get","zValidator","c","req","valid","results","rpc","query_embedding","match_threshold","match_count","filter_visibility","details","message","json","FIRECRAWL_API_KEY","warn","success","url","title","snippet","firecrawl","firecrawlImport","FirecrawlApp","searchResult","search","Array","isArray","formattedResults","slice","map","item","markdown","substring","content","importError","status","Error","GET","handle","serverComponentModule.GET","serverComponentModule.POST","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS"],"sourceRoot":""}