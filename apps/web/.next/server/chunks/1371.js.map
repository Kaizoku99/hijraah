{"version":3,"file":"1371.js","mappings":"2eACA,SACA,QAAU,GAAU,qBACpB,SACA,cACA,CACA,CACA,QACA,QAAU,GAAU,kBACpB,mBACA,GACA,4BACA,CACA,cACA,gBACA,IACA,wBACA,CAAQ,MACR,gBACA,CACA,CAAK,EACL,2BAAiE,aAA6B,MAC9F,4BAAgC,EAAM,EAAE,EAAU,EAClD,CACA,CACA,QACA,QAAU,GAAU,eACpB,WACA,CACA,iHCpBA,SACA,qBACA,aACA,eACA,eACA,eACA,CACA,QAAU,GAAU,oBACpB,UACA,YAEA,OADA,iBACA,KAEA,OACA,qCACA,WACM,OAAY,eAClB,aACA,aACA,eACA,MACA,WACM,OAAY,eAClB,aACA,aACA,eACA,wBACA,CACA,CACA,gBAA2B,GAAY,CACvC,uBACA,QACA,eACA,eACA,iBAAoB,+BACpB,eAAqB,QAAgB,IACrC,0DAAsE,qBAAyB,EAC/F,CACA,QAAU,GAAU,aACpB,OACA,UACA,oBACA,QACA,MAAsB,QAAgB,IAKtC,MAJA,oBACA,iCAEA,mBACA,IACA,CACA,4BACA,CAAQ,OAAE,GAAQ,IAAO,EACzB,EAAmB,IAAK,iBACT,QAAE,GAAQ,GAAQ,EACjC,mBAEA,EAAiB,GAAc,iBAE/B,cACA,cACA,MAAwB,QAAgB,IACxC,8DACA,sBAAkC,EAAU,kCAE5C,yBACA,yBAA0C,QAAE,kBAAmB,IAAG,mDAClE,IACA,UACA,kBAA8B,IAAK,iBACnC,IAAgB,GAAqB,EAAG,2CAA+C,GAEvF,aACA,EACA,IAAgB,GAAqB,EAAG,2CAA+C,GAGvF,CAEA,GADA,2BAA+B,6BAAuC,EACtE,mBACA,UACA,WACA,+BACA,KAEA,aACA,4CACA,6DAEA,+BACA,KAEA,aACA,+BACA,KAEA,YACA,4CACA,6DAEA,8BAGA,CAEA,WACA,CACA,CACA,iCACA,mCACA,kCACA,kCAkCA,SAEA,OADA,oBACA,KAEA,aACA,QACA,kBAA+B,mBAAoB,IAAK,kBACxD,mBACA,MAA0B,QAAgB,mBAC1C,0CAAkE,QAAE,kBAAmB,IAAG,GAC1F,+CACA,OACA,CACA,gCACA,MAA6B,QAAgB,UAC7C,wBAAiD,QAAE,SAAa,IAAG,GACnE,sCACA,OACA,CACA,CACA,CAGA,OADA,sBAA4B,QAAmB,IAC/C,KAGA,SACA,iDACA,CACA,QACA,IAAY,gBAA6B,uCACzC,QACA,CAEA,YACA,mGAEA,OADA,+CACA,CACA,CACA,WACA,uBACA,CACA,UAEA,YAEA,OADA,iBACA,KAEA,WACA,yCACA,CACA,WACA,YAEA,eCxMA,SACA,uBACA,aACA,eACA,eACA,gBACA,6BACA,CACA,QAAU,GAAU,oBACpB,UAEA,YAEA,OADA,iBACA,KAEA,wBAEA,OADA,+BACA,KAEA,UAEA,QADA,0BACA,OACA,+DAEA,gBACA,SACA,aAA8B,IAAK,iBACnC,6BACA,WACA,KAAyB,QAAE,GAAW,IAAG,QAAmB,IAAK,QACjE,CACA,QACA,CAAK,EACL,qCACA,WACA,EACA,aACA,aACA,cACA,GACA,6BACA,MACA,WACA,EACA,aACA,aACA,cACA,GACA,6BACA,wBACA,CACA,UACA,iCAAuE,GAAY,IACnF,IAAS,QAAE,GAAS,IAAG,IAAM,QAAY,YAAY,GAAO,sBAC5D,YACA,sHAGA,qEACA,CACA,CACA,gBAA2B,GAAY,CACvC,2BACA,QACA,eACA,eACA,mBAAoB,wDACpB,CACA,QAAU,GAAU,aACpB,OACA,8BAAuC,IAAK,kBAE5C,OADA,sBAA4B,QAAmB,IAC/C,KAwBA,wBAAiC,EACjC,qBACA,uBAA+B,QAAG,iBAC5B,CACN,SACA,4LACA,cAAsC,QAAG,UAAU,QAAa,QAChE,wBAA+B,QAAG,IAAI,IAAG,QAAmB,GAAG,GAAU,YAEzE,YA+BA,sBACA,wCACA,YACA,+IAGA,cAAoC,QAAG,UAAU,QAAa,SAC9D,gBAAgD,QAAG,UAAU,cAAmB,SAChF,aAA0C,QAAG,UAAU,WAAgB,SACvE,gDAAkE,OAAY,2BAC9E,KAGA,OAFA,4LACA,uBAA6B,QAAG,IAAI,IAAG,QAAmB,GAAG,GAAgB,gBAAgB,EAAO,EAAE,EAAS,EAAE,EAAY,EAC7H,KAGA,SACA,iDACA,CACA,QACA,IAAY,gBAA6B,uCACzC,QACA,CAEA,YACA,OAAW,GAAM,4CACjB,6FAEA,CACA,WACA,uBACA,CACA,UAEA,YAEA,OADA,iBACA,KAEA,WACW,GAAM,yCACjB,0CAGA,YACA,YAEA,CCxLA,gBAA2B,GAAY,CACvC,qBACA,QACA,eACA,eACA,mBAAoB,aACpB,CACA,QAAU,GAAU,aACpB,OA8BA,SAEA,OADA,oBACA,KAEA,8BAAuC,IAAK,kBAE5C,OADA,sBAA4B,QAAmB,IAC/C,KAGA,SACA,iDACA,CACA,QACA,IAAY,gBAA6B,uCACzC,QACA,CAEA,YACA,OAAW,GAAM,4CACjB,6FAEA,CACA,WACA,uBACA,CACA,UAEA,YAEA,OADA,iBACA,KAEA,WACW,GAAM,yCACjB,0CAEA,CACA,WACA,YAEA,CChFA,gBAA6B,IAAG,CAChC,eACA,4DACA,cACA,qBACA,uBACA,sBACA,SACA,UAEA,CACA,IACA,aACA,CAAU,GAAU,oBACpB,qCACA,eACA,wBACA,MAAW,QAAG,yBAAyB,EAAO,EAAE,IAAG,sBAA4B,EAAE,EAAQ,GAEzF,uBACA,MAAW,QAAG,iCAAiC,EAAO,EAAE,IAAG,sBAA4B,EAAE,GAAS,EAGlG,YACA,YACA,CACA,UACA,qEACA,EACA,EAEA,CACA,SACA,0BACA,CACA,WACA,iBACA,IACA,MACA,GAEA,IAEA,MADA,MACA,CACA,EAEA,CACA,eC3CA,SACA,2BACA,kBACA,cACA,qBACA,aACA,mBACA,eACA,cACA,CACA,QAAU,GAAU,6BACpB,YACA,aACA,gBACA,YACA,mBACA,WACA,iBACA,aACA,aACA,KAA0B,CAC1B,OAEA,CACA,aACA,aACA,gBACA,YACA,mBACA,WACA,iBACA,aACA,aACA,GAAiB,cAAsB,CAAI,QAAU,CACrD,QAEA,CACA,CACA,gBAAgC,GAAY,CAC5C,+BACA,QACA,kBACA,cACA,qBACA,aACA,mBACA,eACA,eACA,cACA,WACA,CACA,QAAU,GAAU,sBAEpB,YACA,OAAW,GAAM,6CACjB,UAAc,gBAAoB,cAClC,iCACA,EACA,OACA,EACA,GACA,QACA,YACA,GAAqB,QAAgB,sDAErC,oBACA,KAEA,CACA,EAEA,CAAK,CACL,CACA,WACA,uBACA,CACA,YACA,mDACA,2BACA,mBACA,iCACA,iBACA,6BACA,wBACA,mCACK,CACL,CAEA,SACA,4BAEA,SACA,uBACA,iCACA,aAAa,eACb,CACA,QACA,+BACA,CACA,UAEA,YAEA,OADA,iBACA,KAEA,UACA,OAAW,GAAM,yCACjB,+CAEA,CACA,CClHA,gBAAoB,GAAY,CAChC,qBACA,QACA,eACA,WACA,aACA,qBACA,CACA,QAAU,GAAU,UAEpB,SACA,eACA,CACA,WACA,kBAEA,eACA,iCACA,CACA,WACA,WACA,CAEA,wBACA,QACA,CACA,CCzBA,gBAAwC,GAAY,CACpD,mBACA,QACA,eACA,eACA,kBAAoB,EACpB,CACA,QAAU,GAAU,6BACpB,QACA,eACA,mCACA,+DAGA,OADA,4BACA,KAEA,aACA,qCACA,+DAGA,OADA,0BACA,IACA,CAEA,SACA,kEACA,CACA,QACA,IAAY,gBAA6B,uCACzC,QACA,CAEA,YACA,OAAW,GAAM,4CACjB,8EAEA,CACA,WACA,uBACA,CACA,UAEA,YAEA,OADA,iBACA,KAEA,WACW,GAAM,yCACjB,0CAEA,CCtCA,QACA,mBAeA,GAdA,eACA,eACA,UACA,gBACA,wBACA,8BACA,SACA,EAAM,CACN,cACA,aAAoB,CACpB,gBAAuB,CACvB,SACA,EACA,cACA,cACA,6CACA,kBAAoC,EACpC,aACA,cACA,qBACA,gBACA,EACA,EACA,EAIA,CACA,QAAU,GAAU,eACpB,MAiCA,SACA,WACA,OACA,OACA,sBACA,SAAsB,GAAY,cAElC,UACA,IAAc,GAAY,wCAC1B,IAAc,GAAqB,QAAG,iDAA0D,GAGhG,CACA,CACA,YACA,WAAe,EAAc,QAAG,IAAH,MAAG,uBAAwC,CACxE,CAoBA,WACA,WAoCA,OAAa,OAnCb,YACA,WAAiB,IAAe,EAChC,iBACA,kBACA,kBACA,UACA,CAAO,CACP,EA4Ba,eA3Bb,YACA,WAAiB,IAAe,EAChC,iBACA,kBACA,kBACA,WACA,WACA,CAAO,CACP,EAmBa,iBAlBb,cACA,WAAiB,IAAe,EAChC,iBACA,kBACA,kBACA,WACA,aAAoB,EACpB,CAAO,CACP,EAUa,OATb,YACA,WAAiB,EAAe,wBAChC,EAOa,OANb,YACA,WAAiB,EAAe,wBAChC,EAIa,OAHb,YACA,WAAiB,EAAY,wBAC7B,CACa,CACb,CACA,UACA,WAAe,IAAe,EAC9B,iBACA,qBACA,qBACK,CACL,CACA,kBACA,WAAe,IAAe,EAC9B,iBACA,qBACA,qBACA,WACA,CAAK,CACL,CACA,sBACA,WAAe,IAAe,EAC9B,iBACA,qBACA,qBACA,aAAkB,EAClB,CAAK,CACL,CA4BA,UACA,WAAe,EAAe,4BAC9B,CAyBA,UACA,WAAe,EAAe,4BAC9B,CAyBA,UACA,WAAe,EAAY,4BAC3B,CACA,2BACA,WAAe,EAAyB,4BACxC,CACA,UACA,WACA,yBAA+C,IAAG,mBAClD,6BACA,4BACA,EACA,OACA,OACA,IAEA,WAAe,EACf,GADoB,CACpB,iCACA,EACA,EACA,qBAEA,CACA,iBACA,oCACA,CACA,0BCvRA,SACA,eACA,YACA,CACA,UACA,WACA,kBAEA,eACA,QACA,CAEA,YAEA,OADA,iBACA,KAEA,QAAU,GAAU,oBAEpB,oBAEA,QACA,eACA,cACA,CACA,QAAU,GAAU,cAEpB,aACA,OAAW,GAAM,yCASjB,EARuB,CAAM,4CAC7B,kBACA,2BACA,OACA,OACA,KAGA,8BAEA,CACA,OACA,yBACA,2BACA,OACA,OACA,IACA,KACA,CAEA,iBAEA,cADA,yBAEA,UAEA,CACA,CACA,gBAA4B,EAC5B,QADsC,IACtC,WACA,aACA,cACA,kBACA,CACA,QAAU,GAAU,iBACpB,YACA,UAAc,GAAwB,CAGtC,2BACA,SAUA,OATA,kBACA,0BAAqC,iBAAsB,GAE3D,cACA,qBAEA,gCACA,mDAEW,IAAG,iBACd,CACA,kBACA,4BAAgC,QAAG,mBAAmB,gCAAqC,EAC3F,CACA,CChFA,gBAAsC,EACtC,aADqD,CACrD,aACA,OAAY,eAA0B,EACtC,cACA,mBACA,cACA,cACA,cACA,8BACA,yBACA,CACA,QAAU,GAAU,2BACpB,mBAAsC,EACtC,OAAW,GAAM,6CACjB,MAAqB,QAAgB,gBACrC,kBACA,sCACA,wCACA,CAAO,EACP,yCACA,WAAc,qEAA8E,KAC5F,UACA,OAAe,GAAM,8CACrB,eAGA,YAAyB,GAAM,+CAC/B,kBACA,uBACA,wCACA,CAAS,EACT,yBAEA,OAAa,GAAM,2CACnB,gBAAiF,QAAY,SAE7F,CAAK,CACL,CACA,QAA4B,EAC5B,OAAW,GAAM,6CACjB,MAAqB,QAAgB,gBAMrC,OALA,kBACA,sCACA,wCACA,CAAO,EACP,yCACa,GAAM,+CACnB,kBACA,sCACA,wCACA,CAAS,EACT,wCAEA,CAAK,CACL,CAEA,wBACA,mCAEA,CACA,gBAAgC,EAChC,OADyC,KACzC,UAAmD,EACnD,SACA,cACA,cACA,eACA,0BAAwC,CACxC,CACA,QAFkD,EAExC,CAAU,sBACpB,OACA,wBACA,aACA,YACA,MACA,SACA,YACA,EACA,EACA,EAEA,CACA,WAEA,OADA,0BACA,gCACA,CACA,kBACA,8BACA,CACA,iBACA,mCACA,YACA,EACA,aACA,YACA,cAEA,oCAIA,OAHA,GACA,0BAEA,IACA,CAAK,CACL,CACA,CACA,gBAAoC,EACpC,WADiD,CACjD,WACA,eACA,cACA,CACA,QAAU,GAAU,0BACpB,eACA,yCACA,YACA,EACA,aACA,YACA,sBAGA,SADA,kCAEA,CAAK,CACL,CACA,CCtHA,gBAAiC,EACjC,QAAU,GAAU,uBAEpB,iBAAsC,EACtC,IAQA,EAMA,EAdA,OACA,0CACA,uBACA,0BAEA,gCACA,gCACA,UAAsB,GAAS,EAAG,gBAAuB,EAQzD,GANA,cACA,MAAiB,EACb,WAD0B,EAC1B,EACJ,aAGA,UACA,MAAyB,QAA6B,CACtD,SACM,IAA2B,EAEjC,GACA,oBACA,gBACA,8BAEA,CACA,UAAsB,EAAiB,cAA4B,CAA5B,CAAoC,EAC3E,eAEA,OADA,YACA,CACA,CACA,iBACA,yBAEA,SADqB,OAAQ,OAC7B,MAEA,GAAM,QAAQ,QACd,eAAY,iBAAuC,KACnD,KACA,cACA,uCACA,QAAc,QAAiB,EAE/B,SADwB,OAAQ,MAChC,EACA,CAEA,SADqB,OAAQ,IAC7B,EACA,CACA,mBACA,CAKA,CACC,SAA0B,EAD3B,KAHA,YACA,WAAuB,GACvB","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/logger.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/query-builders/update.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/query-builders/insert.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/query-builders/delete.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/query-builders/count.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/query-builders/query.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/query-builders/raw.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/db.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/pg-core/session.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/postgres-js/session.js","webpack://@hijraah/web/../../node_modules/.pnpm/drizzle-orm@0.36.4_@cloudfl_3297e0cb253def86d9554d78aac005d9/node_modules/drizzle-orm/postgres-js/driver.js"],"sourcesContent":["import { entityKind } from \"./entity.js\";\nclass ConsoleLogWriter {\n  static [entityKind] = \"ConsoleLogWriter\";\n  write(message) {\n    console.log(message);\n  }\n}\nclass DefaultLogger {\n  static [entityKind] = \"DefaultLogger\";\n  writer;\n  constructor(config) {\n    this.writer = config?.writer ?? new ConsoleLogWriter();\n  }\n  logQuery(query, params) {\n    const stringifiedParams = params.map((p) => {\n      try {\n        return JSON.stringify(p);\n      } catch {\n        return String(p);\n      }\n    });\n    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(\", \")}]` : \"\";\n    this.writer.write(`Query: ${query}${paramsStr}`);\n  }\n}\nclass NoopLogger {\n  static [entityKind] = \"NoopLogger\";\n  logQuery() {\n  }\n}\nexport {\n  ConsoleLogWriter,\n  DefaultLogger,\n  NoopLogger\n};\n//# sourceMappingURL=logger.js.map","import { entityKind, is } from \"../../entity.js\";\nimport { PgTable } from \"../table.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { SelectionProxyHandler } from \"../../selection-proxy.js\";\nimport { SQL } from \"../../sql/sql.js\";\nimport { Subquery } from \"../../subquery.js\";\nimport { Table } from \"../../table.js\";\nimport { getTableLikeName, mapUpdateSet, orderSelectedFields } from \"../../utils.js\";\nimport { ViewBaseConfig } from \"../../view-common.js\";\nclass PgUpdateBuilder {\n  constructor(table, session, dialect, withList) {\n    this.table = table;\n    this.session = session;\n    this.dialect = dialect;\n    this.withList = withList;\n  }\n  static [entityKind] = \"PgUpdateBuilder\";\n  authToken;\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  set(values) {\n    return this.authToken === void 0 ? new PgUpdateBase(\n      this.table,\n      mapUpdateSet(this.table, values),\n      this.session,\n      this.dialect,\n      this.withList\n    ) : new PgUpdateBase(\n      this.table,\n      mapUpdateSet(this.table, values),\n      this.session,\n      this.dialect,\n      this.withList\n    ).setToken(this.authToken);\n  }\n}\nclass PgUpdateBase extends QueryPromise {\n  constructor(table, set, session, dialect, withList) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { set, table, withList, joins: [] };\n    this.tableName = getTableLikeName(table);\n    this.joinsNotNullableMap = typeof this.tableName === \"string\" ? { [this.tableName]: true } : {};\n  }\n  static [entityKind] = \"PgUpdate\";\n  config;\n  tableName;\n  joinsNotNullableMap;\n  from(source) {\n    const tableName = getTableLikeName(source);\n    if (typeof tableName === \"string\") {\n      this.joinsNotNullableMap[tableName] = true;\n    }\n    this.config.from = source;\n    return this;\n  }\n  getTableLikeFields(table) {\n    if (is(table, PgTable)) {\n      return table[Table.Symbol.Columns];\n    } else if (is(table, Subquery)) {\n      return table._.selectedFields;\n    }\n    return table[ViewBaseConfig].selectedFields;\n  }\n  createJoin(joinType) {\n    return (table, on) => {\n      const tableName = getTableLikeName(table);\n      if (typeof tableName === \"string\" && this.config.joins.some((join) => join.alias === tableName)) {\n        throw new Error(`Alias \"${tableName}\" is already used in this query`);\n      }\n      if (typeof on === \"function\") {\n        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : void 0;\n        on = on(\n          new Proxy(\n            this.config.table[Table.Symbol.Columns],\n            new SelectionProxyHandler({ sqlAliasedBehavior: \"sql\", sqlBehavior: \"sql\" })\n          ),\n          from && new Proxy(\n            from,\n            new SelectionProxyHandler({ sqlAliasedBehavior: \"sql\", sqlBehavior: \"sql\" })\n          )\n        );\n      }\n      this.config.joins.push({ on, table, joinType, alias: tableName });\n      if (typeof tableName === \"string\") {\n        switch (joinType) {\n          case \"left\": {\n            this.joinsNotNullableMap[tableName] = false;\n            break;\n          }\n          case \"right\": {\n            this.joinsNotNullableMap = Object.fromEntries(\n              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])\n            );\n            this.joinsNotNullableMap[tableName] = true;\n            break;\n          }\n          case \"inner\": {\n            this.joinsNotNullableMap[tableName] = true;\n            break;\n          }\n          case \"full\": {\n            this.joinsNotNullableMap = Object.fromEntries(\n              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])\n            );\n            this.joinsNotNullableMap[tableName] = false;\n            break;\n          }\n        }\n      }\n      return this;\n    };\n  }\n  leftJoin = this.createJoin(\"left\");\n  rightJoin = this.createJoin(\"right\");\n  innerJoin = this.createJoin(\"inner\");\n  fullJoin = this.createJoin(\"full\");\n  /**\n   * Adds a 'where' clause to the query.\n   *\n   * Calling this method will update only those rows that fulfill a specified condition.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/update}\n   *\n   * @param where the 'where' clause.\n   *\n   * @example\n   * You can use conditional operators and `sql function` to filter the rows to be updated.\n   *\n   * ```ts\n   * // Update all cars with green color\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(eq(cars.color, 'green'));\n   * // or\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(sql`${cars.color} = 'green'`)\n   * ```\n   *\n   * You can logically combine conditional operators with `and()` and `or()` operators:\n   *\n   * ```ts\n   * // Update all BMW cars with a green color\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n   *\n   * // Update all cars with the green or blue color\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n   * ```\n   */\n  where(where) {\n    this.config.where = where;\n    return this;\n  }\n  returning(fields) {\n    if (!fields) {\n      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);\n      if (this.config.from) {\n        const tableName = getTableLikeName(this.config.from);\n        if (typeof tableName === \"string\" && this.config.from && !is(this.config.from, SQL)) {\n          const fromFields = this.getTableLikeFields(this.config.from);\n          fields[tableName] = fromFields;\n        }\n        for (const join of this.config.joins) {\n          const tableName2 = getTableLikeName(join.table);\n          if (typeof tableName2 === \"string\" && !is(join.table, SQL)) {\n            const fromFields = this.getTableLikeFields(join.table);\n            fields[tableName2] = fromFields;\n          }\n        }\n      }\n    }\n    this.config.returning = orderSelectedFields(fields);\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildUpdateQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);\n    query.joinsNotNullableMap = this.joinsNotNullableMap;\n    return query;\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return this._prepare().execute(placeholderValues, this.authToken);\n  };\n  $dynamic() {\n    return this;\n  }\n}\nexport {\n  PgUpdateBase,\n  PgUpdateBuilder\n};\n//# sourceMappingURL=update.js.map","import { entityKind, is } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { Param, SQL, sql } from \"../../sql/sql.js\";\nimport { Columns, Table } from \"../../table.js\";\nimport { tracer } from \"../../tracing.js\";\nimport { haveSameKeys, mapUpdateSet, orderSelectedFields } from \"../../utils.js\";\nimport { QueryBuilder } from \"./query-builder.js\";\nclass PgInsertBuilder {\n  constructor(table, session, dialect, withList, overridingSystemValue_) {\n    this.table = table;\n    this.session = session;\n    this.dialect = dialect;\n    this.withList = withList;\n    this.overridingSystemValue_ = overridingSystemValue_;\n  }\n  static [entityKind] = \"PgInsertBuilder\";\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  overridingSystemValue() {\n    this.overridingSystemValue_ = true;\n    return this;\n  }\n  values(values) {\n    values = Array.isArray(values) ? values : [values];\n    if (values.length === 0) {\n      throw new Error(\"values() must be called with at least one value\");\n    }\n    const mappedValues = values.map((entry) => {\n      const result = {};\n      const cols = this.table[Table.Symbol.Columns];\n      for (const colKey of Object.keys(entry)) {\n        const colValue = entry[colKey];\n        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);\n      }\n      return result;\n    });\n    return this.authToken === void 0 ? new PgInsertBase(\n      this.table,\n      mappedValues,\n      this.session,\n      this.dialect,\n      this.withList,\n      false,\n      this.overridingSystemValue_\n    ) : new PgInsertBase(\n      this.table,\n      mappedValues,\n      this.session,\n      this.dialect,\n      this.withList,\n      false,\n      this.overridingSystemValue_\n    ).setToken(this.authToken);\n  }\n  select(selectQuery) {\n    const select = typeof selectQuery === \"function\" ? selectQuery(new QueryBuilder()) : selectQuery;\n    if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {\n      throw new Error(\n        \"Insert select error: selected fields are not the same or are in a different order compared to the table definition\"\n      );\n    }\n    return new PgInsertBase(this.table, select, this.session, this.dialect, this.withList, true);\n  }\n}\nclass PgInsertBase extends QueryPromise {\n  constructor(table, values, session, dialect, withList, select, overridingSystemValue_) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { table, values, withList, select, overridingSystemValue_ };\n  }\n  static [entityKind] = \"PgInsert\";\n  config;\n  returning(fields = this.config.table[Table.Symbol.Columns]) {\n    this.config.returning = orderSelectedFields(fields);\n    return this;\n  }\n  /**\n   * Adds an `on conflict do nothing` clause to the query.\n   *\n   * Calling this method simply avoids inserting a row as its alternative action.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}\n   *\n   * @param config The `target` and `where` clauses.\n   *\n   * @example\n   * ```ts\n   * // Insert one row and cancel the insert if there's a conflict\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoNothing();\n   *\n   * // Explicitly specify conflict target\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoNothing({ target: cars.id });\n   * ```\n   */\n  onConflictDoNothing(config = {}) {\n    if (config.target === void 0) {\n      this.config.onConflict = sql`do nothing`;\n    } else {\n      let targetColumn = \"\";\n      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(\",\") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));\n      const whereSql = config.where ? sql` where ${config.where}` : void 0;\n      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;\n    }\n    return this;\n  }\n  /**\n   * Adds an `on conflict do update` clause to the query.\n   *\n   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}\n   *\n   * @param config The `target`, `set` and `where` clauses.\n   *\n   * @example\n   * ```ts\n   * // Update the row if there's a conflict\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoUpdate({\n   *     target: cars.id,\n   *     set: { brand: 'Porsche' }\n   *   });\n   *\n   * // Upsert with 'where' clause\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoUpdate({\n   *     target: cars.id,\n   *     set: { brand: 'newBMW' },\n   *     targetWhere: sql`${cars.createdAt} > '2023-01-01'::date`,\n   *   });\n   * ```\n   */\n  onConflictDoUpdate(config) {\n    if (config.where && (config.targetWhere || config.setWhere)) {\n      throw new Error(\n        'You cannot use both \"where\" and \"targetWhere\"/\"setWhere\" at the same time - \"where\" is deprecated, use \"targetWhere\" or \"setWhere\" instead.'\n      );\n    }\n    const whereSql = config.where ? sql` where ${config.where}` : void 0;\n    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : void 0;\n    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : void 0;\n    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));\n    let targetColumn = \"\";\n    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(\",\") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));\n    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildInsertQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(placeholderValues, this.authToken);\n    });\n  };\n  $dynamic() {\n    return this;\n  }\n}\nexport {\n  PgInsertBase,\n  PgInsertBuilder\n};\n//# sourceMappingURL=insert.js.map","import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { Table } from \"../../table.js\";\nimport { tracer } from \"../../tracing.js\";\nimport { orderSelectedFields } from \"../../utils.js\";\nclass PgDeleteBase extends QueryPromise {\n  constructor(table, session, dialect, withList) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { table, withList };\n  }\n  static [entityKind] = \"PgDelete\";\n  config;\n  /**\n   * Adds a `where` clause to the query.\n   *\n   * Calling this method will delete only those rows that fulfill a specified condition.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/delete}\n   *\n   * @param where the `where` clause.\n   *\n   * @example\n   * You can use conditional operators and `sql function` to filter the rows to be deleted.\n   *\n   * ```ts\n   * // Delete all cars with green color\n   * await db.delete(cars).where(eq(cars.color, 'green'));\n   * // or\n   * await db.delete(cars).where(sql`${cars.color} = 'green'`)\n   * ```\n   *\n   * You can logically combine conditional operators with `and()` and `or()` operators:\n   *\n   * ```ts\n   * // Delete all BMW cars with a green color\n   * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n   *\n   * // Delete all cars with the green or blue color\n   * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n   * ```\n   */\n  where(where) {\n    this.config.where = where;\n    return this;\n  }\n  returning(fields = this.config.table[Table.Symbol.Columns]) {\n    this.config.returning = orderSelectedFields(fields);\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildDeleteQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(placeholderValues, this.authToken);\n    });\n  };\n  $dynamic() {\n    return this;\n  }\n}\nexport {\n  PgDeleteBase\n};\n//# sourceMappingURL=delete.js.map","import { entityKind } from \"../../entity.js\";\nimport { SQL, sql } from \"../../sql/sql.js\";\nclass PgCountBuilder extends SQL {\n  constructor(params) {\n    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);\n    this.params = params;\n    this.mapWith(Number);\n    this.session = params.session;\n    this.sql = PgCountBuilder.buildCount(\n      params.source,\n      params.filters\n    );\n  }\n  sql;\n  token;\n  static [entityKind] = \"PgCountBuilder\";\n  [Symbol.toStringTag] = \"PgCountBuilder\";\n  session;\n  static buildEmbeddedCount(source, filters) {\n    return sql`(select count(*) from ${source}${sql.raw(\" where \").if(filters)}${filters})`;\n  }\n  static buildCount(source, filters) {\n    return sql`select count(*) as count from ${source}${sql.raw(\" where \").if(filters)}${filters};`;\n  }\n  /** @intrnal */\n  setToken(token) {\n    this.token = token;\n  }\n  then(onfulfilled, onrejected) {\n    return Promise.resolve(this.session.count(this.sql, this.token)).then(\n      onfulfilled,\n      onrejected\n    );\n  }\n  catch(onRejected) {\n    return this.then(void 0, onRejected);\n  }\n  finally(onFinally) {\n    return this.then(\n      (value) => {\n        onFinally?.();\n        return value;\n      },\n      (reason) => {\n        onFinally?.();\n        throw reason;\n      }\n    );\n  }\n}\nexport {\n  PgCountBuilder\n};\n//# sourceMappingURL=count.js.map","import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport {\n  mapRelationalRow\n} from \"../../relations.js\";\nimport { tracer } from \"../../tracing.js\";\nclass RelationalQueryBuilder {\n  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {\n    this.fullSchema = fullSchema;\n    this.schema = schema;\n    this.tableNamesMap = tableNamesMap;\n    this.table = table;\n    this.tableConfig = tableConfig;\n    this.dialect = dialect;\n    this.session = session;\n  }\n  static [entityKind] = \"PgRelationalQueryBuilder\";\n  findMany(config) {\n    return new PgRelationalQuery(\n      this.fullSchema,\n      this.schema,\n      this.tableNamesMap,\n      this.table,\n      this.tableConfig,\n      this.dialect,\n      this.session,\n      config ? config : {},\n      \"many\"\n    );\n  }\n  findFirst(config) {\n    return new PgRelationalQuery(\n      this.fullSchema,\n      this.schema,\n      this.tableNamesMap,\n      this.table,\n      this.tableConfig,\n      this.dialect,\n      this.session,\n      config ? { ...config, limit: 1 } : { limit: 1 },\n      \"first\"\n    );\n  }\n}\nclass PgRelationalQuery extends QueryPromise {\n  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {\n    super();\n    this.fullSchema = fullSchema;\n    this.schema = schema;\n    this.tableNamesMap = tableNamesMap;\n    this.table = table;\n    this.tableConfig = tableConfig;\n    this.dialect = dialect;\n    this.session = session;\n    this.config = config;\n    this.mode = mode;\n  }\n  static [entityKind] = \"PgRelationalQuery\";\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      const { query, builtQuery } = this._toSQL();\n      return this.session.prepareQuery(\n        builtQuery,\n        void 0,\n        name,\n        true,\n        (rawRows, mapColumnValue) => {\n          const rows = rawRows.map(\n            (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)\n          );\n          if (this.mode === \"first\") {\n            return rows[0];\n          }\n          return rows;\n        }\n      );\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  _getQuery() {\n    return this.dialect.buildRelationalQueryWithoutPK({\n      fullSchema: this.fullSchema,\n      schema: this.schema,\n      tableNamesMap: this.tableNamesMap,\n      table: this.table,\n      tableConfig: this.tableConfig,\n      queryConfig: this.config,\n      tableAlias: this.tableConfig.tsName\n    });\n  }\n  /** @internal */\n  getSQL() {\n    return this._getQuery().sql;\n  }\n  _toSQL() {\n    const query = this._getQuery();\n    const builtQuery = this.dialect.sqlToQuery(query.sql);\n    return { query, builtQuery };\n  }\n  toSQL() {\n    return this._toSQL().builtQuery;\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute() {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(void 0, this.authToken);\n    });\n  }\n}\nexport {\n  PgRelationalQuery,\n  RelationalQueryBuilder\n};\n//# sourceMappingURL=query.js.map","import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nclass PgRaw extends QueryPromise {\n  constructor(execute, sql, query, mapBatchResult) {\n    super();\n    this.execute = execute;\n    this.sql = sql;\n    this.query = query;\n    this.mapBatchResult = mapBatchResult;\n  }\n  static [entityKind] = \"PgRaw\";\n  /** @internal */\n  getSQL() {\n    return this.sql;\n  }\n  getQuery() {\n    return this.query;\n  }\n  mapResult(result, isFromBatch) {\n    return isFromBatch ? this.mapBatchResult(result) : result;\n  }\n  _prepare() {\n    return this;\n  }\n  /** @internal */\n  isResponseInArrayMode() {\n    return false;\n  }\n}\nexport {\n  PgRaw\n};\n//# sourceMappingURL=raw.js.map","import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { tracer } from \"../../tracing.js\";\nclass PgRefreshMaterializedView extends QueryPromise {\n  constructor(view, session, dialect) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { view };\n  }\n  static [entityKind] = \"PgRefreshMaterializedView\";\n  config;\n  concurrently() {\n    if (this.config.withNoData !== void 0) {\n      throw new Error(\"Cannot use concurrently and withNoData together\");\n    }\n    this.config.concurrently = true;\n    return this;\n  }\n  withNoData() {\n    if (this.config.concurrently !== void 0) {\n      throw new Error(\"Cannot use concurrently and withNoData together\");\n    }\n    this.config.withNoData = true;\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildRefreshMaterializedViewQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name, true);\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(placeholderValues, this.authToken);\n    });\n  };\n}\nexport {\n  PgRefreshMaterializedView\n};\n//# sourceMappingURL=refresh-materialized-view.js.map","import { entityKind } from \"../entity.js\";\nimport {\n  PgDeleteBase,\n  PgInsertBuilder,\n  PgSelectBuilder,\n  PgUpdateBuilder,\n  QueryBuilder\n} from \"./query-builders/index.js\";\nimport { SelectionProxyHandler } from \"../selection-proxy.js\";\nimport { sql } from \"../sql/sql.js\";\nimport { WithSubquery } from \"../subquery.js\";\nimport { PgCountBuilder } from \"./query-builders/count.js\";\nimport { RelationalQueryBuilder } from \"./query-builders/query.js\";\nimport { PgRaw } from \"./query-builders/raw.js\";\nimport { PgRefreshMaterializedView } from \"./query-builders/refresh-materialized-view.js\";\nclass PgDatabase {\n  constructor(dialect, session, schema) {\n    this.dialect = dialect;\n    this.session = session;\n    this._ = schema ? {\n      schema: schema.schema,\n      fullSchema: schema.fullSchema,\n      tableNamesMap: schema.tableNamesMap,\n      session\n    } : {\n      schema: void 0,\n      fullSchema: {},\n      tableNamesMap: {},\n      session\n    };\n    this.query = {};\n    if (this._.schema) {\n      for (const [tableName, columns] of Object.entries(this._.schema)) {\n        this.query[tableName] = new RelationalQueryBuilder(\n          schema.fullSchema,\n          this._.schema,\n          this._.tableNamesMap,\n          schema.fullSchema[tableName],\n          columns,\n          dialect,\n          session\n        );\n      }\n    }\n  }\n  static [entityKind] = \"PgDatabase\";\n  query;\n  /**\n   * Creates a subquery that defines a temporary named result set as a CTE.\n   *\n   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n   *\n   * @param alias The alias for the subquery.\n   *\n   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.\n   *\n   * @example\n   *\n   * ```ts\n   * // Create a subquery with alias 'sq' and use it in the select query\n   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n   *\n   * const result = await db.with(sq).select().from(sq);\n   * ```\n   *\n   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:\n   *\n   * ```ts\n   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query\n   * const sq = db.$with('sq').as(db.select({\n   *   name: sql<string>`upper(${users.name})`.as('name'),\n   * })\n   * .from(users));\n   *\n   * const result = await db.with(sq).select({ name: sq.name }).from(sq);\n   * ```\n   */\n  $with(alias) {\n    const self = this;\n    return {\n      as(qb) {\n        if (typeof qb === \"function\") {\n          qb = qb(new QueryBuilder(self.dialect));\n        }\n        return new Proxy(\n          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),\n          new SelectionProxyHandler({ alias, sqlAliasedBehavior: \"alias\", sqlBehavior: \"error\" })\n        );\n      }\n    };\n  }\n  $count(source, filters) {\n    return new PgCountBuilder({ source, filters, session: this.session });\n  }\n  /**\n   * Incorporates a previously defined CTE (using `$with`) into the main query.\n   *\n   * This method allows the main query to reference a temporary named result set.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n   *\n   * @param queries The CTEs to incorporate into the main query.\n   *\n   * @example\n   *\n   * ```ts\n   * // Define a subquery 'sq' as a CTE using $with\n   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n   *\n   * // Incorporate the CTE 'sq' into the main query and select from it\n   * const result = await db.with(sq).select().from(sq);\n   * ```\n   */\n  with(...queries) {\n    const self = this;\n    function select(fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: self.session,\n        dialect: self.dialect,\n        withList: queries\n      });\n    }\n    function selectDistinct(fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: self.session,\n        dialect: self.dialect,\n        withList: queries,\n        distinct: true\n      });\n    }\n    function selectDistinctOn(on, fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: self.session,\n        dialect: self.dialect,\n        withList: queries,\n        distinct: { on }\n      });\n    }\n    function update(table) {\n      return new PgUpdateBuilder(table, self.session, self.dialect, queries);\n    }\n    function insert(table) {\n      return new PgInsertBuilder(table, self.session, self.dialect, queries);\n    }\n    function delete_(table) {\n      return new PgDeleteBase(table, self.session, self.dialect, queries);\n    }\n    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };\n  }\n  select(fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: this.session,\n      dialect: this.dialect\n    });\n  }\n  selectDistinct(fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: this.session,\n      dialect: this.dialect,\n      distinct: true\n    });\n  }\n  selectDistinctOn(on, fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: this.session,\n      dialect: this.dialect,\n      distinct: { on }\n    });\n  }\n  /**\n   * Creates an update query.\n   *\n   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n   *\n   * Use `.set()` method to specify which values to update.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/update}\n   *\n   * @param table The table to update.\n   *\n   * @example\n   *\n   * ```ts\n   * // Update all rows in the 'cars' table\n   * await db.update(cars).set({ color: 'red' });\n   *\n   * // Update rows with filters and conditions\n   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n   *\n   * // Update with returning clause\n   * const updatedCar: Car[] = await db.update(cars)\n   *   .set({ color: 'red' })\n   *   .where(eq(cars.id, 1))\n   *   .returning();\n   * ```\n   */\n  update(table) {\n    return new PgUpdateBuilder(table, this.session, this.dialect);\n  }\n  /**\n   * Creates an insert query.\n   *\n   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/insert}\n   *\n   * @param table The table to insert into.\n   *\n   * @example\n   *\n   * ```ts\n   * // Insert one row\n   * await db.insert(cars).values({ brand: 'BMW' });\n   *\n   * // Insert multiple rows\n   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n   *\n   * // Insert with returning clause\n   * const insertedCar: Car[] = await db.insert(cars)\n   *   .values({ brand: 'BMW' })\n   *   .returning();\n   * ```\n   */\n  insert(table) {\n    return new PgInsertBuilder(table, this.session, this.dialect);\n  }\n  /**\n   * Creates a delete query.\n   *\n   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/delete}\n   *\n   * @param table The table to delete from.\n   *\n   * @example\n   *\n   * ```ts\n   * // Delete all rows in the 'cars' table\n   * await db.delete(cars);\n   *\n   * // Delete rows with filters and conditions\n   * await db.delete(cars).where(eq(cars.color, 'green'));\n   *\n   * // Delete with returning clause\n   * const deletedCar: Car[] = await db.delete(cars)\n   *   .where(eq(cars.id, 1))\n   *   .returning();\n   * ```\n   */\n  delete(table) {\n    return new PgDeleteBase(table, this.session, this.dialect);\n  }\n  refreshMaterializedView(view) {\n    return new PgRefreshMaterializedView(view, this.session, this.dialect);\n  }\n  authToken;\n  execute(query) {\n    const sequel = typeof query === \"string\" ? sql.raw(query) : query.getSQL();\n    const builtQuery = this.dialect.sqlToQuery(sequel);\n    const prepared = this.session.prepareQuery(\n      builtQuery,\n      void 0,\n      void 0,\n      false\n    );\n    return new PgRaw(\n      () => prepared.execute(void 0, this.authToken),\n      sequel,\n      builtQuery,\n      (result) => prepared.mapResult(result, true)\n    );\n  }\n  transaction(transaction, config) {\n    return this.session.transaction(transaction, config);\n  }\n}\nconst withReplicas = (primary, replicas, getReplica = () => replicas[Math.floor(Math.random() * replicas.length)]) => {\n  const select = (...args) => getReplica(replicas).select(...args);\n  const selectDistinct = (...args) => getReplica(replicas).selectDistinct(...args);\n  const selectDistinctOn = (...args) => getReplica(replicas).selectDistinctOn(...args);\n  const $with = (...args) => getReplica(replicas).with(...args);\n  const update = (...args) => primary.update(...args);\n  const insert = (...args) => primary.insert(...args);\n  const $delete = (...args) => primary.delete(...args);\n  const execute = (...args) => primary.execute(...args);\n  const transaction = (...args) => primary.transaction(...args);\n  const refreshMaterializedView = (...args) => primary.refreshMaterializedView(...args);\n  return {\n    ...primary,\n    update,\n    insert,\n    delete: $delete,\n    execute,\n    transaction,\n    refreshMaterializedView,\n    $primary: primary,\n    select,\n    selectDistinct,\n    selectDistinctOn,\n    with: $with,\n    get query() {\n      return getReplica(replicas).query;\n    }\n  };\n};\nexport {\n  PgDatabase,\n  withReplicas\n};\n//# sourceMappingURL=db.js.map","import { entityKind } from \"../entity.js\";\nimport { TransactionRollbackError } from \"../errors.js\";\nimport { sql } from \"../sql/index.js\";\nimport { tracer } from \"../tracing.js\";\nimport { PgDatabase } from \"./db.js\";\nclass PgPreparedQuery {\n  constructor(query) {\n    this.query = query;\n  }\n  authToken;\n  getQuery() {\n    return this.query;\n  }\n  mapResult(response, _isFromBatch) {\n    return response;\n  }\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  static [entityKind] = \"PgPreparedQuery\";\n  /** @internal */\n  joinsNotNullableMap;\n}\nclass PgSession {\n  constructor(dialect) {\n    this.dialect = dialect;\n  }\n  static [entityKind] = \"PgSession\";\n  /** @internal */\n  execute(query, token) {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      const prepared = tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n        return this.prepareQuery(\n          this.dialect.sqlToQuery(query),\n          void 0,\n          void 0,\n          false\n        );\n      });\n      return prepared.setToken(token).execute(void 0, token);\n    });\n  }\n  all(query) {\n    return this.prepareQuery(\n      this.dialect.sqlToQuery(query),\n      void 0,\n      void 0,\n      false\n    ).all();\n  }\n  /** @internal */\n  async count(sql2, token) {\n    const res = await this.execute(sql2, token);\n    return Number(\n      res[0][\"count\"]\n    );\n  }\n}\nclass PgTransaction extends PgDatabase {\n  constructor(dialect, session, schema, nestedIndex = 0) {\n    super(dialect, session, schema);\n    this.schema = schema;\n    this.nestedIndex = nestedIndex;\n  }\n  static [entityKind] = \"PgTransaction\";\n  rollback() {\n    throw new TransactionRollbackError();\n  }\n  /** @internal */\n  getTransactionConfigSQL(config) {\n    const chunks = [];\n    if (config.isolationLevel) {\n      chunks.push(`isolation level ${config.isolationLevel}`);\n    }\n    if (config.accessMode) {\n      chunks.push(config.accessMode);\n    }\n    if (typeof config.deferrable === \"boolean\") {\n      chunks.push(config.deferrable ? \"deferrable\" : \"not deferrable\");\n    }\n    return sql.raw(chunks.join(\" \"));\n  }\n  setTransaction(config) {\n    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);\n  }\n}\nexport {\n  PgPreparedQuery,\n  PgSession,\n  PgTransaction\n};\n//# sourceMappingURL=session.js.map","import { entityKind } from \"../entity.js\";\nimport { NoopLogger } from \"../logger.js\";\nimport { PgTransaction } from \"../pg-core/index.js\";\nimport { PgPreparedQuery, PgSession } from \"../pg-core/session.js\";\nimport { fillPlaceholders } from \"../sql/sql.js\";\nimport { tracer } from \"../tracing.js\";\nimport { mapResultRow } from \"../utils.js\";\nclass PostgresJsPreparedQuery extends PgPreparedQuery {\n  constructor(client, queryString, params, logger, fields, _isResponseInArrayMode, customResultMapper) {\n    super({ sql: queryString, params });\n    this.client = client;\n    this.queryString = queryString;\n    this.params = params;\n    this.logger = logger;\n    this.fields = fields;\n    this._isResponseInArrayMode = _isResponseInArrayMode;\n    this.customResultMapper = customResultMapper;\n  }\n  static [entityKind] = \"PostgresJsPreparedQuery\";\n  async execute(placeholderValues = {}) {\n    return tracer.startActiveSpan(\"drizzle.execute\", async (span) => {\n      const params = fillPlaceholders(this.params, placeholderValues);\n      span?.setAttributes({\n        \"drizzle.query.text\": this.queryString,\n        \"drizzle.query.params\": JSON.stringify(params)\n      });\n      this.logger.logQuery(this.queryString, params);\n      const { fields, queryString: query, client, joinsNotNullableMap, customResultMapper } = this;\n      if (!fields && !customResultMapper) {\n        return tracer.startActiveSpan(\"drizzle.driver.execute\", () => {\n          return client.unsafe(query, params);\n        });\n      }\n      const rows = await tracer.startActiveSpan(\"drizzle.driver.execute\", () => {\n        span?.setAttributes({\n          \"drizzle.query.text\": query,\n          \"drizzle.query.params\": JSON.stringify(params)\n        });\n        return client.unsafe(query, params).values();\n      });\n      return tracer.startActiveSpan(\"drizzle.mapResponse\", () => {\n        return customResultMapper ? customResultMapper(rows) : rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));\n      });\n    });\n  }\n  all(placeholderValues = {}) {\n    return tracer.startActiveSpan(\"drizzle.execute\", async (span) => {\n      const params = fillPlaceholders(this.params, placeholderValues);\n      span?.setAttributes({\n        \"drizzle.query.text\": this.queryString,\n        \"drizzle.query.params\": JSON.stringify(params)\n      });\n      this.logger.logQuery(this.queryString, params);\n      return tracer.startActiveSpan(\"drizzle.driver.execute\", () => {\n        span?.setAttributes({\n          \"drizzle.query.text\": this.queryString,\n          \"drizzle.query.params\": JSON.stringify(params)\n        });\n        return this.client.unsafe(this.queryString, params);\n      });\n    });\n  }\n  /** @internal */\n  isResponseInArrayMode() {\n    return this._isResponseInArrayMode;\n  }\n}\nclass PostgresJsSession extends PgSession {\n  constructor(client, dialect, schema, options = {}) {\n    super(dialect);\n    this.client = client;\n    this.schema = schema;\n    this.options = options;\n    this.logger = options.logger ?? new NoopLogger();\n  }\n  static [entityKind] = \"PostgresJsSession\";\n  logger;\n  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper) {\n    return new PostgresJsPreparedQuery(\n      this.client,\n      query.sql,\n      query.params,\n      this.logger,\n      fields,\n      isResponseInArrayMode,\n      customResultMapper\n    );\n  }\n  query(query, params) {\n    this.logger.logQuery(query, params);\n    return this.client.unsafe(query, params).values();\n  }\n  queryObjects(query, params) {\n    return this.client.unsafe(query, params);\n  }\n  transaction(transaction, config) {\n    return this.client.begin(async (client) => {\n      const session = new PostgresJsSession(\n        client,\n        this.dialect,\n        this.schema,\n        this.options\n      );\n      const tx = new PostgresJsTransaction(this.dialect, session, this.schema);\n      if (config) {\n        await tx.setTransaction(config);\n      }\n      return transaction(tx);\n    });\n  }\n}\nclass PostgresJsTransaction extends PgTransaction {\n  constructor(dialect, session, schema, nestedIndex = 0) {\n    super(dialect, session, schema, nestedIndex);\n    this.session = session;\n  }\n  static [entityKind] = \"PostgresJsTransaction\";\n  transaction(transaction) {\n    return this.session.client.savepoint((client) => {\n      const session = new PostgresJsSession(\n        client,\n        this.dialect,\n        this.schema,\n        this.session.options\n      );\n      const tx = new PostgresJsTransaction(this.dialect, session, this.schema);\n      return transaction(tx);\n    });\n  }\n}\nexport {\n  PostgresJsPreparedQuery,\n  PostgresJsSession,\n  PostgresJsTransaction\n};\n//# sourceMappingURL=session.js.map","import pgClient from \"postgres\";\nimport { entityKind } from \"../entity.js\";\nimport { DefaultLogger } from \"../logger.js\";\nimport { PgDatabase } from \"../pg-core/db.js\";\nimport { PgDialect } from \"../pg-core/dialect.js\";\nimport {\n  createTableRelationsHelpers,\n  extractTablesRelationalConfig\n} from \"../relations.js\";\nimport { isConfig } from \"../utils.js\";\nimport { PostgresJsSession } from \"./session.js\";\nclass PostgresJsDatabase extends PgDatabase {\n  static [entityKind] = \"PostgresJsDatabase\";\n}\nfunction construct(client, config = {}) {\n  const transparentParser = (val) => val;\n  for (const type of [\"1184\", \"1082\", \"1083\", \"1114\"]) {\n    client.options.parsers[type] = transparentParser;\n    client.options.serializers[type] = transparentParser;\n  }\n  client.options.serializers[\"114\"] = transparentParser;\n  client.options.serializers[\"3802\"] = transparentParser;\n  const dialect = new PgDialect({ casing: config.casing });\n  let logger;\n  if (config.logger === true) {\n    logger = new DefaultLogger();\n  } else if (config.logger !== false) {\n    logger = config.logger;\n  }\n  let schema;\n  if (config.schema) {\n    const tablesConfig = extractTablesRelationalConfig(\n      config.schema,\n      createTableRelationsHelpers\n    );\n    schema = {\n      fullSchema: config.schema,\n      schema: tablesConfig.tables,\n      tableNamesMap: tablesConfig.tableNamesMap\n    };\n  }\n  const session = new PostgresJsSession(client, dialect, schema, { logger });\n  const db = new PostgresJsDatabase(dialect, session, schema);\n  db.$client = client;\n  return db;\n}\nfunction drizzle(...params) {\n  if (typeof params[0] === \"string\") {\n    const instance = pgClient(params[0]);\n    return construct(instance, params[1]);\n  }\n  if (isConfig(params[0])) {\n    const { connection, client, ...drizzleConfig } = params[0];\n    if (client)\n      return construct(client, drizzleConfig);\n    if (typeof connection === \"object\" && connection.url !== void 0) {\n      const { url, ...config } = connection;\n      const instance2 = pgClient(url, config);\n      return construct(instance2, drizzleConfig);\n    }\n    const instance = pgClient(connection);\n    return construct(instance, drizzleConfig);\n  }\n  return construct(params[0], params[1]);\n}\n((drizzle2) => {\n  function mock(config) {\n    return construct({}, config);\n  }\n  drizzle2.mock = mock;\n})(drizzle || (drizzle = {}));\nexport {\n  PostgresJsDatabase,\n  drizzle\n};\n//# sourceMappingURL=driver.js.map"],"names":[],"sourceRoot":""}