{"version":3,"file":"../app/api/embeddings/route.js","mappings":"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","sources":["webpack://@hijraah/web/../../node_modules/.pnpm/@hono+zod-validator@0.4.3_hono@4.8.2_zod@3.25.67/node_modules/@hono/zod-validator/dist/index.js","webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+instrumentat_04f370d515cee0be955272f826166073/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/./src/lib/ai/chunking.ts","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/buffer.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/validator.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/validator/index.js","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/?26cb","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/http-exception.js","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/src/app/api/embeddings/route.ts","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/utils/cookie.js","webpack://@hijraah/web/../../node_modules/.pnpm/hono@4.8.2/node_modules/hono/dist/helper/cookie/index.js","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/external module \"ai\"","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/external commonjs2 \"events\"","webpack://@hijraah/web/../../node_modules/.pnpm/require-in-the-middle@7.5.2/node_modules/require-in-the-middle/ sync"],"sourcesContent":["// src/index.ts\nimport { validator } from \"hono/validator\";\nimport { ZodObject } from \"zod\";\nvar zValidator = (target, schema, hook) => (\n  // @ts-expect-error not typed well\n  validator(target, async (value, c) => {\n    let validatorValue = value;\n    if (target === \"header\" && schema instanceof ZodObject) {\n      const schemaKeys = Object.keys(schema.shape);\n      const caseInsensitiveKeymap = Object.fromEntries(\n        schemaKeys.map((key) => [key.toLowerCase(), key])\n      );\n      validatorValue = Object.fromEntries(\n        Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2])\n      );\n    }\n    const result = await schema.safeParseAsync(validatorValue);\n    if (hook) {\n      const hookResult = await hook({ data: validatorValue, ...result, target }, c);\n      if (hookResult) {\n        if (hookResult instanceof Response) {\n          return hookResult;\n        }\n        if (\"response\" in hookResult) {\n          return hookResult.response;\n        }\n      }\n    }\n    if (!result.success) {\n      return c.json(result, 400);\n    }\n    return result.data;\n  })\n);\nexport {\n  zValidator\n};\n","module.exports = require(\"module\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 8963;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","/**\r\n * Text Chunking Utilities\r\n */\r\n\r\ninterface ChunkOptions {\r\n  chunkSize?: number;\r\n  chunkOverlap?: number;\r\n  separators?: string[];\r\n}\r\n\r\nconst defaultSeparators = [\"\\n\\n\", \"\\n\", \". \", \"? \", \"! \", \" \", \"\"];\r\nconst defaultChunkSize = 1000; // Target size in characters\r\nconst defaultChunkOverlap = 100; // Overlap in characters\r\n\r\n/**\r\n * Splits text recursively based on separators to achieve a target chunk size with overlap.\r\n *\r\n * @param text The input text to split.\r\n * @param options Optional configuration for chunk size, overlap, and separators.\r\n * @returns An array of text chunks.\r\n */\r\nexport function recursiveCharacterTextSplitter(\r\n  text: string,\r\n  options?: ChunkOptions\r\n): string[] {\r\n  const chunkSize = options?.chunkSize ?? defaultChunkSize;\r\n  const chunkOverlap = options?.chunkOverlap ?? defaultChunkOverlap;\r\n  const separators = options?.separators ?? defaultSeparators;\r\n\r\n  if (chunkSize <= chunkOverlap) {\r\n    throw new Error(\"Chunk size must be greater than chunk overlap.\");\r\n  }\r\n\r\n  const finalChunks: string[] = [];\r\n\r\n  // Start splitting with the first separator\r\n  let currentSeparatorIndex = 0;\r\n  let currentSeparator = separators[currentSeparatorIndex];\r\n  let splits = text.split(currentSeparator);\r\n\r\n  // Find the best separator that creates chunks smaller than chunkSize\r\n  // or keep splitting if chunks are too large\r\n  while (true) {\r\n    let chunksTooLarge = false;\r\n    for (const split of splits) {\r\n      if (split.length > chunkSize) {\r\n        chunksTooLarge = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If chunks are small enough with the current separator, break\r\n    if (!chunksTooLarge) {\r\n      break;\r\n    }\r\n\r\n    // Move to the next separator\r\n    currentSeparatorIndex++;\r\n    if (currentSeparatorIndex >= separators.length) {\r\n      // If no more separators, force split by chunkSize (last resort)\r\n      currentSeparator = \"\";\r\n      break;\r\n    }\r\n    currentSeparator = separators[currentSeparatorIndex];\r\n\r\n    // Re-split the text with the new separator\r\n    splits = text.split(currentSeparator);\r\n  }\r\n\r\n  // Merge smaller chunks and handle overlap\r\n  let currentChunk = \"\";\r\n  for (let i = 0; i < splits.length; i++) {\r\n    const split = splits[i];\r\n    const separatorToAdd = i < splits.length - 1 ? currentSeparator : \"\";\r\n\r\n    // If adding the next split (plus separator) exceeds chunk size\r\n    if (\r\n      currentChunk.length + split.length + separatorToAdd.length >\r\n      chunkSize\r\n    ) {\r\n      // Add the current chunk if it's not empty\r\n      if (currentChunk.length > 0) {\r\n        finalChunks.push(currentChunk.trim());\r\n      }\r\n\r\n      // Start the next chunk with overlap\r\n      // Find where the previous chunk should ideally start to maintain overlap\r\n      const overlapStartIndex = Math.max(0, currentChunk.length - chunkOverlap);\r\n      const overlapText = currentChunk.substring(overlapStartIndex);\r\n\r\n      // Start new chunk with overlap and the current split\r\n      currentChunk = (overlapText + split + separatorToAdd).trim();\r\n    } else {\r\n      // Add the split and separator to the current chunk\r\n      currentChunk += split + separatorToAdd;\r\n    }\r\n  }\r\n\r\n  // Add the last remaining chunk\r\n  if (currentChunk.length > 0) {\r\n    finalChunks.push(currentChunk.trim());\r\n  }\r\n\r\n  // Optional: Filter out potentially empty chunks again after trimming/overlap logic\r\n  return finalChunks.filter((chunk) => chunk.length > 0);\r\n}\r\n","module.exports = require(\"process\");","module.exports = require(\"os\");","// src/utils/buffer.ts\nimport { sha256 } from \"./crypto.js\";\nvar equal = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const va = new DataView(a);\n  const vb = new DataView(b);\n  let i = va.byteLength;\n  while (i--) {\n    if (va.getUint8(i) !== vb.getUint8(i)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar timingSafeEqual = async (a, b, hashFunction) => {\n  if (!hashFunction) {\n    hashFunction = sha256;\n  }\n  const [sa, sb] = await Promise.all([hashFunction(a), hashFunction(b)]);\n  if (!sa || !sb) {\n    return false;\n  }\n  return sa === sb && a === b;\n};\nvar bufferToString = (buffer) => {\n  if (buffer instanceof ArrayBuffer) {\n    const enc = new TextDecoder(\"utf-8\");\n    return enc.decode(buffer);\n  }\n  return buffer;\n};\nvar bufferToFormData = (arrayBuffer, contentType) => {\n  const response = new Response(arrayBuffer, {\n    headers: {\n      \"Content-Type\": contentType\n    }\n  });\n  return response.formData();\n};\nexport {\n  bufferToFormData,\n  bufferToString,\n  equal,\n  timingSafeEqual\n};\n","// src/validator/validator.ts\nimport { getCookie } from \"../helper/cookie/index.js\";\nimport { HTTPException } from \"../http-exception.js\";\nimport { bufferToFormData } from \"../utils/buffer.js\";\nvar jsonRegex = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar multipartRegex = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9'\"()+_,\\-./:=?]+)?$/;\nvar urlencodedRegex = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar validator = (target, validationFunc) => {\n  return async (c, next) => {\n    let value = {};\n    const contentType = c.req.header(\"Content-Type\");\n    switch (target) {\n      case \"json\":\n        if (!contentType || !jsonRegex.test(contentType)) {\n          break;\n        }\n        try {\n          value = await c.req.json();\n        } catch {\n          const message = \"Malformed JSON in request body\";\n          throw new HTTPException(400, { message });\n        }\n        break;\n      case \"form\": {\n        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {\n          break;\n        }\n        let formData;\n        if (c.req.bodyCache.formData) {\n          formData = await c.req.bodyCache.formData;\n        } else {\n          try {\n            const arrayBuffer = await c.req.arrayBuffer();\n            formData = await bufferToFormData(arrayBuffer, contentType);\n            c.req.bodyCache.formData = formData;\n          } catch (e) {\n            let message = \"Malformed FormData request.\";\n            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;\n            throw new HTTPException(400, { message });\n          }\n        }\n        const form = {};\n        formData.forEach((value2, key) => {\n          if (key.endsWith(\"[]\")) {\n            ;\n            (form[key] ??= []).push(value2);\n          } else if (Array.isArray(form[key])) {\n            ;\n            form[key].push(value2);\n          } else if (key in form) {\n            form[key] = [form[key], value2];\n          } else {\n            form[key] = value2;\n          }\n        });\n        value = form;\n        break;\n      }\n      case \"query\":\n        value = Object.fromEntries(\n          Object.entries(c.req.queries()).map(([k, v]) => {\n            return v.length === 1 ? [k, v[0]] : [k, v];\n          })\n        );\n        break;\n      case \"param\":\n        value = c.req.param();\n        break;\n      case \"header\":\n        value = c.req.header();\n        break;\n      case \"cookie\":\n        value = getCookie(c);\n        break;\n    }\n    const res = await validationFunc(value, c);\n    if (res instanceof Response) {\n      return res;\n    }\n    c.req.addValidatedData(target, res);\n    await next();\n  };\n};\nexport {\n  validator\n};\n","// src/validator/index.ts\nimport { validator } from \"./validator.js\";\nexport {\n  validator\n};\n","module.exports = require(\"util\");","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");","module.exports = require(\"path\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:zlib\");","module.exports = require(\"node:tls\");","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","module.exports = require(\"node:os\");","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\embeddings\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/embeddings/route\",\n        pathname: \"/api/embeddings\",\n        filename: \"route\",\n        bundlePath: \"app/api/embeddings/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\embeddings\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","module.exports = require(\"node:diagnostics_channel\");","// src/http-exception.ts\nvar HTTPException = class extends Error {\n  res;\n  status;\n  constructor(status = 500, options) {\n    super(options?.message, { cause: options?.cause });\n    this.res = options?.res;\n    this.status = status;\n  }\n  getResponse() {\n    if (this.res) {\n      const newResponse = new Response(this.res.body, {\n        status: this.status,\n        headers: this.res.headers\n      });\n      return newResponse;\n    }\n    return new Response(this.message, {\n      status: this.status\n    });\n  }\n};\nexport {\n  HTTPException\n};\n","module.exports = require(\"crypto\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","import { mistral } from \"@ai-sdk/mistral\";\r\nimport { zValidator } from \"@hono/zod-validator\";\r\nimport { embed, embedMany } from \"ai\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { handle } from \"hono/vercel\";\r\nimport { z } from \"zod\";\r\n\r\nimport { recursiveCharacterTextSplitter } from \"@/lib/ai/chunking\"; // Ensure this utility exists and is compatible\r\n\r\n// Ensure these environment variables are set\r\nconst internalApiKey = process.env.API_SECRET_KEY;\r\nconst mistralApiKey = process.env.MISTRAL_API_KEY;\r\n\r\nif (!internalApiKey || !mistralApiKey) {\r\n  console.error(\"Missing required environment variables for Embedding API\");\r\n  // Potentially throw an error or prevent startup in a real application\r\n}\r\n\r\n// --- Hono App Setup --- //\r\nconst app = new Hono().basePath(\"/api/embeddings\");\r\n\r\n// --- Middleware --- //\r\napp.use(\"*\", cors());\r\n\r\n// Authentication Middleware\r\napp.use(\"*\", async (c, next) => {\r\n  const authHeader = c.req.header(\"Authorization\");\r\n  if (authHeader !== `Bearer ${internalApiKey}` || !internalApiKey) {\r\n    console.warn(\"Unauthorized attempt to access internal Embedding API\");\r\n    return c.json({ error: \"Unauthorized\" }, 401);\r\n  }\r\n  await next();\r\n});\r\n\r\n// ---------------- Deprecation Gate (DP-3) ----------------\r\nconst legacyApisEnabled =\r\n  process.env.LEGACY_DOC_APIS === undefined ||\r\n  process.env.LEGACY_DOC_APIS.toLowerCase() === \"true\";\r\n\r\napp.use(\"*\", async (c, next) => {\r\n  if (!legacyApisEnabled) {\r\n    c.header(\"X-Deprecation\", \"This endpoint is deprecated and disabled\");\r\n    c.header(\"Access-Control-Expose-Headers\", \"X-Deprecation\");\r\n    return c.json({ error: \"Endpoint deprecated\" }, 410 as any);\r\n  }\r\n  c.header(\r\n    \"X-Deprecation\",\r\n    \"This endpoint is deprecated; migrate to DocumentProcessor inline embedding generation\"\r\n  );\r\n  c.header(\"Access-Control-Expose-Headers\", \"X-Deprecation\");\r\n  await next();\r\n});\r\n\r\n// --- Schemas --- //\r\nconst EmbeddingRequestSchema = z.object({\r\n  text: z.string().min(1, \"Text cannot be empty\"),\r\n  documentId: z.string().uuid().optional(), // Optional, for logging/context\r\n  isQuery: z.boolean().optional().default(false), // Differentiate query vs document\r\n});\r\n\r\n// --- Embedding Model --- //\r\n// Check for API key presence during model initialization might be redundant\r\n// if the SDK handles it, but kept for clarity.\r\nconst embeddingModel = mistralApiKey\r\n  ? mistral.embedding(\"mistral-embed\")\r\n  : null;\r\n\r\n// --- Route --- //\r\napp.post(\"/\", zValidator(\"json\", EmbeddingRequestSchema), async (c) => {\r\n  if (!embeddingModel) {\r\n    console.error(\"Embedding model not initialized due to missing API key.\");\r\n    return c.json({ error: \"Embedding service not configured\" }, 503);\r\n  }\r\n\r\n  const { documentId, text, isQuery } = c.req.valid(\"json\");\r\n\r\n  try {\r\n    if (isQuery) {\r\n      // --- Handle Single Query Embedding ---\r\n      console.log(`[Embed API] Generating embedding for query`);\r\n      const { embedding, usage } = await embed({\r\n        model: embeddingModel,\r\n        value: text,\r\n      });\r\n      console.log(`[Embed API] Query embedding generated. Usage:`, usage);\r\n      return c.json({ embedding });\r\n    } else {\r\n      // --- Handle Document Chunk Embedding ---\r\n      console.log(\r\n        `[Embed API] Generating embeddings for documentId: ${documentId ?? \"N/A\"}`\r\n      );\r\n\r\n      // Chunk the text\r\n      const textChunks = recursiveCharacterTextSplitter(text, {\r\n        // Adjust chunkSize/chunkOverlap if needed\r\n        // chunkSize: 1000,\r\n        // chunkOverlap: 100,\r\n      });\r\n      console.log(`[Embed API] Text chunked into ${textChunks.length} pieces.`);\r\n\r\n      if (textChunks.length === 0) {\r\n        console.warn(\r\n          `[Embed API] No text chunks generated for documentId: ${documentId ?? \"N/A\"}.`\r\n        );\r\n        return c.json({ chunks: [] }); // Return empty if no chunks\r\n      }\r\n\r\n      // Generate embeddings for all chunks\r\n      const { embeddings, usage } = await embedMany({\r\n        model: embeddingModel,\r\n        values: textChunks,\r\n      });\r\n      console.log(\r\n        `[Embed API] Batch embedding generated ${embeddings.length} vectors. Usage:`,\r\n        usage\r\n      );\r\n\r\n      // Combine chunks with their embeddings\r\n      const chunksWithEmbeddings = textChunks.map(\r\n        (chunkText: string, index: number) => ({\r\n          index: index,\r\n          text: chunkText,\r\n          embedding: embeddings[index], // Assumes order matches\r\n        })\r\n      );\r\n\r\n      return c.json({ chunks: chunksWithEmbeddings });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"[Embed API] Error:\", error);\r\n    let errorMessage = \"Internal server error processing embedding request\";\r\n    let statusCode = 500;\r\n    if (error instanceof Error) {\r\n      errorMessage = error.message;\r\n      // Potentially check for specific AI SDK or API errors for better status codes\r\n    }\r\n    return c.json({ error: errorMessage }, statusCode as any);\r\n  }\r\n});\r\n\r\n// --- Export Hono App --- //\r\nexport const POST = handle(app);\r\n// Removed GET handler logic (moved responsibility elsewhere)\r\n\r\n// Optional: Specify runtime (Node.js likely needed for chunking library)\r\nexport const runtime = \"nodejs\";\r\n","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/embeddings',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","// src/utils/cookie.ts\nimport { decodeURIComponent_ } from \"./url.js\";\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  if (name && cookie.indexOf(name) === -1) {\n    return {};\n  }\n  const pairs = cookie.trim().split(\";\");\n  const parsedCookie = {};\n  for (let pairStr of pairs) {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      continue;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      continue;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);\n      if (name) {\n        break;\n      }\n    }\n  }\n  return parsedCookie;\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    throw new Error(\"__Secure- Cookie must have Secure attributes\");\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      throw new Error(\"__Host- Cookie must have Secure attributes\");\n    }\n    if (opt.path !== \"/\") {\n      throw new Error('__Host- Cookie must have Path attributes with \"/\"');\n    }\n    if (opt.domain) {\n      throw new Error(\"__Host- Cookie must not have Domain attributes\");\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${opt.maxAge | 0}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.priority) {\n    cookie += `; Priority=${opt.priority}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nexport {\n  parse,\n  parseSigned,\n  serialize,\n  serializeSigned\n};\n","// src/helper/cookie/index.ts\nimport { parse, parseSigned, serialize, serializeSigned } from \"../../utils/cookie.js\";\nvar getCookie = (c, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = parse(cookie, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = parse(cookie);\n  return obj;\n};\nvar getSignedCookie = async (c, secret, key, prefix) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie) {\n      return void 0;\n    }\n    let finalKey = key;\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n    const obj2 = await parseSigned(cookie, secret, finalKey);\n    return obj2[finalKey];\n  }\n  if (!cookie) {\n    return {};\n  }\n  const obj = await parseSigned(cookie, secret);\n  return obj;\n};\nvar setCookie = (c, name, value, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  c.header(\"Set-Cookie\", cookie, { append: true });\n};\nvar setSignedCookie = async (c, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  c.header(\"set-cookie\", cookie, { append: true });\n};\nvar deleteCookie = (c, name, opt) => {\n  const deletedCookie = getCookie(c, name, opt?.prefix);\n  setCookie(c, name, \"\", { ...opt, maxAge: 0 });\n  return deletedCookie;\n};\nexport {\n  deleteCookie,\n  getCookie,\n  getSignedCookie,\n  setCookie,\n  setSignedCookie\n};\n","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","module.exports = import(\"ai\");;","module.exports = require(\"node:inspector\");","module.exports = require(\"events\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 96708;\nmodule.exports = webpackEmptyContext;"],"names":["defaultSeparators","recursiveCharacterTextSplitter","text","options","chunkSize","defaultChunkSize","chunkOverlap","defaultChunkOverlap","separators","finalChunks","currentSeparatorIndex","currentSeparator","splits","split","chunksTooLarge","length","currentChunk","i","separatorToAdd","push","trim","overlapStartIndex","Math","max","overlapText","substring","filter","chunk","internalApiKey","process","env","API_SECRET_KEY","mistralApiKey","MISTRAL_API_KEY","console","error","app","Hono","basePath","use","cors","c","next","req","header","warn","json","legacyApisEnabled","LEGACY_DOC_APIS","toLowerCase","EmbeddingRequestSchema","z","min","documentId","uuid","optional","isQuery","default","embeddingModel","mistral","embedding","post","zValidator","valid","usage","embed","model","value","textChunks","chunks","embeddings","embedMany","values","chunksWithEmbeddings","map","chunkText","index","errorMessage","Error","message","statusCode","handle","runtime","serverComponentModule.GET","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS"],"sourceRoot":""}