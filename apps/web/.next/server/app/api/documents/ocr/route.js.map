{"version":3,"file":"../app/api/documents/ocr/route.js","mappings":"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","sources":["webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/../../node_modules/.pnpm/@opentelemetry+instrumentat_04f370d515cee0be955272f826166073/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/external commonjs2 \"punycode\"","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/./src/lib/ai/ocr.ts","webpack://@hijraah/web/external commonjs2 \"stream\"","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"tls\"","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external commonjs2 \"https\"","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/ignored|E:\\downloads\\Hijraah\\node_modules\\.pnpm\\ws@8.18.2_bufferutil@4.0.9\\node_modules\\ws\\lib|utf-8-validate","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/external commonjs2 \"zlib\"","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external commonjs2 \"buffer\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/external commonjs2 \"http\"","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/external module \"ai\"","webpack://@hijraah/web/src/app/api/documents/ocr/route.ts","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/?dee0","webpack://@hijraah/web/external commonjs2 \"net\"","webpack://@hijraah/web/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/server/route-modules/app-route/module.compiled.js","webpack://@hijraah/web/external commonjs2 \"events\"","webpack://@hijraah/web/../../node_modules/.pnpm/require-in-the-middle@7.5.2/node_modules/require-in-the-middle/ sync","webpack://@hijraah/web/../../node_modules/.pnpm/@supabase+realtime-js@2.11.10_bufferutil@4.0.9/node_modules/@supabase/realtime-js/dist/main/ sync"],"sourcesContent":["module.exports = require(\"module\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 8963;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","module.exports = require(\"punycode\");","module.exports = require(\"process\");","module.exports = require(\"os\");","import { generateText } from \"ai\";\r\nimport { mistral } from \"@ai-sdk/mistral\";\r\n\r\n/**\r\n * Runs OCR on an image/pdf buffer using the Mistral large model via Vercel AI SDK\r\n * and returns extracted plain text.\r\n *\r\n * NOTE: Mistral currently supports images and PDFs up to ~5 MB. Callers should\r\n * split larger documents up-front (e.g., per page) before invoking.\r\n *\r\n * @param fileBuffer – Raw file data\r\n * @param mimeType – Optional MIME type hint (e.g. \"application/pdf\")\r\n */\r\nexport async function runMistralOCR(\r\n  fileBuffer: Buffer,\r\n  mimeType?: string\r\n): Promise<string> {\r\n  // Initialise on demand – env var MISTRAL_API_KEY must be set\r\n  const mistralLlm = mistral(\"mistral-large-latest\");\r\n\r\n  const { text: extractedText, finishReason } = await generateText({\r\n    model: mistralLlm,\r\n    messages: [\r\n      {\r\n        role: \"user\",\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: \"Extract all text content from the following document accurately. Respond only with the extracted text.\",\r\n          },\r\n          {\r\n            type: \"image\",\r\n            image: fileBuffer,\r\n            mimeType: mimeType ?? undefined,\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n    // Low temperature for deterministic OCR-style output\r\n    temperature: 0,\r\n  });\r\n\r\n  if (finishReason !== \"stop\" && finishReason !== \"length\") {\r\n    console.warn(\"[OCR] Mistral finished with reason:\", finishReason);\r\n  }\r\n\r\n  return extractedText;\r\n}\r\n","module.exports = require(\"stream\");","module.exports = require(\"util\");","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");","module.exports = require(\"path\");","module.exports = require(\"tls\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:zlib\");","module.exports = require(\"node:tls\");","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","module.exports = require(\"node:os\");","module.exports = require(\"node:diagnostics_channel\");","module.exports = require(\"crypto\");","module.exports = require(\"https\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","/* (ignored) */","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"buffer\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","module.exports = require(\"http\");","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","module.exports = import(\"ai\");;","import { mistral } from \"@ai-sdk/mistral\"; // Import Mistral provider\r\nimport { createClient } from \"@supabase/supabase-js\";\r\nimport { generateText } from \"ai\"; // Import Vercel AI SDK core function\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { handle } from \"hono/vercel\";\r\n// Remove direct Mistral client import\r\n// import { Mistral } from '@mistralai/mistralai'\r\nimport { z } from \"zod\";\r\nimport { runMistralOCR } from \"@/lib/ai/ocr\";\r\n\r\n// Define custom interfaces for Mistral OCR API responses - This might not be needed if using generateText simplifies response\r\n// interface MistralOCRResponse { ... } // Keep for now if rawResponse metadata is used\r\n\r\n// Initialize Supabase clients\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || \"\";\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || \"\";\r\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\r\n// Use admin client for accessing potentially restricted buckets like 'documents'\r\nconst supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);\r\n\r\n// Internal API Key for protected access\r\nconst internalApiKey = process.env.API_SECRET_KEY;\r\n\r\n// Create a Hono app\r\nconst app = new Hono();\r\n\r\n// Add CORS middleware\r\napp.use(\"*\", cors());\r\n\r\n// Define schema for the OCR request body - Add filePath and documentId\r\nconst ocrRequestSchema = z.object({\r\n  fileId: z.string(), // Used as primary ID for caching/linking\r\n  chatId: z.string().optional(), // Optional, might not be present for all OCR requests\r\n  userId: z.string().optional(),\r\n  fileName: z.string(),\r\n  fileType: z.string(),\r\n  fileUrl: z.string().url().optional(),\r\n  fileContent: z.string().optional(), // Base64 encoded content\r\n  filePath: z.string().min(1).optional(), // Path within Supabase storage (e.g., 'documents' bucket)\r\n  documentId: z.string().uuid().optional(), // Optional alternative ID if needed downstream\r\n});\r\n\r\n// Define schema for OCR result (consider if Vercel SDK response structure allows simplification)\r\nconst ocrResultSchema = z.object({\r\n  text: z.string(),\r\n  metadata: z\r\n    .object({\r\n      pageCount: z.number().optional(),\r\n      language: z.string().optional(),\r\n      confidence: z.number().optional(),\r\n      processTime: z.number().optional(),\r\n      rawResponse: z.any().optional(), // Keep if detailed response needed\r\n    })\r\n    .optional(),\r\n});\r\n\r\n// Process a document with OCR using Vercel AI SDK + Mistral\r\napp.post(\"/\", async (c) => {\r\n  // Changed route to root '/' relative to /documents/ocr\r\n  try {\r\n    // Check for internal API call authorization first\r\n    const authHeader = c.req.header(\"Authorization\");\r\n    const isInternalCall =\r\n      internalApiKey && authHeader === `Bearer ${internalApiKey}`;\r\n\r\n    if (!isInternalCall) {\r\n      // Add checks for external user authentication if needed (e.g., JWT, session)\r\n      // For now, assume external calls are allowed if not explicitly internal\r\n      console.log(\"[OCR API] Processing external request.\");\r\n    } else {\r\n      console.log(\"[OCR API] Processing internal request.\");\r\n    }\r\n\r\n    // Parse and validate request body\r\n    const body = await c.req.json();\r\n    const validation = ocrRequestSchema.safeParse(body);\r\n\r\n    if (!validation.success) {\r\n      return c.json(\r\n        { error: \"Invalid input\", details: validation.error.errors },\r\n        400\r\n      );\r\n    }\r\n    const validatedData = validation.data;\r\n    const fileId = validatedData.fileId; // Use fileId consistently\r\n\r\n    console.log(`[OCR API] Request received for fileId: ${fileId}`);\r\n\r\n    // Check if result is already cached in Supabase\r\n    // Ensure chatId is present for caching key if it's required context\r\n    const { data: cachedResult, error: cacheError } = await supabase\r\n      .from(\"document_ocr_results\")\r\n      .select(\"result\")\r\n      .eq(\"file_id\", fileId)\r\n      // Add .eq('chat_id', validatedData.chatId) if chatId is part of the unique key\r\n      .maybeSingle();\r\n\r\n    if (cacheError) {\r\n      console.error(\r\n        `[OCR API] Error checking cache for fileId ${fileId}:`,\r\n        cacheError\r\n      );\r\n      // Decide if this should be fatal or just log and continue\r\n    }\r\n\r\n    if (cachedResult) {\r\n      console.log(`[OCR API] Cache hit for fileId: ${fileId}`);\r\n      return c.json(cachedResult.result);\r\n    }\r\n    console.log(`[OCR API] Cache miss for fileId: ${fileId}. Processing...`);\r\n\r\n    let fileBuffer: Buffer | null = null;\r\n    let fileSourceDescription = \"\";\r\n\r\n    // --- File Fetching Logic ---\r\n    if (validatedData.fileContent) {\r\n      console.log(\r\n        `[OCR API] Using provided base64 content for fileId: ${fileId}`\r\n      );\r\n      fileBuffer = Buffer.from(validatedData.fileContent, \"base64\");\r\n      fileSourceDescription = \"provided base64 content\";\r\n    } else if (validatedData.fileUrl) {\r\n      console.log(`[OCR API] Fetching from URL for fileId: ${fileId}`);\r\n      fileSourceDescription = `URL: ${validatedData.fileUrl}`;\r\n      try {\r\n        const response = await fetch(validatedData.fileUrl);\r\n        if (!response.ok)\r\n          throw new Error(`Failed to fetch from URL: ${response.statusText}`);\r\n        const arrayBuffer = await response.arrayBuffer();\r\n        fileBuffer = Buffer.from(arrayBuffer);\r\n      } catch (fetchError) {\r\n        console.error(\r\n          `[OCR API] Error fetching file from URL ${validatedData.fileUrl} for fileId ${fileId}:`,\r\n          fetchError\r\n        );\r\n        return c.json(\r\n          {\r\n            error: `Failed to fetch file from provided URL: ${(fetchError as Error).message}`,\r\n          },\r\n          500\r\n        );\r\n      }\r\n    } else if (validatedData.filePath) {\r\n      console.log(\r\n        `[OCR API] Fetching from storage path: ${validatedData.filePath} for fileId: ${fileId}`\r\n      );\r\n      fileSourceDescription = `storage path: ${validatedData.filePath}`;\r\n      // Determine bucket based on call type or context if needed\r\n      // Assuming 'documents' bucket for filePath, 'chat-attachments' for chatId based path\r\n      const bucket = validatedData.chatId ? \"chat-attachments\" : \"documents\";\r\n      const path = validatedData.chatId\r\n        ? `${validatedData.chatId}/${fileId}`\r\n        : validatedData.filePath;\r\n\r\n      console.log(\r\n        `[OCR API] Attempting download from bucket '${bucket}', path '${path}'`\r\n      );\r\n\r\n      // Use supabaseAdmin if accessing restricted buckets like 'documents'\r\n      const client = bucket === \"documents\" ? supabaseAdmin : supabase;\r\n      const { data: fileData, error: downloadError } = await client.storage\r\n        .from(bucket)\r\n        .download(path);\r\n\r\n      if (downloadError) {\r\n        console.error(\r\n          `[OCR API] Error downloading file ${path} from bucket ${bucket} for fileId ${fileId}:`,\r\n          downloadError\r\n        );\r\n        return c.json(\r\n          {\r\n            error: `Failed to download document from storage (${bucket}): ${downloadError.message}`,\r\n          },\r\n          500\r\n        );\r\n      }\r\n      if (!fileData) {\r\n        console.error(\r\n          `[OCR API] No file data found for path ${path} in bucket ${bucket}, fileId ${fileId}.`\r\n        );\r\n        return c.json({ error: \"Document not found in storage\" }, 404);\r\n      }\r\n      fileBuffer = Buffer.from(await fileData.arrayBuffer());\r\n      console.log(\r\n        `[OCR API] Successfully downloaded ${path} from bucket ${bucket}`\r\n      );\r\n    } else {\r\n      console.error(\r\n        `[OCR API] No file content, URL, or path provided for fileId: ${fileId}`\r\n      );\r\n      return c.json({ error: \"No file content, URL, or path provided\" }, 400);\r\n    }\r\n\r\n    if (!fileBuffer) {\r\n      console.error(\r\n        `[OCR API] Failed to obtain file buffer for fileId: ${fileId} from ${fileSourceDescription}`\r\n      );\r\n      return c.json({ error: \"Failed to obtain file buffer\" }, 500);\r\n    }\r\n    console.log(\r\n      `[OCR API] File buffer obtained (size: ${fileBuffer.length} bytes) for fileId: ${fileId}`\r\n    );\r\n\r\n    // --- Call shared OCR util ---\r\n    try {\r\n      console.log(`[OCR API] Running runMistralOCR util for fileId: ${fileId}`);\r\n      const startTime = Date.now();\r\n      const extractedText = await runMistralOCR(\r\n        fileBuffer,\r\n        validatedData.fileType\r\n      );\r\n      const processTime = Date.now() - startTime;\r\n      console.log(\r\n        `[OCR API] OCR completed for fileId: ${fileId} in ${processTime}ms.`\r\n      );\r\n\r\n      // Build result compatible with previous schema\r\n      const ocrResult = {\r\n        text: extractedText,\r\n        metadata: {\r\n          language: undefined,\r\n          confidence: undefined,\r\n          processTime,\r\n        },\r\n      } satisfies z.infer<typeof ocrResultSchema>;\r\n\r\n      // Cache the result in Supabase\r\n      console.log(`[OCR API] Caching OCR result for fileId: ${fileId}`);\r\n      const { error: upsertError } = await supabase\r\n        .from(\"document_ocr_results\")\r\n        .upsert(\r\n          {\r\n            file_id: fileId,\r\n            chat_id: validatedData.chatId, // Ensure chatId is included if part of the primary key\r\n            user_id: validatedData.userId,\r\n            file_name: validatedData.fileName,\r\n            file_type: validatedData.fileType,\r\n            result: ocrResult, // Cache the standardized result\r\n            created_at: new Date().toISOString(),\r\n          },\r\n          { onConflict: \"file_id\" }\r\n        ); // Specify conflict resolution if needed\r\n\r\n      if (upsertError) {\r\n        console.error(\r\n          `[OCR API] Error caching OCR result for fileId ${fileId}:`,\r\n          upsertError\r\n        );\r\n        // Decide if this should be fatal or just logged\r\n      } else {\r\n        console.log(\r\n          `[OCR API] Successfully cached OCR result for fileId: ${fileId}`\r\n        );\r\n      }\r\n\r\n      return c.json(ocrResult);\r\n    } catch (aiError) {\r\n      console.error(\r\n        `[OCR API] Vercel AI SDK/Mistral error for fileId ${fileId}:`,\r\n        aiError\r\n      );\r\n      return c.json(\r\n        {\r\n          error:\r\n            aiError instanceof Error\r\n              ? aiError.message\r\n              : \"Failed to process document with AI OCR\",\r\n        },\r\n        500 // Use 500 for AI backend errors\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error(\"[OCR API] General error:\", error);\r\n    // Distinguish Zod errors for 400 response\r\n    if (error instanceof z.ZodError) {\r\n      return c.json(\r\n        { error: \"Invalid request body format\", details: error.errors },\r\n        400\r\n      );\r\n    }\r\n    return c.json(\r\n      {\r\n        error: error instanceof Error ? error.message : \"Internal server error\",\r\n      },\r\n      500\r\n    );\r\n  }\r\n});\r\n\r\n// Answer a question about a document using Mistral AI (Leveraging cached OCR)\r\n// Keep this route as it provides distinct Q&A functionality\r\napp.post(\"/question\", async (c) => {\r\n  try {\r\n    const body = await c.req.json();\r\n    // Add validation for this request body\r\n    const { fileId, question, chatId, userId } = body;\r\n\r\n    if (!fileId || !question) {\r\n      return c.json({ error: \"Missing fileId or question\" }, 400);\r\n    }\r\n\r\n    console.log(`[OCR Q&A] Request received for fileId: ${fileId}`);\r\n\r\n    // Fetch OCR result from Supabase\r\n    const { data: ocrData, error: ocrError } = await supabase\r\n      .from(\"document_ocr_results\")\r\n      .select(\"result\")\r\n      .eq(\"file_id\", fileId)\r\n      // Add .eq('chat_id', chatId) if needed\r\n      .maybeSingle(); // Use maybeSingle to handle null gracefully\r\n\r\n    if (ocrError || !ocrData || !ocrData.result?.text) {\r\n      console.error(\r\n        `[OCR Q&A] Error fetching cached OCR result for fileId ${fileId}:`,\r\n        ocrError || \"Not Found\"\r\n      );\r\n      return c.json(\r\n        { error: \"Failed to fetch or parse OCR result for Q&A\" },\r\n        404\r\n      ); // 404 if not found/processed\r\n    }\r\n    console.log(`[OCR Q&A] Found cached OCR text for fileId: ${fileId}`);\r\n\r\n    // Generate an answer using Mistral AI SDK via generateText\r\n    try {\r\n      console.log(\r\n        `[OCR Q&A] Sending Q&A request to Mistral via Vercel AI SDK for fileId: ${fileId}`\r\n      );\r\n      const startTime = Date.now();\r\n      const {\r\n        text: answer,\r\n        usage,\r\n        finishReason,\r\n      } = await generateText({\r\n        model: mistral(\"mistral-large-latest\"), // Can use the same model instance\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content:\r\n              \"You are a helpful document analysis assistant. Answer questions based *only* on the provided document content accurately and concisely. If the answer is not in the text, say so.\",\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: `Document content:\r\n\r\n${ocrData.result.text}\r\n\r\n---\r\n\r\nQuestion: ${question}`,\r\n          },\r\n        ],\r\n        // maxTokens: 1024 // Adjust if needed\r\n      });\r\n      const processTime = Date.now() - startTime;\r\n      console.log(\r\n        `[OCR Q&A] Received answer from Mistral via Vercel AI SDK for fileId: ${fileId}. Time: ${processTime}ms. Reason: ${finishReason}. Usage: ${JSON.stringify(usage)}`\r\n      );\r\n\r\n      const finalAnswer =\r\n        answer || \"Unable to answer this question based on the provided text.\";\r\n\r\n      // Store the Q&A history in Supabase\r\n      const { error: historyError } = await supabase\r\n        .from(\"document_qa_history\")\r\n        .insert({\r\n          file_id: fileId,\r\n          chat_id: chatId,\r\n          user_id: userId,\r\n          question,\r\n          answer: finalAnswer,\r\n          created_at: new Date().toISOString(),\r\n        });\r\n\r\n      if (historyError) {\r\n        console.error(\r\n          `[OCR Q&A] Error saving Q&A history for fileId ${fileId}:`,\r\n          historyError\r\n        );\r\n        // Log error but likely still return the answer\r\n      }\r\n\r\n      return c.json({ answer: finalAnswer });\r\n    } catch (mistralError) {\r\n      console.error(\r\n        `[OCR Q&A] Vercel AI SDK/Mistral chat error for fileId ${fileId}:`,\r\n        mistralError\r\n      );\r\n      return c.json(\r\n        {\r\n          error:\r\n            (mistralError as Error).message ||\r\n            \"Failed to process question with Mistral AI\",\r\n        },\r\n        500 // Use 500 for AI backend errors\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error(\"[OCR Q&A] General error:\", error);\r\n    return c.json(\r\n      {\r\n        error:\r\n          error instanceof Error\r\n            ? error.message\r\n            : \"Internal server error in Q&A\",\r\n      },\r\n      500\r\n    );\r\n  }\r\n});\r\n\r\n// Get document question history (Keep as is)\r\napp.get(\"/:fileId/history\", async (c) => {\r\n  try {\r\n    const fileId = c.req.param(\"fileId\");\r\n    // Add validation for fileId if needed\r\n\r\n    console.log(`[OCR History] Request received for fileId: ${fileId}`);\r\n\r\n    // Fetch question history from Supabase\r\n    const { data, error } = await supabase\r\n      .from(\"document_qa_history\")\r\n      .select(\"question, answer, created_at\")\r\n      .eq(\"file_id\", fileId)\r\n      .order(\"created_at\", { ascending: false }); // Example ordering\r\n\r\n    if (error) {\r\n      console.error(\r\n        `[OCR History] Error fetching history for fileId ${fileId}:`,\r\n        error\r\n      );\r\n      return c.json({ error: \"Failed to fetch question history\" }, 500);\r\n    }\r\n\r\n    return c.json(data || []);\r\n  } catch (error) {\r\n    console.error(\"[OCR History] General error:\", error);\r\n    return c.json(\r\n      {\r\n        error:\r\n          error instanceof Error\r\n            ? error.message\r\n            : \"Internal server error fetching history\",\r\n      },\r\n      500\r\n    );\r\n  }\r\n});\r\n\r\n// Export the app handle for Vercel/Next.js\r\nexport const GET = handle(app);\r\nexport const POST = handle(app);\r\n// Add PUT, DELETE etc. if needed later\r\n// export const PUT = handle(app)\r\n// export const DELETE = handle(app)\r\n\r\n// Add runtime export if necessary (Node.js often better for Buffer operations)\r\n// export const runtime = 'nodejs'; // or 'edge'\r\n\r\n// export const runtime = 'nodejs'; // or 'edge'\r\n","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/documents/ocr',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","module.exports = require(\"node:inspector\");","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\documents\\\\ocr\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/documents/ocr/route\",\n        pathname: \"/api/documents/ocr\",\n        filename: \"route\",\n        bundlePath: \"app/api/documents/ocr/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\documents\\\\ocr\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","module.exports = require(\"net\");","\"use strict\";\nif (process.env.NEXT_RUNTIME === 'edge') {\n    module.exports = require('next/dist/server/route-modules/app-route/module.js');\n} else {\n    if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n        if (process.env.NODE_ENV === 'development') {\n            module.exports = require('next/dist/compiled/next-server/app-route-experimental.runtime.dev.js');\n        } else if (process.env.TURBOPACK) {\n            module.exports = require('next/dist/compiled/next-server/app-route-turbo-experimental.runtime.prod.js');\n        } else {\n            module.exports = require('next/dist/compiled/next-server/app-route-experimental.runtime.prod.js');\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            module.exports = require('next/dist/compiled/next-server/app-route.runtime.dev.js');\n        } else if (process.env.TURBOPACK) {\n            module.exports = require('next/dist/compiled/next-server/app-route-turbo.runtime.prod.js');\n        } else {\n            module.exports = require('next/dist/compiled/next-server/app-route.runtime.prod.js');\n        }\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map","module.exports = require(\"events\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 96708;\nmodule.exports = webpackEmptyContext;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 97108;\nmodule.exports = webpackEmptyContext;"],"names":["runMistralOCR","fileBuffer","mimeType","mistralLlm","mistral","text","extractedText","finishReason","generateText","model","messages","role","content","type","image","undefined","temperature","console","warn","supabaseUrl","process","supabaseServiceKey","env","SUPABASE_SERVICE_ROLE_KEY","supabase","createClient","supabaseAdmin","app","Hono","use","cors","ocrRequestSchema","z","fileId","chatId","optional","userId","fileName","fileType","fileUrl","url","fileContent","filePath","min","documentId","uuid","metadata","pageCount","language","confidence","processTime","rawResponse","post","c","req","header","body","json","validation","safeParse","success","error","details","errors","validatedData","data","cachedResult","cacheError","from","select","eq","maybeSingle","result","fileSourceDescription","Buffer","response","ok","statusText","arrayBuffer","fetchError","message","bucket","path","client","fileData","downloadError","storage","download","startTime","Date","now","ocrResult","upsertError","upsert","file_id","chat_id","user_id","file_name","file_type","created_at","toISOString","onConflict","aiError","Error","question","ocrData","ocrError","answer","usage","finalAnswer","historyError","insert","mistralError","get","param","order","ascending","GET","handle","POST","serverComponentModule.GET","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS"],"sourceRoot":""}