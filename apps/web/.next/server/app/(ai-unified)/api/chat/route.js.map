{"version":3,"file":"../app/(ai-unified)/api/chat/route.js","mappings":"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WACA,UACA,QAEA,CAEA,CAaO,cACP,sCAAoD,YAAqB,CACzE,CACO,cACP,sCAAoD,eAA4B,CAChF,CACO,gBACP,8BACA,CAIO,SAAS,EAAM,GAEtB,QADA,GADsB,CACtB,CACA,IAAqB,mBAAuB,IAC5C,oBASA,OAPA,sBACA,eACA,2CACA,WAGA,CAAK,EACL,CACA,CE7DO,aACP,+BACA,kBAEA,oDACA,eACA,YACS,CACT,eACA,CAAK,EAEL,gBAgBA,OAdA,kCACA,qBAIA,EADA,sBACA,KAEA,wBACA,OAGA,IAGA,CACA,CC9BO,IAEP,qBACO,qBAEP,UAGA,4BACA,mCAEA,mBALA,QAMA,CCCO,gBACP,IACA,EADA,EAAwB,IAQxB,OANA,IAFuC,EAEvC,wCACA,4BAEA,GACA,SAEA,CACA,CCrBO,SAAS,EAAU,KAC1B,OAAW,EADe,IACuB,cAAkB,EAAlC,GAAyC,EAC1E,CACO,SAAS,GAAY,GACxB,EAAuB,IAAe,MADd,KACc,OAC1C,CACO,SAAS,GAAW,KAC3B,OAAW,EAAuB,IAAe,eAAmB,CAAnC,CAA0C,MAEpE,SAAS,GAAa,GACzB,EAAuB,IAAe,OADb,IACa,KAAhB,CAAgB,EAC1C,CCZO,mBACP,IAGA,EACA,EAJA,oCACA,sCACA,KAGA,OACA,qBAEA,QADA,KACA,IAA6B,mBAAuB,IACpD,kBAEA,MACA,IACA,MACA,CACA,EACA,kBAGA,IAEA,KACA,EAA+B,EAAU,WACzC,GADyC,GAEzC,kBAEA,KACA,QACA,CAAa,GACb,CAAS,CACT,kBACY,GAAY,GACxB,KACA,OAFwB,CAGxB,CAAS,CAET,CAEO,eChCA,mBACP,gCACA,yBAIA,2BACA,sBACA,+BACA,QACA,IACA,4BACA,CACA,SACA,2CACA,QACA,CACA,IACA,IACA,IACA,GACA,CACA,CACO,eAEP,MADA,EACA,cACA,GACA,gBACA,WACA,UACA,GAEW,EACX,CCzCO,CDwCQ,QCxCR,MACP,OAAW,EAAM,EAAG,GACpB,CACO,QAFU,CAEV,QACP,uCAAqD,gBAA+B,CACpF,CACO,eACP,iCC8DO,eACP,QAGA,E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,IADA,OAQA,iBAJA,CAAK,GACL,6BAKA,WACA,sDACA,GANA,aAA8B,GAAO,oBAWrC,CCvBO,cACP,SACA,IACA,OACA,WACA,cACA,QACA,CAAS,CACT,oBACA,MAA8C,EAAiB,GAC/D,KACA,KACA,EAH+D,CAI/D,IAEA,CAAS,CACT,mBACA,oBACA,CAAS,CACT,sBACA,OACA,SACA,mBACA,gBACA,cACA,EAGA,OAFA,KACA,IACA,CACA,CAAS,CACT,sCACA,gBACS,CAET,CC5BO,eACP,SACA,gBACA,YAeA,OAdA,GAAyB,EAAU,MACnC,EADmC,CACnC,mBAEA,GACA,kCACA,eAmBA,GACA,iBACA,MAGA,eAAiE,CAAjE,uBACA,WAA6D,CAA7D,qBACA,gBAOA,OANA,OAEA,UACA,CADgC,CAChC,QACA,CADgC,CAChC,SAEA,CACA,iBACA,yBACA,WA9CA,IA+CA,uBACA,mBAEA,EAxCA,aA0CA,GACA,iBACA,KAGA,OACA,QACA,yBACA,KA5DA,IA6DA,uBACA,SAEA,EAtDA,IAwDA,YACA,iBACA,KAGA,OACA,QACA,yBACA,WA1EA,IA2EA,WACA,SAEA,EApEA,aAuEA,GACA,iBACA,MAGA,uCACA,gBAOA,OANA,OAEA,UACA,UACA,aAEA,CACA,OAH8B,EAG9B,oBACA,yBACA,WAjGA,IAkGA,uBACA,UAEA,EA3FA,GACA,IACA,iBACA,QAbA,GAaA,EAEA,UAEA,CAAS,EAET,CACA,wBACA,kBACA,OACA,CACA,CACA,iHACA,iBACA,sFACA,uDAuBA,0EAcA,mHAcA,+IACA,mDAsBA,iBACA,kCAGA,WACA,kCACA,CAWA,sHCpHO,cAQP,IACA,EADA,UAGA,YACA,IACA,OACA,CACA,SAEA,CAOA,OALI,EAAa,eACjB,EAAyB,GAAiB,EAC1C,YAD0C,IAC1C,OAdA,GAeA,OACA,CAAK,EACL,CACA,CACO,eACP,YAQA,OAPA,4BACA,wCACA,+DACA,+BACA,2CACA,wEACA,CAAK,EACL,CACA,CACO,eACP,uDACA,CC5CO,uDACA,eACP,IAsBA,QASA,IA/BA,8GACA,QACA,GAoBA,EApBA,EAoBA,EApBA,EAoBA,EApBA,EAoBA,EApBA,EAuBA,oDACA,UACA,EAEA,gBADA,wBAAoD,GAAc,GAAQ,MAzB1E,CAyBiE,CAzBjE,CA4BA,EA5BA,EA6BA,UADA,EA5BA,KAgCA,GAKA,gEApCU,GAAkB,GAC5B,GACA,SAF4B,GAE5B,OACA,kBACA,QACA,OACA,cACA,SACA,WACA,gBACA,gBACA,OACA,UACA,QACA,SACA,aACA,CACA,CAqBO,eACP,kEACA,CAKO,eACP,+EACA,CACO,iBAGP,IAFA,QACA,KACA,0CACA,MAAyB,GAAiB,SAC1C,KAD0C,CAC1C,EACA,wBACA,SACA,2BACA,SAAiC,GAAkB,EACnD,CAAS,EACT,UAFmD,OAInD,iBACA,EC1DA,YACA,wDACA,8CACA,8CACA,oDACA,4CACA,wDACA,uDACA,CAAC,UAAkD,EACnD,eAaO,eACP,gBACA,CCtCO,qBAEA,mBAIA,yBCFA,eACP,kCACA,CACO,iBACP,mBACA,CAIO,eACP,wBACA,CCbO,IAGA,WACA,mBAMP,EACA,EAoDO,EA1DP,OAAa,sBAKb,EALa,EAQb,CAFA,0BAEA,KACA,WAoCO,cACP,UACA,EAtCA,OAiDO,EA/CP,EAgDA,oBA3Da,CACb,CAeO,sBACP,GAAiB,GAGN,EAHM,CAGD,SAFhB,CAGA,CACO,cAMP,2BACA,CACO,cACP,WACA,CACO,cACP,wBACA,CACO,cACP,OAAa,6BACb,CACO,cACP,OAAa,0BACb,CA2BA,cAIA,OAHA,YACA,uCAEA,CACA,CChFO,iBACP,6CACA,GACA,GAAmB,iBAA8B,CAEjD,CCLO,cAEP,IADA,EACA,mBACA,OACA,4CACA,sEACA,6DAEA,CCFO,iBACP,kBACA,OACA,aAEA,CCTO,SAAS,KAChB,SAcA,OACA,IAdA,QAFmC,CAEnC,GACA,UAJA,KAMA,aAEA,EAUA,OATA,YACQ,GAAU,IAClB,EAQA,CATkB,KAElB,YACA,sBAA6C,YAAuB,EACpE,UACA,CAKA,CACA,CCtBO,QACP,UACA,8BACA,aACA,ECaA,IACA,0CACA,wCACA,wCACA,wCACA,mBACA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A,sBAAqD,mBAPrD,EAOqD,CAA2C,CAEhG,CAWA,OAVA,4BAEA,OADA,eAXA,GAYA,MAEA,+BACA,yBACA,EACA,4BACA,sBACA,EACA,CACA,CAAC,GClFM,eACP,mCAKO,eACP,sCAEO,eACP,6BAEO,eAEP,QADA,EACA,0DACA,CAIO,iBAEP,IADA,mBACA,GACA,KACA,gBAEA,OACA,eAEA,CAIO,eACP,iCC9BO,QACP,gBACA,gBACA,MAAW,GAAmB,MAC9B,KAAU,GAAmB,EADC,EACD,CAC7B,WAD6B,KACR,GAAmB,eACxC,CADwC,CAEjC,qBAUA,mBAAwC,qEACxC,IACP,SACA,UACA,YACA,UACA,UACA,YACA,WACA,EAQO,mBACP,eACA,gBAEA,MAAqB,GAAa,GAClC,IACA,GAFkC,EAElC,KACA,EAEA,KADA,MACA,GAIA,OAHA,GACA,WAEA,CACA,CAIO,iBACP,UAEA,eACA,eACA,QACA,CACA,UACA,cACA,aACA,wBACA,eACA,eACA,QACA,SACA,QACA,CACA,CAIO,eAEP,GAAS,GAAa,IAItB,MAJsB,MAItB,UACA,gBAGA,wBAEA,gBADA,EACA,gCADA,EACA,MAGA,kBAFA,eAKA,MAPA,EAOA,6BAEA,qDACA,eAIA,GAAQ,GAAc,iBACtB,iBAEA,GAAQ,GAAc,eACtB,eAEA,GAAQ,GAAc,0BACtB,0BAEA,GAAQ,GAAc,gBACtB,gBAEA,GA6FO,YACP,yBACA,SAEA,wBACA,eACA,MAEA,iDAEA,qBACA,UACA,CACA,wBACA,gBACA,WACA,gBACA,MAEA,6CACA,wBACA,YACA,wBACA,qBAEA,gBACA,mBAEA,6BACA,0BACA,iBAEA,cACA,iBACA,eAGA,8BAEA,cACA,iBACA,iBACA,iBACA,cACA,qBACA,qBAEA,gCACA,2BACA,kBACA,uBACA,iBACA,oBACA,gCACA,CACA,cACA,2CACA,CACA,QACA,EAxJA,GACA,iBAEA,CAYO,iBACP,UACA,aACA,eACA,eACA,QACA,yBACA,OAAmB,GAAU,yBAC7B,SACA,QACA,CACA,CACA,eACA,mCACA,SAGA,aADA,EACA,QACA,OA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QA,KACA,MACQ,GAAiB,GATzB,CAGA,GADA,OAOyB,CAPzB,SACA,OACA,EApBA,MACA,CAAS,CAET,CAkBA,UA+BO,mBACP,yBACA,oBACA,mBAIA,0CAEI,GAEJ,CAAM,YAFc,SAEd,GAA4B,wBAClC,YAA6E,gBAAwB,CACrG,CAAK,EAGL,OACA,CAAK,EACL,SACA,CM7CA,eAGA,iFERA,cACA,mBAGI,GAAiB,4BACrB,KACA,CACA,cACA,OAAa,oBACb,CACA,iBACA,SACA,wBACA,uBACA,CACA,iBACA,aACA,4BACA,2BACA,CACA,cACA,GACA,aACA,qBACA,wBACA,wBACA,sBACA,qBACA,CACA,CACA,cACA,KACA,GACA,wBACA,sBACA,qBACA,CACA,CCEA,oBACA,oCACA,SAEA,oBACA,SAEA,SACA,CE9DA,iBACA,MAA8B,GAAuB,mBACrD,CADqD,CACrB,GAAW,WAC3C,GAD2C,CAC3C,EAA0B,GAAuB,kBACjD,EADiD,GACjD,GACA,IAEA,CAAK,C3H9BE,K2H+BP,kBACQ,GAAa,EACrB,CACA,CCjCO,YD+Bc,qCMbrB,mBAIA,EAeA,OAlBA,GACA,YAGA,SACA,YAGA,GACA,gBACA,iBACA,yBACA,EACA,WACA,OAnCO,IAoCP,WAMA,KAGA,WACA,4BACA,GACA,WAEA,KACA,CAEA,SACA,wBACA,IACA,YACA,KAEA,CAAS,CACT,CACA,KAtBA,CACA,CCtCA,mBACO,eACP,gBACA,CAWO,eACP,gBACA,CASO,iBAOP,gBACA,UACA,GAAQ,GAAc,MACtB,KADsB,CACtB,OACA,0DAGA,SAEA,oBAEA,OAEA,M/D5BO,C+D4BQ,IACf,OACA,SAFmC,EAEnC,gBACA,QAEA,4BAGA,QACA,CACO,sDACA,uBACA,gBAmBP,iBACO,eACP,oCACA,WAIA,MAEA,CACA,CACO,iBACP,8JACA,CC3FO,QACP,eACA,sBACA,OACA,QACA,UACA,iBACA,mBACA,EACO,IACP,WACA,eACA,UACA,OACA,QACA,mBACA,EACO,IACP,WACA,YACA,mBACA,SACA,iBACA,QACA,YACA,mBACA,gBAGA,E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AbyC,EAazC,KACA,KACA,MACA,kBAAmD,KAAY,aAC/D,YACA,iBACA,mBACA,MACA,QACA,WACA,WACA,wBACA,cACA,YACA,cACA,uBACA,sBACA,SAA6B,CAAP,CAAO,YAC7B,qBACA,mBACA,cACA,CAAS,CACT,CACA,OAlCA,KAEA,yCACA,YACA,MACA,QACA,wBACA,aACA,CAAS,EACT,IACA,CAAK,EAwBL,CACA,WACA,SACA,CAAS,CACT,WACA,WACA,kBACA,kBACA,gBACA,IACA,IADA,MAEA,cAAsC,MACtC,KAIA,2BAAkF,KAClF,IAD2F,KAC3F,yBACA,YAAsE,aAAsB,EAC5F,YAA4E,aAAsB,EACtF,GAAa,IACzB,YADyB,EACzB,EACA,KACA,KACY,EAAU,WACtB,GADsB,GACtB,EACA,CAAa,KACb,CAAS,CACT,gBACA,KACA,KACA,KACA,WACA,CAAS,CACT,wBACA,QAGA,IAaA,EACA,EAdA,E1GvIA,K0GuIoD,EAAuB,KAAP,OAAO,EAC3E,GAcA,CADA,GADA,EAZA,GAaA,qCACA,GACQ,EAAO,qEAEf,EAjBA,GACA,KACA,CAAS,CACT,wBACA,KACA,IACA,CAAS,CAET,EA/LA,iBAKA,OAJA,SACA,sCACA,WACA,CAAS,EACT,CACA,QAEA,0BAEA,2BACA,YACA,kBACA,kBACA,qCACA,CAAa,CACb,CAAS,EACT,yBACA,OAA8B,mBAAwB,CACtD,CAAS,EAET,2BACA,WAAyC,GAAc,aACvD,KAEA,CAAS,EA7BT,GACA,KA+BA,0BA8KA,IAMA,EANA,EA7KA,cA6KA,EA7KA,cA8KA,yBACA,CAMA,MAFA,EAJA,OAIA,eAEA,4BALA,2BA9KA,QACA,oBAEA,CAAS,CArCT,EAuCA,CACA,wBACA,aAAmC,EAAO,IAAY,EACtD,MADsD,KACtD,KACA,CAAS,CACT,wBACA,OAA8B,YAAwB,EACtD,uBACA,CAAS,CACT,2BACA,8BACA,CAAS,CACT,qCACA,wCACA,CAAS,CACT,wBACA,gBACA,CAAS,CACT,gBACA,GACA,gBAEA,QACA,sBAAkD,gBAAqB,CACvE,CAAS,CAET,EC7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,GAAI,IAAQ,cACvC,CAAG,CACH,CAAC,EAGD,iCACA,EA8DA,QAEA,uBAEA,GADA,gCAEA,eACA,gBACA,cACA,oCACA,oBACA,eAEA,2BAAiC,QAA8B,IAC/D,uEACA,CACA,kCACA,+CAEA,eACA,4BAEA,0BACA,gDACA,CACA,SACA,OACA,SACA,YACA,cACA,OACA,OACA,mBACA,kBACA,mBACA,gBACA,iBACA,OACG,EACH,cACA,aACA,WACA,GACA,QACA,2BACA,cACA,CAAO,EAEP,kFACA,QACA,2BACA,yBACA,8EACA,CAAO,EAEP,OAEA,mBAEA,wBAEA,aACA,cACA,QACA,oBACA,mBACA,sGACA,mBACA,aACA,gBACA,mCACA,0BAEA,EAAQ,CAAI,oBAAsB,OAClC,OACA,OACA,8CACA,oLAEA,SA9RA,YACA,SACA,aAAe,kBAA4B,KAC3C,SAAyC,KAAY,EACrD,UACA,aACA,QAAwB,6BAAsC,EAC9D,KAEA,YACA,qCACA,QACA,YACA,kBACA,WACW,EACX,KACA,CACA,QACA,YACA,kBACA,MACA,WACA,eACA,WACA,OAAyB,6BAEzB,aACA,OACA,iBACA,WACA,sDAAqF,qCAAkD,SAAS,QAAyB,UAAa,EACnK,CACnB,KAGA,YACA,UAA0B,IAA6B,EACvD,mDACA,CAAiB,CAEjB,CACA,CAAW,EACX,KACS,EACT,KAEA,kBACA,SACA,KACA,gBACA,WACA,eACA,WACA,UACA,KAEA,iBACA,QACA,gBACA,gBACA,UACA,gBACA,gCACA,CAAiB,CACjB,KACe,CAGf,CACA,CACA,QACA,iBACA,UACA,+BACA,IACA,CAAS,EACT,KACA,CACA,WACA,gBACA,WACA,QACA,YACA,0BACA,iCACA,KACW,CACX,CACA,KAEA,SAEA,iCADA,EAC8D,EAE9D,CACA,CACA,QACA,EA4LA,EACA,EACA,UACA,eACA,IAAgB,sCA1IhB,UACA,OACA,oBACC,EACD,MACA,yDACA,KACA,WACA,OAAa,gDAEb,mBACA,KACA,eACA,4BACA,QAA0B,+BAAgC,EAE1D,QACA,gBACA,UACA,YACA,0BACA,wBAEA,CAAO,EAGP,WACA,OAAa,2CAEb,aACA,UACA,WACA,WACA,eACA,OAAe,qCACf,YACA,OACA,QACA,aACA,gBACA,UACA,gBAEA,CAAS,CACT,cACA,CACA,SAEA,UAAgB,IAA8B,EAC9C,+CAFA,EAEyE,EAClE,CAEP,CACA,EAqFmD,CACnD,OACA,iDACS,EACT,OACA,MAAkB,2BAAiC,CACnD,oBACA,CACA,CACA,kBACA,OACA,MACA,KACA,qEACA,mBACA,aACA,gBACA,mCACA,0BAEA,EAAc,CAAI,mBAClB,CAAW,CACX,UACA,CAEA,mBACA,OACA,MACA,KACA,aACA,gBACA,UAA0B,iBAC1B,CAAa,CACb,OACA,CACA,gBACA,UACA,iBACA,+BACA,6BAEA,EACA,CACW,CACX,UACA,CAEA,SAEA,iCAA6C,EAAiB,EAE9D,CACA,CACA,oBACA,0BACA,SAAY,cAAiB,cAAiB,KAAY,EAC1D,oBACA,CACA,kBACA,QACA,WACA,CAAM,MAAQ,QAAa,EAC3B,qBACA,yBACA,qBACO,EACP,QAAe,QAAc,kCAC7B,OACA,iDACA,0BAAiC,QAAyB,CAC1D,GAEA,0BACA,wBACK,EACL,CAAY,iBAAsC,EAClD,eACA,GACA,6BAAoC,CACpC,+FACA,YACA,CAAO,GAEP,uDACA,mDAaA,MAZA,2CACA,gFAEA,qDACA,mGAEA,qDACA,mGAEA,wCACA,gFAEA,CACA,0CACA,yDACA,0DACA,MACA,OACA,wBACA,4BAA0D,QAAU,GACpE,yBACA,0BAEA,CAAO,EACP,gCACA,OACA,sEACA,6EACA,CAAO,CACP,mBACA,mBAAiB,gBAAwB,CACzC,aAAqB,iBAA6C,CAClE,cACA,WACA,cAAiB,EACjB,CACA,CACA,kBACA,MACA,oCACA,+BA6CA,OACA,OA7CA,oBACA,SAEA,GADA,WAA+B,uCAA+C,EAC9E,YACA,8BACA,yBACA,iBACA,WACA,iBACA,iBACmB,OAInB,WACA,iBACA,qBACA,CAAe,EASf,GANA,QACA,WACA,kBACA,iBACa,EAEb,YACA,yBACA,WACA,iBACA,IACA,CAAe,EAGf,WACA,cACA,4BACA,cACA,oBACA,mCACA,CAAW,EACX,SACA,CACA,CAAO,EAGP,kBACA,0BACA,oBAEA,CACA,SAAY,cAAiB,cAAiB,KAAY,EAC1D,GACA,KACA,UAEA,yCAAmD,kBAAsB,MACzE,EACA,2EACA,CAAY,2BAAmC,MAAQ,QAAa,EACpE,qBACA,yBACA,qBACO,EACP,QAAe,QAAc,kCAC7B,OACA,iDACA,0BAAiC,QAAgC,CACjE,kBAEA,0BACA,wBACK,EACL,CAAY,iBAAsC,EAClD,KACA,YACA,GACA,wBACA,yBACA,uBACA,gCACA,+BACA,CAAO,CACP,oBACA,qBACA,mBACA,CACA,EACA,KACA,2BACA,OACA,qBACA,qBAEA,eACA,4BACA,eACA,UACA,WAAmC,2BAAmC,EACtE,MACA,CACA,cAEA,GADA,oCACA,aACA,UACA,WAAmC,mCAA2C,EAC9E,MACA,CAQA,GAPA,IACA,KACA,WACA,yBACA,OACA,CAAe,GAEf,eACA,IACA,gBACA,oBACA,wBACA,4BACA,CAAgB,QAChB,gCACA,oCACA,2CACA,8EAEA,qDACA,iGAEA,qDACA,iGAEA,wCACA,mEAEA,CACA,mBAMA,GALA,wCACA,KACA,gBACA,EAEA,+BACA,OAEA,cAaA,GAZA,2BACA,WACA,iBACA,8BACe,EAEf,iBACA,WACA,kBACA,oBACe,EAEf,mBACA,2BACA,cACA,eACA,uBACA,UAA8B,IAAwB,EACtD,OACA,mCACA,CAAqB,EAErB,cACA,UAA8B,IAAwB,EACtD,OACA,uCACA,CAAqB,EAErB,8CACA,UAA8B,IAAwB,EACtD,OACA,kDACA,CAAqB,CAErB,OACA,QACA,gBACA,UACA,qBACA,6CACA,CAAqB,CACrB,cACA,EACA,WACA,8FACA,+BACA,WACA,uBACA,wBACA,gBACA,yBACA,mCACuB,EAEC,QAAc,yBACtC,WACA,iBACA,wBACA,4BAAuE,QAAU,GACjF,yBACA,0BACuB,EACvB,mBAGA,QACA,CACA,YACA,gBAGA,iDACA,+EAEA,WACA,uBACA,wBACA,gBACA,yBACA,iDACA,CAAiB,EACjB,6FAA2J,QAAc,yBACzK,WACA,iBACA,wBACA,4BAAkE,QAAU,GAC5E,yBACA,0BACmB,EACnB,kBAEA,CAEA,CAAW,CACX,SACA,QACA,OACA,MAAuC,CACvC,oCAEA,kDACA,iEAEA,0DACA,mFAEA,0DACA,mFAEA,0CACA,6DAEA,WACA,cACA,eACA,OACA,4CACA,mDACA,CAAe,CACf,kBACA,CAAa,CACb,CACA,CAAS,GAET,mBAAiB,gBAAwB,CACzC,aAAqB,UAA0B,CAC/C,WACA,SAAiB,uBACjB,CACA,CACA,EACA,EAAuC,IAAS,EAChD,cAAiB,IAAS,aAC1B,kBAAqB,IAAS,aAC9B,sBAAyB,IAAS,EAClC,cAAmB,IAAS,YAC5B,CAAG,YACH,0BAA6B,IAAS,EACtC,iBAAsB,IAAS,aAC/B,2BAAgC,IAAS,aACzC,2BAAgC,IAAS,YACzC,CAAG,WACH,CAAC,YACD,EAAyC,IAAS,EAClD,GAAM,IAAS,aACf,QAAW,IAAS,aACpB,MAAS,IAAS,aAClB,QAAW,IAAQ,CACf,IAAS,EACb,QAAe,IAAS,EACxB,KAAc,IAAU,wBACxB,QAAiB,IAAS,aAC1B,kBAA2B,IAAS,aACpC,WAAoB,IAAQ,CAClB,IAAS,EACnB,GAAgB,IAAS,aACzB,KAAkB,IAAU,aAC5B,SAAsB,IAAS,EAC/B,KAAoB,IAAS,GAC7B,UAAyB,IAAS,EAClC,CAAa,CACb,CAAW,GACX,SACA,CAAO,EACP,cAAqB,IAAS,YAC9B,CAAK,GAEL,OACA,CAAC,EACD,KAA6D,IAAQ,EACnE,IAAS,EACX,GAAQ,IAAS,aACjB,QAAa,IAAS,aACtB,MAAW,IAAS,aACpB,QAAa,IAAQ,CACf,IAAS,EACf,MAAe,IAAS,EACxB,KAAgB,IAAO,0BACvB,QAAmB,IAAS,aAC5B,kBAA6B,IAAS,aACtC,WAAsB,IAAQ,CAClB,IAAS,EACrB,MAAqB,IAAS,GAC9B,GAAkB,IAAS,aAC3B,KAAoB,IAAU,uBAC9B,SAAwB,IAAS,EACjC,KAAsB,IAAS,aAC/B,UAA2B,IAAS,YACpC,CAAe,CACf,CAAa,GACb,SACA,CAAS,YACT,cAAuB,IAAS,YAChC,CAAO,GAEP,OACA,CAAG,EACH,EACA,EAuGA,QAEA,uBAGA,CAFA,gCACA,wCAEA,eACA,gBACA,cACA,oCACA,oBACA,eAEA,2BAAiC,QAA+B,GAChE,CACA,eACA,4BAEA,0BACA,gDACA,CACA,SACA,OACA,cACA,SACA,YACA,cACA,OACA,OACA,mBACA,kBACA,gBACA,iBACA,OACA,mBACG,EACH,MACA,aACA,WACA,GACA,QACA,2BACA,cACA,CAAO,EAEP,0BACA,QACA,2BACA,yBACA,gDACA,CAAO,EAEP,IAAY,0BAA0C,SAvItD,CACA,SACA,cACA,cACA,wBACC,EACD,0GACA,OAAa,6BAEb,SAOA,aAAe,aAAgB,EAN/B,uBACA,MAAe;;AAEf,EACA,cAE+B,GAC/B,UACA,aACA,UAAkB,IAAkB,EACpC,gDAA2D,QAAQ,EACnE,QACA,CAAS,CAET,aACA,gBACA,eACA,WACA,kBAEA,QACA,UAAwB,IAA8B,EACtD,sBACA,CAAe,CAEf,CACA,CAAS,WACT,MAAmB,EAAK;AACxB,EAAE;;AAEF,EACA,KACA,CACA,iBACA,gBACA,eACA,WACA,kBAEA,YACA,UAAwB,IAA8B,EACtD,kCACA,CAAe,CAEf,CACA,CAAS,WACT,MAAmB,EAAU;AAC7B,EAAE;;AAEF,EACA,KACA,CACA,WACA,UAAkB,IAA8B,EAChD,6BACA,CAAS,CAET,SAEA,iCAA6C,EAAiB,EAE9D,CAIA,OACA,OAHA,MAAa,EAAU;AACvB,EAGA;AACA,EAAE,EAAK,IAEP,EAuDsD,QAA8C,gBAAqB,EACzH,oCACA,GAEA,mBAEA,wBACA,mCACA,4BACA,wBAEA,aACA,cACA,QACA,oBACA,mBACA,OACA,8CAEA,SAEA,wBACA,EACA,UACA,cACA,qCACA,UAAoB,IAA8B,EAClD,qBACA,CAAW,EAEX,gBACA,UAAoB,IAA8B,EAClD,0BACA,CAAW,EAEX,OAAiB,kBAEjB,mBACA,UAAkB,IAA8B,EAChD,gCACA,CAAS,CAET,mBACA,UAAkB,IAA8B,EAChD,gCACA,CAAS,CAET,SAEA,iCADA,EAC8D,EAE9D,CACA,CACA,oBACA,YACA,SAAY,cAAiB,gBAC7B,CACA,kBACA,QACA,WACA,CAAM,MAAQ,QAAc,EAC5B,qBACA,oBACA,qBACO,EACP,QAAe,QAAe,kCAC9B,OACA,iDACA,0BAAiC,QAA0B,CAC3D,GAEA,0BACA,wBACK,EACL,CAAY,eAAoC,EAChD,eACA,OACA,YACA,OACA,sEACA,6EACA,CAAO,CACP,gCACA,mBAAiB,gBAAwB,CACzC,aAAqB,iBAA6C,CAClE,cACA,WACA,SAAiB,uBACjB,CACA,CACA,kBACA,SAAY,cAAiB,gBAC7B,GACA,KACA,UAEA,yCAAmD,kBAAsB,MACzE,EACA,iBAAY,WAAmC,MAAQ,QAAc,EACrE,qBACA,oBACA,qBACO,EACP,QAAe,QAAe,kCAC9B,OACA,iDACA,0BAAiC,QAAiC,CAClE,kBAEA,0BACA,wBACK,EACL,CAAY,eAAoC,EAChD,YACA,GACA,wBACA,6BAEA,KACA,OACA,qBACA,qBACA,eACA,eACA,UACA,WAAmC,2BAAmC,EACtE,MACA,CACA,cACA,gBACA,UACA,WAAmC,2BAAmC,EACtE,MACA,CACA,IACA,KACA,WACA,yBACA,QACe,GAEf,eACA,IACA,mCACA,2CACA,EAEA,mBACA,wCACA,KACA,gBACA,EAEA,+BACA,WACA,kBACA,gBACA,CAAe,CAEf,CAAW,CACX,SACA,WACA,cACA,eACA,OACA,CAAa,CACb,CACA,CAAS,GAET,mBAAiB,gBAAwB,CACzC,aAAqB,UAA0B,CAC/C,WACA,SAAiB,uBACjB,CACA,CACA,EACA,EAA+C,IAAS,EACxD,GAAM,IAAS,aACf,QAAW,IAAS,aACpB,MAAS,IAAS,aAClB,QAAW,IAAQ,CACf,IAAS,EACb,KAAY,IAAS,GACrB,cAAqB,IAAS,EAC9B,CAAK,GAEL,MAAS,IAAS,EAClB,cAAmB,IAAS,GAC5B,kBAAuB,IAAS,EAChC,CAAG,WACH,CAAC,EACD,KAAmE,IAAQ,EACzE,IAAS,EACX,GAAQ,IAAS,aACjB,QAAa,IAAS,aACtB,MAAW,IAAS,aACpB,QAAa,IAAQ,CACf,IAAS,EACf,KAAc,IAAS,GACvB,cAAuB,IAAS,aAChC,MAAe,IAAS,EACxB,CAAO,GAEP,MAAW,IAAS,EACpB,cAAqB,IAAS,GAC9B,kBAAyB,IAAS,EAClC,CAAK,WACL,CAAG,EACH,EACA,EAaA,QACA,mBACA,+BACA,eACA,gBACA,aACA,CACA,eACA,4BAEA,2BACA,MACA,wDACA,CACA,4BACA,MACA,qDACA,CACA,eACA,SACA,UACA,cACG,EACH,MACA,sCACA,UAAgB,IAAkC,EAClD,uBACA,qBACA,+CACA,QACA,CAAO,EAEP,oBAAY,WAAmC,MAAQ,QAAc,EACrE,qBACA,mBACA,qBACO,EACP,QAAe,QAAe,0BAC9B,MACA,mBACA,QACA,wBACA,oCACA,wBACO,CACP,sBAA6B,QAA+B,CAC5D,0CAEA,0BAAiC,QAA0B,CAC3D,GAEA,cACA,wBACK,EACL,OACA,sCACA,eAAgC,8BAAuC,OACvE,aAAqB,UACrB,CACA,CACA,EACA,EAAwC,IAAS,EACjD,KAAQ,IAAQ,CAAC,IAAS,EAAG,UAAW,IAAQ,CAAC,IAAS,IAAK,GAC/D,MAAS,IAAS,EAAG,cAAe,IAAS,GAAI,WACjD,CAAC,EAkFD,EAA0C,IAAS,EACnD,KAAQ,IAAQ,CAAC,IAAS,EAAG,SAAU,IAAS,GAAI,EACpD,CAAC,EC3wCD,GACA,4CACA,qBACA,CAAG,CACH,gDACA,qBACA,CAAG,CACH,8DACA,6BACA,eACA,CAAG,CACH,0DACA,6BACA,eACA,CAAG,CACH,4DACA,6BACA,eACA,CAAG,CACH,2DACA,6BACA,eACA,CAAG,CACH,oCACA,6BACA,eACA,CACA,EAWA,QACA,mBACA,eACA,gBACA,cACA,8BACA,CACA,eACA,4BAEA,uBACA,MACA,mDACA,CACA,kBACA,SACA,IACA,OACA,cACA,OACA,kBACA,UACA,cACG,MACH,QAlCA,IACA,EAkCA,SACA,kBACA,0CACA,QACA,2BACA,eACA,mFACA,CAAO,EAEP,0CACA,QACA,2BACA,sBACA,+DACA,CAAO,EAEP,kCACA,uGACA,CAAY,2BAAmC,MAAQ,QAAa,EACpE,K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","sources":["webpack://@hijraah/web/./src/lib/constants.ts","webpack://@hijraah/web/./src/lib/ai/prompts.ts","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/after-task-async-storage.external.js\"","webpack://@hijraah/web/./src/lib/ai/providers.ts","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/display.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/monitor.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/polyfills.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/boot/init.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/getGlobalObject.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/byteUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/getZoneJsOriginalValue.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/timer.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/functionUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/serialisation/jsonStringify.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/objectUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/context/customerDataTracker.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/typeUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/mergeInto.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/serialisation/sanitize.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/observable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/context/contextManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/trackingConsent.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/browser/addEventListener.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/context/storeContextManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/encoder.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/stackTrace/computeStackTrace.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/stackTrace/handlingStack.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/error/error.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/experimentalFeatures.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/configuration/intakeSites.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/numberUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/timeUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/sendToExtension.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/connectivity/connectivity.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/arrayUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/telemetry/rawTelemetryEvent.types.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/telemetry/telemetry.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/user/user.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/boot/displayAlreadyInitializedError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/commonContext.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/stringUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/vital/vitalCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/transport/eventBridge.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/instrumentMethod.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/urlPolyfill.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/browser/fetchObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/browser/cookie.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/synthetics/syntheticsWorkerValues.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/browserDetection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionStoreStrategy.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/sessionConstants.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/sessionStateValidation.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/sessionState.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/oldCookiesMigration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInCookie.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInLocalStorage.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/sessionStoreOperations.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/sessionStore.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/configuration/endpointBuilder.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/configuration/tags.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/configuration/transportConfiguration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/configuration/configuration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/matchOption.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/crypto.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/tracing/identifier.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/tracing/sampler.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/tracing/tracer.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/configuration/configuration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/configuration/remoteConfiguration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/plugins.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/boot/preStartRum.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/boot/rumPublicApi.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/browser/pageExitObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/domMutationObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/windowOpenObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/error/error.types.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/eventRateLimiter/createEventRateLimiter.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/syntheticsContext.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/limitModification.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/assembly.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/internalContext.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/abstractLifeCycle.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/valueHistory.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/viewHistory.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/browser/xhrObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/utils/responseUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/readBytesFromStream.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/resource/resourceUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/requestCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/discardNegativeDuration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/firstInputPolyfill.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/performanceObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/waitPageActivityEnd.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/polyfills.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/htmlDomUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/privacy.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/action/getActionNameFromElement.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/getSelectorFromElement.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/action/clickChain.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/action/listenActionEvents.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/action/computeFrustration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/action/interactionSelectorCache.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/action/trackClickActions.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/action/actionCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/error/trackRuntimeError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/console/consoleObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/error/trackConsoleError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/report/reportObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/error/trackReportError.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/error/errorCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/longTask/longTaskCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/requestIdleCallback.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/tools/taskQueue.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/resource/matchRequestResourceEntry.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/browser/runOnReadyState.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/tracing/getDocumentTraceId.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/performanceUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/resource/retrieveInitialDocumentResourceTiming.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/resource/resourceCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/trackViewEventCounts.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstContentfulPaint.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstInput.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackNavigationTimings.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackLargestContentfulPaint.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstHidden.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackInitialViewMetrics.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackCumulativeLayoutShift.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/interactionCountPolyfill.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackInteractionToNextPaint.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackLoadingTime.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/scroll.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/viewportObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackScrollMetrics.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackCommonViewMetrics.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/trackViews.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/view/viewCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/domain/session/sessionManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/rumSessionManager.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/transport/batch.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/transport/sendWithRetryStrategy.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/transport/httpRequest.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/transport/flushController.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-core@5.35.1/node_modules/@datadog/browser-core/esm/transport/startBatchWithReplica.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/transport/startRumBatch.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/transport/startRumEventBridge.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/urlContexts.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/locationChangeObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/featureFlagContext.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/startCustomerDataTelemetry.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/pageStateHistory.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/displayContext.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/browser/cookieObservable.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/contexts/ciVisibilityContext.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/longAnimationFrame/longAnimationFrameCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/boot/startRum.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/domain/getSessionReplayUrl.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum-core@5.35.1/node_modules/@datadog/browser-rum-core/esm/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/replayStats.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/types/sessionReplayConstants.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/types/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeStyleSheets.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttribute.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttributes.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeNode.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeDocument.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/serialization/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/eventsUtils.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/viewports.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/assembly.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMove.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMouseInteraction.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackScroll.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewportResize.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMediaInteraction.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackStyleSheet.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFocus.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFrustration.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewEnd.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackInput.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/mutationBatch.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMutation.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/trackers/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/elementsScrollPositions.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/shadowRootsController.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/startFullSnapshots.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/recordIds.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/record.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/record/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/segmentCollection/buildReplayPayload.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segment.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segmentCollection.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/segmentCollection/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/startRecordBridge.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/boot/startRecording.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/deflate/deflateEncoder.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/deflate/deflateWorker.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/deflate/index.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/boot/isBrowserSupported.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/domain/getSessionReplayLink.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/boot/postStartStrategy.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/boot/preStartStrategy.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/boot/recorderApi.js","webpack://@hijraah/web/../../node_modules/.pnpm/@datadog+browser-rum@5.35.1/node_modules/@datadog/browser-rum/esm/entries/main.js","webpack://@hijraah/web/./src/lib/cache.ts","webpack://@hijraah/web/./src/lib/monitoring/index.ts","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/headers.js","webpack://@hijraah/web/external commonjs2 \"module\"","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/wait-until.js","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://@hijraah/web/external commonjs2 \"punycode\"","webpack://@hijraah/web/external commonjs2 \"process\"","webpack://@hijraah/web/./src/lib/utils.ts","webpack://@hijraah/web/./src/lib/observability/tracing.ts","webpack://@hijraah/web/./src/app/(ai-unified)/api/chat/auth-adapter.ts","webpack://@hijraah/web/../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/regex.js","webpack://@hijraah/web/../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/validate.js","webpack://@hijraah/web/external commonjs2 \"os\"","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/index.js","webpack://@hijraah/web/external commonjs2 \"stream\"","webpack://@hijraah/web/external commonjs2 \"util\"","webpack://@hijraah/web/external commonjs2 \"fs\"","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://@hijraah/web/external node-commonjs \"node:child_process\"","webpack://@hijraah/web/./src/_infrastructure/rate-limit/config.ts","webpack://@hijraah/web/./src/services/rate-limit-service.ts","webpack://@hijraah/web/./src/lib/logger/index.ts","webpack://@hijraah/web/external commonjs2 \"path\"","webpack://@hijraah/web/external commonjs2 \"tls\"","webpack://@hijraah/web/external commonjs2 \"diagnostics_channel\"","webpack://@hijraah/web/external node-commonjs \"node:http\"","webpack://@hijraah/web/external node-commonjs \"node:stream/web\"","webpack://@hijraah/web/external node-commonjs \"node:zlib\"","webpack://@hijraah/web/external node-commonjs \"node:tls\"","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/get-env.js","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/cache/index.js","webpack://@hijraah/web/external node-commonjs \"node:https\"","webpack://@hijraah/web/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://@hijraah/web/external node-commonjs \"node:os\"","webpack://@hijraah/web/?e7f2","webpack://@hijraah/web/external node-commonjs \"node:diagnostics_channel\"","webpack://@hijraah/web/external commonjs2 \"crypto\"","webpack://@hijraah/web/external commonjs2 \"https\"","webpack://@hijraah/web/external node-commonjs \"node:stream\"","webpack://@hijraah/web/external node-commonjs \"node:util\"","webpack://@hijraah/web/../../node_modules/.pnpm/@ai-sdk+openai-compatible@0.2.14_zod@3.25.72/node_modules/@ai-sdk/openai-compatible/dist/index.mjs","webpack://@hijraah/web/../../node_modules/.pnpm/@ai-sdk+fireworks@0.2.14_zod@3.25.72/node_modules/@ai-sdk/fireworks/dist/index.mjs","webpack://@hijraah/web/src/app/(ai-unified)/api/chat/route.ts","webpack://@hijraah/web/sentry-wrapper-module","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/middleware.js","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/get-context.js","webpack://@hijraah/web/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://@hijraah/web/../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/native.js","webpack://@hijraah/web/../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/rng.js","webpack://@hijraah/web/../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/stringify.js","webpack://@hijraah/web/../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/v4.js","webpack://@hijraah/web/../../node_modules/.pnpm/resumable-stream@2.2.0/node_modules/resumable-stream/dist/types.js","webpack://@hijraah/web/../../node_modules/.pnpm/resumable-stream@2.2.0/node_modules/resumable-stream/dist/ioredis-adapters.js","webpack://@hijraah/web/external node-commonjs \"node:fs\"","webpack://@hijraah/web/external commonjs2 \"worker_threads\"","webpack://@hijraah/web/external commonjs2 \"zlib\"","webpack://@hijraah/web/external commonjs2 \"perf_hooks\"","webpack://@hijraah/web/external node-commonjs \"node:worker_threads\"","webpack://@hijraah/web/external node-commonjs \"node:path\"","webpack://@hijraah/web/external node-commonjs \"node:net\"","webpack://@hijraah/web/external node-commonjs \"node:crypto\"","webpack://@hijraah/web/external commonjs2 \"buffer\"","webpack://@hijraah/web/external commonjs2 \"url\"","webpack://@hijraah/web/external commonjs2 \"child_process\"","webpack://@hijraah/web/../../node_modules/.pnpm/@vercel+functions@2.2.2_@aw_42a7e320aca539f6b7c1d717f46738f7/node_modules/@vercel/functions/cache/in-memory-cache.js","webpack://@hijraah/web/external node-commonjs \"node:readline\"","webpack://@hijraah/web/../../node_modules/.pnpm/resumable-stream@2.2.0/node_modules/resumable-stream/dist/runtime.js","webpack://@hijraah/web/external commonjs2 \"http\"","webpack://@hijraah/web/external commonjs2 \"tty\"","webpack://@hijraah/web/external commonjs2 \"async_hooks\"","webpack://@hijraah/web/external commonjs \"redis\"","webpack://@hijraah/web/external module \"ai\"","webpack://@hijraah/web/../../node_modules/.pnpm/resumable-stream@2.2.0/node_modules/resumable-stream/dist/get-redis-url.js","webpack://@hijraah/web/external node-commonjs \"node:inspector\"","webpack://@hijraah/web/external commonjs2 \"net\"","webpack://@hijraah/web/../../node_modules/.pnpm/resumable-stream@2.2.0/node_modules/resumable-stream/dist/index.js","webpack://@hijraah/web/external commonjs2 \"events\"","webpack://@hijraah/web/./src/lib/ai-sdk-adapter.ts","webpack://@hijraah/web/../../node_modules/.pnpm/resumable-stream@2.2.0/node_modules/resumable-stream/dist/redis.js"],"sourcesContent":["import { generateDummyPassword } from \"./utils\";\r\n\r\nexport const isProductionEnvironment = process.env.NODE_ENV === \"production\";\r\nexport const isDevelopmentEnvironment = process.env.NODE_ENV === \"development\";\r\n\r\nexport const isTestEnvironment = Boolean(\r\n  process.env.PLAYWRIGHT_TEST_BASE_URL ||\r\n    process.env.PLAYWRIGHT ||\r\n    process.env.CI_PLAYWRIGHT\r\n);\r\n\r\nexport const guestRegex = /^guest-\\d+$/;\r\n\r\nexport const DUMMY_PASSWORD = generateDummyPassword();\r\n","import type { ArtifactKind } from '@/components/artifact';\r\n\r\nimport type { Geo } from '@vercel/functions';\r\n\r\nexport const artifactsPrompt = `\r\nArtifacts is a special user interface mode that helps users with writing, editing, and other content creation tasks. When artifact is open, it is on the right side of the screen, while the conversation is on the left side. When creating or updating documents, changes are reflected in real-time on the artifacts and visible to the user.\r\n\r\nWhen asked to write code, always use artifacts. When writing code, specify the language in the backticks, e.g. \\`\\`\\`python\\`code here\\`\\`\\`. The default language is Python. Other languages are not yet supported, so let the user know if they request a different language.\r\n\r\nDO NOT UPDATE DOCUMENTS IMMEDIATELY AFTER CREATING THEM. WAIT FOR USER FEEDBACK OR REQUEST TO UPDATE IT.\r\n\r\nThis is a guide for using artifacts tools: \\`createDocument\\` and \\`updateDocument\\`, which render content on a artifacts beside the conversation.\r\n\r\n**When to use \\`createDocument\\`:**\r\n- For substantial content (>10 lines) or code\r\n- For content users will likely save/reuse (emails, code, essays, etc.)\r\n- When explicitly requested to create a document\r\n- For when content contains a single code snippet\r\n\r\n**When NOT to use \\`createDocument\\`:**\r\n- For informational/explanatory content\r\n- For conversational responses\r\n- When asked to keep it in chat\r\n\r\n**Using \\`updateDocument\\`:**\r\n- Default to full document rewrites for major changes\r\n- Use targeted updates only for specific, isolated changes\r\n- Follow user instructions for which parts to modify\r\n\r\n**When NOT to use \\`updateDocument\\`:**\r\n- Immediately after creating a document\r\n\r\nDo not update document right after creating it. Wait for user feedback or request to update it.\r\n`;\r\n\r\nexport const regularPrompt =\r\n  'You are a friendly assistant! Keep your responses concise and helpful.';\r\n\r\nexport interface RequestHints {\r\n  latitude: Geo['latitude'];\r\n  longitude: Geo['longitude'];\r\n  city: Geo['city'];\r\n  country: Geo['country'];\r\n}\r\n\r\nexport const getRequestPromptFromHints = (requestHints: RequestHints) => `\\\r\nAbout the origin of user's request:\r\n- lat: ${requestHints.latitude}\r\n- lon: ${requestHints.longitude}\r\n- city: ${requestHints.city}\r\n- country: ${requestHints.country}\r\n`;\r\n\r\nexport const systemPrompt = ({\r\n  selectedChatModel,\r\n  requestHints,\r\n}: {\r\n  selectedChatModel: string;\r\n  requestHints: RequestHints;\r\n}) => {\r\n  const requestPrompt = getRequestPromptFromHints(requestHints);\r\n\r\n  if (selectedChatModel === 'chat-model-reasoning') {\r\n    return `${regularPrompt}\\n\\n${requestPrompt}`;\r\n  } else {\r\n    return `${regularPrompt}\\n\\n${requestPrompt}\\n\\n${artifactsPrompt}`;\r\n  }\r\n};\r\n\r\nexport const codePrompt = `\r\nYou are a Python code generator that creates self-contained, executable code snippets. When writing code:\r\n\r\n1. Each snippet should be complete and runnable on its own\r\n2. Prefer using print() statements to display outputs\r\n3. Include helpful comments explaining the code\r\n4. Keep snippets concise (generally under 15 lines)\r\n5. Avoid external dependencies - use Python standard library\r\n6. Handle potential errors gracefully\r\n7. Return meaningful output that demonstrates the code's functionality\r\n8. Don't use input() or other interactive functions\r\n9. Don't access files or network resources\r\n10. Don't use infinite loops\r\n\r\nExamples of good snippets:\r\n\r\n# Calculate factorial iteratively\r\ndef factorial(n):\r\n    result = 1\r\n    for i in range(1, n + 1):\r\n        result *= i\r\n    return result\r\n\r\nprint(f\"Factorial of 5 is: {factorial(5)}\")\r\n`;\r\n\r\nexport const sheetPrompt = `\r\nYou are a spreadsheet creation assistant. Create a spreadsheet in csv format based on the given prompt. The spreadsheet should contain meaningful column headers and data.\r\n`;\r\n\r\nexport const updateDocumentPrompt = (\r\n  currentContent: string | null,\r\n  type: ArtifactKind,\r\n) =>\r\n  type === 'text'\r\n    ? `\\\r\nImprove the following contents of the document based on the given prompt.\r\n\r\n${currentContent}\r\n`\r\n    : type === 'code'\r\n      ? `\\\r\nImprove the following code snippet based on the given prompt.\r\n\r\n${currentContent}\r\n`\r\n      : type === 'sheet'\r\n        ? `\\\r\nImprove the following spreadsheet based on the given prompt.\r\n\r\n${currentContent}\r\n`\r\n        : '';\r\n","module.exports = require(\"next/dist/server/app-render/after-task-async-storage.external.js\");","import { fireworks } from \"@ai-sdk/fireworks\";\r\nimport { openai } from \"@ai-sdk/openai\";\r\nimport {\r\n  customProvider,\r\n  extractReasoningMiddleware,\r\n  wrapLanguageModel,\r\n} from \"ai\";\r\n\r\nimport { isTestEnvironment } from \"../constants\";\r\n\r\nimport {\r\n  artifactModel,\r\n  chatModel,\r\n  reasoningModel,\r\n  titleModel,\r\n} from \"./models.test\";\r\n\r\n// Define basic mocks here if in test environment, to avoid importing .test.ts file\r\nlet testChatModel: any = null;\r\nlet testReasoningModel: any = null;\r\nlet testTitleModel: any = null;\r\nlet testArtifactModel: any = null;\r\n\r\nif (isTestEnvironment) {\r\n  // These are simplified mocks. Ideally, proper mocks would be in a separate non-test file.\r\n  const mockModel = (name: string) => ({\r\n    id: `mock-${name}`,\r\n    doGenerate: async () => ({ text: `mock response from ${name}` }),\r\n  });\r\n  testChatModel = mockModel(\"chat\");\r\n  testReasoningModel = mockModel(\"reasoning\");\r\n  testTitleModel = mockModel(\"title\");\r\n  testArtifactModel = mockModel(\"artifact\");\r\n}\r\n\r\nexport const myProvider = isTestEnvironment\r\n  ? customProvider({\r\n      languageModels: {\r\n        \"chat-model-small\": testChatModel,\r\n        \"chat-model-large\": testChatModel, // Using same mock for simplicity\r\n        \"chat-model-reasoning\": testReasoningModel,\r\n        \"title-model\": testTitleModel,\r\n        \"artifact-model\": testArtifactModel,\r\n      },\r\n    })\r\n  : customProvider({\r\n      languageModels: {\r\n        \"chat-model-small\": openai(\"gpt-4o-mini\"),\r\n        \"chat-model-large\": openai(\"gpt-4o\"),\r\n        \"chat-model-reasoning\": wrapLanguageModel({\r\n          model: fireworks(\"accounts/fireworks/models/deepseek-r1\"),\r\n          middleware: extractReasoningMiddleware({ tagName: \"think\" }),\r\n        }),\r\n        \"title-model\": openai(\"gpt-4-turbo\"),\r\n        \"artifact-model\": openai(\"gpt-4o-mini\"),\r\n      },\r\n      imageModels: {\r\n        \"small-model\": openai.image(\"dall-e-2\"),\r\n        \"large-model\": openai.image(\"dall-e-3\"),\r\n      },\r\n    });\r\n","/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\nexport var ConsoleApiName = {\n    log: 'log',\n    debug: 'debug',\n    info: 'info',\n    warn: 'warn',\n    error: 'error',\n};\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport var globalConsole = console;\nexport var originalConsoleMethods = {};\nObject.keys(ConsoleApiName).forEach(function (name) {\n    originalConsoleMethods[name] = globalConsole[name];\n});\nvar PREFIX = 'Datadog Browser SDK:';\nexport var display = {\n    debug: originalConsoleMethods.debug.bind(globalConsole, PREFIX),\n    log: originalConsoleMethods.log.bind(globalConsole, PREFIX),\n    info: originalConsoleMethods.info.bind(globalConsole, PREFIX),\n    warn: originalConsoleMethods.warn.bind(globalConsole, PREFIX),\n    error: originalConsoleMethods.error.bind(globalConsole, PREFIX),\n};\nexport var DOCS_ORIGIN = 'https://docs.datadoghq.com';\nexport var DOCS_TROUBLESHOOTING = \"\".concat(DOCS_ORIGIN, \"/real_user_monitoring/browser/troubleshooting\");\nexport var MORE_DETAILS = 'More details:';\n//# sourceMappingURL=display.js.map","import { display } from './display';\nexport function catchUserErrors(fn, errorMsg) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        try {\n            return fn.apply(void 0, args);\n        }\n        catch (err) {\n            display.error(errorMsg, err);\n        }\n    };\n}\n//# sourceMappingURL=catchUserErrors.js.map","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { display } from './display';\nvar onMonitorErrorCollected;\nvar debugMode = false;\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected) {\n    onMonitorErrorCollected = newOnMonitorErrorCollected;\n}\nexport function setDebugMode(newDebugMode) {\n    debugMode = newDebugMode;\n}\nexport function resetMonitor() {\n    onMonitorErrorCollected = undefined;\n    debugMode = false;\n}\nexport function monitored(_, __, descriptor) {\n    var originalMethod = descriptor.value;\n    descriptor.value = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod;\n        return decorated.apply(this, args);\n    };\n}\nexport function monitor(fn) {\n    return function () {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return callMonitored(fn, this, arguments);\n    }; // consider output type has input type\n}\nexport function callMonitored(fn, context, args) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return fn.apply(context, args);\n    }\n    catch (e) {\n        displayIfDebugEnabled(e);\n        if (onMonitorErrorCollected) {\n            try {\n                onMonitorErrorCollected(e);\n            }\n            catch (e) {\n                displayIfDebugEnabled(e);\n            }\n        }\n    }\n}\nexport function displayIfDebugEnabled() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (debugMode) {\n        display.error.apply(display, __spreadArray(['[MONITOR]'], args, false));\n    }\n}\n//# sourceMappingURL=monitor.js.map","export function includes(candidate, search) {\n    return candidate.indexOf(search) !== -1;\n}\nexport function arrayFrom(arrayLike) {\n    if (Array.from) {\n        return Array.from(arrayLike);\n    }\n    var array = [];\n    if (arrayLike instanceof Set) {\n        arrayLike.forEach(function (item) { return array.push(item); });\n    }\n    else {\n        for (var i = 0; i < arrayLike.length; i++) {\n            array.push(arrayLike[i]);\n        }\n    }\n    return array;\n}\nexport function find(array, predicate) {\n    for (var i = 0; i < array.length; i += 1) {\n        var item = array[i];\n        if (predicate(item, i)) {\n            return item;\n        }\n    }\n    return undefined;\n}\nexport function findLast(array, predicate) {\n    for (var i = array.length - 1; i >= 0; i -= 1) {\n        var item = array[i];\n        if (predicate(item, i, array)) {\n            return item;\n        }\n    }\n    return undefined;\n}\nexport function forEach(list, callback) {\n    Array.prototype.forEach.call(list, callback);\n}\nexport function objectValues(object) {\n    return Object.keys(object).map(function (key) { return object[key]; });\n}\nexport function objectEntries(object) {\n    return Object.keys(object).map(function (key) { return [key, object[key]]; });\n}\nexport function startsWith(candidate, search) {\n    return candidate.slice(0, search.length) === search;\n}\nexport function endsWith(candidate, search) {\n    return candidate.slice(-search.length) === search;\n}\nexport function assign(target) {\n    var toAssign = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        toAssign[_i - 1] = arguments[_i];\n    }\n    toAssign.forEach(function (source) {\n        for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    });\n    return target;\n}\n//# sourceMappingURL=polyfills.js.map","import { catchUserErrors } from '../tools/catchUserErrors';\nimport { setDebugMode } from '../tools/monitor';\nimport { assign } from '../tools/utils/polyfills';\nimport { display } from '../tools/display';\nexport function makePublicApi(stub) {\n    var publicApi = assign({\n        version: \"5.35.1\",\n        // This API method is intentionally not monitored, since the only thing executed is the\n        // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n        // we don't want to interfere with the user uncaught exceptions.\n        onReady: function (callback) {\n            callback();\n        },\n    }, stub);\n    // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n    // as much as possible but of course it's not a real protection.\n    Object.defineProperty(publicApi, '_setDebug', {\n        get: function () {\n            return setDebugMode;\n        },\n        enumerable: false,\n    });\n    return publicApi;\n}\nexport function defineGlobal(global, name, api) {\n    var existingGlobalVariable = global[name];\n    if (existingGlobalVariable && !existingGlobalVariable.q && existingGlobalVariable.version) {\n        display.warn('SDK is loaded more than once. This is unsupported and might have unexpected behavior.');\n    }\n    global[name] = api;\n    if (existingGlobalVariable && existingGlobalVariable.q) {\n        existingGlobalVariable.q.forEach(function (fn) { return catchUserErrors(fn, 'onReady callback threw an error:')(); });\n    }\n}\n//# sourceMappingURL=init.js.map","/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\nexport function getGlobalObject() {\n    if (typeof globalThis === 'object') {\n        return globalThis;\n    }\n    Object.defineProperty(Object.prototype, '_dd_temp_', {\n        get: function () {\n            return this;\n        },\n        configurable: true,\n    });\n    // @ts-ignore _dd_temp is defined using defineProperty\n    var globalObject = _dd_temp_;\n    // @ts-ignore _dd_temp is defined using defineProperty\n    delete Object.prototype._dd_temp_;\n    if (typeof globalObject !== 'object') {\n        // on safari _dd_temp_ is available on window but not globally\n        // fallback on other browser globals check\n        if (typeof self === 'object') {\n            globalObject = self;\n        }\n        else if (typeof window === 'object') {\n            globalObject = window;\n        }\n        else {\n            globalObject = {};\n        }\n    }\n    return globalObject;\n}\n//# sourceMappingURL=getGlobalObject.js.map","export var ONE_KIBI_BYTE = 1024;\nexport var ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE;\n// eslint-disable-next-line no-control-regex\nvar HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/;\nexport function computeBytesCount(candidate) {\n    // Accurate bytes count computations can degrade performances when there is a lot of events to process\n    if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n        return candidate.length;\n    }\n    if (window.TextEncoder !== undefined) {\n        return new TextEncoder().encode(candidate).length;\n    }\n    return new Blob([candidate]).size;\n}\nexport function concatBuffers(buffers) {\n    var length = buffers.reduce(function (total, buffer) { return total + buffer.length; }, 0);\n    var result = new Uint8Array(length);\n    var offset = 0;\n    for (var _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {\n        var buffer = buffers_1[_i];\n        result.set(buffer, offset);\n        offset += buffer.length;\n    }\n    return result;\n}\n//# sourceMappingURL=byteUtils.js.map","import { getGlobalObject } from './getGlobalObject';\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue(target, name) {\n    var browserWindow = getGlobalObject();\n    var original;\n    if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n        original = target[browserWindow.Zone.__symbol__(name)];\n    }\n    if (!original) {\n        original = target[name];\n    }\n    return original;\n}\n//# sourceMappingURL=getZoneJsOriginalValue.js.map","import { getZoneJsOriginalValue } from './getZoneJsOriginalValue';\nimport { monitor } from './monitor';\nimport { getGlobalObject } from './getGlobalObject';\nexport function setTimeout(callback, delay) {\n    return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay);\n}\nexport function clearTimeout(timeoutId) {\n    getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId);\n}\nexport function setInterval(callback, delay) {\n    return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay);\n}\nexport function clearInterval(timeoutId) {\n    getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId);\n}\n//# sourceMappingURL=timer.js.map","import { setTimeout, clearTimeout } from '../timer';\n// use lodash API\nexport function throttle(fn, wait, options) {\n    var needLeadingExecution = options && options.leading !== undefined ? options.leading : true;\n    var needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true;\n    var inWaitPeriod = false;\n    var pendingExecutionWithParameters;\n    var pendingTimeoutId;\n    return {\n        throttled: function () {\n            var parameters = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                parameters[_i] = arguments[_i];\n            }\n            if (inWaitPeriod) {\n                pendingExecutionWithParameters = parameters;\n                return;\n            }\n            if (needLeadingExecution) {\n                fn.apply(void 0, parameters);\n            }\n            else {\n                pendingExecutionWithParameters = parameters;\n            }\n            inWaitPeriod = true;\n            pendingTimeoutId = setTimeout(function () {\n                if (needTrailingExecution && pendingExecutionWithParameters) {\n                    fn.apply(void 0, pendingExecutionWithParameters);\n                }\n                inWaitPeriod = false;\n                pendingExecutionWithParameters = undefined;\n            }, wait);\n        },\n        cancel: function () {\n            clearTimeout(pendingTimeoutId);\n            inWaitPeriod = false;\n            pendingExecutionWithParameters = undefined;\n        },\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() { }\n//# sourceMappingURL=functionUtils.js.map","import { noop } from '../utils/functionUtils';\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(value, replacer, space) {\n    if (typeof value !== 'object' || value === null) {\n        return JSON.stringify(value);\n    }\n    // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n    // subclasses.\n    var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);\n    var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);\n    var restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value));\n    var restoreValueToJson = detachToJsonMethod(value);\n    try {\n        return JSON.stringify(value, replacer, space);\n    }\n    catch (_a) {\n        return '<error: unable to serialize object>';\n    }\n    finally {\n        restoreObjectPrototypeToJson();\n        restoreArrayPrototypeToJson();\n        restoreValuePrototypeToJson();\n        restoreValueToJson();\n    }\n}\nexport function detachToJsonMethod(value) {\n    var object = value;\n    var objectToJson = object.toJSON;\n    if (objectToJson) {\n        delete object.toJSON;\n        return function () {\n            object.toJSON = objectToJson;\n        };\n    }\n    return noop;\n}\n//# sourceMappingURL=jsonStringify.js.map","import { assign } from './polyfills';\nexport function shallowClone(object) {\n    return assign({}, object);\n}\nexport function objectHasValue(object, value) {\n    return Object.keys(object).some(function (key) { return object[key] === value; });\n}\nexport function isEmptyObject(object) {\n    return Object.keys(object).length === 0;\n}\nexport function mapValues(object, fn) {\n    var newObject = {};\n    for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {\n        var key = _a[_i];\n        newObject[key] = fn(object[key]);\n    }\n    return newObject;\n}\n//# sourceMappingURL=objectUtils.js.map","import { ONE_KIBI_BYTE, computeBytesCount } from '../../tools/utils/byteUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../../tools/display';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport var CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE;\n// We observed that the compression ratio is around 8 in general, but we also want to keep a margin\n// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB\n// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this\n// is a bit arbitrary.\nexport var CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * ONE_KIBI_BYTE;\nexport var BYTES_COMPUTATION_THROTTLING_DELAY = 200;\nexport function createCustomerDataTrackerManager(compressionStatus) {\n    if (compressionStatus === void 0) { compressionStatus = 2 /* CustomerDataCompressionStatus.Disabled */; }\n    var customerDataTrackers = new Map();\n    var alreadyWarned = false;\n    function checkCustomerDataLimit(initialBytesCount) {\n        if (initialBytesCount === void 0) { initialBytesCount = 0; }\n        if (alreadyWarned || compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n            return;\n        }\n        var bytesCountLimit = compressionStatus === 2 /* CustomerDataCompressionStatus.Disabled */\n            ? CUSTOMER_DATA_BYTES_LIMIT\n            : CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT;\n        var bytesCount = initialBytesCount;\n        customerDataTrackers.forEach(function (tracker) {\n            bytesCount += tracker.getBytesCount();\n        });\n        if (bytesCount > bytesCountLimit) {\n            displayCustomerDataLimitReachedWarning(bytesCountLimit);\n            alreadyWarned = true;\n        }\n    }\n    return {\n        /**\n         * Creates a detached tracker. The manager will not store a reference to that tracker, and the\n         * bytes count will be counted independently from other detached trackers.\n         *\n         * This is particularly useful when we don't know when the tracker will be unused, so we don't\n         * leak memory (ex: when used in Logger instances).\n         */\n        createDetachedTracker: function () {\n            var tracker = createCustomerDataTracker(function () { return checkCustomerDataLimit(tracker.getBytesCount()); });\n            return tracker;\n        },\n        /**\n         * Creates a tracker if it doesn't exist, and returns it.\n         */\n        getOrCreateTracker: function (type) {\n            if (!customerDataTrackers.has(type)) {\n                customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit));\n            }\n            return customerDataTrackers.get(type);\n        },\n        setCompressionStatus: function (newCompressionStatus) {\n            if (compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n                compressionStatus = newCompressionStatus;\n                checkCustomerDataLimit();\n            }\n        },\n        getCompressionStatus: function () { return compressionStatus; },\n        stop: function () {\n            customerDataTrackers.forEach(function (tracker) { return tracker.stop(); });\n            customerDataTrackers.clear();\n        },\n    };\n}\nexport function createCustomerDataTracker(checkCustomerDataLimit) {\n    var bytesCountCache = 0;\n    // Throttle the bytes computation to minimize the impact on performance.\n    // Especially useful if the user call context APIs synchronously multiple times in a row\n    var _a = throttle(function (context) {\n        bytesCountCache = computeBytesCount(jsonStringify(context));\n        checkCustomerDataLimit();\n    }, BYTES_COMPUTATION_THROTTLING_DELAY), computeBytesCountThrottled = _a.throttled, cancelComputeBytesCount = _a.cancel;\n    var resetBytesCount = function () {\n        cancelComputeBytesCount();\n        bytesCountCache = 0;\n    };\n    return {\n        updateCustomerData: function (context) {\n            if (isEmptyObject(context)) {\n                resetBytesCount();\n            }\n            else {\n                computeBytesCountThrottled(context);\n            }\n        },\n        resetCustomerData: resetBytesCount,\n        getBytesCount: function () { return bytesCountCache; },\n        stop: function () {\n            cancelComputeBytesCount();\n        },\n    };\n}\nfunction displayCustomerDataLimitReachedWarning(bytesCountLimit) {\n    display.warn(\"Customer data exceeds the recommended \".concat(bytesCountLimit / ONE_KIBI_BYTE, \"KiB threshold. \").concat(MORE_DETAILS, \" \").concat(DOCS_TROUBLESHOOTING, \"/#customer-data-exceeds-the-recommended-threshold-warning\"));\n}\n//# sourceMappingURL=customerDataTracker.js.map","/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value) {\n    if (value === null) {\n        return 'null';\n    }\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n    return typeof value;\n}\n//# sourceMappingURL=typeUtils.js.map","import { getType } from './utils/typeUtils';\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto(destination, source, circularReferenceChecker) {\n    if (circularReferenceChecker === void 0) { circularReferenceChecker = createCircularReferenceChecker(); }\n    // ignore the source if it is undefined\n    if (source === undefined) {\n        return destination;\n    }\n    if (typeof source !== 'object' || source === null) {\n        // primitive values - just return source\n        return source;\n    }\n    else if (source instanceof Date) {\n        return new Date(source.getTime());\n    }\n    else if (source instanceof RegExp) {\n        var flags = source.flags ||\n            // old browsers compatibility\n            [\n                source.global ? 'g' : '',\n                source.ignoreCase ? 'i' : '',\n                source.multiline ? 'm' : '',\n                source.sticky ? 'y' : '',\n                source.unicode ? 'u' : '',\n            ].join('');\n        return new RegExp(source.source, flags);\n    }\n    if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n        // remove circular references\n        return undefined;\n    }\n    else if (Array.isArray(source)) {\n        var merged_1 = Array.isArray(destination) ? destination : [];\n        for (var i = 0; i < source.length; ++i) {\n            merged_1[i] = mergeInto(merged_1[i], source[i], circularReferenceChecker);\n        }\n        return merged_1;\n    }\n    var merged = getType(destination) === 'object' ? destination : {};\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);\n        }\n    }\n    return merged;\n}\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone(value) {\n    return mergeInto(undefined, value);\n}\nexport function combine() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    var destination;\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n        var source = sources_1[_a];\n        // Ignore any undefined or null sources.\n        if (source === undefined || source === null) {\n            continue;\n        }\n        destination = mergeInto(destination, source);\n    }\n    return destination;\n}\nfunction createCircularReferenceChecker() {\n    if (typeof WeakSet !== 'undefined') {\n        var set_1 = new WeakSet();\n        return {\n            hasAlreadyBeenSeen: function (value) {\n                var has = set_1.has(value);\n                if (!has) {\n                    set_1.add(value);\n                }\n                return has;\n            },\n        };\n    }\n    var array = [];\n    return {\n        hasAlreadyBeenSeen: function (value) {\n            var has = array.indexOf(value) >= 0;\n            if (!has) {\n                array.push(value);\n            }\n            return has;\n        },\n    };\n}\n//# sourceMappingURL=mergeInto.js.map","import { display } from '../display';\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils';\nimport { detachToJsonMethod } from './jsonStringify';\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nvar SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE;\n// Symbol for the root element of the JSONPath used for visited objects\nvar JSON_PATH_ROOT_ELEMENT = '$';\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nvar KEY_DECORATION_LENGTH = 3;\nexport function sanitize(source, maxCharacterCount) {\n    if (maxCharacterCount === void 0) { maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT; }\n    // Unbind any toJSON function we may have on [] or {} prototypes\n    var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);\n    var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);\n    // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n    var containerQueue = [];\n    var visitedObjectsWithPath = new WeakMap();\n    var sanitizedData = sanitizeProcessor(source, JSON_PATH_ROOT_ELEMENT, undefined, containerQueue, visitedObjectsWithPath);\n    var serializedSanitizedData = JSON.stringify(sanitizedData);\n    var accumulatedCharacterCount = serializedSanitizedData ? serializedSanitizedData.length : 0;\n    if (accumulatedCharacterCount > maxCharacterCount) {\n        warnOverCharacterLimit(maxCharacterCount, 'discarded', source);\n        return undefined;\n    }\n    while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n        var containerToProcess = containerQueue.shift();\n        var separatorLength = 0; // 0 for the first element, 1 for subsequent elements\n        // Arrays and Objects have to be handled distinctly to ensure\n        // we do not pick up non-numerical properties from Arrays\n        if (Array.isArray(containerToProcess.source)) {\n            for (var key = 0; key < containerToProcess.source.length; key++) {\n                var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n                if (targetData !== undefined) {\n                    accumulatedCharacterCount += JSON.stringify(targetData).length;\n                }\n                else {\n                    // When an element of an Array (targetData) is undefined, it is serialized as null:\n                    // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n                    accumulatedCharacterCount += 4;\n                }\n                accumulatedCharacterCount += separatorLength;\n                separatorLength = 1;\n                if (accumulatedCharacterCount > maxCharacterCount) {\n                    warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n                    break;\n                }\n                ;\n                containerToProcess.target[key] = targetData;\n            }\n        }\n        else {\n            for (var key in containerToProcess.source) {\n                if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n                    var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n                    // When a property of an object has an undefined value, it will be dropped during serialization:\n                    // JSON.stringify({a:undefined}) => '{}'\n                    if (targetData !== undefined) {\n                        accumulatedCharacterCount +=\n                            JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH;\n                        separatorLength = 1;\n                    }\n                    if (accumulatedCharacterCount > maxCharacterCount) {\n                        warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n                        break;\n                    }\n                    ;\n                    containerToProcess.target[key] = targetData;\n                }\n            }\n        }\n    }\n    // Rebind detached toJSON functions\n    restoreObjectPrototypeToJson();\n    restoreArrayPrototypeToJson();\n    return sanitizedData;\n}\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(source, parentPath, key, queue, visitedObjectsWithPath) {\n    // Start by handling toJSON, as we want to sanitize its output\n    var sourceToSanitize = tryToApplyToJSON(source);\n    if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n        return sanitizePrimitivesAndFunctions(sourceToSanitize);\n    }\n    var sanitizedSource = sanitizeObjects(sourceToSanitize);\n    if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n        return sanitizedSource;\n    }\n    // Handle potential cyclic references\n    // We need to use source as sourceToSanitize could be a reference to a new object\n    // At this stage, we know the source is an object type\n    var sourceAsObject = source;\n    if (visitedObjectsWithPath.has(sourceAsObject)) {\n        return \"[Reference seen at \".concat(visitedObjectsWithPath.get(sourceAsObject), \"]\");\n    }\n    // Add processed source to queue\n    var currentPath = key !== undefined ? \"\".concat(parentPath, \".\").concat(key) : parentPath;\n    var target = Array.isArray(sourceToSanitize) ? [] : {};\n    visitedObjectsWithPath.set(sourceAsObject, currentPath);\n    queue.push({ source: sourceToSanitize, target: target, path: currentPath });\n    return target;\n}\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value) {\n    // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n    if (typeof value === 'bigint') {\n        return \"[BigInt] \".concat(value.toString());\n    }\n    // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n    // so it won't prevent stringify from serializing later\n    if (typeof value === 'function') {\n        return \"[Function] \".concat(value.name || 'unknown');\n    }\n    // JSON.stringify() does not serialize symbols.\n    if (typeof value === 'symbol') {\n        return \"[Symbol] \".concat(value.description || value.toString());\n    }\n    return value;\n}\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value) {\n    try {\n        // Handle events - Keep a simple implementation to avoid breaking changes\n        if (value instanceof Event) {\n            return {\n                isTrusted: value.isTrusted,\n            };\n        }\n        // Handle all remaining object types in a generic way\n        var result = Object.prototype.toString.call(value);\n        var match = result.match(/\\[object (.*)\\]/);\n        if (match && match[1]) {\n            return \"[\".concat(match[1], \"]\");\n        }\n    }\n    catch (_a) {\n        // If the previous serialization attempts failed, and we cannot convert using\n        // Object.prototype.toString, declare the value unserializable\n    }\n    return '[Unserializable]';\n}\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value) {\n    var object = value;\n    if (object && typeof object.toJSON === 'function') {\n        try {\n            return object.toJSON();\n        }\n        catch (_a) {\n            // If toJSON fails, we continue by trying to serialize the value manually\n        }\n    }\n    return value;\n}\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount, changeType, source) {\n    display.warn(\"The data provided has been \".concat(changeType, \" as it is over the limit of \").concat(maxCharacterCount, \" characters:\"), source);\n}\n//# sourceMappingURL=sanitize.js.map","// eslint-disable-next-line no-restricted-syntax\nvar Observable = /** @class */ (function () {\n    function Observable(onFirstSubscribe) {\n        this.onFirstSubscribe = onFirstSubscribe;\n        this.observers = [];\n    }\n    Observable.prototype.subscribe = function (f) {\n        var _this = this;\n        this.observers.push(f);\n        if (this.observers.length === 1 && this.onFirstSubscribe) {\n            this.onLastUnsubscribe = this.onFirstSubscribe(this) || undefined;\n        }\n        return {\n            unsubscribe: function () {\n                _this.observers = _this.observers.filter(function (other) { return f !== other; });\n                if (!_this.observers.length && _this.onLastUnsubscribe) {\n                    _this.onLastUnsubscribe();\n                }\n            },\n        };\n    };\n    Observable.prototype.notify = function (data) {\n        this.observers.forEach(function (observer) { return observer(data); });\n    };\n    return Observable;\n}());\nexport { Observable };\nexport function mergeObservables() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return new Observable(function (globalObservable) {\n        var subscriptions = observables.map(function (observable) {\n            return observable.subscribe(function (data) { return globalObservable.notify(data); });\n        });\n        return function () { return subscriptions.forEach(function (subscription) { return subscription.unsubscribe(); }); };\n    });\n}\n//# sourceMappingURL=observable.js.map","import { deepClone } from '../../tools/mergeInto';\nimport { getType } from '../../tools/utils/typeUtils';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { Observable } from '../../tools/observable';\nexport function createContextManager(customerDataTracker) {\n    var context = {};\n    var changeObservable = new Observable();\n    var contextManager = {\n        getContext: function () { return deepClone(context); },\n        setContext: function (newContext) {\n            if (getType(newContext) === 'object') {\n                context = sanitize(newContext);\n                customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            }\n            else {\n                contextManager.clearContext();\n            }\n            changeObservable.notify();\n        },\n        setContextProperty: function (key, property) {\n            context[key] = sanitize(property);\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            changeObservable.notify();\n        },\n        removeContextProperty: function (key) {\n            delete context[key];\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            changeObservable.notify();\n        },\n        clearContext: function () {\n            context = {};\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.resetCustomerData();\n            changeObservable.notify();\n        },\n        changeObservable: changeObservable,\n    };\n    return contextManager;\n}\n//# sourceMappingURL=contextManager.js.map","import { Observable } from '../tools/observable';\nexport var TrackingConsent = {\n    GRANTED: 'granted',\n    NOT_GRANTED: 'not-granted',\n};\nexport function createTrackingConsentState(currentConsent) {\n    var observable = new Observable();\n    return {\n        tryToInit: function (trackingConsent) {\n            if (!currentConsent) {\n                currentConsent = trackingConsent;\n            }\n        },\n        update: function (trackingConsent) {\n            currentConsent = trackingConsent;\n            observable.notify();\n        },\n        isGranted: function () {\n            return currentConsent === TrackingConsent.GRANTED;\n        },\n        observable: observable,\n    };\n}\n//# sourceMappingURL=trackingConsent.js.map","import { monitor } from '../tools/monitor';\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue';\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener(configuration, eventTarget, eventName, listener, options) {\n    return addEventListeners(configuration, eventTarget, [eventName], listener, options);\n}\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners(configuration, eventTarget, eventNames, listener, _a) {\n    var _b = _a === void 0 ? {} : _a, once = _b.once, capture = _b.capture, passive = _b.passive;\n    var listenerWithMonitor = monitor(function (event) {\n        if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n            return;\n        }\n        if (once) {\n            stop();\n        }\n        listener(event);\n    });\n    var options = passive ? { capture: capture, passive: passive } : capture;\n    // Use the window.EventTarget.prototype when possible to avoid wrong overrides (e.g: https://github.com/salesforce/lwc/issues/1824)\n    var listenerTarget = window.EventTarget && eventTarget instanceof EventTarget ? window.EventTarget.prototype : eventTarget;\n    var add = getZoneJsOriginalValue(listenerTarget, 'addEventListener');\n    eventNames.forEach(function (eventName) { return add.call(eventTarget, eventName, listenerWithMonitor, options); });\n    function stop() {\n        var remove = getZoneJsOriginalValue(listenerTarget, 'removeEventListener');\n        eventNames.forEach(function (eventName) { return remove.call(eventTarget, eventName, listenerWithMonitor, options); });\n    }\n    return {\n        stop: stop,\n    };\n}\n//# sourceMappingURL=addEventListener.js.map","import { addEventListener } from '../../browser/addEventListener';\nimport { combine } from '../../tools/mergeInto';\nvar CONTEXT_STORE_KEY_PREFIX = '_dd_c';\nvar storageListeners = [];\nexport function storeContextManager(configuration, contextManager, productKey, customerDataType) {\n    var storageKey = buildStorageKey(productKey, customerDataType);\n    storageListeners.push(addEventListener(configuration, window, \"storage\" /* DOM_EVENT.STORAGE */, function (_a) {\n        var key = _a.key;\n        if (storageKey === key) {\n            synchronizeWithStorage();\n        }\n    }));\n    contextManager.changeObservable.subscribe(dumpToStorage);\n    contextManager.setContext(combine(getFromStorage(), contextManager.getContext()));\n    function synchronizeWithStorage() {\n        contextManager.setContext(getFromStorage());\n    }\n    function dumpToStorage() {\n        localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()));\n    }\n    function getFromStorage() {\n        var rawContext = localStorage.getItem(storageKey);\n        return rawContext !== null ? JSON.parse(rawContext) : {};\n    }\n}\nexport function buildStorageKey(productKey, customerDataType) {\n    return \"\".concat(CONTEXT_STORE_KEY_PREFIX, \"_\").concat(productKey, \"_\").concat(customerDataType);\n}\nexport function removeStorageListeners() {\n    storageListeners.map(function (listener) { return listener.stop(); });\n}\n//# sourceMappingURL=storeContextManager.js.map","import { computeBytesCount } from './utils/byteUtils';\nexport function createIdentityEncoder() {\n    var output = '';\n    var outputBytesCount = 0;\n    return {\n        isAsync: false,\n        get isEmpty() {\n            return !output;\n        },\n        write: function (data, callback) {\n            var additionalEncodedBytesCount = computeBytesCount(data);\n            outputBytesCount += additionalEncodedBytesCount;\n            output += data;\n            if (callback) {\n                callback(additionalEncodedBytesCount);\n            }\n        },\n        finish: function (callback) {\n            callback(this.finishSync());\n        },\n        finishSync: function () {\n            var result = {\n                output: output,\n                outputBytesCount: outputBytesCount,\n                rawBytesCount: outputBytesCount,\n                pendingData: '',\n            };\n            output = '';\n            outputBytesCount = 0;\n            return result;\n        },\n        estimateEncodedBytesCount: function (data) {\n            return data.length;\n        },\n    };\n}\n//# sourceMappingURL=encoder.js.map","/**\n * Cross-browser stack trace computation.\n *\n * Reference implementation: https://github.com/csnover/TraceKit/blob/04530298073c3823de72deb0b97e7b38ca7bcb59/tracekit.js\n */\nimport { startsWith } from '../utils/polyfills';\nvar UNKNOWN_FUNCTION = '?';\nexport function computeStackTrace(ex) {\n    var stack = [];\n    var stackProperty = tryToGetString(ex, 'stack');\n    var exString = String(ex);\n    if (stackProperty && startsWith(stackProperty, exString)) {\n        stackProperty = stackProperty.slice(exString.length);\n    }\n    if (stackProperty) {\n        stackProperty.split('\\n').forEach(function (line) {\n            var stackFrame = parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line);\n            if (stackFrame) {\n                if (!stackFrame.func && stackFrame.line) {\n                    stackFrame.func = UNKNOWN_FUNCTION;\n                }\n                stack.push(stackFrame);\n            }\n        });\n    }\n    return {\n        message: tryToGetString(ex, 'message'),\n        name: tryToGetString(ex, 'name'),\n        stack: stack,\n    };\n}\nvar fileUrl = '((?:file|https?|blob|chrome-extension|electron|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)';\nvar filePosition = '(?::(\\\\d+))';\nvar CHROME_LINE_RE = new RegExp(\"^\\\\s*at (.*?) ?\\\\(\".concat(fileUrl).concat(filePosition, \"?\").concat(filePosition, \"?\\\\)?\\\\s*$\"), 'i');\nvar CHROME_EVAL_RE = new RegExp(\"\\\\((\\\\S*)\".concat(filePosition).concat(filePosition, \"\\\\)\"));\nfunction parseChromeLine(line) {\n    var parts = CHROME_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n    var submatch = CHROME_EVAL_RE.exec(parts[2]);\n    if (isEval && submatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = submatch[1]; // url\n        parts[3] = submatch[2]; // line\n        parts[4] = submatch[3]; // column\n    }\n    return {\n        args: isNative ? [parts[2]] : [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[3] ? +parts[3] : undefined,\n        url: !isNative ? parts[2] : undefined,\n    };\n}\nvar CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(\"^\\\\s*at ?\".concat(fileUrl).concat(filePosition, \"?\").concat(filePosition, \"??\\\\s*$\"), 'i');\nfunction parseChromeAnonymousLine(line) {\n    var parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    return {\n        args: [],\n        column: parts[3] ? +parts[3] : undefined,\n        func: UNKNOWN_FUNCTION,\n        line: parts[2] ? +parts[2] : undefined,\n        url: parts[1],\n    };\n}\nvar WINJS_LINE_RE = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nfunction parseWinLine(line) {\n    var parts = WINJS_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    return {\n        args: [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: +parts[3],\n        url: parts[2],\n    };\n}\nvar GECKO_LINE_RE = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nfunction parseGeckoLine(line) {\n    var parts = GECKO_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    var submatch = GECKO_EVAL_RE.exec(parts[3]);\n    if (isEval && submatch) {\n        // throw out eval line/column and use top-most line number\n        parts[3] = submatch[1];\n        parts[4] = submatch[2];\n        parts[5] = undefined; // no column when eval\n    }\n    return {\n        args: parts[2] ? parts[2].split(',') : [],\n        column: parts[5] ? +parts[5] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[4] ? +parts[4] : undefined,\n        url: parts[3],\n    };\n}\nfunction tryToGetString(candidate, property) {\n    if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n        return undefined;\n    }\n    var value = candidate[property];\n    return typeof value === 'string' ? value : undefined;\n}\nexport function computeStackTraceFromOnErrorMessage(messageObj, url, line, column) {\n    var stack = [{ url: url, column: column, line: line }];\n    var _a = tryToParseMessage(messageObj), name = _a.name, message = _a.message;\n    return {\n        name: name,\n        message: message,\n        stack: stack,\n    };\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/;\nfunction tryToParseMessage(messageObj) {\n    var _a;\n    var name;\n    var message;\n    if ({}.toString.call(messageObj) === '[object String]') {\n        ;\n        _a = ERROR_TYPES_RE.exec(messageObj), name = _a[1], message = _a[2];\n    }\n    return { name: name, message: message };\n}\n//# sourceMappingURL=computeStackTrace.js.map","import { callMonitored } from '../monitor';\nimport { noop } from '../utils/functionUtils';\nimport { computeStackTrace } from './computeStackTrace';\n/**\n * Creates a stacktrace without SDK internal frames.\n * Constraints:\n * - Has to be called at the utmost position of the call stack.\n * - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack() {\n    /**\n     * Skip the two internal frames:\n     * - SDK API (console.error, ...)\n     * - this function\n     * in order to keep only the user calls\n     */\n    var internalFramesToSkip = 2;\n    var error = new Error();\n    var formattedStack;\n    // IE needs to throw the error to fill in the stack trace\n    if (!error.stack) {\n        try {\n            throw error;\n        }\n        catch (_a) {\n            noop();\n        }\n    }\n    callMonitored(function () {\n        var stackTrace = computeStackTrace(error);\n        stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);\n        formattedStack = toStackTraceString(stackTrace);\n    });\n    return formattedStack;\n}\nexport function toStackTraceString(stack) {\n    var result = formatErrorMessage(stack);\n    stack.stack.forEach(function (frame) {\n        var func = frame.func === '?' ? '<anonymous>' : frame.func;\n        var args = frame.args && frame.args.length > 0 ? \"(\".concat(frame.args.join(', '), \")\") : '';\n        var line = frame.line ? \":\".concat(frame.line) : '';\n        var column = frame.line && frame.column ? \":\".concat(frame.column) : '';\n        result += \"\\n  at \".concat(func).concat(args, \" @ \").concat(frame.url).concat(line).concat(column);\n    });\n    return result;\n}\nexport function formatErrorMessage(stack) {\n    return \"\".concat(stack.name || 'Error', \": \").concat(stack.message);\n}\n//# sourceMappingURL=handlingStack.js.map","import { sanitize } from '../../tools/serialisation/sanitize';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nexport var NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error';\nexport function computeRawError(_a) {\n    var stackTrace = _a.stackTrace, originalError = _a.originalError, handlingStack = _a.handlingStack, startClocks = _a.startClocks, nonErrorPrefix = _a.nonErrorPrefix, source = _a.source, handling = _a.handling;\n    var isErrorInstance = isError(originalError);\n    var message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError);\n    var stack = hasUsableStack(isErrorInstance, stackTrace)\n        ? toStackTraceString(stackTrace)\n        : NO_ERROR_STACK_PRESENT_MESSAGE;\n    var causes = isErrorInstance ? flattenErrorCauses(originalError, source) : undefined;\n    var type = stackTrace ? stackTrace.name : undefined;\n    var fingerprint = tryToGetFingerprint(originalError);\n    return {\n        startClocks: startClocks,\n        source: source,\n        handling: handling,\n        handlingStack: handlingStack,\n        originalError: originalError,\n        type: type,\n        message: message,\n        stack: stack,\n        causes: causes,\n        fingerprint: fingerprint,\n    };\n}\nfunction computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError) {\n    // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n    // TODO rework tracekit integration to avoid scattering error building logic\n    return (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.message) && (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name)\n        ? stackTrace.message\n        : !isErrorInstance\n            ? \"\".concat(nonErrorPrefix, \" \").concat(jsonStringify(sanitize(originalError)))\n            : 'Empty message';\n}\nfunction hasUsableStack(isErrorInstance, stackTrace) {\n    if (stackTrace === undefined) {\n        return false;\n    }\n    if (isErrorInstance) {\n        return true;\n    }\n    // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n    // TODO rework tracekit integration to avoid generating those unusable stack\n    return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined);\n}\nexport function tryToGetFingerprint(originalError) {\n    return isError(originalError) && 'dd_fingerprint' in originalError ? String(originalError.dd_fingerprint) : undefined;\n}\nexport function getFileFromStackTraceString(stack) {\n    var _a;\n    return (_a = /@ (.+)/.exec(stack)) === null || _a === void 0 ? void 0 : _a[1];\n}\nexport function isError(error) {\n    return error instanceof Error || Object.prototype.toString.call(error) === '[object Error]';\n}\nexport function flattenErrorCauses(error, parentSource) {\n    var currentError = error;\n    var causes = [];\n    while (isError(currentError === null || currentError === void 0 ? void 0 : currentError.cause) && causes.length < 10) {\n        var stackTrace = computeStackTrace(currentError.cause);\n        causes.push({\n            message: currentError.cause.message,\n            source: parentSource,\n            type: stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name,\n            stack: stackTrace && toStackTraceString(stackTrace),\n        });\n        currentError = currentError.cause;\n    }\n    return causes.length ? causes : undefined;\n}\n//# sourceMappingURL=error.js.map","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\nimport { objectHasValue } from './utils/objectUtils';\n// eslint-disable-next-line no-restricted-syntax\nexport var ExperimentalFeature;\n(function (ExperimentalFeature) {\n    ExperimentalFeature[\"WRITABLE_RESOURCE_GRAPHQL\"] = \"writable_resource_graphql\";\n    ExperimentalFeature[\"REMOTE_CONFIGURATION\"] = \"remote_configuration\";\n    ExperimentalFeature[\"LONG_ANIMATION_FRAME\"] = \"long_animation_frame\";\n    ExperimentalFeature[\"ANONYMOUS_USER_TRACKING\"] = \"anonymous_user_tracking\";\n    ExperimentalFeature[\"ACTION_NAME_MASKING\"] = \"action_name_masking\";\n    ExperimentalFeature[\"CONSISTENT_TRACE_SAMPLING\"] = \"consistent_trace_sampling\";\n    ExperimentalFeature[\"DELAY_VIEWPORT_COLLECTION\"] = \"delay_viewport_collection\";\n})(ExperimentalFeature || (ExperimentalFeature = {}));\nvar enabledExperimentalFeatures = new Set();\nexport function initFeatureFlags(enableExperimentalFeatures) {\n    if (Array.isArray(enableExperimentalFeatures)) {\n        addExperimentalFeatures(enableExperimentalFeatures.filter(function (flag) {\n            return objectHasValue(ExperimentalFeature, flag);\n        }));\n    }\n}\nexport function addExperimentalFeatures(enabledFeatures) {\n    enabledFeatures.forEach(function (flag) {\n        enabledExperimentalFeatures.add(flag);\n    });\n}\nexport function isExperimentalFeatureEnabled(featureName) {\n    return enabledExperimentalFeatures.has(featureName);\n}\nexport function resetExperimentalFeatures() {\n    enabledExperimentalFeatures.clear();\n}\nexport function getExperimentalFeatures() {\n    return enabledExperimentalFeatures;\n}\n//# sourceMappingURL=experimentalFeatures.js.map","export var INTAKE_SITE_STAGING = 'datad0g.com';\nexport var INTAKE_SITE_FED_STAGING = 'dd0g-gov.com';\nexport var INTAKE_SITE_US1 = 'datadoghq.com';\nexport var INTAKE_SITE_EU1 = 'datadoghq.eu';\nexport var INTAKE_SITE_US1_FED = 'ddog-gov.com';\nexport var PCI_INTAKE_HOST_US1 = 'pci.browser-intake-datadoghq.com';\nexport var INTAKE_URL_PARAMETERS = ['ddsource', 'ddtags'];\n//# sourceMappingURL=intakeSites.js.map","/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold) {\n    return threshold !== 0 && Math.random() * 100 <= threshold;\n}\nexport function round(num, decimals) {\n    return +num.toFixed(decimals);\n}\nexport function isPercentage(value) {\n    return isNumber(value) && value >= 0 && value <= 100;\n}\nexport function isNumber(value) {\n    return typeof value === 'number';\n}\n//# sourceMappingURL=numberUtils.js.map","import { isNumber, round } from './numberUtils';\nexport var ONE_SECOND = 1000;\nexport var ONE_MINUTE = 60 * ONE_SECOND;\nexport var ONE_HOUR = 60 * ONE_MINUTE;\nexport var ONE_DAY = 24 * ONE_HOUR;\nexport var ONE_YEAR = 365 * ONE_DAY;\nexport function relativeToClocks(relative) {\n    return { relative: relative, timeStamp: getCorrectedTimeStamp(relative) };\n}\nexport function timeStampToClocks(timeStamp) {\n    return { relative: getRelativeTime(timeStamp), timeStamp: timeStamp };\n}\nfunction getCorrectedTimeStamp(relativeTime) {\n    var correctedOrigin = (dateNow() - performance.now());\n    // apply correction only for positive drift\n    if (correctedOrigin > getNavigationStart()) {\n        return Math.round(addDuration(correctedOrigin, relativeTime));\n    }\n    return getTimeStamp(relativeTime);\n}\nexport function currentDrift() {\n    return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now()));\n}\nexport function toServerDuration(duration) {\n    if (!isNumber(duration)) {\n        return duration;\n    }\n    return round(duration * 1e6, 0);\n}\nexport function dateNow() {\n    // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n    // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n    // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n    // case ourselves.\n    // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n    return new Date().getTime();\n}\nexport function timeStampNow() {\n    return dateNow();\n}\nexport function relativeNow() {\n    return performance.now();\n}\nexport function clocksNow() {\n    return { relative: relativeNow(), timeStamp: timeStampNow() };\n}\nexport function clocksOrigin() {\n    return { relative: 0, timeStamp: getNavigationStart() };\n}\nexport function elapsed(start, end) {\n    return (end - start);\n}\nexport function addDuration(a, b) {\n    return a + b;\n}\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp) {\n    return (timestamp - getNavigationStart());\n}\nexport function getTimeStamp(relativeTime) {\n    return Math.round(addDuration(getNavigationStart(), relativeTime));\n}\nexport function looksLikeRelativeTime(time) {\n    return time < ONE_YEAR;\n}\n/**\n * Navigation start slightly change on some rare cases\n */\nvar navigationStart;\nfunction getNavigationStart() {\n    if (navigationStart === undefined) {\n        navigationStart = performance.timing.navigationStart;\n    }\n    return navigationStart;\n}\n//# sourceMappingURL=timeUtils.js.map","export function sendToExtension(type, payload) {\n    var callback = window.__ddBrowserSdkExtensionCallback;\n    if (callback) {\n        callback({ type: type, payload: payload });\n    }\n}\n//# sourceMappingURL=sendToExtension.js.map","export function getConnectivity() {\n    var _a;\n    var navigator = window.navigator;\n    return {\n        status: navigator.onLine ? 'connected' : 'not_connected',\n        interfaces: navigator.connection && navigator.connection.type ? [navigator.connection.type] : undefined,\n        effective_type: (_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.effectiveType,\n    };\n}\n//# sourceMappingURL=connectivity.js.map","import { arrayFrom } from './polyfills';\nexport function removeDuplicates(array) {\n    var set = new Set();\n    array.forEach(function (item) { return set.add(item); });\n    return arrayFrom(set);\n}\nexport function removeItem(array, item) {\n    var index = array.indexOf(item);\n    if (index >= 0) {\n        array.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrayUtils.js.map","import { removeItem } from './utils/arrayUtils';\nvar BUFFER_LIMIT = 500;\nexport function createBoundedBuffer() {\n    var buffer = [];\n    var add = function (callback) {\n        var length = buffer.push(callback);\n        if (length > BUFFER_LIMIT) {\n            buffer.splice(0, 1);\n        }\n    };\n    var remove = function (callback) {\n        removeItem(buffer, callback);\n    };\n    var drain = function (arg) {\n        buffer.forEach(function (callback) { return callback(arg); });\n        buffer.length = 0;\n    };\n    return {\n        add: add,\n        remove: remove,\n        drain: drain,\n    };\n}\n//# sourceMappingURL=boundedBuffer.js.map","export var TelemetryType = {\n    log: 'log',\n    configuration: 'configuration',\n    usage: 'usage',\n};\n//# sourceMappingURL=rawTelemetryEvent.types.js.map","import { ConsoleApiName } from '../../tools/display';\nimport { NO_ERROR_STACK_PRESENT_MESSAGE, isError } from '../error/error';\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures';\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration';\nimport { Observable } from '../../tools/observable';\nimport { timeStampNow } from '../../tools/utils/timeUtils';\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor';\nimport { sendToExtension } from '../../tools/sendToExtension';\nimport { startsWith, arrayFrom, includes, assign } from '../../tools/utils/polyfills';\nimport { performDraw } from '../../tools/utils/numberUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { combine } from '../../tools/mergeInto';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { getConnectivity } from '../connectivity';\nimport { createBoundedBuffer } from '../../tools/boundedBuffer';\nimport { TelemetryType } from './rawTelemetryEvent.types';\nvar ALLOWED_FRAME_URLS = [\n    'https://www.datadoghq-browser-agent.com',\n    'https://www.datad0g-browser-agent.com',\n    'https://d3uc069fcn7uxw.cloudfront.net',\n    'https://d20xtzwzcl0ceb.cloudfront.net',\n    'http://localhost',\n    '<anonymous>',\n];\nvar TELEMETRY_EXCLUDED_SITES = [INTAKE_SITE_US1_FED];\n// eslint-disable-next-line local-rules/disallow-side-effects\nvar preStartTelemetryBuffer = createBoundedBuffer();\nvar onRawTelemetryEventCollected = function (event) {\n    preStartTelemetryBuffer.add(function () { return onRawTelemetryEventCollected(event); });\n};\nexport function startTelemetry(telemetryService, configuration) {\n    var _a;\n    var contextProvider;\n    var observable = new Observable();\n    var alreadySentEvents = new Set();\n    var telemetryEnabled = !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate);\n    var telemetryEnabledPerType = (_a = {},\n        _a[TelemetryType.log] = telemetryEnabled,\n        _a[TelemetryType.configuration] = telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),\n        _a[TelemetryType.usage] = telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),\n        _a);\n    var runtimeEnvInfo = getRuntimeEnvInfo();\n    onRawTelemetryEventCollected = function (rawEvent) {\n        var stringifiedEvent = jsonStringify(rawEvent);\n        if (telemetryEnabledPerType[rawEvent.type] &&\n            alreadySentEvents.size < configuration.maxTelemetryEventsPerPage &&\n            !alreadySentEvents.has(stringifiedEvent)) {\n            var event_1 = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo);\n            observable.notify(event_1);\n            sendToExtension('telemetry', event_1);\n            alreadySentEvents.add(stringifiedEvent);\n        }\n    };\n    startMonitorErrorCollection(addTelemetryError);\n    function toTelemetryEvent(telemetryService, event, runtimeEnvInfo) {\n        return combine({\n            type: 'telemetry',\n            date: timeStampNow(),\n            service: telemetryService,\n            version: \"5.35.1\",\n            source: 'browser',\n            _dd: {\n                format_version: 2,\n            },\n            telemetry: combine(event, {\n                runtime_env: runtimeEnvInfo,\n                connectivity: getConnectivity(),\n                sdk_setup: \"npm\",\n            }),\n            experimental_features: arrayFrom(getExperimentalFeatures()),\n        }, contextProvider !== undefined ? contextProvider() : {});\n    }\n    return {\n        setContextProvider: function (provider) {\n            contextProvider = provider;\n        },\n        observable: observable,\n        enabled: telemetryEnabled,\n    };\n}\nfunction getRuntimeEnvInfo() {\n    return {\n        is_local_file: window.location.protocol === 'file:',\n        is_worker: 'WorkerGlobalScope' in self,\n    };\n}\nexport function startFakeTelemetry() {\n    var events = [];\n    onRawTelemetryEventCollected = function (event) {\n        events.push(event);\n    };\n    return events;\n}\n// need to be called after telemetry context is provided and observers are registered\nexport function drainPreStartTelemetry() {\n    preStartTelemetryBuffer.drain();\n}\nexport function resetTelemetry() {\n    preStartTelemetryBuffer = createBoundedBuffer();\n    onRawTelemetryEventCollected = function (event) {\n        preStartTelemetryBuffer.add(function () { return onRawTelemetryEventCollected(event); });\n    };\n}\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration) {\n    return configuration.site === INTAKE_SITE_STAGING;\n}\nexport function addTelemetryDebug(message, context) {\n    displayIfDebugEnabled(ConsoleApiName.debug, message, context);\n    onRawTelemetryEventCollected(assign({\n        type: TelemetryType.log,\n        message: message,\n        status: \"debug\" /* StatusType.debug */,\n    }, context));\n}\nexport function addTelemetryError(e, context) {\n    onRawTelemetryEventCollected(assign({\n        type: TelemetryType.log,\n        status: \"error\" /* StatusType.error */,\n    }, formatError(e), context));\n}\nexport function addTelemetryConfiguration(configuration) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.configuration,\n        configuration: configuration,\n    });\n}\nexport function addTelemetryUsage(usage) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.usage,\n        usage: usage,\n    });\n}\nexport function formatError(e) {\n    if (isError(e)) {\n        var stackTrace = computeStackTrace(e);\n        return {\n            error: {\n                kind: stackTrace.name,\n                stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n            },\n            message: stackTrace.message,\n        };\n    }\n    return {\n        error: {\n            stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n        },\n        message: \"\".concat(\"Uncaught\" /* NonErrorPrefix.UNCAUGHT */, \" \").concat(jsonStringify(e)),\n    };\n}\nexport function scrubCustomerFrames(stackTrace) {\n    stackTrace.stack = stackTrace.stack.filter(function (frame) { return !frame.url || ALLOWED_FRAME_URLS.some(function (allowedFrameUrl) { return startsWith(frame.url, allowedFrameUrl); }); });\n    return stackTrace;\n}\n//# sourceMappingURL=telemetry.js.map","import { display } from '../../tools/display';\nimport { getType } from '../../tools/utils/typeUtils';\nimport { assign } from '../../tools/utils/polyfills';\n/**\n * Clone input data and ensure known user properties (id, name, email)\n * are strings, as defined here:\n * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n */\nexport function sanitizeUser(newUser) {\n    // We shallow clone only to prevent mutation of user data.\n    var user = assign({}, newUser);\n    var keys = ['id', 'name', 'email'];\n    keys.forEach(function (key) {\n        if (key in user) {\n            /* eslint-disable @typescript-eslint/no-base-to-string */\n            user[key] = String(user[key]);\n        }\n    });\n    return user;\n}\n/**\n * Simple check to ensure user is valid\n */\nexport function checkUser(newUser) {\n    var isValid = getType(newUser) === 'object';\n    if (!isValid) {\n        display.error('Unsupported user:', newUser);\n    }\n    return isValid;\n}\nexport function generateAnonymousId() {\n    return Math.floor(Math.random() * Math.pow(2, 53)).toString(36);\n}\n//# sourceMappingURL=user.js.map","import { display } from '../tools/display';\nexport function displayAlreadyInitializedError(sdkName, initConfiguration) {\n    if (!initConfiguration.silentMultipleInit) {\n        display.error(\"\".concat(sdkName, \" is already initialized.\"));\n    }\n}\n//# sourceMappingURL=displayAlreadyInitializedError.js.map","export function buildCommonContext(globalContextManager, userContextManager, recorderApi) {\n    return {\n        context: globalContextManager.getContext(),\n        user: userContextManager.getContext(),\n        hasReplay: recorderApi.isRecording() ? true : undefined,\n    };\n}\n//# sourceMappingURL=commonContext.js.map","/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder) {\n    return placeholder\n        ? // eslint-disable-next-line  no-bitwise\n            (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n        : \"\".concat(1e7, \"-\").concat(1e3, \"-\").concat(4e3, \"-\").concat(8e3, \"-\").concat(1e11).replace(/[018]/g, generateUUID);\n}\nvar COMMA_SEPARATED_KEY_VALUE = /([\\w-]+)\\s*=\\s*([^;]+)/g;\nexport function findCommaSeparatedValue(rawString, name) {\n    COMMA_SEPARATED_KEY_VALUE.lastIndex = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var match = COMMA_SEPARATED_KEY_VALUE.exec(rawString);\n        if (match) {\n            if (match[1] === name) {\n                return match[2];\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nexport function findCommaSeparatedValues(rawString) {\n    var result = new Map();\n    COMMA_SEPARATED_KEY_VALUE.lastIndex = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var match = COMMA_SEPARATED_KEY_VALUE.exec(rawString);\n        if (match) {\n            result.set(match[1], match[2]);\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\nexport function safeTruncate(candidate, length, suffix) {\n    if (suffix === void 0) { suffix = ''; }\n    var lastChar = candidate.charCodeAt(length - 1);\n    var isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff;\n    var correctedLength = isLastCharSurrogatePair ? length + 1 : length;\n    if (candidate.length <= correctedLength) {\n        return candidate;\n    }\n    return \"\".concat(candidate.slice(0, correctedLength)).concat(suffix);\n}\n//# sourceMappingURL=stringUtils.js.map","import { clocksNow, combine, elapsed, generateUUID, toServerDuration } from '@datadog/browser-core';\nexport function createCustomVitalsState() {\n    var vitalsByName = new Map();\n    var vitalsByReference = new WeakMap();\n    return { vitalsByName: vitalsByName, vitalsByReference: vitalsByReference };\n}\nexport function startVitalCollection(lifeCycle, pageStateHistory, customVitalsState) {\n    function isValid(vital) {\n        return !pageStateHistory.wasInPageStateDuringPeriod(\"frozen\" /* PageState.FROZEN */, vital.startClocks.relative, vital.duration);\n    }\n    function addDurationVital(vital) {\n        if (isValid(vital)) {\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processVital(vital, true));\n        }\n    }\n    return {\n        addDurationVital: addDurationVital,\n        startDurationVital: function (name, options) {\n            if (options === void 0) { options = {}; }\n            return startDurationVital(customVitalsState, name, options);\n        },\n        stopDurationVital: function (nameOrRef, options) {\n            if (options === void 0) { options = {}; }\n            stopDurationVital(addDurationVital, customVitalsState, nameOrRef, options);\n        },\n    };\n}\nexport function startDurationVital(_a, name, options) {\n    var vitalsByName = _a.vitalsByName, vitalsByReference = _a.vitalsByReference;\n    if (options === void 0) { options = {}; }\n    var vital = {\n        name: name,\n        startClocks: clocksNow(),\n        context: options.context,\n        description: options.description,\n    };\n    // To avoid leaking implementation details of the vital, we return a reference to it.\n    var reference = { __dd_vital_reference: true };\n    vitalsByName.set(name, vital);\n    // To avoid memory leaks caused by the creation of numerous references (e.g., from improper useEffect implementations), we use a WeakMap.\n    vitalsByReference.set(reference, vital);\n    return reference;\n}\nexport function stopDurationVital(stopCallback, _a, nameOrRef, options) {\n    var vitalsByName = _a.vitalsByName, vitalsByReference = _a.vitalsByReference;\n    if (options === void 0) { options = {}; }\n    var vitalStart = typeof nameOrRef === 'string' ? vitalsByName.get(nameOrRef) : vitalsByReference.get(nameOrRef);\n    if (!vitalStart) {\n        return;\n    }\n    stopCallback(buildDurationVital(vitalStart, vitalStart.startClocks, options, clocksNow()));\n    if (typeof nameOrRef === 'string') {\n        vitalsByName.delete(nameOrRef);\n    }\n    else {\n        vitalsByReference.delete(nameOrRef);\n    }\n}\nfunction buildDurationVital(vitalStart, startClocks, stopOptions, stopClocks) {\n    var _a;\n    return {\n        name: vitalStart.name,\n        type: \"duration\" /* VitalType.DURATION */,\n        startClocks: startClocks,\n        duration: elapsed(startClocks.timeStamp, stopClocks.timeStamp),\n        context: combine(vitalStart.context, stopOptions.context),\n        description: (_a = stopOptions.description) !== null && _a !== void 0 ? _a : vitalStart.description,\n    };\n}\nfunction processVital(vital, valueComputedBySdk) {\n    var rawRumEvent = {\n        date: vital.startClocks.timeStamp,\n        vital: {\n            id: generateUUID(),\n            type: vital.type,\n            name: vital.name,\n            duration: toServerDuration(vital.duration),\n            description: vital.description,\n        },\n        type: \"vital\" /* RumEventType.VITAL */,\n    };\n    if (valueComputedBySdk) {\n        rawRumEvent._dd = {\n            vital: {\n                computed_value: true,\n            },\n        };\n    }\n    return {\n        rawRumEvent: rawRumEvent,\n        startTime: vital.startClocks.relative,\n        customerContext: vital.context,\n        domainContext: {},\n    };\n}\n//# sourceMappingURL=vitalCollection.js.map","import { endsWith, includes } from '../tools/utils/polyfills';\nimport { getGlobalObject } from '../tools/getGlobalObject';\nexport function getEventBridge() {\n    var eventBridgeGlobal = getEventBridgeGlobal();\n    if (!eventBridgeGlobal) {\n        return;\n    }\n    return {\n        getCapabilities: function () {\n            var _a;\n            return JSON.parse(((_a = eventBridgeGlobal.getCapabilities) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal)) || '[]');\n        },\n        getPrivacyLevel: function () {\n            var _a;\n            return (_a = eventBridgeGlobal.getPrivacyLevel) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal);\n        },\n        getAllowedWebViewHosts: function () {\n            return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts());\n        },\n        send: function (eventType, event, viewId) {\n            var view = viewId ? { id: viewId } : undefined;\n            eventBridgeGlobal.send(JSON.stringify({ eventType: eventType, event: event, view: view }));\n        },\n    };\n}\nexport function bridgeSupports(capability) {\n    var bridge = getEventBridge();\n    return !!bridge && includes(bridge.getCapabilities(), capability);\n}\nexport function canUseEventBridge(currentHost) {\n    var _a;\n    if (currentHost === void 0) { currentHost = (_a = getGlobalObject().location) === null || _a === void 0 ? void 0 : _a.hostname; }\n    var bridge = getEventBridge();\n    return (!!bridge &&\n        bridge\n            .getAllowedWebViewHosts()\n            .some(function (allowedHost) { return currentHost === allowedHost || endsWith(currentHost, \".\".concat(allowedHost)); }));\n}\nfunction getEventBridgeGlobal() {\n    return getGlobalObject().DatadogEventBridge;\n}\n//# sourceMappingURL=eventBridge.js.map","import { setTimeout } from './timer';\nimport { callMonitored } from './monitor';\nimport { noop } from './utils/functionUtils';\nimport { arrayFrom, startsWith } from './utils/polyfills';\nimport { createHandlingStack } from './stackTrace/handlingStack';\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod(targetPrototype, method, onPreCall, _a) {\n    var _b = _a === void 0 ? {} : _a, computeHandlingStack = _b.computeHandlingStack;\n    var original = targetPrototype[method];\n    if (typeof original !== 'function') {\n        if (method in targetPrototype && startsWith(method, 'on')) {\n            original = noop;\n        }\n        else {\n            return { stop: noop };\n        }\n    }\n    var stopped = false;\n    var instrumentation = function () {\n        if (stopped) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n            return original.apply(this, arguments);\n        }\n        var parameters = arrayFrom(arguments);\n        var postCallCallback;\n        callMonitored(onPreCall, null, [\n            {\n                target: this,\n                parameters: parameters,\n                onPostCall: function (callback) {\n                    postCallCallback = callback;\n                },\n                handlingStack: computeHandlingStack ? createHandlingStack() : undefined,\n            },\n        ]);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        var result = original.apply(this, parameters);\n        if (postCallCallback) {\n            callMonitored(postCallCallback, null, [result]);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result;\n    };\n    targetPrototype[method] = instrumentation;\n    return {\n        stop: function () {\n            stopped = true;\n            // If the instrumentation has been removed by a third party, keep the last one\n            if (targetPrototype[method] === instrumentation) {\n                targetPrototype[method] = original;\n            }\n        },\n    };\n}\nexport function instrumentSetter(targetPrototype, property, after) {\n    var originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property);\n    if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n        return { stop: noop };\n    }\n    var stoppedInstrumentation = noop;\n    var instrumentation = function (target, value) {\n        // put hooked setter into event loop to avoid of set latency\n        setTimeout(function () {\n            if (instrumentation !== stoppedInstrumentation) {\n                after(target, value);\n            }\n        }, 0);\n    };\n    var instrumentationWrapper = function (value) {\n        originalDescriptor.set.call(this, value);\n        instrumentation(this, value);\n    };\n    Object.defineProperty(targetPrototype, property, {\n        set: instrumentationWrapper,\n    });\n    return {\n        stop: function () {\n            var _a;\n            if (((_a = Object.getOwnPropertyDescriptor(targetPrototype, property)) === null || _a === void 0 ? void 0 : _a.set) === instrumentationWrapper) {\n                Object.defineProperty(targetPrototype, property, originalDescriptor);\n            }\n            instrumentation = stoppedInstrumentation;\n        },\n    };\n}\n//# sourceMappingURL=instrumentMethod.js.map","import { jsonStringify } from '../serialisation/jsonStringify';\nexport function normalizeUrl(url) {\n    return buildUrl(url, location.href).href;\n}\nexport function isValidUrl(url) {\n    try {\n        return !!buildUrl(url);\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function getPathName(url) {\n    var pathname = buildUrl(url).pathname;\n    return pathname[0] === '/' ? pathname : \"/\".concat(pathname);\n}\nexport function buildUrl(url, base) {\n    var supportedURL = getSupportedUrl();\n    if (supportedURL) {\n        try {\n            return base !== undefined ? new supportedURL(url, base) : new supportedURL(url);\n        }\n        catch (error) {\n            throw new Error(\"Failed to construct URL: \".concat(String(error), \" \").concat(jsonStringify({ url: url, base: base })));\n        }\n    }\n    if (base === undefined && !/:/.test(url)) {\n        throw new Error(\"Invalid URL: '\".concat(url, \"'\"));\n    }\n    var doc = document;\n    var anchorElement = doc.createElement('a');\n    if (base !== undefined) {\n        doc = document.implementation.createHTMLDocument('');\n        var baseElement = doc.createElement('base');\n        baseElement.href = base;\n        doc.head.appendChild(baseElement);\n        doc.body.appendChild(anchorElement);\n    }\n    anchorElement.href = url;\n    return anchorElement;\n}\nvar originalURL = URL;\nvar isURLSupported;\nfunction getSupportedUrl() {\n    if (isURLSupported === undefined) {\n        try {\n            var url = new originalURL('http://test/path');\n            isURLSupported = url.href === 'http://test/path';\n        }\n        catch (_a) {\n            isURLSupported = false;\n        }\n    }\n    return isURLSupported ? originalURL : undefined;\n}\n//# sourceMappingURL=urlPolyfill.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { monitor } from '../tools/monitor';\nimport { Observable } from '../tools/observable';\nimport { assign } from '../tools/utils/polyfills';\nimport { clocksNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nvar fetchObservable;\nexport function initFetchObservable() {\n    if (!fetchObservable) {\n        fetchObservable = createFetchObservable();\n    }\n    return fetchObservable;\n}\nexport function resetFetchObservable() {\n    fetchObservable = undefined;\n}\nfunction createFetchObservable() {\n    return new Observable(function (observable) {\n        if (!window.fetch) {\n            return;\n        }\n        var stop = instrumentMethod(window, 'fetch', function (call) { return beforeSend(call, observable); }, {\n            computeHandlingStack: true,\n        }).stop;\n        return stop;\n    });\n}\nfunction beforeSend(_a, observable) {\n    var parameters = _a.parameters, onPostCall = _a.onPostCall, handlingStack = _a.handlingStack;\n    var input = parameters[0], init = parameters[1];\n    var methodFromParams = init && init.method;\n    if (methodFromParams === undefined && input instanceof Request) {\n        methodFromParams = input.method;\n    }\n    var method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET';\n    var url = input instanceof Request ? input.url : normalizeUrl(String(input));\n    var startClocks = clocksNow();\n    var context = {\n        state: 'start',\n        init: init,\n        input: input,\n        method: method,\n        startClocks: startClocks,\n        url: url,\n        handlingStack: handlingStack,\n    };\n    observable.notify(context);\n    // Those properties can be changed by observable subscribers\n    parameters[0] = context.input;\n    parameters[1] = context.init;\n    onPostCall(function (responsePromise) { return afterSend(observable, responsePromise, context); });\n}\nfunction afterSend(observable, responsePromise, startContext) {\n    var context = startContext;\n    function reportFetch(partialContext) {\n        context.state = 'resolve';\n        assign(context, partialContext);\n        observable.notify(context);\n    }\n    responsePromise.then(monitor(function (response) {\n        reportFetch({\n            response: response,\n            responseType: response.type,\n            status: response.status,\n            isAborted: false,\n        });\n    }), monitor(function (error) {\n        var _a, _b;\n        reportFetch({\n            status: 0,\n            isAborted: ((_b = (_a = context.init) === null || _a === void 0 ? void 0 : _a.signal) === null || _b === void 0 ? void 0 : _b.aborted) || (error instanceof DOMException && error.code === DOMException.ABORT_ERR),\n            error: error,\n        });\n    }));\n}\n//# sourceMappingURL=fetchObservable.js.map","import { display } from '../tools/display';\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { findCommaSeparatedValue, findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils';\nexport function setCookie(name, value, expireDelay, options) {\n    if (expireDelay === void 0) { expireDelay = 0; }\n    var date = new Date();\n    date.setTime(date.getTime() + expireDelay);\n    var expires = \"expires=\".concat(date.toUTCString());\n    var sameSite = options && options.crossSite ? 'none' : 'strict';\n    var domain = options && options.domain ? \";domain=\".concat(options.domain) : '';\n    var secure = options && options.secure ? ';secure' : '';\n    var partitioned = options && options.partitioned ? ';partitioned' : '';\n    document.cookie = \"\".concat(name, \"=\").concat(value, \";\").concat(expires, \";path=/;samesite=\").concat(sameSite).concat(domain).concat(secure).concat(partitioned);\n}\nexport function getCookie(name) {\n    return findCommaSeparatedValue(document.cookie, name);\n}\nvar initCookieParsed;\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name) {\n    if (!initCookieParsed) {\n        initCookieParsed = findCommaSeparatedValues(document.cookie);\n    }\n    return initCookieParsed.get(name);\n}\nexport function resetInitCookies() {\n    initCookieParsed = undefined;\n}\nexport function deleteCookie(name, options) {\n    setCookie(name, '', 0, options);\n}\nexport function areCookiesAuthorized(options) {\n    if (document.cookie === undefined || document.cookie === null) {\n        return false;\n    }\n    try {\n        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n        // the test cookie lifetime\n        var testCookieName = \"dd_cookie_test_\".concat(generateUUID());\n        var testCookieValue = 'test';\n        setCookie(testCookieName, testCookieValue, ONE_MINUTE, options);\n        var isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue;\n        deleteCookie(testCookieName, options);\n        return isCookieCorrectlySet;\n    }\n    catch (error) {\n        display.error(error);\n        return false;\n    }\n}\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nvar getCurrentSiteCache;\nexport function getCurrentSite() {\n    if (getCurrentSiteCache === undefined) {\n        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n        // the test cookie lifetime\n        var testCookieName = \"dd_site_test_\".concat(generateUUID());\n        var testCookieValue = 'test';\n        var domainLevels = window.location.hostname.split('.');\n        var candidateDomain = domainLevels.pop();\n        while (domainLevels.length && !getCookie(testCookieName)) {\n            candidateDomain = \"\".concat(domainLevels.pop(), \".\").concat(candidateDomain);\n            setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain });\n        }\n        deleteCookie(testCookieName, { domain: candidateDomain });\n        getCurrentSiteCache = candidateDomain;\n    }\n    return getCurrentSiteCache;\n}\n//# sourceMappingURL=cookie.js.map","import { getInitCookie } from '../../browser/cookie';\nexport var SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id';\nexport var SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id';\nexport var SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum';\nexport function willSyntheticsInjectRum() {\n    return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || getInitCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME));\n}\nexport function getSyntheticsTestId() {\n    var value = window._DATADOG_SYNTHETICS_PUBLIC_ID || getInitCookie(SYNTHETICS_TEST_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\nexport function getSyntheticsResultId() {\n    var value = window._DATADOG_SYNTHETICS_RESULT_ID || getInitCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\n//# sourceMappingURL=syntheticsWorkerValues.js.map","export function isIE() {\n    return detectBrowserCached() === 0 /* Browser.IE */;\n}\nexport function isChromium() {\n    return detectBrowserCached() === 1 /* Browser.CHROMIUM */;\n}\nexport function isSafari() {\n    return detectBrowserCached() === 2 /* Browser.SAFARI */;\n}\nvar browserCache;\nfunction detectBrowserCached() {\n    return browserCache !== null && browserCache !== void 0 ? browserCache : (browserCache = detectBrowser());\n}\n// Exported only for tests\nexport function detectBrowser(browserWindow) {\n    var _a;\n    if (browserWindow === void 0) { browserWindow = window; }\n    var userAgent = browserWindow.navigator.userAgent;\n    if (browserWindow.chrome || /HeadlessChrome/.test(userAgent)) {\n        return 1 /* Browser.CHROMIUM */;\n    }\n    if (\n    // navigator.vendor is deprecated, but it is the most resilient way we found to detect\n    // \"Apple maintained browsers\" (AKA Safari). If one day it gets removed, we still have the\n    // useragent test as a semi-working fallback.\n    ((_a = browserWindow.navigator.vendor) === null || _a === void 0 ? void 0 : _a.indexOf('Apple')) === 0 ||\n        (/safari/i.test(userAgent) && !/chrome|android/i.test(userAgent))) {\n        return 2 /* Browser.SAFARI */;\n    }\n    if (browserWindow.document.documentMode) {\n        return 0 /* Browser.IE */;\n    }\n    return 3 /* Browser.OTHER */;\n}\n//# sourceMappingURL=browserDetection.js.map","export var SESSION_STORE_KEY = '_dd_s';\n//# sourceMappingURL=sessionStoreStrategy.js.map","import { ONE_HOUR, ONE_MINUTE, ONE_YEAR } from '../../tools/utils/timeUtils';\nexport var SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR;\nexport var SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE;\nexport var SESSION_COOKIE_EXPIRATION_DELAY = ONE_YEAR;\nexport var SessionPersistence = {\n    COOKIE: 'cookie',\n    LOCAL_STORAGE: 'local-storage',\n};\n//# sourceMappingURL=sessionConstants.js.map","export var SESSION_ENTRY_REGEXP = /^([a-zA-Z]+)=([a-z0-9-]+)$/;\nexport var SESSION_ENTRY_SEPARATOR = '&';\nexport function isValidSessionString(sessionString) {\n    return (!!sessionString &&\n        (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString)));\n}\n//# sourceMappingURL=sessionStateValidation.js.map","import { ExperimentalFeature, isExperimentalFeatureEnabled } from '../../tools/experimentalFeatures';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\nimport { objectEntries } from '../../tools/utils/polyfills';\nimport { dateNow } from '../../tools/utils/timeUtils';\nimport { generateAnonymousId } from '../user';\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { isValidSessionString, SESSION_ENTRY_REGEXP, SESSION_ENTRY_SEPARATOR } from './sessionStateValidation';\nexport var EXPIRED = '1';\nexport function getExpiredSessionState(previousSessionState) {\n    var expiredSessionState = {\n        isExpired: EXPIRED,\n    };\n    if (isExperimentalFeatureEnabled(ExperimentalFeature.ANONYMOUS_USER_TRACKING)) {\n        if (previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId) {\n            expiredSessionState.anonymousId = previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId;\n        }\n        else {\n            expiredSessionState.anonymousId = generateAnonymousId();\n        }\n    }\n    return expiredSessionState;\n}\nexport function isSessionInNotStartedState(session) {\n    return isEmptyObject(session);\n}\nexport function isSessionStarted(session) {\n    return !isSessionInNotStartedState(session);\n}\nexport function isSessionInExpiredState(session) {\n    return session.isExpired !== undefined || !isActiveSession(session);\n}\n// An active session is a session in either `Tracked` or `NotTracked` state\nfunction isActiveSession(sessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return ((sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n        (sessionState.expire === undefined || dateNow() < Number(sessionState.expire)));\n}\nexport function expandSessionState(session) {\n    session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY);\n}\nexport function toSessionString(session) {\n    return (objectEntries(session)\n        // we use `aid` as a key for anonymousId\n        .map(function (_a) {\n        var key = _a[0], value = _a[1];\n        return (key === 'anonymousId' ? \"aid=\".concat(value) : \"\".concat(key, \"=\").concat(value));\n    })\n        .join(SESSION_ENTRY_SEPARATOR));\n}\nexport function toSessionState(sessionString) {\n    var session = {};\n    if (isValidSessionString(sessionString)) {\n        sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function (entry) {\n            var matches = SESSION_ENTRY_REGEXP.exec(entry);\n            if (matches !== null) {\n                var key = matches[1], value = matches[2];\n                if (key === 'aid') {\n                    // we use `aid` as a key for anonymousId\n                    session.anonymousId = value;\n                }\n                else {\n                    session[key] = value;\n                }\n            }\n        });\n    }\n    return session;\n}\n//# sourceMappingURL=sessionState.js.map","import { getInitCookie } from '../../browser/cookie';\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy';\nimport { expandSessionState, isSessionStarted } from './sessionState';\nexport var OLD_SESSION_COOKIE_NAME = '_dd';\nexport var OLD_RUM_COOKIE_NAME = '_dd_r';\nexport var OLD_LOGS_COOKIE_NAME = '_dd_l';\n// duplicate values to avoid dependency issues\nexport var RUM_SESSION_KEY = 'rum';\nexport var LOGS_SESSION_KEY = 'logs';\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy) {\n    var sessionString = getInitCookie(SESSION_STORE_KEY);\n    if (!sessionString) {\n        var oldSessionId = getInitCookie(OLD_SESSION_COOKIE_NAME);\n        var oldRumType = getInitCookie(OLD_RUM_COOKIE_NAME);\n        var oldLogsType = getInitCookie(OLD_LOGS_COOKIE_NAME);\n        var session = {};\n        if (oldSessionId) {\n            session.id = oldSessionId;\n        }\n        if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n            session[LOGS_SESSION_KEY] = oldLogsType;\n        }\n        if (oldRumType && /^[012]$/.test(oldRumType)) {\n            session[RUM_SESSION_KEY] = oldRumType;\n        }\n        if (isSessionStarted(session)) {\n            expandSessionState(session);\n            cookieStoreStrategy.persistSession(session);\n        }\n    }\n}\n//# sourceMappingURL=oldCookiesMigration.js.map","import { isChromium } from '../../../tools/utils/browserDetection';\nimport { ExperimentalFeature, isExperimentalFeatureEnabled } from '../../../tools/experimentalFeatures';\nimport { getCurrentSite, areCookiesAuthorized, getCookie, setCookie } from '../../../browser/cookie';\nimport { tryOldCookiesMigration } from '../oldCookiesMigration';\nimport { SESSION_COOKIE_EXPIRATION_DELAY, SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY, SessionPersistence, } from '../sessionConstants';\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState';\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy';\nexport function selectCookieStrategy(initConfiguration) {\n    var cookieOptions = buildCookieOptions(initConfiguration);\n    return areCookiesAuthorized(cookieOptions) ? { type: SessionPersistence.COOKIE, cookieOptions: cookieOptions } : undefined;\n}\nexport function initCookieStrategy(cookieOptions) {\n    var cookieStore = {\n        /**\n         * Lock strategy allows mitigating issues due to concurrent access to cookie.\n         * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n         */\n        isLockEnabled: isChromium(),\n        persistSession: persistSessionCookie(cookieOptions),\n        retrieveSession: retrieveSessionCookie,\n        expireSession: function (sessionState) { return expireSessionCookie(cookieOptions, sessionState); },\n    };\n    tryOldCookiesMigration(cookieStore);\n    return cookieStore;\n}\nfunction persistSessionCookie(options) {\n    return function (session) {\n        setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options);\n    };\n}\nfunction expireSessionCookie(options, sessionState) {\n    var expiredSessionState = getExpiredSessionState(sessionState);\n    setCookie(SESSION_STORE_KEY, toSessionString(expiredSessionState), isExperimentalFeatureEnabled(ExperimentalFeature.ANONYMOUS_USER_TRACKING)\n        ? SESSION_COOKIE_EXPIRATION_DELAY\n        : SESSION_TIME_OUT_DELAY, options);\n}\nfunction retrieveSessionCookie() {\n    var sessionString = getCookie(SESSION_STORE_KEY);\n    var sessionState = toSessionState(sessionString);\n    return sessionState;\n}\nexport function buildCookieOptions(initConfiguration) {\n    var cookieOptions = {};\n    cookieOptions.secure =\n        !!initConfiguration.useSecureSessionCookie ||\n            !!initConfiguration.usePartitionedCrossSiteSessionCookie ||\n            !!initConfiguration.useCrossSiteSessionCookie;\n    cookieOptions.crossSite =\n        !!initConfiguration.usePartitionedCrossSiteSessionCookie || !!initConfiguration.useCrossSiteSessionCookie;\n    cookieOptions.partitioned = !!initConfiguration.usePartitionedCrossSiteSessionCookie;\n    if (initConfiguration.trackSessionAcrossSubdomains) {\n        cookieOptions.domain = getCurrentSite();\n    }\n    return cookieOptions;\n}\n//# sourceMappingURL=sessionInCookie.js.map","import { generateUUID } from '../../../tools/utils/stringUtils';\nimport { SessionPersistence } from '../sessionConstants';\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState';\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy';\nvar LOCAL_STORAGE_TEST_KEY = '_dd_test_';\nexport function selectLocalStorageStrategy() {\n    try {\n        var id = generateUUID();\n        var testKey = \"\".concat(LOCAL_STORAGE_TEST_KEY).concat(id);\n        localStorage.setItem(testKey, id);\n        var retrievedId = localStorage.getItem(testKey);\n        localStorage.removeItem(testKey);\n        return id === retrievedId ? { type: SessionPersistence.LOCAL_STORAGE } : undefined;\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\nexport function initLocalStorageStrategy() {\n    return {\n        isLockEnabled: false,\n        persistSession: persistInLocalStorage,\n        retrieveSession: retrieveSessionFromLocalStorage,\n        expireSession: expireSessionFromLocalStorage,\n    };\n}\nfunction persistInLocalStorage(sessionState) {\n    localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState));\n}\nfunction retrieveSessionFromLocalStorage() {\n    var sessionString = localStorage.getItem(SESSION_STORE_KEY);\n    return toSessionState(sessionString);\n}\nfunction expireSessionFromLocalStorage(previousSessionState) {\n    persistInLocalStorage(getExpiredSessionState(previousSessionState));\n}\n//# sourceMappingURL=sessionInLocalStorage.js.map","import { setTimeout } from '../../tools/timer';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { assign } from '../../tools/utils/polyfills';\nimport { expandSessionState, isSessionInExpiredState } from './sessionState';\nexport var LOCK_RETRY_DELAY = 10;\nexport var LOCK_MAX_TRIES = 100;\nvar bufferedOperations = [];\nvar ongoingOperations;\nexport function processSessionStoreOperations(operations, sessionStoreStrategy, numberOfRetries) {\n    var _a;\n    if (numberOfRetries === void 0) { numberOfRetries = 0; }\n    var isLockEnabled = sessionStoreStrategy.isLockEnabled, persistSession = sessionStoreStrategy.persistSession, expireSession = sessionStoreStrategy.expireSession;\n    var persistWithLock = function (session) { return persistSession(assign({}, session, { lock: currentLock })); };\n    var retrieveStore = function () {\n        var session = sessionStoreStrategy.retrieveSession();\n        var lock = session.lock;\n        if (session.lock) {\n            delete session.lock;\n        }\n        return {\n            session: session,\n            lock: lock,\n        };\n    };\n    if (!ongoingOperations) {\n        ongoingOperations = operations;\n    }\n    if (operations !== ongoingOperations) {\n        bufferedOperations.push(operations);\n        return;\n    }\n    if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n        next(sessionStoreStrategy);\n        return;\n    }\n    var currentLock;\n    var currentStore = retrieveStore();\n    if (isLockEnabled) {\n        // if someone has lock, retry later\n        if (currentStore.lock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n        // acquire lock\n        currentLock = generateUUID();\n        persistWithLock(currentStore.session);\n        // if lock is not acquired, retry later\n        currentStore = retrieveStore();\n        if (currentStore.lock !== currentLock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n    }\n    var processedSession = operations.process(currentStore.session);\n    if (isLockEnabled) {\n        // if lock corrupted after process, retry later\n        currentStore = retrieveStore();\n        if (currentStore.lock !== currentLock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n    }\n    if (processedSession) {\n        if (isSessionInExpiredState(processedSession)) {\n            expireSession(processedSession);\n        }\n        else {\n            expandSessionState(processedSession);\n            if (isLockEnabled) {\n                persistWithLock(processedSession);\n            }\n            else {\n                persistSession(processedSession);\n            }\n        }\n    }\n    if (isLockEnabled) {\n        // correctly handle lock around expiration would require to handle this case properly at several levels\n        // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n        if (!(processedSession && isSessionInExpiredState(processedSession))) {\n            // if lock corrupted after persist, retry later\n            currentStore = retrieveStore();\n            if (currentStore.lock !== currentLock) {\n                retryLater(operations, sessionStoreStrategy, numberOfRetries);\n                return;\n            }\n            persistSession(currentStore.session);\n            processedSession = currentStore.session;\n        }\n    }\n    // call after even if session is not persisted in order to perform operations on\n    // up-to-date session state value => the value could have been modified by another tab\n    (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentStore.session);\n    next(sessionStoreStrategy);\n}\nfunction retryLater(operations, sessionStore, currentNumberOfRetries) {\n    setTimeout(function () {\n        processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1);\n    }, LOCK_RETRY_DELAY);\n}\nfunction next(sessionStore) {\n    ongoingOperations = undefined;\n    var nextOperations = bufferedOperations.shift();\n    if (nextOperations) {\n        processSessionStoreOperations(nextOperations, sessionStore);\n    }\n}\n//# sourceMappingURL=sessionStoreOperations.js.map","import { clearInterval, setInterval } from '../../tools/timer';\nimport { Observable } from '../../tools/observable';\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { assign } from '../../tools/utils/polyfills';\nimport { display } from '../../tools/display';\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie';\nimport { getExpiredSessionState, isSessionInExpiredState, isSessionInNotStartedState, isSessionStarted, } from './sessionState';\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage';\nimport { processSessionStoreOperations } from './sessionStoreOperations';\nimport { SessionPersistence } from './sessionConstants';\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport var STORAGE_POLL_DELAY = ONE_SECOND;\n/**\n * Selects the correct session store strategy type based on the configuration and storage\n * availability.\n */\nexport function selectSessionStoreStrategyType(initConfiguration) {\n    switch (initConfiguration.sessionPersistence) {\n        case SessionPersistence.COOKIE:\n            return selectCookieStrategy(initConfiguration);\n        case SessionPersistence.LOCAL_STORAGE:\n            return selectLocalStorageStrategy();\n        case undefined: {\n            var sessionStoreStrategyType = selectCookieStrategy(initConfiguration);\n            if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n                sessionStoreStrategyType = selectLocalStorageStrategy();\n            }\n            return sessionStoreStrategyType;\n        }\n        default:\n            display.error(\"Invalid session persistence '\".concat(String(initConfiguration.sessionPersistence), \"'\"));\n    }\n}\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore(sessionStoreStrategyType, productKey, computeSessionState) {\n    var renewObservable = new Observable();\n    var expireObservable = new Observable();\n    var sessionStateUpdateObservable = new Observable();\n    var sessionStoreStrategy = sessionStoreStrategyType.type === SessionPersistence.COOKIE\n        ? initCookieStrategy(sessionStoreStrategyType.cookieOptions)\n        : initLocalStorageStrategy();\n    var expireSession = sessionStoreStrategy.expireSession;\n    var watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY);\n    var sessionCache;\n    startSession();\n    var _a = throttle(function () {\n        processSessionStoreOperations({\n            process: function (sessionState) {\n                if (isSessionInNotStartedState(sessionState)) {\n                    return;\n                }\n                var synchronizedSession = synchronizeSession(sessionState);\n                expandOrRenewSessionState(synchronizedSession);\n                return synchronizedSession;\n            },\n            after: function (sessionState) {\n                if (isSessionStarted(sessionState) && !hasSessionInCache()) {\n                    renewSessionInCache(sessionState);\n                }\n                sessionCache = sessionState;\n            },\n        }, sessionStoreStrategy);\n    }, STORAGE_POLL_DELAY), throttledExpandOrRenewSession = _a.throttled, cancelExpandOrRenewSession = _a.cancel;\n    function expandSession() {\n        processSessionStoreOperations({\n            process: function (sessionState) { return (hasSessionInCache() ? synchronizeSession(sessionState) : undefined); },\n        }, sessionStoreStrategy);\n    }\n    /**\n     * allows two behaviors:\n     * - if the session is active, synchronize the session cache without updating the session store\n     * - if the session is not active, clear the session store and expire the session cache\n     */\n    function watchSession() {\n        processSessionStoreOperations({\n            process: function (sessionState) {\n                return isSessionInExpiredState(sessionState) ? getExpiredSessionState(sessionState) : undefined;\n            },\n            after: synchronizeSession,\n        }, sessionStoreStrategy);\n    }\n    function synchronizeSession(sessionState) {\n        if (isSessionInExpiredState(sessionState)) {\n            sessionState = getExpiredSessionState(sessionState);\n        }\n        if (hasSessionInCache()) {\n            if (isSessionInCacheOutdated(sessionState)) {\n                expireSessionInCache();\n            }\n            else {\n                sessionStateUpdateObservable.notify({ previousState: sessionCache, newState: sessionState });\n                sessionCache = sessionState;\n            }\n        }\n        return sessionState;\n    }\n    function startSession() {\n        processSessionStoreOperations({\n            process: function (sessionState) {\n                if (isSessionInNotStartedState(sessionState)) {\n                    return getExpiredSessionState(sessionState);\n                }\n            },\n            after: function (sessionState) {\n                sessionCache = sessionState;\n            },\n        }, sessionStoreStrategy);\n    }\n    function expandOrRenewSessionState(sessionState) {\n        if (isSessionInNotStartedState(sessionState)) {\n            return false;\n        }\n        var _a = computeSessionState(sessionState[productKey]), trackingType = _a.trackingType, isTracked = _a.isTracked;\n        sessionState[productKey] = trackingType;\n        delete sessionState.isExpired;\n        if (isTracked && !sessionState.id) {\n            sessionState.id = generateUUID();\n            sessionState.created = String(dateNow());\n        }\n    }\n    function hasSessionInCache() {\n        return sessionCache[productKey] !== undefined;\n    }\n    function isSessionInCacheOutdated(sessionState) {\n        return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey];\n    }\n    function expireSessionInCache() {\n        sessionCache = getExpiredSessionState(sessionCache);\n        expireObservable.notify();\n    }\n    function renewSessionInCache(sessionState) {\n        sessionCache = sessionState;\n        renewObservable.notify();\n    }\n    function updateSessionState(partialSessionState) {\n        processSessionStoreOperations({\n            process: function (sessionState) { return assign({}, sessionState, partialSessionState); },\n            after: synchronizeSession,\n        }, sessionStoreStrategy);\n    }\n    return {\n        expandOrRenewSession: throttledExpandOrRenewSession,\n        expandSession: expandSession,\n        getSession: function () { return sessionCache; },\n        renewObservable: renewObservable,\n        expireObservable: expireObservable,\n        sessionStateUpdateObservable: sessionStateUpdateObservable,\n        restartSession: startSession,\n        expire: function () {\n            cancelExpandOrRenewSession();\n            expireSession(sessionCache);\n            synchronizeSession(getExpiredSessionState(sessionCache));\n        },\n        stop: function () {\n            clearInterval(watchSessionTimeoutId);\n        },\n        updateSessionState: updateSessionState,\n    };\n}\n//# sourceMappingURL=sessionStore.js.map","import { timeStampNow } from '../../tools/utils/timeUtils';\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { INTAKE_SITE_US1, INTAKE_SITE_FED_STAGING, PCI_INTAKE_HOST_US1 } from './intakeSites';\nexport function createEndpointBuilder(initConfiguration, trackType, configurationTags) {\n    var buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, trackType);\n    return {\n        build: function (api, payload) {\n            var parameters = buildEndpointParameters(initConfiguration, trackType, configurationTags, api, payload);\n            return buildUrlWithParameters(parameters);\n        },\n        urlPrefix: buildUrlWithParameters(''),\n        trackType: trackType,\n    };\n}\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(initConfiguration, trackType) {\n    var path = \"/api/v2/\".concat(trackType);\n    var proxy = initConfiguration.proxy;\n    if (typeof proxy === 'string') {\n        var normalizedProxyUrl_1 = normalizeUrl(proxy);\n        return function (parameters) { return \"\".concat(normalizedProxyUrl_1, \"?ddforward=\").concat(encodeURIComponent(\"\".concat(path, \"?\").concat(parameters))); };\n    }\n    if (typeof proxy === 'function') {\n        return function (parameters) { return proxy({ path: path, parameters: parameters }); };\n    }\n    var host = buildEndpointHost(trackType, initConfiguration);\n    return function (parameters) { return \"https://\".concat(host).concat(path, \"?\").concat(parameters); };\n}\nfunction buildEndpointHost(trackType, initConfiguration) {\n    var _a = initConfiguration.site, site = _a === void 0 ? INTAKE_SITE_US1 : _a, internalAnalyticsSubdomain = initConfiguration.internalAnalyticsSubdomain;\n    if (trackType === 'logs' && initConfiguration.usePciIntake && site === INTAKE_SITE_US1) {\n        return PCI_INTAKE_HOST_US1;\n    }\n    if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n        return \"\".concat(internalAnalyticsSubdomain, \".\").concat(INTAKE_SITE_US1);\n    }\n    if (site === INTAKE_SITE_FED_STAGING) {\n        return \"http-intake.logs.\".concat(site);\n    }\n    var domainParts = site.split('.');\n    var extension = domainParts.pop();\n    return \"browser-intake-\".concat(domainParts.join('-'), \".\").concat(extension);\n}\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters(_a, trackType, configurationTags, api, _b) {\n    var clientToken = _a.clientToken, internalAnalyticsSubdomain = _a.internalAnalyticsSubdomain;\n    var retry = _b.retry, encoding = _b.encoding;\n    var tags = [\"sdk_version:\".concat(\"5.35.1\"), \"api:\".concat(api)].concat(configurationTags);\n    if (retry) {\n        tags.push(\"retry_count:\".concat(retry.count), \"retry_after:\".concat(retry.lastFailureStatus));\n    }\n    var parameters = [\n        'ddsource=browser',\n        \"ddtags=\".concat(encodeURIComponent(tags.join(','))),\n        \"dd-api-key=\".concat(clientToken),\n        \"dd-evp-origin-version=\".concat(encodeURIComponent(\"5.35.1\")),\n        'dd-evp-origin=browser',\n        \"dd-request-id=\".concat(generateUUID()),\n    ];\n    if (encoding) {\n        parameters.push(\"dd-evp-encoding=\".concat(encoding));\n    }\n    if (trackType === 'rum') {\n        parameters.push(\"batch_time=\".concat(timeStampNow()));\n    }\n    if (internalAnalyticsSubdomain) {\n        parameters.reverse();\n    }\n    return parameters.join('&');\n}\n//# sourceMappingURL=endpointBuilder.js.map","import { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display';\nexport var TAG_SIZE_LIMIT = 200;\nexport function buildTags(configuration) {\n    var env = configuration.env, service = configuration.service, version = configuration.version, datacenter = configuration.datacenter;\n    var tags = [];\n    if (env) {\n        tags.push(buildTag('env', env));\n    }\n    if (service) {\n        tags.push(buildTag('service', service));\n    }\n    if (version) {\n        tags.push(buildTag('version', version));\n    }\n    if (datacenter) {\n        tags.push(buildTag('datacenter', datacenter));\n    }\n    return tags;\n}\nexport function buildTag(key, rawValue) {\n    // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n    // that the backend may not follow the exact same rules, so we only want to display an informal\n    // warning.\n    var valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1;\n    if (rawValue.length > valueSizeLimit || hasForbiddenCharacters(rawValue)) {\n        display.warn(\"\".concat(key, \" value doesn't meet tag requirements and will be sanitized. \").concat(MORE_DETAILS, \" \").concat(DOCS_ORIGIN, \"/getting_started/tagging/#defining-tags\"));\n    }\n    // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n    // by forging a value containing commas.\n    var sanitizedValue = rawValue.replace(/,/g, '_');\n    return \"\".concat(key, \":\").concat(sanitizedValue);\n}\nfunction hasForbiddenCharacters(rawValue) {\n    // Unicode property escapes is not supported in all browsers, so we use a try/catch.\n    // Todo: Remove the try/catch when dropping IE11.\n    if (!supportUnicodePropertyEscapes()) {\n        return false;\n    }\n    // We use the Unicode property escapes to match any character that is a letter including other languages like Chinese, Japanese, etc.\n    // p{Ll} matches a lowercase letter.\n    // p{Lo} matches a letter that is neither uppercase nor lowercase (ex: Japanese characters).\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#unicode_property_escapes_vs._character_classes\n    return new RegExp('[^\\\\p{Ll}\\\\p{Lo}0-9_:./-]', 'u').test(rawValue);\n}\nexport function supportUnicodePropertyEscapes() {\n    try {\n        new RegExp('[\\\\p{Ll}]', 'u');\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n//# sourceMappingURL=tags.js.map","import { assign, includes } from '../../tools/utils/polyfills';\nimport { createEndpointBuilder } from './endpointBuilder';\nimport { buildTags } from './tags';\nimport { INTAKE_SITE_US1, INTAKE_URL_PARAMETERS } from './intakeSites';\nexport function computeTransportConfiguration(initConfiguration) {\n    var site = initConfiguration.site || INTAKE_SITE_US1;\n    var tags = buildTags(initConfiguration);\n    var endpointBuilders = computeEndpointBuilders(initConfiguration, tags);\n    var replicaConfiguration = computeReplicaConfiguration(initConfiguration, tags);\n    return assign({\n        replica: replicaConfiguration,\n        site: site,\n    }, endpointBuilders);\n}\nfunction computeEndpointBuilders(initConfiguration, tags) {\n    return {\n        logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n        rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n        sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'replay', tags),\n    };\n}\nfunction computeReplicaConfiguration(initConfiguration, tags) {\n    if (!initConfiguration.replica) {\n        return;\n    }\n    var replicaConfiguration = assign({}, initConfiguration, {\n        site: INTAKE_SITE_US1,\n        clientToken: initConfiguration.replica.clientToken,\n    });\n    var replicaEndpointBuilders = {\n        logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n        rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n    };\n    return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders);\n}\nexport function isIntakeUrl(url) {\n    // check if tags is present in the query string\n    return INTAKE_URL_PARAMETERS.every(function (param) { return includes(url, param); });\n}\n//# sourceMappingURL=transportConfiguration.js.map","import { catchUserErrors } from '../../tools/catchUserErrors';\nimport { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display';\nimport { ONE_SECOND } from '../../tools/utils/timeUtils';\nimport { isPercentage } from '../../tools/utils/numberUtils';\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils';\nimport { objectHasValue } from '../../tools/utils/objectUtils';\nimport { assign } from '../../tools/utils/polyfills';\nimport { selectSessionStoreStrategyType } from '../session/sessionStore';\nimport { TrackingConsent } from '../trackingConsent';\nimport { computeTransportConfiguration } from './transportConfiguration';\nexport var DefaultPrivacyLevel = {\n    ALLOW: 'allow',\n    MASK: 'mask',\n    MASK_USER_INPUT: 'mask-user-input',\n};\nexport var TraceContextInjection = {\n    ALL: 'all',\n    SAMPLED: 'sampled',\n};\nfunction isString(tag, tagName) {\n    if (tag !== undefined && tag !== null && typeof tag !== 'string') {\n        display.error(\"\".concat(tagName, \" must be defined as a string\"));\n        return false;\n    }\n    return true;\n}\nfunction isDatadogSite(site) {\n    if (site && typeof site === 'string' && !/(datadog|ddog|datad0g|dd0g)/.test(site)) {\n        display.error(\"Site should be a valid Datadog site. \".concat(MORE_DETAILS, \" \").concat(DOCS_ORIGIN, \"/getting_started/site/.\"));\n        return false;\n    }\n    return true;\n}\nexport function isSampleRate(sampleRate, name) {\n    if (sampleRate !== undefined && !isPercentage(sampleRate)) {\n        display.error(\"\".concat(name, \" Sample Rate should be a number between 0 and 100\"));\n        return false;\n    }\n    return true;\n}\nexport function validateAndBuildConfiguration(initConfiguration) {\n    var _a, _b, _c, _d, _e;\n    if (!initConfiguration || !initConfiguration.clientToken) {\n        display.error('Client Token is not configured, we will not send any data.');\n        return;\n    }\n    if (!isDatadogSite(initConfiguration.site) ||\n        !isSampleRate(initConfiguration.sessionSampleRate, 'Session') ||\n        !isSampleRate(initConfiguration.telemetrySampleRate, 'Telemetry') ||\n        !isSampleRate(initConfiguration.telemetryConfigurationSampleRate, 'Telemetry Configuration') ||\n        !isSampleRate(initConfiguration.telemetryUsageSampleRate, 'Telemetry Usage') ||\n        !isString(initConfiguration.version, 'Version') ||\n        !isString(initConfiguration.env, 'Env') ||\n        !isString(initConfiguration.service, 'Service')) {\n        return;\n    }\n    if (initConfiguration.trackingConsent !== undefined &&\n        !objectHasValue(TrackingConsent, initConfiguration.trackingConsent)) {\n        display.error('Tracking Consent should be either \"granted\" or \"not-granted\"');\n        return;\n    }\n    return assign({\n        beforeSend: initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n        sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n        sessionSampleRate: (_a = initConfiguration.sessionSampleRate) !== null && _a !== void 0 ? _a : 100,\n        telemetrySampleRate: (_b = initConfiguration.telemetrySampleRate) !== null && _b !== void 0 ? _b : 20,\n        telemetryConfigurationSampleRate: (_c = initConfiguration.telemetryConfigurationSampleRate) !== null && _c !== void 0 ? _c : 5,\n        telemetryUsageSampleRate: (_d = initConfiguration.telemetryUsageSampleRate) !== null && _d !== void 0 ? _d : 5,\n        service: initConfiguration.service || undefined,\n        silentMultipleInit: !!initConfiguration.silentMultipleInit,\n        allowUntrustedEvents: !!initConfiguration.allowUntrustedEvents,\n        trackingConsent: (_e = initConfiguration.trackingConsent) !== null && _e !== void 0 ? _e : TrackingConsent.GRANTED,\n        storeContextsAcrossPages: !!initConfiguration.storeContextsAcrossPages,\n        /**\n         * beacon payload max queue size implementation is 64kb\n         * ensure that we leave room for logs, rum and potential other users\n         */\n        batchBytesLimit: 16 * ONE_KIBI_BYTE,\n        eventRateLimiterThreshold: 3000,\n        maxTelemetryEventsPerPage: 15,\n        /**\n         * flush automatically, aim to be lower than ALB connection timeout\n         * to maximize connection reuse.\n         */\n        flushTimeout: (30 * ONE_SECOND),\n        /**\n         * Logs intake limit\n         */\n        batchMessagesLimit: 50,\n        messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    }, computeTransportConfiguration(initConfiguration));\n}\nexport function serializeConfiguration(initConfiguration) {\n    return {\n        session_sample_rate: initConfiguration.sessionSampleRate,\n        telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n        telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n        telemetry_usage_sample_rate: initConfiguration.telemetryUsageSampleRate,\n        use_before_send: !!initConfiguration.beforeSend,\n        use_cross_site_session_cookie: initConfiguration.useCrossSiteSessionCookie,\n        use_partitioned_cross_site_session_cookie: initConfiguration.usePartitionedCrossSiteSessionCookie,\n        use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n        use_proxy: !!initConfiguration.proxy,\n        silent_multiple_init: initConfiguration.silentMultipleInit,\n        track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n        session_persistence: initConfiguration.sessionPersistence,\n        allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n        store_contexts_across_pages: !!initConfiguration.storeContextsAcrossPages,\n        allow_untrusted_events: !!initConfiguration.allowUntrustedEvents,\n        tracking_consent: initConfiguration.trackingConsent,\n    };\n}\n//# sourceMappingURL=configuration.js.map","import { startsWith } from './utils/polyfills';\nimport { display } from './display';\nimport { getType } from './utils/typeUtils';\nexport function isMatchOption(item) {\n    var itemType = getType(item);\n    return itemType === 'string' || itemType === 'function' || item instanceof RegExp;\n}\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list, value, useStartsWith) {\n    if (useStartsWith === void 0) { useStartsWith = false; }\n    return list.some(function (item) {\n        try {\n            if (typeof item === 'function') {\n                return item(value);\n            }\n            else if (item instanceof RegExp) {\n                return item.test(value);\n            }\n            else if (typeof item === 'string') {\n                return useStartsWith ? startsWith(value, item) : item === value;\n            }\n        }\n        catch (e) {\n            display.error(e);\n        }\n        return false;\n    });\n}\n//# sourceMappingURL=matchOption.js.map","export function getCrypto() {\n    // TODO: remove msCrypto when IE11 support is dropped\n    return window.crypto || window.msCrypto;\n}\n//# sourceMappingURL=crypto.js.map","import { ExperimentalFeature, isExperimentalFeatureEnabled } from '@datadog/browser-core';\nimport { getCrypto } from '../../browser/crypto';\nexport function createTraceIdentifier() {\n    return createIdentifier(64);\n}\nexport function createSpanIdentifier() {\n    return createIdentifier(63);\n}\nvar createIdentifierImplementationCache;\nfunction createIdentifier(bits) {\n    if (!createIdentifierImplementationCache) {\n        createIdentifierImplementationCache =\n            isExperimentalFeatureEnabled(ExperimentalFeature.CONSISTENT_TRACE_SAMPLING) && areBigIntIdentifiersSupported()\n                ? createIdentifierUsingBigInt\n                : createIdentifierUsingUint32Array;\n    }\n    return createIdentifierImplementationCache(bits);\n}\nexport function areBigIntIdentifiersSupported() {\n    try {\n        crypto.getRandomValues(new BigUint64Array(1));\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createIdentifierUsingBigInt(bits) {\n    var id = crypto.getRandomValues(new BigUint64Array(1))[0];\n    if (bits === 63) {\n        // eslint-disable-next-line no-bitwise\n        id >>= BigInt('1');\n    }\n    return id;\n}\n// TODO: remove this when all browser we support have BigInt support\nfunction createIdentifierUsingUint32Array(bits) {\n    var buffer = getCrypto().getRandomValues(new Uint32Array(2));\n    if (bits === 63) {\n        // eslint-disable-next-line no-bitwise\n        buffer[buffer.length - 1] >>>= 1; // force 63-bit\n    }\n    return {\n        toString: function (radix) {\n            if (radix === void 0) { radix = 10; }\n            var high = buffer[1];\n            var low = buffer[0];\n            var str = '';\n            do {\n                var mod = (high % radix) * 4294967296 + low;\n                high = Math.floor(high / radix);\n                low = Math.floor(mod / radix);\n                str = (mod % radix).toString(radix) + str;\n            } while (high || low);\n            return str;\n        },\n    };\n}\nexport function toPaddedHexadecimalString(id) {\n    var traceId = id.toString(16);\n    // TODO: replace with String.prototype.padStart when we drop IE11 support\n    return Array(17 - traceId.length).join('0') + traceId;\n}\n//# sourceMappingURL=identifier.js.map","import { performDraw } from '@datadog/browser-core';\nexport function isTraceSampled(identifier, sampleRate) {\n    // Shortcuts for common cases. This is not strictly necessary, but it makes the code faster for\n    // customers willing to ingest all traces.\n    if (sampleRate === 100) {\n        return true;\n    }\n    if (sampleRate === 0) {\n        return false;\n    }\n    // For simplicity, we don't use consistent sampling for browser that don't support BigInt\n    // TODO: remove this when all browser we support have BigInt support\n    if (typeof identifier !== 'bigint') {\n        return performDraw(sampleRate);\n    }\n    // Offer consistent sampling for the same trace id across different environments. The rule is:\n    //\n    //   (identifier * knuthFactor) % 2^64 < sampleRate * 2^64\n    //\n    // Because JavaScript numbers are 64-bit floats, we can't represent 64-bit integers, and the\n    // modulo would be incorrect. Thus, we are using BigInts here.\n    //\n    // Implementation in other languages:\n    // * Go     https://github.com/DataDog/dd-trace-go/blob/ec6fbb1f2d517b7b8e69961052adf7136f3af773/ddtrace/tracer/sampler.go#L86-L91\n    // * Python https://github.com/DataDog/dd-trace-py/blob/0cee2f066fb6e79aa15947c1514c0f406dea47c5/ddtrace/sampling_rule.py#L197\n    // * Ruby   https://github.com/DataDog/dd-trace-rb/blob/1a6e255cdcb7e7e22235ea5955f90f6dfa91045d/lib/datadog/tracing/sampling/rate_sampler.rb#L42\n    // * C++    https://github.com/DataDog/dd-trace-cpp/blob/159629edc438ae45f2bb318eb7bd51abd05e94b5/src/datadog/trace_sampler.cpp#L58\n    // * Java   https://github.com/DataDog/dd-trace-java/blob/896dd6b380533216e0bdee59614606c8272d313e/dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java#L48\n    //\n    // Note: All implementations have slight variations. Some of them use '<=' instead of '<', and\n    // use `sampleRate * 2^64 - 1` instead of `sampleRate * 2^64`. The following implementation\n    // should adhere to the spec and is a bit simpler than using a 2^64-1 limit as there are less\n    // BigInt arithmetic to write. In practice this does not matter, as we are using floating point\n    // numbers in the end, and Number(2n**64n-1n) === Number(2n**64n).\n    var knuthFactor = BigInt('1111111111111111111');\n    var twoPow64 = BigInt('0x10000000000000000'); // 2n ** 64n\n    var hash = (identifier * knuthFactor) % twoPow64;\n    return Number(hash) <= (sampleRate / 100) * Number(twoPow64);\n}\n//# sourceMappingURL=sampler.js.map","import { objectEntries, shallowClone, assign, find, getType, isMatchOption, matchList, TraceContextInjection, } from '@datadog/browser-core';\nimport { getCrypto } from '../../browser/crypto';\nimport { createSpanIdentifier, createTraceIdentifier, toPaddedHexadecimalString } from './identifier';\nimport { isTraceSampled } from './sampler';\nexport function isTracingOption(item) {\n    var expectedItem = item;\n    return (getType(expectedItem) === 'object' &&\n        isMatchOption(expectedItem.match) &&\n        Array.isArray(expectedItem.propagatorTypes));\n}\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context) {\n    if (context.status === 0 && !context.isAborted) {\n        context.traceId = undefined;\n        context.spanId = undefined;\n        context.traceSampled = undefined;\n    }\n}\nexport function startTracer(configuration, sessionManager) {\n    return {\n        clearTracingIfNeeded: clearTracingIfNeeded,\n        traceFetch: function (context) {\n            return injectHeadersIfTracingAllowed(configuration, context, sessionManager, function (tracingHeaders) {\n                var _a;\n                if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {\n                    context.input = new Request(context.input);\n                    Object.keys(tracingHeaders).forEach(function (key) {\n                        ;\n                        context.input.headers.append(key, tracingHeaders[key]);\n                    });\n                }\n                else {\n                    context.init = shallowClone(context.init);\n                    var headers_1 = [];\n                    if (context.init.headers instanceof Headers) {\n                        context.init.headers.forEach(function (value, key) {\n                            headers_1.push([key, value]);\n                        });\n                    }\n                    else if (Array.isArray(context.init.headers)) {\n                        context.init.headers.forEach(function (header) {\n                            headers_1.push(header);\n                        });\n                    }\n                    else if (context.init.headers) {\n                        Object.keys(context.init.headers).forEach(function (key) {\n                            headers_1.push([key, context.init.headers[key]]);\n                        });\n                    }\n                    context.init.headers = headers_1.concat(objectEntries(tracingHeaders));\n                }\n            });\n        },\n        traceXhr: function (context, xhr) {\n            return injectHeadersIfTracingAllowed(configuration, context, sessionManager, function (tracingHeaders) {\n                Object.keys(tracingHeaders).forEach(function (name) {\n                    xhr.setRequestHeader(name, tracingHeaders[name]);\n                });\n            });\n        },\n    };\n}\nfunction injectHeadersIfTracingAllowed(configuration, context, sessionManager, inject) {\n    if (!isTracingSupported() || !sessionManager.findTrackedSession()) {\n        return;\n    }\n    var tracingOption = find(configuration.allowedTracingUrls, function (tracingOption) {\n        return matchList([tracingOption.match], context.url, true);\n    });\n    if (!tracingOption) {\n        return;\n    }\n    var traceId = createTraceIdentifier();\n    context.traceSampled = isTraceSampled(traceId, configuration.traceSampleRate);\n    var shouldInjectHeaders = context.traceSampled || configuration.traceContextInjection === TraceContextInjection.ALL;\n    if (!shouldInjectHeaders) {\n        return;\n    }\n    context.traceId = traceId;\n    context.spanId = createSpanIdentifier();\n    inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes));\n}\nexport function isTracingSupported() {\n    return getCrypto() !== undefined;\n}\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(traceId, spanId, traceSampled, propagatorTypes) {\n    var tracingHeaders = {};\n    propagatorTypes.forEach(function (propagatorType) {\n        switch (propagatorType) {\n            case 'datadog': {\n                assign(tracingHeaders, {\n                    'x-datadog-origin': 'rum',\n                    'x-datadog-parent-id': spanId.toString(),\n                    'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n                    'x-datadog-trace-id': traceId.toString(),\n                });\n                break;\n            }\n            // https://www.w3.org/TR/trace-context/\n            case 'tracecontext': {\n                assign(tracingHeaders, {\n                    traceparent: \"00-0000000000000000\".concat(toPaddedHexadecimalString(traceId), \"-\").concat(toPaddedHexadecimalString(spanId), \"-0\").concat(traceSampled ? '1' : '0'),\n                });\n                break;\n            }\n            // https://github.com/openzipkin/b3-propagation\n            case 'b3': {\n                assign(tracingHeaders, {\n                    b3: \"\".concat(toPaddedHexadecimalString(traceId), \"-\").concat(toPaddedHexadecimalString(spanId), \"-\").concat(traceSampled ? '1' : '0'),\n                });\n                break;\n            }\n            case 'b3multi': {\n                assign(tracingHeaders, {\n                    'X-B3-TraceId': toPaddedHexadecimalString(traceId),\n                    'X-B3-SpanId': toPaddedHexadecimalString(spanId),\n                    'X-B3-Sampled': traceSampled ? '1' : '0',\n                });\n                break;\n            }\n        }\n    });\n    return tracingHeaders;\n}\n//# sourceMappingURL=tracer.js.map","import { getType, arrayFrom, isMatchOption, serializeConfiguration, assign, DefaultPrivacyLevel, TraceContextInjection, display, objectHasValue, validateAndBuildConfiguration, isSampleRate, isNumber, } from '@datadog/browser-core';\nimport { isTracingOption } from '../tracing/tracer';\nexport var DEFAULT_PROPAGATOR_TYPES = ['tracecontext', 'datadog'];\nexport function validateAndBuildRumConfiguration(initConfiguration) {\n    var _a, _b, _c;\n    if (!initConfiguration.applicationId) {\n        display.error('Application ID is not configured, no RUM data will be collected.');\n        return;\n    }\n    if (!isSampleRate(initConfiguration.sessionReplaySampleRate, 'Session Replay') ||\n        !isSampleRate(initConfiguration.traceSampleRate, 'Trace')) {\n        return;\n    }\n    if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n        display.error('Excluded Activity Urls should be an array');\n        return;\n    }\n    var allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration);\n    if (!allowedTracingUrls) {\n        return;\n    }\n    var baseConfiguration = validateAndBuildConfiguration(initConfiguration);\n    if (!baseConfiguration) {\n        return;\n    }\n    var sessionReplaySampleRate = (_a = initConfiguration.sessionReplaySampleRate) !== null && _a !== void 0 ? _a : 0;\n    return assign({\n        applicationId: initConfiguration.applicationId,\n        version: initConfiguration.version || undefined,\n        actionNameAttribute: initConfiguration.actionNameAttribute,\n        sessionReplaySampleRate: sessionReplaySampleRate,\n        startSessionReplayRecordingManually: initConfiguration.startSessionReplayRecordingManually !== undefined\n            ? !!initConfiguration.startSessionReplayRecordingManually\n            : sessionReplaySampleRate === 0,\n        traceSampleRate: (_b = initConfiguration.traceSampleRate) !== null && _b !== void 0 ? _b : 100,\n        rulePsr: isNumber(initConfiguration.traceSampleRate) ? initConfiguration.traceSampleRate / 100 : undefined,\n        allowedTracingUrls: allowedTracingUrls,\n        excludedActivityUrls: (_c = initConfiguration.excludedActivityUrls) !== null && _c !== void 0 ? _c : [],\n        workerUrl: initConfiguration.workerUrl,\n        compressIntakeRequests: !!initConfiguration.compressIntakeRequests,\n        trackUserInteractions: !!initConfiguration.trackUserInteractions,\n        trackViewsManually: !!initConfiguration.trackViewsManually,\n        trackResources: !!initConfiguration.trackResources,\n        trackLongTasks: !!initConfiguration.trackLongTasks,\n        subdomain: initConfiguration.subdomain,\n        defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n            ? initConfiguration.defaultPrivacyLevel\n            : DefaultPrivacyLevel.MASK,\n        enablePrivacyForActionName: !!initConfiguration.enablePrivacyForActionName,\n        customerDataTelemetrySampleRate: 1,\n        traceContextInjection: objectHasValue(TraceContextInjection, initConfiguration.traceContextInjection)\n            ? initConfiguration.traceContextInjection\n            : TraceContextInjection.ALL,\n        plugins: initConfiguration.plugins || [],\n    }, baseConfiguration);\n}\n/**\n * Validates allowedTracingUrls and converts match options to tracing options\n */\nfunction validateAndBuildTracingOptions(initConfiguration) {\n    if (initConfiguration.allowedTracingUrls === undefined) {\n        return [];\n    }\n    if (!Array.isArray(initConfiguration.allowedTracingUrls)) {\n        display.error('Allowed Tracing URLs should be an array');\n        return;\n    }\n    if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {\n        display.error('Service needs to be configured when tracing is enabled');\n        return;\n    }\n    // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties\n    var tracingOptions = [];\n    initConfiguration.allowedTracingUrls.forEach(function (option) {\n        if (isMatchOption(option)) {\n            tracingOptions.push({ match: option, propagatorTypes: DEFAULT_PROPAGATOR_TYPES });\n        }\n        else if (isTracingOption(option)) {\n            tracingOptions.push(option);\n        }\n        else {\n            display.warn('Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter', option);\n        }\n    });\n    return tracingOptions;\n}\n/**\n * Combines the selected tracing propagators from the different options in allowedTracingUrls\n */\nfunction getSelectedTracingPropagators(configuration) {\n    var usedTracingPropagators = new Set();\n    if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {\n        configuration.allowedTracingUrls.forEach(function (option) {\n            if (isMatchOption(option)) {\n                DEFAULT_PROPAGATOR_TYPES.forEach(function (propagatorType) { return usedTracingPropagators.add(propagatorType); });\n            }\n            else if (getType(option) === 'object' && Array.isArray(option.propagatorTypes)) {\n                // Ensure we have an array, as we cannot rely on types yet (configuration is provided by users)\n                option.propagatorTypes.forEach(function (propagatorType) { return usedTracingPropagators.add(propagatorType); });\n            }\n        });\n    }\n    return arrayFrom(usedTracingPropagators);\n}\nexport function serializeRumConfiguration(configuration) {\n    var _a;\n    var baseSerializedConfiguration = serializeConfiguration(configuration);\n    return assign({\n        session_replay_sample_rate: configuration.sessionReplaySampleRate,\n        start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n        trace_sample_rate: configuration.traceSampleRate,\n        trace_context_injection: configuration.traceContextInjection,\n        action_name_attribute: configuration.actionNameAttribute,\n        use_allowed_tracing_urls: Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,\n        selected_tracing_propagators: getSelectedTracingPropagators(configuration),\n        default_privacy_level: configuration.defaultPrivacyLevel,\n        enable_privacy_for_action_name: configuration.enablePrivacyForActionName,\n        use_excluded_activity_urls: Array.isArray(configuration.excludedActivityUrls) && configuration.excludedActivityUrls.length > 0,\n        use_worker_url: !!configuration.workerUrl,\n        compress_intake_requests: configuration.compressIntakeRequests,\n        track_views_manually: configuration.trackViewsManually,\n        track_user_interactions: configuration.trackUserInteractions,\n        track_resources: configuration.trackResources,\n        track_long_task: configuration.trackLongTasks,\n        plugins: (_a = configuration.plugins) === null || _a === void 0 ? void 0 : _a.map(function (plugin) { var _a; return assign({ name: plugin.name }, (_a = plugin.getConfigurationTelemetry) === null || _a === void 0 ? void 0 : _a.call(plugin)); }),\n    }, baseSerializedConfiguration);\n}\n//# sourceMappingURL=configuration.js.map","import { display, addEventListener, assign } from '@datadog/browser-core';\nexport var REMOTE_CONFIGURATION_URL = 'https://d3uc069fcn7uxw.cloudfront.net/configuration';\nexport function fetchAndApplyRemoteConfiguration(initConfiguration, callback) {\n    fetchRemoteConfiguration(initConfiguration, function (remoteInitConfiguration) {\n        callback(applyRemoteConfiguration(initConfiguration, remoteInitConfiguration));\n    });\n}\nexport function applyRemoteConfiguration(initConfiguration, remoteInitConfiguration) {\n    return assign({}, initConfiguration, remoteInitConfiguration);\n}\nexport function fetchRemoteConfiguration(configuration, callback) {\n    var xhr = new XMLHttpRequest();\n    addEventListener(configuration, xhr, 'load', function () {\n        if (xhr.status === 200) {\n            callback(JSON.parse(xhr.responseText));\n        }\n        else {\n            displayRemoteConfigurationFetchingError();\n        }\n    });\n    addEventListener(configuration, xhr, 'error', function () {\n        displayRemoteConfigurationFetchingError();\n    });\n    xhr.open('GET', \"\".concat(REMOTE_CONFIGURATION_URL, \"/\").concat(encodeURIComponent(configuration.remoteConfigurationId), \".json\"));\n    xhr.send();\n}\nfunction displayRemoteConfigurationFetchingError() {\n    display.error('Error fetching the remote configuration.');\n}\n//# sourceMappingURL=remoteConfiguration.js.map","export function callPluginsMethod(plugins, methodName, parameter) {\n    if (!plugins) {\n        return;\n    }\n    for (var _i = 0, plugins_1 = plugins; _i < plugins_1.length; _i++) {\n        var plugin = plugins_1[_i];\n        var method = plugin[methodName];\n        if (method) {\n            method(parameter);\n        }\n    }\n}\n//# sourceMappingURL=plugins.js.map","import { createBoundedBuffer, display, canUseEventBridge, displayAlreadyInitializedError, willSyntheticsInjectRum, noop, timeStampNow, clocksNow, assign, getEventBridge, ExperimentalFeature, isExperimentalFeatureEnabled, initFeatureFlags, addTelemetryConfiguration, initFetchObservable, } from '@datadog/browser-core';\nimport { validateAndBuildRumConfiguration, } from '../domain/configuration';\nimport { startDurationVital, stopDurationVital } from '../domain/vital/vitalCollection';\nimport { fetchAndApplyRemoteConfiguration, serializeRumConfiguration } from '../domain/configuration';\nimport { callPluginsMethod } from '../domain/plugins';\nexport function createPreStartStrategy(_a, getCommonContext, trackingConsentState, customVitalsState, doStartRum) {\n    var ignoreInitIfSyntheticsWillInjectRum = _a.ignoreInitIfSyntheticsWillInjectRum, startDeflateWorker = _a.startDeflateWorker;\n    var bufferApiCalls = createBoundedBuffer();\n    var firstStartViewCall;\n    var deflateWorker;\n    var cachedInitConfiguration;\n    var cachedConfiguration;\n    var trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartRum);\n    function tryStartRum() {\n        if (!cachedInitConfiguration || !cachedConfiguration || !trackingConsentState.isGranted()) {\n            return;\n        }\n        trackingConsentStateSubscription.unsubscribe();\n        var initialViewOptions;\n        if (cachedConfiguration.trackViewsManually) {\n            if (!firstStartViewCall) {\n                return;\n            }\n            // An initial view is always created when starting RUM.\n            // When tracking views automatically, any startView call before RUM start creates an extra\n            // view.\n            // When tracking views manually, we use the ViewOptions from the first startView call as the\n            // initial view options, and we remove the actual startView call so we don't create an extra\n            // view.\n            bufferApiCalls.remove(firstStartViewCall.callback);\n            initialViewOptions = firstStartViewCall.options;\n        }\n        var startRumResult = doStartRum(cachedConfiguration, deflateWorker, initialViewOptions);\n        bufferApiCalls.drain(startRumResult);\n    }\n    function doInit(initConfiguration) {\n        var eventBridgeAvailable = canUseEventBridge();\n        if (eventBridgeAvailable) {\n            initConfiguration = overrideInitConfigurationForBridge(initConfiguration);\n        }\n        // Update the exposed initConfiguration to reflect the bridge and remote configuration overrides\n        cachedInitConfiguration = initConfiguration;\n        addTelemetryConfiguration(serializeRumConfiguration(initConfiguration));\n        if (cachedConfiguration) {\n            displayAlreadyInitializedError('DD_RUM', initConfiguration);\n            return;\n        }\n        var configuration = validateAndBuildRumConfiguration(initConfiguration);\n        if (!configuration) {\n            return;\n        }\n        if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {\n            display.warn('No storage available for session. We will not send any data.');\n            return;\n        }\n        if (configuration.compressIntakeRequests && !eventBridgeAvailable && startDeflateWorker) {\n            deflateWorker = startDeflateWorker(configuration, 'Datadog RUM', \n            // Worker initialization can fail asynchronously, especially in Firefox where even CSP\n            // issues are reported asynchronously. For now, the SDK will continue its execution even if\n            // data won't be sent to Datadog. We could improve this behavior in the future.\n            noop);\n            if (!deflateWorker) {\n                // `startDeflateWorker` should have logged an error message explaining the issue\n                return;\n            }\n        }\n        cachedConfiguration = configuration;\n        // Instrumuent fetch to track network requests\n        // This is needed in case the consent is not granted and some cutsomer\n        // library (Apollo Client) is storing uninstrumented fetch to be used later\n        // The subscrption is needed so that the instrumentation process is completed\n        initFetchObservable().subscribe(noop);\n        trackingConsentState.tryToInit(configuration.trackingConsent);\n        tryStartRum();\n    }\n    var addDurationVital = function (vital) {\n        bufferApiCalls.add(function (startRumResult) { return startRumResult.addDurationVital(vital); });\n    };\n    return {\n        init: function (initConfiguration, publicApi) {\n            if (!initConfiguration) {\n                display.error('Missing configuration');\n                return;\n            }\n            // Set the experimental feature flags as early as possible, so we can use them in most places\n            initFeatureFlags(initConfiguration.enableExperimentalFeatures);\n            // Expose the initial configuration regardless of initialization success.\n            cachedInitConfiguration = initConfiguration;\n            // If we are in a Synthetics test configured to automatically inject a RUM instance, we want\n            // to completely discard the customer application RUM instance by ignoring their init() call.\n            // But, we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n            // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n            if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n                return;\n            }\n            callPluginsMethod(initConfiguration.plugins, 'onInit', { initConfiguration: initConfiguration, publicApi: publicApi });\n            if (initConfiguration.remoteConfigurationId &&\n                isExperimentalFeatureEnabled(ExperimentalFeature.REMOTE_CONFIGURATION)) {\n                fetchAndApplyRemoteConfiguration(initConfiguration, doInit);\n            }\n            else {\n                doInit(initConfiguration);\n            }\n        },\n        get initConfiguration() {\n            return cachedInitConfiguration;\n        },\n        getInternalContext: noop,\n        stopSession: noop,\n        addTiming: function (name, time) {\n            if (time === void 0) { time = timeStampNow(); }\n            bufferApiCalls.add(function (startRumResult) { return startRumResult.addTiming(name, time); });\n        },\n        startView: function (options, startClocks) {\n            if (startClocks === void 0) { startClocks = clocksNow(); }\n            var callback = function (startRumResult) {\n                startRumResult.startView(options, startClocks);\n            };\n            bufferApiCalls.add(callback);\n            if (!firstStartViewCall) {\n                firstStartViewCall = { options: options, callback: callback };\n                tryStartRum();\n            }\n        },\n        setViewName: function (name) {\n            bufferApiCalls.add(function (startRumResult) { return startRumResult.setViewName(name); });\n        },\n        setViewContext: function (context) {\n            bufferApiCalls.add(function (startRumResult) { return startRumResult.setViewContext(context); });\n        },\n        setViewContextProperty: function (key, value) {\n            bufferApiCalls.add(function (startRumResult) { return startRumResult.setViewContextProperty(key, value); });\n        },\n        addAction: function (action, commonContext) {\n            if (commonContext === void 0) { commonContext = getCommonContext(); }\n            bufferApiCalls.add(function (startRumResult) { return startRumResult.addAction(action, commonContext); });\n        },\n        addError: function (providedError, commonContext) {\n            if (commonContext === void 0) { commonContext = getCommonContext(); }\n            bufferApiCalls.add(function (startRumResult) { return startRumResult.addError(providedError, commonContext); });\n        },\n        addFeatureFlagEvaluation: function (key, value) {\n            bufferApiCalls.add(function (startRumResult) { return startRumResult.addFeatureFlagEvaluation(key, value); });\n        },\n        startDurationVital: function (name, options) {\n            return startDurationVital(customVitalsState, name, options);\n        },\n        stopDurationVital: function (name, options) {\n            stopDurationVital(addDurationVital, customVitalsState, name, options);\n        },\n        addDurationVital: addDurationVital,\n    };\n}\nfunction overrideInitConfigurationForBridge(initConfiguration) {\n    var _a, _b;\n    return assign({}, initConfiguration, {\n        applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n        clientToken: 'empty',\n        sessionSampleRate: 100,\n        defaultPrivacyLevel: (_a = initConfiguration.defaultPrivacyLevel) !== null && _a !== void 0 ? _a : (_b = getEventBridge()) === null || _b === void 0 ? void 0 : _b.getPrivacyLevel(),\n    });\n}\n//# sourceMappingURL=preStartRum.js.map","import { addTelemetryUsage, assign, createContextManager, deepClone, makePublicApi, monitor, clocksNow, callMonitored, createHandlingStack, checkUser, sanitizeUser, sanitize, createIdentityEncoder, createCustomerDataTrackerManager, storeContextManager, displayAlreadyInitializedError, createTrackingConsentState, timeStampToClocks, } from '@datadog/browser-core';\nimport { buildCommonContext } from '../domain/contexts/commonContext';\nimport { createCustomVitalsState } from '../domain/vital/vitalCollection';\nimport { createPreStartStrategy } from './preStartRum';\nvar RUM_STORAGE_KEY = 'rum';\nexport function makeRumPublicApi(startRumImpl, recorderApi, options) {\n    if (options === void 0) { options = {}; }\n    var customerDataTrackerManager = createCustomerDataTrackerManager(0 /* CustomerDataCompressionStatus.Unknown */);\n    var globalContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(2 /* CustomerDataType.GlobalContext */));\n    var userContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */));\n    var trackingConsentState = createTrackingConsentState();\n    var customVitalsState = createCustomVitalsState();\n    function getCommonContext() {\n        return buildCommonContext(globalContextManager, userContextManager, recorderApi);\n    }\n    var strategy = createPreStartStrategy(options, getCommonContext, trackingConsentState, customVitalsState, function (configuration, deflateWorker, initialViewOptions) {\n        if (configuration.storeContextsAcrossPages) {\n            storeContextManager(configuration, globalContextManager, RUM_STORAGE_KEY, 2 /* CustomerDataType.GlobalContext */);\n            storeContextManager(configuration, userContextManager, RUM_STORAGE_KEY, 1 /* CustomerDataType.User */);\n        }\n        customerDataTrackerManager.setCompressionStatus(deflateWorker ? 1 /* CustomerDataCompressionStatus.Enabled */ : 2 /* CustomerDataCompressionStatus.Disabled */);\n        var startRumResult = startRumImpl(configuration, recorderApi, customerDataTrackerManager, getCommonContext, initialViewOptions, deflateWorker && options.createDeflateEncoder\n            ? function (streamId) { return options.createDeflateEncoder(configuration, deflateWorker, streamId); }\n            : createIdentityEncoder, trackingConsentState, customVitalsState);\n        recorderApi.onRumStart(startRumResult.lifeCycle, configuration, startRumResult.session, startRumResult.viewHistory, deflateWorker);\n        strategy = createPostStartStrategy(strategy, startRumResult);\n        return startRumResult;\n    });\n    var startView = monitor(function (options) {\n        var sanitizedOptions = typeof options === 'object' ? options : { name: options };\n        if (sanitizedOptions.context) {\n            customerDataTrackerManager.getOrCreateTracker(3 /* CustomerDataType.View */).updateCustomerData(sanitizedOptions.context);\n        }\n        strategy.startView(sanitizedOptions);\n        addTelemetryUsage({ feature: 'start-view' });\n    });\n    var rumPublicApi = makePublicApi({\n        init: monitor(function (initConfiguration) {\n            strategy.init(initConfiguration, rumPublicApi);\n        }),\n        setTrackingConsent: monitor(function (trackingConsent) {\n            trackingConsentState.update(trackingConsent);\n            addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent });\n        }),\n        setViewName: monitor(function (name) {\n            strategy.setViewName(name);\n        }),\n        setViewContext: monitor(function (context) {\n            strategy.setViewContext(context);\n        }),\n        setViewContextProperty: monitor(function (key, value) {\n            strategy.setViewContextProperty(key, value);\n        }),\n        setGlobalContext: monitor(function (context) {\n            globalContextManager.setContext(context);\n            addTelemetryUsage({ feature: 'set-global-context' });\n        }),\n        getGlobalContext: monitor(function () { return globalContextManager.getContext(); }),\n        setGlobalContextProperty: monitor(function (key, value) {\n            globalContextManager.setContextProperty(key, value);\n            addTelemetryUsage({ feature: 'set-global-context' });\n        }),\n        removeGlobalContextProperty: monitor(function (key) { return globalContextManager.removeContextProperty(key); }),\n        clearGlobalContext: monitor(function () { return globalContextManager.clearContext(); }),\n        getInternalContext: monitor(function (startTime) { return strategy.getInternalContext(startTime); }),\n        getInitConfiguration: monitor(function () { return deepClone(strategy.initConfiguration); }),\n        addAction: function (name, context) {\n            var handlingStack = createHandlingStack();\n            callMonitored(function () {\n                strategy.addAction({\n                    name: sanitize(name),\n                    context: sanitize(context),\n                    startClocks: clocksNow(),\n                    type: \"custom\" /* ActionType.CUSTOM */,\n                    handlingStack: handlingStack,\n                });\n                addTelemetryUsage({ feature: 'add-action' });\n            });\n        },\n        addError: function (error, context) {\n            var handlingStack = createHandlingStack();\n            callMonitored(function () {\n                strategy.addError({\n                    error: error, // Do not sanitize error here, it is needed unserialized by computeRawError()\n                    handlingStack: handlingStack,\n                    context: sanitize(context),\n                    startClocks: clocksNow(),\n                });\n                addTelemetryUsage({ feature: 'add-error' });\n            });\n        },\n        addTiming: monitor(function (name, time) {\n            // TODO: next major decide to drop relative time support or update its behaviour\n            strategy.addTiming(sanitize(name), time);\n        }),\n        setUser: monitor(function (newUser) {\n            if (checkUser(newUser)) {\n                userContextManager.setContext(sanitizeUser(newUser));\n            }\n            addTelemetryUsage({ feature: 'set-user' });\n        }),\n        getUser: monitor(function () { return userContextManager.getContext(); }),\n        setUserProperty: monitor(function (key, property) {\n            var _a;\n            var sanitizedProperty = sanitizeUser((_a = {}, _a[key] = property, _a))[key];\n            userContextManager.setContextProperty(key, sanitizedProperty);\n            addTelemetryUsage({ feature: 'set-user' });\n        }),\n        removeUserProperty: monitor(function (key) { return userContextManager.removeContextProperty(key); }),\n        clearUser: monitor(function () { return userContextManager.clearContext(); }),\n        startView: startView,\n        stopSession: monitor(function () {\n            strategy.stopSession();\n            addTelemetryUsage({ feature: 'stop-session' });\n        }),\n        addFeatureFlagEvaluation: monitor(function (key, value) {\n            strategy.addFeatureFlagEvaluation(sanitize(key), sanitize(value));\n            addTelemetryUsage({ feature: 'add-feature-flag-evaluation' });\n        }),\n        getSessionReplayLink: monitor(function () { return recorderApi.getSessionReplayLink(); }),\n        startSessionReplayRecording: monitor(function (options) {\n            recorderApi.start(options);\n            addTelemetryUsage({ feature: 'start-session-replay-recording', force: options && options.force });\n        }),\n        stopSessionReplayRecording: monitor(function () { return recorderApi.stop(); }),\n        addDurationVital: monitor(function (name, options) {\n            addTelemetryUsage({ feature: 'add-duration-vital' });\n            strategy.addDurationVital({\n                name: sanitize(name),\n                type: \"duration\" /* VitalType.DURATION */,\n                startClocks: timeStampToClocks(options.startTime),\n                duration: options.duration,\n                context: sanitize(options && options.context),\n                description: sanitize(options && options.description),\n            });\n        }),\n        startDurationVital: monitor(function (name, options) {\n            addTelemetryUsage({ feature: 'start-duration-vital' });\n            return strategy.startDurationVital(sanitize(name), {\n                context: sanitize(options && options.context),\n                description: sanitize(options && options.description),\n            });\n        }),\n        stopDurationVital: monitor(function (nameOrRef, options) {\n            addTelemetryUsage({ feature: 'stop-duration-vital' });\n            strategy.stopDurationVital(typeof nameOrRef === 'string' ? sanitize(nameOrRef) : nameOrRef, {\n                context: sanitize(options && options.context),\n                description: sanitize(options && options.description),\n            });\n        }),\n    });\n    return rumPublicApi;\n}\nfunction createPostStartStrategy(preStartStrategy, startRumResult) {\n    return assign({\n        init: function (initConfiguration) {\n            displayAlreadyInitializedError('DD_RUM', initConfiguration);\n        },\n        initConfiguration: preStartStrategy.initConfiguration,\n    }, startRumResult);\n}\n//# sourceMappingURL=rumPublicApi.js.map","import { Observable } from '../tools/observable';\nimport { objectValues, includes } from '../tools/utils/polyfills';\nimport { addEventListeners, addEventListener } from './addEventListener';\nexport var PageExitReason = {\n    HIDDEN: 'visibility_hidden',\n    UNLOADING: 'before_unload',\n    PAGEHIDE: 'page_hide',\n    FROZEN: 'page_frozen',\n};\nexport function createPageExitObservable(configuration) {\n    return new Observable(function (observable) {\n        var stopListeners = addEventListeners(configuration, window, [\"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, \"freeze\" /* DOM_EVENT.FREEZE */], function (event) {\n            if (event.type === \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */ && document.visibilityState === 'hidden') {\n                /**\n                 * Only event that guarantee to fire on mobile devices when the page transitions to background state\n                 * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n                 */\n                observable.notify({ reason: PageExitReason.HIDDEN });\n            }\n            else if (event.type === \"freeze\" /* DOM_EVENT.FREEZE */) {\n                /**\n                 * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n                 * Allow to collect events happening between hidden and frozen state.\n                 */\n                observable.notify({ reason: PageExitReason.FROZEN });\n            }\n        }, { capture: true }).stop;\n        var stopBeforeUnloadListener = addEventListener(configuration, window, \"beforeunload\" /* DOM_EVENT.BEFORE_UNLOAD */, function () {\n            observable.notify({ reason: PageExitReason.UNLOADING });\n        }).stop;\n        return function () {\n            stopListeners();\n            stopBeforeUnloadListener();\n        };\n    });\n}\nexport function isPageExitReason(reason) {\n    return includes(objectValues(PageExitReason), reason);\n}\n//# sourceMappingURL=pageExitObservable.js.map","import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core';\nexport function createDOMMutationObservable() {\n    var MutationObserver = getMutationObserverConstructor();\n    return new Observable(function (observable) {\n        if (!MutationObserver) {\n            return;\n        }\n        var observer = new MutationObserver(monitor(function () { return observable.notify(); }));\n        observer.observe(document, {\n            attributes: true,\n            characterData: true,\n            childList: true,\n            subtree: true,\n        });\n        return function () { return observer.disconnect(); };\n    });\n}\nexport function getMutationObserverConstructor() {\n    var constructor;\n    var browserWindow = window;\n    // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n    // global MutationObserver constructor with a patched version to support the context propagation.\n    // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n    // component: on some occasions, the callback is being called in an infinite loop, causing the\n    // page to freeze (even if the callback is completely empty).\n    //\n    // To work around this issue, we try to get the original MutationObserver constructor stored by\n    // Zone.js.\n    //\n    // [1] https://github.com/angular/angular/issues/26948\n    // [2] https://github.com/angular/angular/issues/31712\n    if (browserWindow.Zone) {\n        // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n        //\n        // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n        constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver');\n        if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n            // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n            // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n            // instance in its properties[4]. Let's get the original MutationObserver constructor from\n            // there.\n            //\n            // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n            var patchedInstance = new browserWindow.MutationObserver(noop);\n            var originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance');\n            constructor = originalInstance && originalInstance.constructor;\n        }\n    }\n    if (!constructor) {\n        constructor = browserWindow.MutationObserver;\n    }\n    return constructor;\n}\n//# sourceMappingURL=domMutationObservable.js.map","import { instrumentMethod, Observable } from '@datadog/browser-core';\nexport function createWindowOpenObservable() {\n    var observable = new Observable();\n    var stop = instrumentMethod(window, 'open', function () { return observable.notify(); }).stop;\n    return { observable: observable, stop: stop };\n}\n//# sourceMappingURL=windowOpenObservable.js.map","export var ErrorSource = {\n    AGENT: 'agent',\n    CONSOLE: 'console',\n    CUSTOM: 'custom',\n    LOGGER: 'logger',\n    NETWORK: 'network',\n    SOURCE: 'source',\n    REPORT: 'report',\n};\n//# sourceMappingURL=error.types.js.map","import { setTimeout } from '../../tools/timer';\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { ErrorSource } from '../error/error.types';\nexport function createEventRateLimiter(eventType, limit, onLimitReached) {\n    var eventCount = 0;\n    var allowNextEvent = false;\n    return {\n        isLimitReached: function () {\n            if (eventCount === 0) {\n                setTimeout(function () {\n                    eventCount = 0;\n                }, ONE_MINUTE);\n            }\n            eventCount += 1;\n            if (eventCount <= limit || allowNextEvent) {\n                allowNextEvent = false;\n                return false;\n            }\n            if (eventCount === limit + 1) {\n                allowNextEvent = true;\n                try {\n                    onLimitReached({\n                        message: \"Reached max number of \".concat(eventType, \"s by minute: \").concat(limit),\n                        source: ErrorSource.AGENT,\n                        startClocks: clocksNow(),\n                    });\n                }\n                finally {\n                    allowNextEvent = false;\n                }\n            }\n            return true;\n        },\n    };\n}\n//# sourceMappingURL=createEventRateLimiter.js.map","import { getSyntheticsResultId, getSyntheticsTestId, willSyntheticsInjectRum } from '@datadog/browser-core';\nexport function getSyntheticsContext() {\n    var testId = getSyntheticsTestId();\n    var resultId = getSyntheticsResultId();\n    if (testId && resultId) {\n        return {\n            test_id: testId,\n            result_id: resultId,\n            injected: willSyntheticsInjectRum(),\n        };\n    }\n}\n//# sourceMappingURL=syntheticsContext.js.map","import { sanitize, deepClone, getType, objectEntries } from '@datadog/browser-core';\n/**\n * Current limitation:\n * - field path do not support array, 'a.b.c' only\n */\nexport function limitModification(object, modifiableFieldPaths, modifier) {\n    var clone = deepClone(object);\n    var result = modifier(clone);\n    objectEntries(modifiableFieldPaths).forEach(function (_a) {\n        var fieldPath = _a[0], fieldType = _a[1];\n        var newValue = get(clone, fieldPath);\n        var newType = getType(newValue);\n        if (newType === fieldType) {\n            set(object, fieldPath, sanitize(newValue));\n        }\n        else if (fieldType === 'object' && (newType === 'undefined' || newType === 'null')) {\n            set(object, fieldPath, {});\n        }\n    });\n    return result;\n}\nfunction get(object, path) {\n    var current = object;\n    for (var _i = 0, _a = path.split('.'); _i < _a.length; _i++) {\n        var field = _a[_i];\n        if (!isValidObjectContaining(current, field)) {\n            return;\n        }\n        current = current[field];\n    }\n    return current;\n}\nfunction set(object, path, value) {\n    var current = object;\n    var fields = path.split('.');\n    for (var i = 0; i < fields.length; i += 1) {\n        var field = fields[i];\n        if (!isValidObject(current)) {\n            return;\n        }\n        if (i !== fields.length - 1) {\n            current = current[field];\n        }\n        else {\n            current[field] = value;\n        }\n    }\n}\nfunction isValidObject(object) {\n    return getType(object) === 'object';\n}\nfunction isValidObjectContaining(object, field) {\n    return isValidObject(object) && Object.prototype.hasOwnProperty.call(object, field);\n}\n//# sourceMappingURL=limitModification.js.map","import { combine, isEmptyObject, timeStampNow, currentDrift, display, createEventRateLimiter, canUseEventBridge, assign, round, isExperimentalFeatureEnabled, ExperimentalFeature, getConnectivity, } from '@datadog/browser-core';\nimport { getSyntheticsContext } from './contexts/syntheticsContext';\nimport { limitModification } from './limitModification';\nvar VIEW_MODIFIABLE_FIELD_PATHS = {\n    'view.name': 'string',\n    'view.url': 'string',\n    'view.referrer': 'string',\n};\nvar USER_CUSTOMIZABLE_FIELD_PATHS = {\n    context: 'object',\n};\nvar ROOT_MODIFIABLE_FIELD_PATHS = {\n    service: 'string',\n    version: 'string',\n};\nvar modifiableFieldPathsByEvent;\nexport function startRumAssembly(configuration, lifeCycle, sessionManager, viewHistory, urlContexts, actionContexts, displayContext, ciVisibilityContext, getCommonContext, reportError) {\n    var _a, _b;\n    modifiableFieldPathsByEvent = (_a = {},\n        _a[\"view\" /* RumEventType.VIEW */] = assign({}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS),\n        _a[\"error\" /* RumEventType.ERROR */] = assign({\n            'error.message': 'string',\n            'error.stack': 'string',\n            'error.resource.url': 'string',\n            'error.fingerprint': 'string',\n        }, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS, ROOT_MODIFIABLE_FIELD_PATHS),\n        _a[\"resource\" /* RumEventType.RESOURCE */] = assign({\n            'resource.url': 'string',\n        }, isExperimentalFeatureEnabled(ExperimentalFeature.WRITABLE_RESOURCE_GRAPHQL)\n            ? {\n                'resource.graphql': 'object',\n            }\n            : {}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS, ROOT_MODIFIABLE_FIELD_PATHS),\n        _a[\"action\" /* RumEventType.ACTION */] = assign({\n            'action.target.name': 'string',\n        }, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS, ROOT_MODIFIABLE_FIELD_PATHS),\n        _a[\"long_task\" /* RumEventType.LONG_TASK */] = assign({}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS),\n        _a[\"vital\" /* RumEventType.VITAL */] = assign({}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS),\n        _a);\n    var eventRateLimiters = (_b = {},\n        _b[\"error\" /* RumEventType.ERROR */] = createEventRateLimiter(\"error\" /* RumEventType.ERROR */, configuration.eventRateLimiterThreshold, reportError),\n        _b[\"action\" /* RumEventType.ACTION */] = createEventRateLimiter(\"action\" /* RumEventType.ACTION */, configuration.eventRateLimiterThreshold, reportError),\n        _b[\"vital\" /* RumEventType.VITAL */] = createEventRateLimiter(\"vital\" /* RumEventType.VITAL */, configuration.eventRateLimiterThreshold, reportError),\n        _b);\n    var syntheticsContext = getSyntheticsContext();\n    lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, function (_a) {\n        var startTime = _a.startTime, rawRumEvent = _a.rawRumEvent, domainContext = _a.domainContext, savedCommonContext = _a.savedCommonContext, customerContext = _a.customerContext;\n        var viewHistoryEntry = viewHistory.findView(startTime);\n        var urlContext = urlContexts.findUrl(startTime);\n        var session = sessionManager.findTrackedSession(startTime);\n        if (session && viewHistoryEntry && urlContext) {\n            var commonContext = savedCommonContext || getCommonContext();\n            var actionId = actionContexts.findActionId(startTime);\n            var rumContext = {\n                _dd: {\n                    format_version: 2,\n                    drift: currentDrift(),\n                    configuration: {\n                        session_sample_rate: round(configuration.sessionSampleRate, 3),\n                        session_replay_sample_rate: round(configuration.sessionReplaySampleRate, 3),\n                    },\n                    browser_sdk_version: canUseEventBridge() ? \"5.35.1\" : undefined,\n                },\n                application: {\n                    id: configuration.applicationId,\n                },\n                date: timeStampNow(),\n                service: viewHistoryEntry.service || configuration.service,\n                version: viewHistoryEntry.version || configuration.version,\n                source: 'browser',\n                session: {\n                    id: session.id,\n                    type: syntheticsContext\n                        ? \"synthetics\" /* SessionType.SYNTHETICS */\n                        : ciVisibilityContext.get()\n                            ? \"ci_test\" /* SessionType.CI_TEST */\n                            : \"user\" /* SessionType.USER */,\n                },\n                view: {\n                    id: viewHistoryEntry.id,\n                    name: viewHistoryEntry.name,\n                    url: urlContext.url,\n                    referrer: urlContext.referrer,\n                },\n                action: needToAssembleWithAction(rawRumEvent) && actionId ? { id: actionId } : undefined,\n                synthetics: syntheticsContext,\n                ci_test: ciVisibilityContext.get(),\n                display: displayContext.get(),\n                connectivity: getConnectivity(),\n            };\n            var serverRumEvent = combine(rumContext, rawRumEvent);\n            serverRumEvent.context = combine(commonContext.context, viewHistoryEntry.context, customerContext);\n            if (!('has_replay' in serverRumEvent.session)) {\n                ;\n                serverRumEvent.session.has_replay = commonContext.hasReplay;\n            }\n            if (serverRumEvent.type === 'view') {\n                ;\n                serverRumEvent.session.sampled_for_replay =\n                    session.sessionReplay === 1 /* SessionReplayState.SAMPLED */;\n            }\n            if (\n            // TODO: remove ff and should always add anonymous user id\n            isExperimentalFeatureEnabled(ExperimentalFeature.ANONYMOUS_USER_TRACKING) &&\n                !commonContext.user.anonymous_id) {\n                commonContext.user.anonymous_id = session.anonymousId;\n            }\n            if (!isEmptyObject(commonContext.user)) {\n                ;\n                serverRumEvent.usr = commonContext.user;\n            }\n            if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n                if (isEmptyObject(serverRumEvent.context)) {\n                    delete serverRumEvent.context;\n                }\n                lifeCycle.notify(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, serverRumEvent);\n            }\n        }\n    });\n}\nfunction shouldSend(event, beforeSend, domainContext, eventRateLimiters) {\n    var _a;\n    if (beforeSend) {\n        var result = limitModification(event, modifiableFieldPathsByEvent[event.type], function (event) {\n            return beforeSend(event, domainContext);\n        });\n        if (result === false && event.type !== \"view\" /* RumEventType.VIEW */) {\n            return false;\n        }\n        if (result === false) {\n            display.warn(\"Can't dismiss view events using beforeSend!\");\n        }\n    }\n    var rateLimitReached = (_a = eventRateLimiters[event.type]) === null || _a === void 0 ? void 0 : _a.isLimitReached();\n    return !rateLimitReached;\n}\nfunction needToAssembleWithAction(event) {\n    return [\"error\" /* RumEventType.ERROR */, \"resource\" /* RumEventType.RESOURCE */, \"long_task\" /* RumEventType.LONG_TASK */].indexOf(event.type) !== -1;\n}\n//# sourceMappingURL=assembly.js.map","/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(applicationId, sessionManager, viewHistory, actionContexts, urlContexts) {\n    return {\n        get: function (startTime) {\n            var viewContext = viewHistory.findView(startTime);\n            var urlContext = urlContexts.findUrl(startTime);\n            var session = sessionManager.findTrackedSession(startTime);\n            if (session && viewContext && urlContext) {\n                var actionId = actionContexts.findActionId(startTime);\n                return {\n                    application_id: applicationId,\n                    session_id: session.id,\n                    user_action: actionId ? { id: actionId } : undefined,\n                    view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n                };\n            }\n        },\n    };\n}\n//# sourceMappingURL=internalContext.js.map","// eslint-disable-next-line no-restricted-syntax\nvar AbstractLifeCycle = /** @class */ (function () {\n    function AbstractLifeCycle() {\n        this.callbacks = {};\n    }\n    AbstractLifeCycle.prototype.notify = function (eventType, data) {\n        var eventCallbacks = this.callbacks[eventType];\n        if (eventCallbacks) {\n            eventCallbacks.forEach(function (callback) { return callback(data); });\n        }\n    };\n    AbstractLifeCycle.prototype.subscribe = function (eventType, callback) {\n        var _this = this;\n        if (!this.callbacks[eventType]) {\n            this.callbacks[eventType] = [];\n        }\n        this.callbacks[eventType].push(callback);\n        return {\n            unsubscribe: function () {\n                _this.callbacks[eventType] = _this.callbacks[eventType].filter(function (other) { return callback !== other; });\n            },\n        };\n    };\n    return AbstractLifeCycle;\n}());\nexport { AbstractLifeCycle };\n//# sourceMappingURL=abstractLifeCycle.js.map","import { AbstractLifeCycle } from '@datadog/browser-core';\nexport var LifeCycle = (AbstractLifeCycle);\n//# sourceMappingURL=lifeCycle.js.map","import { setInterval, clearInterval } from './timer';\nimport { removeItem } from './utils/arrayUtils';\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils';\nvar END_OF_TIMES = Infinity;\nexport var CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE;\nexport function createValueHistory(_a) {\n    var expireDelay = _a.expireDelay, maxEntries = _a.maxEntries;\n    var entries = [];\n    var clearOldValuesInterval = setInterval(function () { return clearOldValues(); }, CLEAR_OLD_VALUES_INTERVAL);\n    function clearOldValues() {\n        var oldTimeThreshold = relativeNow() - expireDelay;\n        while (entries.length > 0 && entries[entries.length - 1].endTime < oldTimeThreshold) {\n            entries.pop();\n        }\n    }\n    /**\n     * Add a value to the history associated with a start time. Returns a reference to this newly\n     * added entry that can be removed or closed.\n     */\n    function add(value, startTime) {\n        var entry = {\n            value: value,\n            startTime: startTime,\n            endTime: END_OF_TIMES,\n            remove: function () {\n                removeItem(entries, entry);\n            },\n            close: function (endTime) {\n                entry.endTime = endTime;\n            },\n        };\n        if (maxEntries && entries.length >= maxEntries) {\n            entries.pop();\n        }\n        entries.unshift(entry);\n        return entry;\n    }\n    /**\n     * Return the latest value that was active during `startTime`, or the currently active value\n     * if no `startTime` is provided. This method assumes that entries are not overlapping.\n     *\n     * If `option.returnInactive` is true, returns the value at `startTime` (active or not).\n     */\n    function find(startTime, options) {\n        if (startTime === void 0) { startTime = END_OF_TIMES; }\n        if (options === void 0) { options = { returnInactive: false }; }\n        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n            var entry = entries_1[_i];\n            if (entry.startTime <= startTime) {\n                if (options.returnInactive || startTime <= entry.endTime) {\n                    return entry.value;\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * Helper function to close the currently active value, if any. This method assumes that entries\n     * are not overlapping.\n     */\n    function closeActive(endTime) {\n        var latestEntry = entries[0];\n        if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n            latestEntry.close(endTime);\n        }\n    }\n    /**\n     * Return all values with an active period overlapping with the duration,\n     * or all values that were active during `startTime` if no duration is provided,\n     * or all currently active values if no `startTime` is provided.\n     */\n    function findAll(startTime, duration) {\n        if (startTime === void 0) { startTime = END_OF_TIMES; }\n        if (duration === void 0) { duration = 0; }\n        var endTime = addDuration(startTime, duration);\n        return entries\n            .filter(function (entry) { return entry.startTime <= endTime && startTime <= entry.endTime; })\n            .map(function (entry) { return entry.value; });\n    }\n    /**\n     * Remove all entries from this collection.\n     */\n    function reset() {\n        entries = [];\n    }\n    /**\n     * Stop internal garbage collection of past entries.\n     */\n    function stop() {\n        clearInterval(clearOldValuesInterval);\n    }\n    return { add: add, find: find, closeActive: closeActive, findAll: findAll, reset: reset, stop: stop };\n}\n//# sourceMappingURL=valueHistory.js.map","import { SESSION_TIME_OUT_DELAY, createValueHistory } from '@datadog/browser-core';\nexport var VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport function startViewHistory(lifeCycle) {\n    var viewValueHistory = createValueHistory({ expireDelay: VIEW_CONTEXT_TIME_OUT_DELAY });\n    lifeCycle.subscribe(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, function (view) {\n        viewValueHistory.add(buildViewHistoryEntry(view), view.startClocks.relative);\n    });\n    lifeCycle.subscribe(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, function (_a) {\n        var endClocks = _a.endClocks;\n        viewValueHistory.closeActive(endClocks.relative);\n    });\n    lifeCycle.subscribe(3 /* LifeCycleEventType.BEFORE_VIEW_UPDATED */, function (viewUpdate) {\n        var currentView = viewValueHistory.find(viewUpdate.startClocks.relative);\n        if (currentView && viewUpdate.name) {\n            currentView.name = viewUpdate.name;\n        }\n        if (currentView && viewUpdate.context) {\n            currentView.context = viewUpdate.context;\n        }\n    });\n    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, function () {\n        viewValueHistory.reset();\n    });\n    function buildViewHistoryEntry(view) {\n        return {\n            service: view.service,\n            version: view.version,\n            context: view.context,\n            id: view.id,\n            name: view.name,\n            startClocks: view.startClocks,\n        };\n    }\n    return {\n        findView: function (startTime) { return viewValueHistory.find(startTime); },\n        stop: function () {\n            viewValueHistory.stop();\n        },\n    };\n}\n//# sourceMappingURL=viewHistory.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, clocksNow, timeStampNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nimport { shallowClone } from '../tools/utils/objectUtils';\nimport { addEventListener } from './addEventListener';\nvar xhrObservable;\nvar xhrContexts = new WeakMap();\nexport function initXhrObservable(configuration) {\n    if (!xhrObservable) {\n        xhrObservable = createXhrObservable(configuration);\n    }\n    return xhrObservable;\n}\nfunction createXhrObservable(configuration) {\n    return new Observable(function (observable) {\n        var stopInstrumentingStart = instrumentMethod(XMLHttpRequest.prototype, 'open', openXhr).stop;\n        var stopInstrumentingSend = instrumentMethod(XMLHttpRequest.prototype, 'send', function (call) {\n            sendXhr(call, configuration, observable);\n        }, { computeHandlingStack: true }).stop;\n        var stopInstrumentingAbort = instrumentMethod(XMLHttpRequest.prototype, 'abort', abortXhr).stop;\n        return function () {\n            stopInstrumentingStart();\n            stopInstrumentingSend();\n            stopInstrumentingAbort();\n        };\n    });\n}\nfunction openXhr(_a) {\n    var xhr = _a.target, _b = _a.parameters, method = _b[0], url = _b[1];\n    xhrContexts.set(xhr, {\n        state: 'open',\n        method: String(method).toUpperCase(),\n        url: normalizeUrl(String(url)),\n    });\n}\nfunction sendXhr(_a, configuration, observable) {\n    var xhr = _a.target, handlingStack = _a.handlingStack;\n    var context = xhrContexts.get(xhr);\n    if (!context) {\n        return;\n    }\n    var startContext = context;\n    startContext.state = 'start';\n    startContext.startClocks = clocksNow();\n    startContext.isAborted = false;\n    startContext.xhr = xhr;\n    startContext.handlingStack = handlingStack;\n    var hasBeenReported = false;\n    var stopInstrumentingOnReadyStateChange = instrumentMethod(xhr, 'onreadystatechange', function () {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n            // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n            // application during a future event. For example, Angular is calling .abort() on\n            // completed requests during an onreadystatechange event, so the status becomes '0'\n            // before the request is collected.\n            onEnd();\n        }\n    }).stop;\n    var onEnd = function () {\n        unsubscribeLoadEndListener();\n        stopInstrumentingOnReadyStateChange();\n        if (hasBeenReported) {\n            return;\n        }\n        hasBeenReported = true;\n        var completeContext = context;\n        completeContext.state = 'complete';\n        completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());\n        completeContext.status = xhr.status;\n        observable.notify(shallowClone(completeContext));\n    };\n    var unsubscribeLoadEndListener = addEventListener(configuration, xhr, 'loadend', onEnd).stop;\n    observable.notify(startContext);\n}\nfunction abortXhr(_a) {\n    var xhr = _a.target;\n    var context = xhrContexts.get(xhr);\n    if (context) {\n        context.isAborted = true;\n    }\n}\n//# sourceMappingURL=xhrObservable.js.map","export function isServerError(status) {\n    return status >= 500;\n}\nexport function tryToClone(response) {\n    try {\n        return response.clone();\n    }\n    catch (_a) {\n        // clone can throw if the response has already been used by another instrumentation or is disturbed\n        return;\n    }\n}\n//# sourceMappingURL=responseUtils.js.map","import { monitor } from './monitor';\nimport { noop } from './utils/functionUtils';\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(stream, callback, options) {\n    var reader = stream.getReader();\n    var chunks = [];\n    var readBytesCount = 0;\n    readMore();\n    function readMore() {\n        reader.read().then(monitor(function (result) {\n            if (result.done) {\n                onDone();\n                return;\n            }\n            if (options.collectStreamBody) {\n                chunks.push(result.value);\n            }\n            readBytesCount += result.value.length;\n            if (readBytesCount > options.bytesLimit) {\n                onDone();\n            }\n            else {\n                readMore();\n            }\n        }), monitor(function (error) { return callback(error); }));\n    }\n    function onDone() {\n        reader.cancel().catch(\n        // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n        // as an unhandled rejection\n        noop);\n        var bytes;\n        var limitExceeded;\n        if (options.collectStreamBody) {\n            var completeBuffer_1;\n            if (chunks.length === 1) {\n                // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n                // use it directly.\n                completeBuffer_1 = chunks[0];\n            }\n            else {\n                // else, we need to copy buffers into a larger buffer to concatenate them.\n                completeBuffer_1 = new Uint8Array(readBytesCount);\n                var offset_1 = 0;\n                chunks.forEach(function (chunk) {\n                    completeBuffer_1.set(chunk, offset_1);\n                    offset_1 += chunk.length;\n                });\n            }\n            bytes = completeBuffer_1.slice(0, options.bytesLimit);\n            limitExceeded = completeBuffer_1.length > options.bytesLimit;\n        }\n        callback(undefined, bytes, limitExceeded);\n    }\n}\n//# sourceMappingURL=readBytesFromStream.js.map","import { addTelemetryDebug, elapsed, getPathName, includes, isValidUrl, toServerDuration, isIntakeUrl, } from '@datadog/browser-core';\nexport var FAKE_INITIAL_DOCUMENT = 'initial_document';\nvar RESOURCE_TYPES = [\n    [\"document\" /* ResourceType.DOCUMENT */, function (initiatorType) { return FAKE_INITIAL_DOCUMENT === initiatorType; }],\n    [\"xhr\" /* ResourceType.XHR */, function (initiatorType) { return 'xmlhttprequest' === initiatorType; }],\n    [\"fetch\" /* ResourceType.FETCH */, function (initiatorType) { return 'fetch' === initiatorType; }],\n    [\"beacon\" /* ResourceType.BEACON */, function (initiatorType) { return 'beacon' === initiatorType; }],\n    [\"css\" /* ResourceType.CSS */, function (_, path) { return /\\.css$/i.test(path); }],\n    [\"js\" /* ResourceType.JS */, function (_, path) { return /\\.js$/i.test(path); }],\n    [\n        \"image\" /* ResourceType.IMAGE */,\n        function (initiatorType, path) {\n            return includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null;\n        },\n    ],\n    [\"font\" /* ResourceType.FONT */, function (_, path) { return /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null; }],\n    [\n        \"media\" /* ResourceType.MEDIA */,\n        function (initiatorType, path) {\n            return includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null;\n        },\n    ],\n];\nexport function computeResourceEntryType(entry) {\n    var url = entry.name;\n    if (!isValidUrl(url)) {\n        addTelemetryDebug(\"Failed to construct URL for \\\"\".concat(entry.name, \"\\\"\"));\n        return \"other\" /* ResourceType.OTHER */;\n    }\n    var path = getPathName(url);\n    for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {\n        var _a = RESOURCE_TYPES_1[_i], type = _a[0], isType = _a[1];\n        if (isType(entry.initiatorType, path)) {\n            return type;\n        }\n    }\n    return \"other\" /* ResourceType.OTHER */;\n}\nfunction areInOrder() {\n    var numbers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        numbers[_i] = arguments[_i];\n    }\n    for (var i = 1; i < numbers.length; i += 1) {\n        if (numbers[i - 1] > numbers[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isResourceEntryRequestType(entry) {\n    return entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch';\n}\nexport function computeResourceEntryDuration(entry) {\n    var duration = entry.duration, startTime = entry.startTime, responseEnd = entry.responseEnd;\n    // Safari duration is always 0 on timings blocked by cross origin policies.\n    if (duration === 0 && startTime < responseEnd) {\n        return toServerDuration(elapsed(startTime, responseEnd));\n    }\n    return toServerDuration(duration);\n}\nexport function computeResourceEntryDetails(entry) {\n    if (!hasValidResourceEntryTimings(entry)) {\n        return undefined;\n    }\n    var startTime = entry.startTime, fetchStart = entry.fetchStart, workerStart = entry.workerStart, redirectStart = entry.redirectStart, redirectEnd = entry.redirectEnd, domainLookupStart = entry.domainLookupStart, domainLookupEnd = entry.domainLookupEnd, connectStart = entry.connectStart, secureConnectionStart = entry.secureConnectionStart, connectEnd = entry.connectEnd, requestStart = entry.requestStart, responseStart = entry.responseStart, responseEnd = entry.responseEnd;\n    var details = {\n        download: formatTiming(startTime, responseStart, responseEnd),\n        first_byte: formatTiming(startTime, requestStart, responseStart),\n    };\n    // Make sure a worker processing time is recorded\n    if (0 < workerStart && workerStart < fetchStart) {\n        details.worker = formatTiming(startTime, workerStart, fetchStart);\n    }\n    // Make sure a connection occurred\n    if (fetchStart < connectEnd) {\n        details.connect = formatTiming(startTime, connectStart, connectEnd);\n        // Make sure a secure connection occurred\n        if (connectStart <= secureConnectionStart && secureConnectionStart <= connectEnd) {\n            details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);\n        }\n    }\n    // Make sure a domain lookup occurred\n    if (fetchStart < domainLookupEnd) {\n        details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);\n    }\n    // Make sure a redirection occurred\n    if (startTime < redirectEnd) {\n        details.redirect = formatTiming(startTime, redirectStart, redirectEnd);\n    }\n    return details;\n}\n/**\n * Entries with negative duration are unexpected and should be dismissed. The intake will ignore RUM\n * Resource events with negative durations anyway.\n * Since Chromium 128, more entries have unexpected negative durations, see\n * https://issues.chromium.org/issues/363031537\n */\nexport function hasValidResourceEntryDuration(entry) {\n    return entry.duration >= 0;\n}\nexport function hasValidResourceEntryTimings(entry) {\n    // Ensure timings are in the right order. On top of filtering out potential invalid\n    // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n    // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n    // it.\n    var areCommonTimingsInOrder = areInOrder(entry.startTime, entry.fetchStart, entry.domainLookupStart, entry.domainLookupEnd, entry.connectStart, entry.connectEnd, entry.requestStart, entry.responseStart, entry.responseEnd);\n    var areRedirectionTimingsInOrder = hasRedirection(entry)\n        ? areInOrder(entry.startTime, entry.redirectStart, entry.redirectEnd, entry.fetchStart)\n        : true;\n    return areCommonTimingsInOrder && areRedirectionTimingsInOrder;\n}\nfunction hasRedirection(entry) {\n    return entry.redirectEnd > entry.startTime;\n}\nfunction formatTiming(origin, start, end) {\n    if (origin <= start && start <= end) {\n        return {\n            duration: toServerDuration(elapsed(start, end)),\n            start: toServerDuration(elapsed(origin, start)),\n        };\n    }\n}\n/**\n * The 'nextHopProtocol' is an empty string for cross-origin resources without CORS headers,\n * meaning the protocol is unknown, and we shouldn't report it.\n * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/nextHopProtocol#cross-origin_resources\n */\nexport function computeResourceEntryProtocol(entry) {\n    return entry.nextHopProtocol === '' ? undefined : entry.nextHopProtocol;\n}\n/**\n * Handles the 'deliveryType' property to distinguish between supported values ('cache', 'navigational-prefetch'),\n * undefined (unsupported in some browsers), and other cases ('other' for unknown or unrecognized values).\n * see: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/deliveryType\n */\nexport function computeResourceEntryDeliveryType(entry) {\n    return entry.deliveryType === '' ? 'other' : entry.deliveryType;\n}\nexport function computeResourceEntrySize(entry) {\n    // Make sure a request actually occurred\n    if (entry.startTime < entry.responseStart) {\n        var encodedBodySize = entry.encodedBodySize, decodedBodySize = entry.decodedBodySize, transferSize = entry.transferSize;\n        return {\n            size: decodedBodySize,\n            encoded_body_size: encodedBodySize,\n            decoded_body_size: decodedBodySize,\n            transfer_size: transferSize,\n        };\n    }\n    return {\n        size: undefined,\n        encoded_body_size: undefined,\n        decoded_body_size: undefined,\n        transfer_size: undefined,\n    };\n}\nexport function isAllowedRequestUrl(url) {\n    return url && !isIntakeUrl(url);\n}\nvar DATA_URL_REGEX = /data:(.+)?(;base64)?,/g;\nexport var MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 24000;\nexport function isLongDataUrl(url) {\n    if (url.length <= MAX_ATTRIBUTE_VALUE_CHAR_LENGTH) {\n        return false;\n    }\n    else if (url.substring(0, 5) === 'data:') {\n        // Avoid String.match RangeError: Maximum call stack size exceeded\n        url = url.substring(0, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH);\n        return true;\n    }\n    return false;\n}\nexport function sanitizeDataUrl(url) {\n    return \"\".concat(url.match(DATA_URL_REGEX)[0], \"[...]\");\n}\n//# sourceMappingURL=resourceUtils.js.map","import { initFetchObservable, initXhrObservable, readBytesFromStream, elapsed, timeStampNow, tryToClone, } from '@datadog/browser-core';\nimport { isAllowedRequestUrl } from './resource/resourceUtils';\nimport { startTracer } from './tracing/tracer';\nvar nextRequestIndex = 1;\nexport function startRequestCollection(lifeCycle, configuration, sessionManager) {\n    var tracer = startTracer(configuration, sessionManager);\n    trackXhr(lifeCycle, configuration, tracer);\n    trackFetch(lifeCycle, tracer);\n}\nexport function trackXhr(lifeCycle, configuration, tracer) {\n    var subscription = initXhrObservable(configuration).subscribe(function (rawContext) {\n        var context = rawContext;\n        if (!isAllowedRequestUrl(context.url)) {\n            return;\n        }\n        switch (context.state) {\n            case 'start':\n                tracer.traceXhr(context, context.xhr);\n                context.requestIndex = getNextRequestIndex();\n                lifeCycle.notify(7 /* LifeCycleEventType.REQUEST_STARTED */, {\n                    requestIndex: context.requestIndex,\n                    url: context.url,\n                });\n                break;\n            case 'complete':\n                tracer.clearTracingIfNeeded(context);\n                lifeCycle.notify(8 /* LifeCycleEventType.REQUEST_COMPLETED */, {\n                    duration: context.duration,\n                    method: context.method,\n                    requestIndex: context.requestIndex,\n                    spanId: context.spanId,\n                    startClocks: context.startClocks,\n                    status: context.status,\n                    traceId: context.traceId,\n                    traceSampled: context.traceSampled,\n                    type: \"xhr\" /* RequestType.XHR */,\n                    url: context.url,\n                    xhr: context.xhr,\n                    isAborted: context.isAborted,\n                    handlingStack: context.handlingStack,\n                });\n                break;\n        }\n    });\n    return { stop: function () { return subscription.unsubscribe(); } };\n}\nexport function trackFetch(lifeCycle, tracer) {\n    var subscription = initFetchObservable().subscribe(function (rawContext) {\n        var context = rawContext;\n        if (!isAllowedRequestUrl(context.url)) {\n            return;\n        }\n        switch (context.state) {\n            case 'start':\n                tracer.traceFetch(context);\n                context.requestIndex = getNextRequestIndex();\n                lifeCycle.notify(7 /* LifeCycleEventType.REQUEST_STARTED */, {\n                    requestIndex: context.requestIndex,\n                    url: context.url,\n                });\n                break;\n            case 'resolve':\n                waitForResponseToComplete(context, function (duration) {\n                    tracer.clearTracingIfNeeded(context);\n                    lifeCycle.notify(8 /* LifeCycleEventType.REQUEST_COMPLETED */, {\n                        duration: duration,\n                        method: context.method,\n                        requestIndex: context.requestIndex,\n                        responseType: context.responseType,\n                        spanId: context.spanId,\n                        startClocks: context.startClocks,\n                        status: context.status,\n                        traceId: context.traceId,\n                        traceSampled: context.traceSampled,\n                        type: \"fetch\" /* RequestType.FETCH */,\n                        url: context.url,\n                        response: context.response,\n                        init: context.init,\n                        input: context.input,\n                        isAborted: context.isAborted,\n                        handlingStack: context.handlingStack,\n                    });\n                });\n                break;\n        }\n    });\n    return { stop: function () { return subscription.unsubscribe(); } };\n}\nfunction getNextRequestIndex() {\n    var result = nextRequestIndex;\n    nextRequestIndex += 1;\n    return result;\n}\nfunction waitForResponseToComplete(context, callback) {\n    var clonedResponse = context.response && tryToClone(context.response);\n    if (!clonedResponse || !clonedResponse.body) {\n        // do not try to wait for the response if the clone failed, fetch error or null body\n        callback(elapsed(context.startClocks.timeStamp, timeStampNow()));\n    }\n    else {\n        readBytesFromStream(clonedResponse.body, function () {\n            callback(elapsed(context.startClocks.timeStamp, timeStampNow()));\n        }, {\n            bytesLimit: Number.POSITIVE_INFINITY,\n            collectStreamBody: false,\n        });\n    }\n}\n//# sourceMappingURL=requestCollection.js.map","import { isNumber } from '@datadog/browser-core';\nexport function discardNegativeDuration(duration) {\n    return isNumber(duration) && duration < 0 ? undefined : duration;\n}\n//# sourceMappingURL=discardNegativeDuration.js.map","import { noop } from '@datadog/browser-core';\nexport function trackEventCounts(_a) {\n    var lifeCycle = _a.lifeCycle, isChildEvent = _a.isChildEvent, _b = _a.onChange, callback = _b === void 0 ? noop : _b;\n    var eventCounts = {\n        errorCount: 0,\n        longTaskCount: 0,\n        resourceCount: 0,\n        actionCount: 0,\n        frustrationCount: 0,\n    };\n    var subscription = lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (event) {\n        var _a;\n        if (event.type === 'view' || event.type === 'vital' || !isChildEvent(event)) {\n            return;\n        }\n        switch (event.type) {\n            case \"error\" /* RumEventType.ERROR */:\n                eventCounts.errorCount += 1;\n                callback();\n                break;\n            case \"action\" /* RumEventType.ACTION */:\n                eventCounts.actionCount += 1;\n                if (event.action.frustration) {\n                    eventCounts.frustrationCount += event.action.frustration.type.length;\n                }\n                callback();\n                break;\n            case \"long_task\" /* RumEventType.LONG_TASK */:\n                eventCounts.longTaskCount += 1;\n                callback();\n                break;\n            case \"resource\" /* RumEventType.RESOURCE */:\n                if (!((_a = event._dd) === null || _a === void 0 ? void 0 : _a.discarded)) {\n                    eventCounts.resourceCount += 1;\n                    callback();\n                }\n                break;\n        }\n    });\n    return {\n        stop: function () {\n            subscription.unsubscribe();\n        },\n        eventCounts: eventCounts,\n    };\n}\n//# sourceMappingURL=trackEventCounts.js.map","import { addEventListeners, dateNow, relativeNow } from '@datadog/browser-core';\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nexport function retrieveFirstInputTiming(configuration, callback) {\n    var startTimeStamp = dateNow();\n    var timingSent = false;\n    var removeEventListeners = addEventListeners(configuration, window, [\"click\" /* DOM_EVENT.CLICK */, \"mousedown\" /* DOM_EVENT.MOUSE_DOWN */, \"keydown\" /* DOM_EVENT.KEY_DOWN */, \"touchstart\" /* DOM_EVENT.TOUCH_START */, \"pointerdown\" /* DOM_EVENT.POINTER_DOWN */], function (evt) {\n        // Only count cancelable events, which should trigger behavior important to the user.\n        if (!evt.cancelable) {\n            return;\n        }\n        // This timing will be used to compute the \"first Input delay\", which is the delta between\n        // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n        // (e.g. performance.now()).\n        var timing = {\n            entryType: 'first-input',\n            processingStart: relativeNow(),\n            processingEnd: relativeNow(),\n            startTime: evt.timeStamp,\n            duration: 0, // arbitrary value to avoid nullable duration and simplify INP logic\n            name: '',\n            cancelable: false,\n            target: null,\n            toJSON: function () { return ({}); },\n        };\n        if (evt.type === \"pointerdown\" /* DOM_EVENT.POINTER_DOWN */) {\n            sendTimingIfPointerIsNotCancelled(configuration, timing);\n        }\n        else {\n            sendTiming(timing);\n        }\n    }, { passive: true, capture: true }).stop;\n    return { stop: removeEventListeners };\n    /**\n     * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n     * We differentiate these cases based on whether or not we see a pointercancel event, which are\n     * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n     * scrolling and pinch/zooming.\n     */\n    function sendTimingIfPointerIsNotCancelled(configuration, timing) {\n        addEventListeners(configuration, window, [\"pointerup\" /* DOM_EVENT.POINTER_UP */, \"pointercancel\" /* DOM_EVENT.POINTER_CANCEL */], function (event) {\n            if (event.type === \"pointerup\" /* DOM_EVENT.POINTER_UP */) {\n                sendTiming(timing);\n            }\n        }, { once: true });\n    }\n    function sendTiming(timing) {\n        if (!timingSent) {\n            timingSent = true;\n            removeEventListeners();\n            // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n            // the time between now and when the page was loaded.\n            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n            var delay = timing.processingStart - timing.startTime;\n            if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n                callback(timing);\n            }\n        }\n    }\n}\n//# sourceMappingURL=firstInputPolyfill.js.map","import { addEventListener, Observable, setTimeout, clearTimeout, monitor, includes } from '@datadog/browser-core';\nimport { hasValidResourceEntryDuration, isAllowedRequestUrl } from '../domain/resource/resourceUtils';\nimport { retrieveFirstInputTiming } from './firstInputPolyfill';\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected performance entry\n// eslint-disable-next-line no-restricted-syntax\nexport var RumPerformanceEntryType;\n(function (RumPerformanceEntryType) {\n    RumPerformanceEntryType[\"EVENT\"] = \"event\";\n    RumPerformanceEntryType[\"FIRST_INPUT\"] = \"first-input\";\n    RumPerformanceEntryType[\"LARGEST_CONTENTFUL_PAINT\"] = \"largest-contentful-paint\";\n    RumPerformanceEntryType[\"LAYOUT_SHIFT\"] = \"layout-shift\";\n    RumPerformanceEntryType[\"LONG_TASK\"] = \"longtask\";\n    RumPerformanceEntryType[\"LONG_ANIMATION_FRAME\"] = \"long-animation-frame\";\n    RumPerformanceEntryType[\"NAVIGATION\"] = \"navigation\";\n    RumPerformanceEntryType[\"PAINT\"] = \"paint\";\n    RumPerformanceEntryType[\"RESOURCE\"] = \"resource\";\n})(RumPerformanceEntryType || (RumPerformanceEntryType = {}));\nexport function createPerformanceObservable(configuration, options) {\n    return new Observable(function (observable) {\n        if (!window.PerformanceObserver) {\n            return;\n        }\n        var handlePerformanceEntries = function (entries) {\n            var rumPerformanceEntries = filterRumPerformanceEntries(entries);\n            if (rumPerformanceEntries.length > 0) {\n                observable.notify(rumPerformanceEntries);\n            }\n        };\n        var timeoutId;\n        var isObserverInitializing = true;\n        var observer = new PerformanceObserver(monitor(function (entries) {\n            // In Safari the performance observer callback is synchronous.\n            // Because the buffered performance entry list can be quite large we delay the computation to prevent the SDK from blocking the main thread on init\n            if (isObserverInitializing) {\n                timeoutId = setTimeout(function () { return handlePerformanceEntries(entries.getEntries()); });\n            }\n            else {\n                handlePerformanceEntries(entries.getEntries());\n            }\n        }));\n        try {\n            observer.observe(options);\n        }\n        catch (_a) {\n            // Some old browser versions (<= chrome 74 ) don't support the PerformanceObserver type and buffered options\n            // In these cases, fallback to getEntriesByType and PerformanceObserver with entryTypes\n            // TODO: remove this fallback in the next major version\n            var fallbackSupportedEntryTypes = [\n                RumPerformanceEntryType.RESOURCE,\n                RumPerformanceEntryType.NAVIGATION,\n                RumPerformanceEntryType.LONG_TASK,\n                RumPerformanceEntryType.PAINT,\n            ];\n            if (includes(fallbackSupportedEntryTypes, options.type)) {\n                if (options.buffered) {\n                    timeoutId = setTimeout(function () { return handlePerformanceEntries(performance.getEntriesByType(options.type)); });\n                }\n                try {\n                    observer.observe({ entryTypes: [options.type] });\n                }\n                catch (_b) {\n                    // Old versions of Safari are throwing \"entryTypes contained only unsupported types\"\n                    // errors when observing only unsupported entry types.\n                    //\n                    // We could use `supportPerformanceTimingEvent` to make sure we don't invoke\n                    // `observer.observe` with an unsupported entry type, but Safari 11 and 12 don't support\n                    // `Performance.supportedEntryTypes`, so doing so would lose support for these versions\n                    // even if they do support the entry type.\n                    return;\n                }\n            }\n        }\n        isObserverInitializing = false;\n        manageResourceTimingBufferFull(configuration);\n        var stopFirstInputTiming;\n        if (!supportPerformanceTimingEvent(RumPerformanceEntryType.FIRST_INPUT) &&\n            options.type === RumPerformanceEntryType.FIRST_INPUT) {\n            ;\n            (stopFirstInputTiming = retrieveFirstInputTiming(configuration, function (timing) {\n                handlePerformanceEntries([timing]);\n            }).stop);\n        }\n        return function () {\n            observer.disconnect();\n            if (stopFirstInputTiming) {\n                stopFirstInputTiming();\n            }\n            clearTimeout(timeoutId);\n        };\n    });\n}\nvar resourceTimingBufferFullListener;\nfunction manageResourceTimingBufferFull(configuration) {\n    if (!resourceTimingBufferFullListener && supportPerformanceObject() && 'addEventListener' in performance) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n        resourceTimingBufferFullListener = addEventListener(configuration, performance, 'resourcetimingbufferfull', function () {\n            performance.clearResourceTimings();\n        });\n    }\n    return function () {\n        resourceTimingBufferFullListener === null || resourceTimingBufferFullListener === void 0 ? void 0 : resourceTimingBufferFullListener.stop();\n    };\n}\nfunction supportPerformanceObject() {\n    return window.performance !== undefined && 'getEntries' in performance;\n}\nexport function supportPerformanceTimingEvent(entryType) {\n    return (window.PerformanceObserver &&\n        PerformanceObserver.supportedEntryTypes !== undefined &&\n        PerformanceObserver.supportedEntryTypes.includes(entryType));\n}\nfunction filterRumPerformanceEntries(entries) {\n    return entries.filter(function (entry) { return !isForbiddenResource(entry); });\n}\nfunction isForbiddenResource(entry) {\n    return (entry.entryType === RumPerformanceEntryType.RESOURCE &&\n        (!isAllowedRequestUrl(entry.name) || !hasValidResourceEntryDuration(entry)));\n}\n//# sourceMappingURL=performanceObservable.js.map","import { matchList, monitor, Observable, timeStampNow, setTimeout, clearTimeout } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../browser/performanceObservable';\n// Delay to wait for a page activity to validate the tracking process\nexport var PAGE_ACTIVITY_VALIDATION_DELAY = 100;\n// Delay to wait after a page activity to end the tracking process\nexport var PAGE_ACTIVITY_END_DELAY = 100;\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, pageActivityEndCallback, maxDuration) {\n    var pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration);\n    return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);\n}\nexport function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {\n    var pageActivityEndTimeoutId;\n    var hasCompleted = false;\n    var validationTimeoutId = setTimeout(monitor(function () { return complete({ hadActivity: false }); }), PAGE_ACTIVITY_VALIDATION_DELAY);\n    var maxDurationTimeoutId = maxDuration !== undefined\n        ? setTimeout(monitor(function () { return complete({ hadActivity: true, end: timeStampNow() }); }), maxDuration)\n        : undefined;\n    var pageActivitySubscription = pageActivityObservable.subscribe(function (_a) {\n        var isBusy = _a.isBusy;\n        clearTimeout(validationTimeoutId);\n        clearTimeout(pageActivityEndTimeoutId);\n        var lastChangeTime = timeStampNow();\n        if (!isBusy) {\n            pageActivityEndTimeoutId = setTimeout(monitor(function () { return complete({ hadActivity: true, end: lastChangeTime }); }), PAGE_ACTIVITY_END_DELAY);\n        }\n    });\n    var stop = function () {\n        hasCompleted = true;\n        clearTimeout(validationTimeoutId);\n        clearTimeout(pageActivityEndTimeoutId);\n        clearTimeout(maxDurationTimeoutId);\n        pageActivitySubscription.unsubscribe();\n    };\n    function complete(event) {\n        if (hasCompleted) {\n            return;\n        }\n        stop();\n        pageActivityEndCallback(event);\n    }\n    return { stop: stop };\n}\nexport function createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {\n    return new Observable(function (observable) {\n        var subscriptions = [];\n        var firstRequestIndex;\n        var pendingRequestsCount = 0;\n        subscriptions.push(domMutationObservable.subscribe(notifyPageActivity), windowOpenObservable.subscribe(notifyPageActivity), createPerformanceObservable(configuration, { type: RumPerformanceEntryType.RESOURCE }).subscribe(function (entries) {\n            if (entries.some(function (entry) { return !isExcludedUrl(configuration, entry.name); })) {\n                notifyPageActivity();\n            }\n        }), lifeCycle.subscribe(7 /* LifeCycleEventType.REQUEST_STARTED */, function (startEvent) {\n            if (isExcludedUrl(configuration, startEvent.url)) {\n                return;\n            }\n            if (firstRequestIndex === undefined) {\n                firstRequestIndex = startEvent.requestIndex;\n            }\n            pendingRequestsCount += 1;\n            notifyPageActivity();\n        }), lifeCycle.subscribe(8 /* LifeCycleEventType.REQUEST_COMPLETED */, function (request) {\n            if (isExcludedUrl(configuration, request.url) ||\n                firstRequestIndex === undefined ||\n                // If the request started before the tracking start, ignore it\n                request.requestIndex < firstRequestIndex) {\n                return;\n            }\n            pendingRequestsCount -= 1;\n            notifyPageActivity();\n        }));\n        return function () {\n            subscriptions.forEach(function (s) { return s.unsubscribe(); });\n        };\n        function notifyPageActivity() {\n            observable.notify({ isBusy: pendingRequestsCount > 0 });\n        }\n    });\n}\nfunction isExcludedUrl(configuration, requestUrl) {\n    return matchList(configuration.excludedActivityUrls, requestUrl);\n}\n//# sourceMappingURL=waitPageActivityEnd.js.map","// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str) {\n    if (window.CSS && window.CSS.escape) {\n        return window.CSS.escape(str);\n    }\n    // eslint-disable-next-line no-control-regex\n    return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n        if (asCodePoint) {\n            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n            if (ch === '\\0') {\n                return '\\uFFFD';\n            }\n            // Control characters and (dependent upon position) numbers get escaped as code points\n            return \"\".concat(ch.slice(0, -1), \"\\\\\").concat(ch.charCodeAt(ch.length - 1).toString(16), \" \");\n        }\n        // Other potentially-special ASCII characters get backslash-escaped\n        return \"\\\\\".concat(ch);\n    });\n}\nexport function elementMatches(element, selector) {\n    if (element.matches) {\n        return element.matches(selector);\n    }\n    // IE11 support\n    if (element.msMatchesSelector) {\n        return element.msMatchesSelector(selector);\n    }\n    return false;\n}\n/**\n * Return the parentElement of an node\n *\n * In cases where parentElement is not supported, such as in IE11 for SVG nodes, we fallback to parentNode\n */\nexport function getParentElement(node) {\n    if (node.parentElement) {\n        return node.parentElement;\n    }\n    while (node.parentNode) {\n        if (node.parentNode.nodeType === Node.ELEMENT_NODE) {\n            return node.parentNode;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\n/**\n * Return the classList of an element or an array of classes if classList is not supported\n *\n * In cases where classList is not supported, such as in IE11 for SVG and MathML elements,\n * we fallback to using element.getAttribute('class').\n * We opt for element.getAttribute('class') over element.className because className returns an SVGAnimatedString for SVG elements.\n */\nexport function getClassList(element) {\n    if (element.classList) {\n        return element.classList;\n    }\n    var classes = (element.getAttribute('class') || '').trim();\n    return classes ? classes.split(/\\s+/) : [];\n}\n// ie11 supports WeakMap but not WeakSet\nvar PLACEHOLDER = 1;\n// eslint-disable-next-line no-restricted-syntax\nvar WeakSet = /** @class */ (function () {\n    function WeakSet(initialValues) {\n        var _this = this;\n        this.map = new WeakMap();\n        if (initialValues) {\n            initialValues.forEach(function (value) { return _this.map.set(value, PLACEHOLDER); });\n        }\n    }\n    WeakSet.prototype.add = function (value) {\n        this.map.set(value, PLACEHOLDER);\n        return this;\n    };\n    WeakSet.prototype.delete = function (value) {\n        return this.map.delete(value);\n    };\n    WeakSet.prototype.has = function (value) {\n        return this.map.has(value);\n    };\n    return WeakSet;\n}());\nexport { WeakSet };\n//# sourceMappingURL=polyfills.js.map","export function isTextNode(node) {\n    return node.nodeType === Node.TEXT_NODE;\n}\nexport function isCommentNode(node) {\n    return node.nodeType === Node.COMMENT_NODE;\n}\nexport function isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nexport function isNodeShadowHost(node) {\n    return isElementNode(node) && Boolean(node.shadowRoot);\n}\nexport function isNodeShadowRoot(node) {\n    var shadowRoot = node;\n    return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host);\n}\nexport function hasChildNodes(node) {\n    return node.childNodes.length > 0 || isNodeShadowHost(node);\n}\nexport function forEachChildNodes(node, callback) {\n    var child = node.firstChild;\n    while (child) {\n        callback(child);\n        child = child.nextSibling;\n    }\n    if (isNodeShadowHost(node)) {\n        callback(node.shadowRoot);\n    }\n}\n/**\n * Return `host` in case if the current node is a shadow root otherwise will return the `parentNode`\n */\nexport function getParentNode(node) {\n    return isNodeShadowRoot(node) ? node.host : node.parentNode;\n}\n//# sourceMappingURL=htmlDomUtils.js.map","import { DefaultPrivacyLevel } from '@datadog/browser-core';\nimport { isElementNode, getParentNode, isTextNode } from '../browser/htmlDomUtils';\nimport { elementMatches } from '../browser/polyfills';\nexport var NodePrivacyLevel = {\n    IGNORE: 'ignore',\n    HIDDEN: 'hidden',\n    ALLOW: DefaultPrivacyLevel.ALLOW,\n    MASK: DefaultPrivacyLevel.MASK,\n    MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT,\n};\nexport var PRIVACY_ATTR_NAME = 'data-dd-privacy';\n// Privacy Attrs\nexport var PRIVACY_ATTR_VALUE_ALLOW = 'allow';\nexport var PRIVACY_ATTR_VALUE_MASK = 'mask';\nexport var PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input';\nexport var PRIVACY_ATTR_VALUE_HIDDEN = 'hidden';\n// Privacy Classes - not all customers can set plain HTML attributes, so support classes too\nexport var PRIVACY_CLASS_PREFIX = 'dd-privacy-';\n// Private Replacement Templates\nexport var CENSORED_STRING_MARK = '***';\nexport var CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==';\nexport var FORM_PRIVATE_TAG_NAMES = {\n    INPUT: true,\n    OUTPUT: true,\n    TEXTAREA: true,\n    SELECT: true,\n    OPTION: true,\n    DATALIST: true,\n    OPTGROUP: true,\n};\nvar TEXT_MASKING_CHAR = 'x';\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node, defaultPrivacyLevel, cache) {\n    if (cache && cache.has(node)) {\n        return cache.get(node);\n    }\n    var parentNode = getParentNode(node);\n    var parentNodePrivacyLevel = parentNode\n        ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel, cache)\n        : defaultPrivacyLevel;\n    var selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);\n    var nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);\n    if (cache) {\n        cache.set(node, nodePrivacyLevel);\n    }\n    return nodePrivacyLevel;\n}\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {\n    switch (parentNodePrivacyLevel) {\n        // These values cannot be overridden\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return parentNodePrivacyLevel;\n    }\n    switch (childPrivacyLevel) {\n        case NodePrivacyLevel.ALLOW:\n        case NodePrivacyLevel.MASK:\n        case NodePrivacyLevel.MASK_USER_INPUT:\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return childPrivacyLevel;\n        default:\n            return parentNodePrivacyLevel;\n    }\n}\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node) {\n    // Only Element types can have a privacy level set\n    if (!isElementNode(node)) {\n        return;\n    }\n    // Overrules for replay purpose\n    if (node.tagName === 'BASE') {\n        return NodePrivacyLevel.ALLOW;\n    }\n    // Overrules to enforce end-user protection\n    if (node.tagName === 'INPUT') {\n        var inputElement = node;\n        if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n            return NodePrivacyLevel.MASK;\n        }\n        if (inputElement.type === 'hidden') {\n            return NodePrivacyLevel.MASK;\n        }\n        var autocomplete = inputElement.getAttribute('autocomplete');\n        // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year/new-password/current-password]\n        if (autocomplete && (autocomplete.startsWith('cc-') || autocomplete.endsWith('-password'))) {\n            return NodePrivacyLevel.MASK;\n        }\n    }\n    // Check HTML privacy attributes and classes\n    if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.HIDDEN))) {\n        return NodePrivacyLevel.HIDDEN;\n    }\n    if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.MASK))) {\n        return NodePrivacyLevel.MASK;\n    }\n    if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.MASK_USER_INPUT))) {\n        return NodePrivacyLevel.MASK_USER_INPUT;\n    }\n    if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.ALLOW))) {\n        return NodePrivacyLevel.ALLOW;\n    }\n    if (shouldIgnoreElement(node)) {\n        return NodePrivacyLevel.IGNORE;\n    }\n}\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node, privacyLevel) {\n    switch (privacyLevel) {\n        case NodePrivacyLevel.MASK:\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return true;\n        case NodePrivacyLevel.MASK_USER_INPUT:\n            return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node);\n        default:\n            return false;\n    }\n}\nfunction isFormElement(node) {\n    if (!node || node.nodeType !== node.ELEMENT_NODE) {\n        return false;\n    }\n    var element = node;\n    if (element.tagName === 'INPUT') {\n        switch (element.type) {\n            case 'button':\n            case 'color':\n            case 'reset':\n            case 'submit':\n                return false;\n        }\n    }\n    return !!FORM_PRIVATE_TAG_NAMES[element.tagName];\n}\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport var censorText = function (text) { return text.replace(/\\S/g, TEXT_MASKING_CHAR); };\nexport function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {\n    var _a;\n    // The parent node may not be a html element which has a tagName attribute.\n    // So just let it be undefined which is ok in this use case.\n    var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n    var textContent = textNode.textContent || '';\n    if (ignoreWhiteSpace && !textContent.trim()) {\n        return;\n    }\n    var nodePrivacyLevel = parentNodePrivacyLevel;\n    var isScript = parentTagName === 'SCRIPT';\n    if (isScript) {\n        // For perf reasons, we don't record script (heuristic)\n        textContent = CENSORED_STRING_MARK;\n    }\n    else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // Should never occur, but just in case, we set to CENSORED_MARK.\n        textContent = CENSORED_STRING_MARK;\n    }\n    else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n        if (\n        // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n        parentTagName === 'DATALIST' ||\n            parentTagName === 'SELECT' ||\n            parentTagName === 'OPTGROUP') {\n            if (!textContent.trim()) {\n                return;\n            }\n        }\n        else if (parentTagName === 'OPTION') {\n            // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n            textContent = CENSORED_STRING_MARK;\n        }\n        else {\n            textContent = censorText(textContent);\n        }\n    }\n    return textContent;\n}\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element) {\n    if (element.nodeName === 'SCRIPT') {\n        return true;\n    }\n    if (element.nodeName === 'LINK') {\n        var relAttribute = getLowerCaseAttribute('rel');\n        return (\n        // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n        (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n            // Favicons\n            relAttribute === 'shortcut icon' ||\n            relAttribute === 'icon');\n    }\n    if (element.nodeName === 'META') {\n        var nameAttribute = getLowerCaseAttribute('name');\n        var relAttribute = getLowerCaseAttribute('rel');\n        var propertyAttribute = getLowerCaseAttribute('property');\n        return (\n        // Favicons\n        /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n            nameAttribute === 'application-name' ||\n            relAttribute === 'icon' ||\n            relAttribute === 'apple-touch-icon' ||\n            relAttribute === 'shortcut icon' ||\n            // Description\n            nameAttribute === 'keywords' ||\n            nameAttribute === 'description' ||\n            // Social\n            /^(og|twitter|fb):/.test(propertyAttribute) ||\n            /^(og|twitter):/.test(nameAttribute) ||\n            nameAttribute === 'pinterest' ||\n            // Robots\n            nameAttribute === 'robots' ||\n            nameAttribute === 'googlebot' ||\n            nameAttribute === 'bingbot' ||\n            // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n            // X-Translated-By\n            element.hasAttribute('http-equiv') ||\n            // Authorship\n            nameAttribute === 'author' ||\n            nameAttribute === 'generator' ||\n            nameAttribute === 'framework' ||\n            nameAttribute === 'publisher' ||\n            nameAttribute === 'progid' ||\n            /^article:/.test(propertyAttribute) ||\n            /^product:/.test(propertyAttribute) ||\n            // Verification\n            nameAttribute === 'google-site-verification' ||\n            nameAttribute === 'yandex-verification' ||\n            nameAttribute === 'csrf-token' ||\n            nameAttribute === 'p:domain_verify' ||\n            nameAttribute === 'verify-v1' ||\n            nameAttribute === 'verification' ||\n            nameAttribute === 'shopify-checkout-api-token');\n    }\n    function getLowerCaseAttribute(name) {\n        return (element.getAttribute(name) || '').toLowerCase();\n    }\n    return false;\n}\nexport function getPrivacySelector(privacyLevel) {\n    return \"[\".concat(PRIVACY_ATTR_NAME, \"=\\\"\").concat(privacyLevel, \"\\\"], .\").concat(PRIVACY_CLASS_PREFIX).concat(privacyLevel);\n}\n//# sourceMappingURL=privacy.js.map","import { safeTruncate, isIE, find } from '@datadog/browser-core';\nimport { getParentElement } from '../../browser/polyfills';\nimport { NodePrivacyLevel, getPrivacySelector } from '../privacy';\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport var DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name';\nexport var ACTION_NAME_PLACEHOLDER = 'Masked Element';\nexport function getActionNameFromElement(element, _a, nodePrivacyLevel) {\n    var enablePrivacyForActionName = _a.enablePrivacyForActionName, userProgrammaticAttribute = _a.actionNameAttribute;\n    // Proceed to get the action name in two steps:\n    // * first, get the name programmatically, explicitly defined by the user.\n    // * then, if privacy is set to mask, return a placeholder for the undefined.\n    // * if privacy is not set to mask, use strategies that are known to return good results.\n    //   Those strategies will be used on the element and a few parents, but it's likely that they won't succeed at all.\n    // * if no name is found this way, use strategies returning less accurate names as a fallback.\n    //   Those are much likely to succeed.\n    var defaultActionName = getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n        (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute));\n    if (defaultActionName) {\n        return { name: defaultActionName, nameSource: \"custom_attribute\" /* ActionNameSource.CUSTOM_ATTRIBUTE */ };\n    }\n    else if (nodePrivacyLevel === NodePrivacyLevel.MASK) {\n        return { name: ACTION_NAME_PLACEHOLDER, nameSource: \"mask_placeholder\" /* ActionNameSource.MASK_PLACEHOLDER */ };\n    }\n    return (getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies, enablePrivacyForActionName) ||\n        getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies, enablePrivacyForActionName) || { name: '', nameSource: \"blank\" /* ActionNameSource.BLANK */ });\n}\nfunction getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {\n    var elementWithAttribute;\n    // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n    // without limit. It is up to the user to declare a relevant naming strategy.\n    // If available, use element.closest() to match get the attribute from the element or any of its\n    // parent.  Else fallback to a more traditional implementation.\n    if (supportsElementClosest()) {\n        elementWithAttribute = targetElement.closest(\"[\".concat(programmaticAttribute, \"]\"));\n    }\n    else {\n        var element = targetElement;\n        while (element) {\n            if (element.hasAttribute(programmaticAttribute)) {\n                elementWithAttribute = element;\n                break;\n            }\n            element = getParentElement(element);\n        }\n    }\n    if (!elementWithAttribute) {\n        return;\n    }\n    var name = elementWithAttribute.getAttribute(programmaticAttribute);\n    return truncate(normalizeWhitespace(name.trim()));\n}\nvar priorityStrategies = [\n    // associated LABEL text\n    function (element, userProgrammaticAttribute, privacy) {\n        // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n        // instead\n        if (supportsLabelProperty()) {\n            if ('labels' in element && element.labels && element.labels.length > 0) {\n                return getActionNameFromTextualContent(element.labels[0], userProgrammaticAttribute);\n            }\n        }\n        else if (element.id) {\n            var label = element.ownerDocument &&\n                find(element.ownerDocument.querySelectorAll('label'), function (label) { return label.htmlFor === element.id; });\n            return label && getActionNameFromTextualContent(label, userProgrammaticAttribute, privacy);\n        }\n    },\n    // INPUT button (and associated) value\n    function (element) {\n        if (element.nodeName === 'INPUT') {\n            var input = element;\n            var type = input.getAttribute('type');\n            if (type === 'button' || type === 'submit' || type === 'reset') {\n                return { name: input.value, nameSource: \"text_content\" /* ActionNameSource.TEXT_CONTENT */ };\n            }\n        }\n    },\n    // BUTTON, LABEL or button-like element text\n    function (element, userProgrammaticAttribute, privacyEnabledActionName) {\n        if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n            return getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName);\n        }\n    },\n    function (element) { return getActionNameFromStandardAttribute(element, 'aria-label'); },\n    // associated element text designated by the aria-labelledby attribute\n    function (element, userProgrammaticAttribute, privacyEnabledActionName) {\n        var labelledByAttribute = element.getAttribute('aria-labelledby');\n        if (labelledByAttribute) {\n            return {\n                name: labelledByAttribute\n                    .split(/\\s+/)\n                    .map(function (id) { return getElementById(element, id); })\n                    .filter(function (label) { return Boolean(label); })\n                    .map(function (element) { return getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName); })\n                    .join(' '),\n                nameSource: \"text_content\" /* ActionNameSource.TEXT_CONTENT */,\n            };\n        }\n    },\n    function (element) { return getActionNameFromStandardAttribute(element, 'alt'); },\n    function (element) { return getActionNameFromStandardAttribute(element, 'name'); },\n    function (element) { return getActionNameFromStandardAttribute(element, 'title'); },\n    function (element) { return getActionNameFromStandardAttribute(element, 'placeholder'); },\n    // SELECT first OPTION text\n    function (element, userProgrammaticAttribute) {\n        if ('options' in element && element.options.length > 0) {\n            return getActionNameFromTextualContent(element.options[0], userProgrammaticAttribute);\n        }\n    },\n];\nvar fallbackStrategies = [\n    function (element, userProgrammaticAttribute, privacyEnabledActionName) {\n        return getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName);\n    },\n];\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nvar MAX_PARENTS_TO_CONSIDER = 10;\nfunction getActionNameFromElementForStrategies(targetElement, userProgrammaticAttribute, strategies, privacyEnabledActionName) {\n    var element = targetElement;\n    var recursionCounter = 0;\n    while (recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n        element &&\n        element.nodeName !== 'BODY' &&\n        element.nodeName !== 'HTML' &&\n        element.nodeName !== 'HEAD') {\n        for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {\n            var strategy = strategies_1[_i];\n            var actionName = strategy(element, userProgrammaticAttribute, privacyEnabledActionName);\n            if (actionName) {\n                var name_1 = actionName.name, nameSource = actionName.nameSource;\n                var trimmedName = name_1 && name_1.trim();\n                if (trimmedName) {\n                    return { name: truncate(normalizeWhitespace(trimmedName)), nameSource: nameSource };\n                }\n            }\n        }\n        // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n        // be reconsidered in the future.\n        if (element.nodeName === 'FORM') {\n            break;\n        }\n        element = getParentElement(element);\n        recursionCounter += 1;\n    }\n}\nfunction normalizeWhitespace(s) {\n    return s.replace(/\\s+/g, ' ');\n}\nfunction truncate(s) {\n    return s.length > 100 ? \"\".concat(safeTruncate(s, 100), \" [...]\") : s;\n}\nfunction getElementById(refElement, id) {\n    // Use the element ownerDocument here, because tests are executed in an iframe, so\n    // document.getElementById won't work.\n    return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;\n}\nfunction getActionNameFromStandardAttribute(element, attribute) {\n    return {\n        name: element.getAttribute(attribute) || '',\n        nameSource: \"standard_attribute\" /* ActionNameSource.STANDARD_ATTRIBUTE */,\n    };\n}\nfunction getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) {\n    return {\n        name: getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) || '',\n        nameSource: \"text_content\" /* ActionNameSource.TEXT_CONTENT */,\n    };\n}\nfunction getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) {\n    if (element.isContentEditable) {\n        return;\n    }\n    if ('innerText' in element) {\n        var text_1 = element.innerText;\n        var removeTextFromElements = function (query) {\n            var list = element.querySelectorAll(query);\n            for (var index = 0; index < list.length; index += 1) {\n                var element_1 = list[index];\n                if ('innerText' in element_1) {\n                    var textToReplace = element_1.innerText;\n                    if (textToReplace && textToReplace.trim().length > 0) {\n                        text_1 = text_1.replace(textToReplace, '');\n                    }\n                }\n            }\n        };\n        if (!supportsInnerTextScriptAndStyleRemoval()) {\n            // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n            // be relatively fast and work in most cases.\n            removeTextFromElements('script, style');\n        }\n        // remove the text of elements with programmatic attribute value\n        removeTextFromElements(\"[\".concat(DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE, \"]\"));\n        if (userProgrammaticAttribute) {\n            removeTextFromElements(\"[\".concat(userProgrammaticAttribute, \"]\"));\n        }\n        if (privacyEnabledActionName) {\n            // remove the text of elements with privacy override\n            removeTextFromElements(\"\".concat(getPrivacySelector(NodePrivacyLevel.HIDDEN), \", \").concat(getPrivacySelector(NodePrivacyLevel.MASK)));\n        }\n        return text_1;\n    }\n    return element.textContent;\n}\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n    return !isIE();\n}\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nvar supportsLabelPropertyResult;\nfunction supportsLabelProperty() {\n    if (supportsLabelPropertyResult === undefined) {\n        supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype;\n    }\n    return supportsLabelPropertyResult;\n}\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nvar supportsElementClosestResult;\nfunction supportsElementClosest() {\n    if (supportsElementClosestResult === undefined) {\n        supportsElementClosestResult = 'closest' in HTMLElement.prototype;\n    }\n    return supportsElementClosestResult;\n}\n//# sourceMappingURL=getActionNameFromElement.js.map","import { cssEscape, elementMatches, getClassList, getParentElement } from '../browser/polyfills';\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './action/getActionNameFromElement';\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport var STABLE_ATTRIBUTES = [\n    DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n    // Common test attributes (list provided by google recorder)\n    'data-testid',\n    'data-test',\n    'data-qa',\n    'data-cy',\n    'data-test-id',\n    'data-qa-id',\n    'data-testing',\n    // FullStory decorator attributes:\n    'data-component',\n    'data-element',\n    'data-source-file',\n];\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nvar GLOBALLY_UNIQUE_SELECTOR_GETTERS = [getStableAttributeSelector, getIDSelector];\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nvar UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS = [\n    getStableAttributeSelector,\n    getClassSelector,\n    getTagNameSelector,\n];\nexport function getSelectorFromElement(targetElement, actionNameAttribute) {\n    if (!isConnected(targetElement)) {\n        // We cannot compute a selector for a detached element, as we don't have access to all of its\n        // parents, and we cannot determine if it's unique in the document.\n        return;\n    }\n    var targetElementSelector;\n    var currentElement = targetElement;\n    while (currentElement && currentElement.nodeName !== 'HTML') {\n        var globallyUniqueSelector = findSelector(currentElement, GLOBALLY_UNIQUE_SELECTOR_GETTERS, isSelectorUniqueGlobally, actionNameAttribute, targetElementSelector);\n        if (globallyUniqueSelector) {\n            return globallyUniqueSelector;\n        }\n        var uniqueSelectorAmongChildren = findSelector(currentElement, UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS, isSelectorUniqueAmongSiblings, actionNameAttribute, targetElementSelector);\n        targetElementSelector =\n            uniqueSelectorAmongChildren || combineSelector(getPositionSelector(currentElement), targetElementSelector);\n        currentElement = getParentElement(currentElement);\n    }\n    return targetElementSelector;\n}\nfunction isGeneratedValue(value) {\n    // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n    // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n    // present.\n    //\n    // Here, we use the same strategy: if the value contains a digit, we consider it generated. This\n    // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n    // CSS selectors so it should be fine most of the time.\n    return /[0-9]/.test(value);\n}\nfunction getIDSelector(element) {\n    if (element.id && !isGeneratedValue(element.id)) {\n        return \"#\".concat(cssEscape(element.id));\n    }\n}\nfunction getClassSelector(element) {\n    if (element.tagName === 'BODY') {\n        return;\n    }\n    var classList = getClassList(element);\n    for (var i = 0; i < classList.length; i += 1) {\n        var className = classList[i];\n        if (isGeneratedValue(className)) {\n            continue;\n        }\n        return \"\".concat(cssEscape(element.tagName), \".\").concat(cssEscape(className));\n    }\n}\nfunction getTagNameSelector(element) {\n    return cssEscape(element.tagName);\n}\nfunction getStableAttributeSelector(element, actionNameAttribute) {\n    if (actionNameAttribute) {\n        var selector = getAttributeSelector(actionNameAttribute);\n        if (selector) {\n            return selector;\n        }\n    }\n    for (var _i = 0, STABLE_ATTRIBUTES_1 = STABLE_ATTRIBUTES; _i < STABLE_ATTRIBUTES_1.length; _i++) {\n        var attributeName = STABLE_ATTRIBUTES_1[_i];\n        var selector = getAttributeSelector(attributeName);\n        if (selector) {\n            return selector;\n        }\n    }\n    function getAttributeSelector(attributeName) {\n        if (element.hasAttribute(attributeName)) {\n            return \"\".concat(cssEscape(element.tagName), \"[\").concat(attributeName, \"=\\\"\").concat(cssEscape(element.getAttribute(attributeName)), \"\\\"]\");\n        }\n    }\n}\nfunction getPositionSelector(element) {\n    var sibling = getParentElement(element).firstElementChild;\n    var elementIndex = 1;\n    while (sibling && sibling !== element) {\n        if (sibling.tagName === element.tagName) {\n            elementIndex += 1;\n        }\n        sibling = sibling.nextElementSibling;\n    }\n    return \"\".concat(cssEscape(element.tagName), \":nth-of-type(\").concat(elementIndex, \")\");\n}\nfunction findSelector(element, selectorGetters, predicate, actionNameAttribute, childSelector) {\n    for (var _i = 0, selectorGetters_1 = selectorGetters; _i < selectorGetters_1.length; _i++) {\n        var selectorGetter = selectorGetters_1[_i];\n        var elementSelector = selectorGetter(element, actionNameAttribute);\n        if (!elementSelector) {\n            continue;\n        }\n        if (predicate(element, elementSelector, childSelector)) {\n            return combineSelector(elementSelector, childSelector);\n        }\n    }\n}\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element, elementSelector, childSelector) {\n    return element.ownerDocument.querySelectorAll(combineSelector(elementSelector, childSelector)).length === 1;\n}\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > CHILD_SELECTOR\" returns a single element.\n *\n * @param {Element} currentElement - the element being considered while iterating over the target\n * element ancestors.\n *\n * @param {string} currentElementSelector - a selector that matches the current element. That\n * selector is not a composed selector (i.e. it might be a single tag name, class name...).\n *\n * @param {string|undefined} childSelector - child selector is a selector that targets a descendant\n * of the current element. When undefined, the current element is the target element.\n *\n * # Scope selector usage\n *\n * When composed together, the final selector will be joined with `>` operators to make sure we\n * target direct descendants at each level. In this function, we'll use `querySelector` to check if\n * a selector matches descendants of the current element. But by default, the query selector match\n * elements at any level. Example:\n *\n * ```html\n * <main>\n *   <div>\n *     <span></span>\n *   </div>\n *   <marquee>\n *     <div>\n *       <span></span>\n *     </div>\n *   </marquee>\n * </main>\n * ```\n *\n * `sibling.querySelector('DIV > SPAN')` will match both span elements, so we would consider the\n * selector to be not unique, even if it is unique when we'll compose it with the parent with a `>`\n * operator (`MAIN > DIV > SPAN`).\n *\n * To avoid this, we can use the `:scope` selector to make sure the selector starts from the current\n * sibling (i.e. `sibling.querySelector('DIV:scope > SPAN')` will only match the first span).\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT CHILD_SELECTOR\" returns a single element), regardless of whether the selector is\n * a direct descendant of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n *\n * [1]: https://developer.mozilla.org/fr/docs/Web/CSS/:scope\n *\n * # Performance considerations\n *\n * We compute selectors in performance-critical operations (ex: during a click), so we need to make\n * sure the function is as fast as possible. We observed that naively using `querySelectorAll` to\n * check if the selector matches more than 1 element is quite expensive, so we want to avoid it.\n *\n * Because we are iterating the DOM upward and we use that function at every level, we know the\n * child selector is already unique among the current element children, so we don't need to check\n * for the current element subtree.\n *\n * Instead, we can focus on the current element siblings. If we find a single element matching the\n * selector within a sibling, we know that it's not unique. This allows us to use `querySelector`\n * (or `matches`, when the current element is the target element) instead of `querySelectorAll`.\n */\nexport function isSelectorUniqueAmongSiblings(currentElement, currentElementSelector, childSelector) {\n    var isSiblingMatching;\n    if (childSelector === undefined) {\n        // If the child selector is undefined (meaning `currentElement` is the target element, not one\n        // of its ancestor), we need to use `matches` to check if the sibling is matching the selector,\n        // as `querySelector` only returns a descendant of the element.\n        isSiblingMatching = function (sibling) { return elementMatches(sibling, currentElementSelector); };\n    }\n    else {\n        var scopedSelector_1 = supportScopeSelector()\n            ? combineSelector(\"\".concat(currentElementSelector, \":scope\"), childSelector)\n            : combineSelector(currentElementSelector, childSelector);\n        isSiblingMatching = function (sibling) { return sibling.querySelector(scopedSelector_1) !== null; };\n    }\n    var parent = getParentElement(currentElement);\n    var sibling = parent.firstElementChild;\n    while (sibling) {\n        if (sibling !== currentElement && isSiblingMatching(sibling)) {\n            return false;\n        }\n        sibling = sibling.nextElementSibling;\n    }\n    return true;\n}\nfunction combineSelector(parent, child) {\n    return child ? \"\".concat(parent, \">\").concat(child) : parent;\n}\nvar supportScopeSelectorCache;\nexport function supportScopeSelector() {\n    if (supportScopeSelectorCache === undefined) {\n        try {\n            document.querySelector(':scope');\n            supportScopeSelectorCache = true;\n        }\n        catch (_a) {\n            supportScopeSelectorCache = false;\n        }\n    }\n    return supportScopeSelectorCache;\n}\n/**\n * Polyfill-utility for the `isConnected` property not supported in IE11\n */\nfunction isConnected(element) {\n    if ('isConnected' in\n        // cast is to make sure `element` is not inferred as `never` after the check\n        element) {\n        return element.isConnected;\n    }\n    return element.ownerDocument.documentElement.contains(element);\n}\n//# sourceMappingURL=getSelectorFromElement.js.map","import { ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nexport var MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND;\nexport var MAX_DISTANCE_BETWEEN_CLICKS = 100;\nexport function createClickChain(firstClick, onFinalize) {\n    var bufferedClicks = [];\n    var status = 0 /* ClickChainStatus.WaitingForMoreClicks */;\n    var maxDurationBetweenClicksTimeoutId;\n    appendClick(firstClick);\n    function appendClick(click) {\n        click.stopObservable.subscribe(tryFinalize);\n        bufferedClicks.push(click);\n        clearTimeout(maxDurationBetweenClicksTimeoutId);\n        maxDurationBetweenClicksTimeoutId = setTimeout(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS);\n    }\n    function tryFinalize() {\n        if (status === 1 /* ClickChainStatus.WaitingForClicksToStop */ && bufferedClicks.every(function (click) { return click.isStopped(); })) {\n            status = 2 /* ClickChainStatus.Finalized */;\n            onFinalize(bufferedClicks);\n        }\n    }\n    function dontAcceptMoreClick() {\n        clearTimeout(maxDurationBetweenClicksTimeoutId);\n        if (status === 0 /* ClickChainStatus.WaitingForMoreClicks */) {\n            status = 1 /* ClickChainStatus.WaitingForClicksToStop */;\n            tryFinalize();\n        }\n    }\n    return {\n        tryAppend: function (click) {\n            if (status !== 0 /* ClickChainStatus.WaitingForMoreClicks */) {\n                return false;\n            }\n            if (bufferedClicks.length > 0 &&\n                !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)) {\n                dontAcceptMoreClick();\n                return false;\n            }\n            appendClick(click);\n            return true;\n        },\n        stop: function () {\n            dontAcceptMoreClick();\n        },\n    };\n}\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first, second) {\n    return (first.target === second.target &&\n        mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n        first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS);\n}\nfunction mouseEventDistance(origin, other) {\n    return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2));\n}\n//# sourceMappingURL=clickChain.js.map","import { addEventListener } from '@datadog/browser-core';\nexport function listenActionEvents(configuration, _a) {\n    var onPointerDown = _a.onPointerDown, onPointerUp = _a.onPointerUp;\n    var selectionEmptyAtPointerDown;\n    var userActivity = {\n        selection: false,\n        input: false,\n        scroll: false,\n    };\n    var clickContext;\n    var listeners = [\n        addEventListener(configuration, window, \"pointerdown\" /* DOM_EVENT.POINTER_DOWN */, function (event) {\n            if (isValidPointerEvent(event)) {\n                selectionEmptyAtPointerDown = isSelectionEmpty();\n                userActivity = {\n                    selection: false,\n                    input: false,\n                    scroll: false,\n                };\n                clickContext = onPointerDown(event);\n            }\n        }, { capture: true }),\n        addEventListener(configuration, window, \"selectionchange\" /* DOM_EVENT.SELECTION_CHANGE */, function () {\n            if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n                userActivity.selection = true;\n            }\n        }, { capture: true }),\n        addEventListener(configuration, window, \"scroll\" /* DOM_EVENT.SCROLL */, function () {\n            userActivity.scroll = true;\n        }, { capture: true, passive: true }),\n        addEventListener(configuration, window, \"pointerup\" /* DOM_EVENT.POINTER_UP */, function (event) {\n            if (isValidPointerEvent(event) && clickContext) {\n                // Use a scoped variable to make sure the value is not changed by other clicks\n                var localUserActivity_1 = userActivity;\n                onPointerUp(clickContext, event, function () { return localUserActivity_1; });\n                clickContext = undefined;\n            }\n        }, { capture: true }),\n        addEventListener(configuration, window, \"input\" /* DOM_EVENT.INPUT */, function () {\n            userActivity.input = true;\n        }, { capture: true }),\n    ];\n    return {\n        stop: function () {\n            listeners.forEach(function (listener) { return listener.stop(); });\n        },\n    };\n}\nfunction isSelectionEmpty() {\n    var selection = window.getSelection();\n    return !selection || selection.isCollapsed;\n}\nfunction isValidPointerEvent(event) {\n    return (event.target instanceof Element &&\n        // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in\n        // the future.\n        event.isPrimary !== false);\n}\n//# sourceMappingURL=listenActionEvents.js.map","import { ONE_SECOND } from '@datadog/browser-core';\nimport { elementMatches } from '../../browser/polyfills';\nvar MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3;\nexport function computeFrustration(clicks, rageClick) {\n    if (isRage(clicks)) {\n        rageClick.addFrustration(\"rage_click\" /* FrustrationType.RAGE_CLICK */);\n        if (clicks.some(isDead)) {\n            rageClick.addFrustration(\"dead_click\" /* FrustrationType.DEAD_CLICK */);\n        }\n        if (rageClick.hasError) {\n            rageClick.addFrustration(\"error_click\" /* FrustrationType.ERROR_CLICK */);\n        }\n        return { isRage: true };\n    }\n    var hasSelectionChanged = clicks.some(function (click) { return click.getUserActivity().selection; });\n    clicks.forEach(function (click) {\n        if (click.hasError) {\n            click.addFrustration(\"error_click\" /* FrustrationType.ERROR_CLICK */);\n        }\n        if (isDead(click) &&\n            // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n            !hasSelectionChanged) {\n            click.addFrustration(\"dead_click\" /* FrustrationType.DEAD_CLICK */);\n        }\n    });\n    return { isRage: false };\n}\nexport function isRage(clicks) {\n    if (clicks.some(function (click) { return click.getUserActivity().selection || click.getUserActivity().scroll; })) {\n        return false;\n    }\n    for (var i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n        if (clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n            ONE_SECOND) {\n            return true;\n        }\n    }\n    return false;\n}\nvar DEAD_CLICK_EXCLUDE_SELECTOR = \n// inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n// inputs (using a negative selector is shorter here)\n'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n    'textarea,' +\n    'select,' +\n    // contenteditable and their descendants don't always trigger meaningful changes when manipulated\n    '[contenteditable],' +\n    '[contenteditable] *,' +\n    // canvas, as there is no good way to detect activity occurring on them\n    'canvas,' +\n    // links that are interactive (have an href attribute) or any of their descendants, as they can\n    // open a new tab or navigate to a hash without triggering a meaningful event\n    'a[href],' +\n    'a[href] *';\nexport function isDead(click) {\n    if (click.hasPageActivity || click.getUserActivity().input || click.getUserActivity().scroll) {\n        return false;\n    }\n    return !elementMatches(click.event.target, DEAD_CLICK_EXCLUDE_SELECTOR);\n}\n//# sourceMappingURL=computeFrustration.js.map","import { elapsed, ONE_SECOND, relativeNow } from '@datadog/browser-core';\n// Maximum duration for click actions\nexport var CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND;\nexport var interactionSelectorCache = new Map();\nexport function getInteractionSelector(relativeTimestamp) {\n    var selector = interactionSelectorCache.get(relativeTimestamp);\n    interactionSelectorCache.delete(relativeTimestamp);\n    return selector;\n}\nexport function updateInteractionSelector(relativeTimestamp, selector) {\n    interactionSelectorCache.set(relativeTimestamp, selector);\n    interactionSelectorCache.forEach(function (_, relativeTimestamp) {\n        if (elapsed(relativeTimestamp, relativeNow()) > CLICK_ACTION_MAX_DURATION) {\n            interactionSelectorCache.delete(relativeTimestamp);\n        }\n    });\n}\n//# sourceMappingURL=interactionSelectorCache.js.map","import { includes, timeStampNow, Observable, assign, getRelativeTime, ONE_MINUTE, generateUUID, clocksNow, elapsed, createValueHistory, } from '@datadog/browser-core';\nimport { trackEventCounts } from '../trackEventCounts';\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../waitPageActivityEnd';\nimport { getSelectorFromElement } from '../getSelectorFromElement';\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '../privacy';\nimport { createClickChain } from './clickChain';\nimport { getActionNameFromElement } from './getActionNameFromElement';\nimport { listenActionEvents } from './listenActionEvents';\nimport { computeFrustration } from './computeFrustration';\nimport { CLICK_ACTION_MAX_DURATION, updateInteractionSelector } from './interactionSelectorCache';\nexport var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE; // arbitrary\nexport function trackClickActions(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {\n    var history = createValueHistory({ expireDelay: ACTION_CONTEXT_TIME_OUT_DELAY });\n    var stopObservable = new Observable();\n    var currentClickChain;\n    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, function () {\n        history.reset();\n    });\n    lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, stopClickChain);\n    var stopActionEventsListener = listenActionEvents(configuration, {\n        onPointerDown: function (pointerDownEvent) {\n            return processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable);\n        },\n        onPointerUp: function (_a, startEvent, getUserActivity) {\n            var clickActionBase = _a.clickActionBase, hadActivityOnPointerDown = _a.hadActivityOnPointerDown;\n            startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown);\n        },\n    }).stop;\n    var actionContexts = {\n        findActionId: function (startTime) { return history.findAll(startTime); },\n    };\n    return {\n        stop: function () {\n            stopClickChain();\n            stopObservable.notify();\n            stopActionEventsListener();\n        },\n        actionContexts: actionContexts,\n    };\n    function appendClickToClickChain(click) {\n        if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n            var rageClick_1 = click.clone();\n            currentClickChain = createClickChain(click, function (clicks) {\n                finalizeClicks(clicks, rageClick_1);\n            });\n        }\n    }\n    function stopClickChain() {\n        if (currentClickChain) {\n            currentClickChain.stop();\n        }\n    }\n}\nfunction processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable) {\n    var nodePrivacyLevel = configuration.enablePrivacyForActionName\n        ? getNodePrivacyLevel(pointerDownEvent.target, configuration.defaultPrivacyLevel)\n        : NodePrivacyLevel.ALLOW;\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return undefined;\n    }\n    var clickActionBase = computeClickActionBase(pointerDownEvent, nodePrivacyLevel, configuration);\n    var hadActivityOnPointerDown = false;\n    waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, function (pageActivityEndEvent) {\n        hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;\n    }, \n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY);\n    return { clickActionBase: clickActionBase, hadActivityOnPointerDown: function () { return hadActivityOnPointerDown; } };\n}\nfunction startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {\n    var _a;\n    var click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);\n    appendClickToClickChain(click);\n    var selector = (_a = clickActionBase === null || clickActionBase === void 0 ? void 0 : clickActionBase.target) === null || _a === void 0 ? void 0 : _a.selector;\n    if (selector) {\n        updateInteractionSelector(startEvent.timeStamp, selector);\n    }\n    var stopWaitPageActivityEnd = waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, function (pageActivityEndEvent) {\n        if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n            // If the clock is looking weird, just discard the click\n            click.discard();\n        }\n        else {\n            if (pageActivityEndEvent.hadActivity) {\n                click.stop(pageActivityEndEvent.end);\n            }\n            else if (hadActivityOnPointerDown()) {\n                click.stop(\n                // using the click start as activity end, so the click will have some activity but its\n                // duration will be 0 (as the activity started before the click start)\n                click.startClocks.timeStamp);\n            }\n            else {\n                click.stop();\n            }\n        }\n    }, CLICK_ACTION_MAX_DURATION).stop;\n    var viewEndedSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, function (_a) {\n        var endClocks = _a.endClocks;\n        click.stop(endClocks.timeStamp);\n    });\n    var stopSubscription = stopObservable.subscribe(function () {\n        click.stop();\n    });\n    click.stopObservable.subscribe(function () {\n        viewEndedSubscription.unsubscribe();\n        stopWaitPageActivityEnd();\n        stopSubscription.unsubscribe();\n    });\n}\nfunction computeClickActionBase(event, nodePrivacyLevel, configuration) {\n    var rect = event.target.getBoundingClientRect();\n    var selector = getSelectorFromElement(event.target, configuration.actionNameAttribute);\n    if (selector) {\n        updateInteractionSelector(event.timeStamp, selector);\n    }\n    var actionName = getActionNameFromElement(event.target, configuration, nodePrivacyLevel);\n    return {\n        type: \"click\" /* ActionType.CLICK */,\n        target: {\n            width: Math.round(rect.width),\n            height: Math.round(rect.height),\n            selector: selector,\n        },\n        position: {\n            // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n            x: Math.round(event.clientX - rect.left),\n            y: Math.round(event.clientY - rect.top),\n        },\n        name: actionName.name,\n        nameSource: actionName.nameSource,\n    };\n}\nfunction newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent) {\n    var id = generateUUID();\n    var startClocks = clocksNow();\n    var historyEntry = history.add(id, startClocks.relative);\n    var eventCountsSubscription = trackEventCounts({\n        lifeCycle: lifeCycle,\n        isChildEvent: function (event) {\n            return event.action !== undefined &&\n                (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id);\n        },\n    });\n    var status = 0 /* ClickStatus.ONGOING */;\n    var activityEndTime;\n    var frustrationTypes = [];\n    var stopObservable = new Observable();\n    function stop(newActivityEndTime) {\n        if (status !== 0 /* ClickStatus.ONGOING */) {\n            return;\n        }\n        activityEndTime = newActivityEndTime;\n        status = 1 /* ClickStatus.STOPPED */;\n        if (activityEndTime) {\n            historyEntry.close(getRelativeTime(activityEndTime));\n        }\n        else {\n            historyEntry.remove();\n        }\n        eventCountsSubscription.stop();\n        stopObservable.notify();\n    }\n    return {\n        event: startEvent,\n        stop: stop,\n        stopObservable: stopObservable,\n        get hasError() {\n            return eventCountsSubscription.eventCounts.errorCount > 0;\n        },\n        get hasPageActivity() {\n            return activityEndTime !== undefined;\n        },\n        getUserActivity: getUserActivity,\n        addFrustration: function (frustrationType) {\n            frustrationTypes.push(frustrationType);\n        },\n        startClocks: startClocks,\n        isStopped: function () { return status === 1 /* ClickStatus.STOPPED */ || status === 2 /* ClickStatus.FINALIZED */; },\n        clone: function () { return newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent); },\n        validate: function (domEvents) {\n            stop();\n            if (status !== 1 /* ClickStatus.STOPPED */) {\n                return;\n            }\n            var _a = eventCountsSubscription.eventCounts, resourceCount = _a.resourceCount, errorCount = _a.errorCount, longTaskCount = _a.longTaskCount;\n            var clickAction = assign({\n                type: \"click\" /* ActionType.CLICK */,\n                duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n                startClocks: startClocks,\n                id: id,\n                frustrationTypes: frustrationTypes,\n                counts: {\n                    resourceCount: resourceCount,\n                    errorCount: errorCount,\n                    longTaskCount: longTaskCount,\n                },\n                events: domEvents !== null && domEvents !== void 0 ? domEvents : [startEvent],\n                event: startEvent,\n            }, clickActionBase);\n            lifeCycle.notify(0 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, clickAction);\n            status = 2 /* ClickStatus.FINALIZED */;\n        },\n        discard: function () {\n            stop();\n            status = 2 /* ClickStatus.FINALIZED */;\n        },\n    };\n}\nexport function finalizeClicks(clicks, rageClick) {\n    var isRage = computeFrustration(clicks, rageClick).isRage;\n    if (isRage) {\n        clicks.forEach(function (click) { return click.discard(); });\n        rageClick.stop(timeStampNow());\n        rageClick.validate(clicks.map(function (click) { return click.event; }));\n    }\n    else {\n        rageClick.discard();\n        clicks.forEach(function (click) { return click.validate(); });\n    }\n}\n//# sourceMappingURL=trackClickActions.js.map","import { noop, assign, combine, toServerDuration, generateUUID, ExperimentalFeature, isExperimentalFeatureEnabled, } from '@datadog/browser-core';\nimport { discardNegativeDuration } from '../discardNegativeDuration';\nimport { trackClickActions } from './trackClickActions';\nexport function startActionCollection(lifeCycle, domMutationObservable, windowOpenObservable, configuration, pageStateHistory) {\n    var _a;\n    lifeCycle.subscribe(0 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, function (action) {\n        return lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processAction(action, pageStateHistory));\n    });\n    var actionContexts = { findActionId: noop };\n    var stop = noop;\n    if (configuration.trackUserInteractions) {\n        ;\n        (_a = trackClickActions(lifeCycle, domMutationObservable, windowOpenObservable, configuration), actionContexts = _a.actionContexts, stop = _a.stop);\n    }\n    return {\n        addAction: function (action, savedCommonContext) {\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, assign({\n                savedCommonContext: savedCommonContext,\n            }, processAction(action, pageStateHistory)));\n        },\n        actionContexts: actionContexts,\n        stop: stop,\n    };\n}\nfunction processAction(action, pageStateHistory) {\n    var autoActionProperties = isAutoAction(action)\n        ? {\n            action: {\n                id: action.id,\n                loading_time: discardNegativeDuration(toServerDuration(action.duration)),\n                frustration: {\n                    type: action.frustrationTypes,\n                },\n                error: {\n                    count: action.counts.errorCount,\n                },\n                long_task: {\n                    count: action.counts.longTaskCount,\n                },\n                resource: {\n                    count: action.counts.resourceCount,\n                },\n            },\n            _dd: {\n                action: {\n                    target: action.target,\n                    position: action.position,\n                    name_source: isExperimentalFeatureEnabled(ExperimentalFeature.ACTION_NAME_MASKING)\n                        ? action.nameSource\n                        : undefined,\n                },\n            },\n        }\n        : undefined;\n    var customerContext = !isAutoAction(action) ? action.context : undefined;\n    var actionEvent = combine({\n        action: {\n            id: generateUUID(),\n            target: {\n                name: action.name,\n            },\n            type: action.type,\n        },\n        date: action.startClocks.timeStamp,\n        type: \"action\" /* RumEventType.ACTION */,\n        view: { in_foreground: pageStateHistory.wasInPageStateAt(\"active\" /* PageState.ACTIVE */, action.startClocks.relative) },\n    }, autoActionProperties);\n    var domainContext = isAutoAction(action) ? { events: action.events } : {};\n    if (!isAutoAction(action) && action.handlingStack) {\n        domainContext.handlingStack = action.handlingStack;\n    }\n    return {\n        customerContext: customerContext,\n        rawRumEvent: actionEvent,\n        startTime: action.startClocks.relative,\n        domainContext: domainContext,\n    };\n}\nfunction isAutoAction(action) {\n    return action.type !== \"custom\" /* ActionType.CUSTOM */;\n}\n//# sourceMappingURL=actionCollection.js.map","import { instrumentMethod } from '../../tools/instrumentMethod';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nimport { computeStackTrace, computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace';\nimport { computeRawError, isError } from './error';\nimport { ErrorSource } from './error.types';\nexport function trackRuntimeError(errorObservable) {\n    var handleRuntimeError = function (stackTrace, originalError) {\n        var rawError = computeRawError({\n            stackTrace: stackTrace,\n            originalError: originalError,\n            startClocks: clocksNow(),\n            nonErrorPrefix: \"Uncaught\" /* NonErrorPrefix.UNCAUGHT */,\n            source: ErrorSource.SOURCE,\n            handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n        });\n        errorObservable.notify(rawError);\n    };\n    var stopInstrumentingOnError = instrumentOnError(handleRuntimeError).stop;\n    var stopInstrumentingOnUnhandledRejection = instrumentUnhandledRejection(handleRuntimeError).stop;\n    return {\n        stop: function () {\n            stopInstrumentingOnError();\n            stopInstrumentingOnUnhandledRejection();\n        },\n    };\n}\nexport function instrumentOnError(callback) {\n    return instrumentMethod(window, 'onerror', function (_a) {\n        var _b = _a.parameters, messageObj = _b[0], url = _b[1], line = _b[2], column = _b[3], errorObj = _b[4];\n        var stackTrace;\n        if (isError(errorObj)) {\n            stackTrace = computeStackTrace(errorObj);\n        }\n        else {\n            stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column);\n        }\n        callback(stackTrace, errorObj !== null && errorObj !== void 0 ? errorObj : messageObj);\n    });\n}\nexport function instrumentUnhandledRejection(callback) {\n    return instrumentMethod(window, 'onunhandledrejection', function (_a) {\n        var e = _a.parameters[0];\n        var reason = e.reason || 'Empty reason';\n        var stack = computeStackTrace(reason);\n        callback(stack, reason);\n    });\n}\n//# sourceMappingURL=trackRuntimeError.js.map","import { flattenErrorCauses, isError, tryToGetFingerprint } from '../error/error';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { ConsoleApiName, globalConsole } from '../../tools/display';\nimport { callMonitored } from '../../tools/monitor';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { find } from '../../tools/utils/polyfills';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { ErrorSource } from '../error/error.types';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { createHandlingStack, toStackTraceString, formatErrorMessage } from '../../tools/stackTrace/handlingStack';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nvar consoleObservablesByApi = {};\nexport function initConsoleObservable(apis) {\n    var consoleObservables = apis.map(function (api) {\n        if (!consoleObservablesByApi[api]) {\n            consoleObservablesByApi[api] = createConsoleObservable(api); // we are sure that the observable created for this api will yield the expected ConsoleLog type\n        }\n        return consoleObservablesByApi[api];\n    });\n    return mergeObservables.apply(void 0, consoleObservables);\n}\nexport function resetConsoleObservable() {\n    consoleObservablesByApi = {};\n}\nfunction createConsoleObservable(api) {\n    return new Observable(function (observable) {\n        var originalConsoleApi = globalConsole[api];\n        globalConsole[api] = function () {\n            var params = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                params[_i] = arguments[_i];\n            }\n            originalConsoleApi.apply(console, params);\n            var handlingStack = createHandlingStack();\n            callMonitored(function () {\n                observable.notify(buildConsoleLog(params, api, handlingStack));\n            });\n        };\n        return function () {\n            globalConsole[api] = originalConsoleApi;\n        };\n    });\n}\nfunction buildConsoleLog(params, api, handlingStack) {\n    var message = params.map(function (param) { return formatConsoleParameters(param); }).join(' ');\n    var error;\n    if (api === ConsoleApiName.error) {\n        var firstErrorParam = find(params, isError);\n        error = {\n            stack: firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined,\n            fingerprint: tryToGetFingerprint(firstErrorParam),\n            causes: firstErrorParam ? flattenErrorCauses(firstErrorParam, 'console') : undefined,\n            startClocks: clocksNow(),\n            message: message,\n            source: ErrorSource.CONSOLE,\n            handling: \"handled\" /* ErrorHandling.HANDLED */,\n            handlingStack: handlingStack,\n        };\n    }\n    return {\n        api: api,\n        message: message,\n        error: error,\n        handlingStack: handlingStack,\n    };\n}\nfunction formatConsoleParameters(param) {\n    if (typeof param === 'string') {\n        return sanitize(param);\n    }\n    if (isError(param)) {\n        return formatErrorMessage(computeStackTrace(param));\n    }\n    return jsonStringify(sanitize(param), undefined, 2);\n}\n//# sourceMappingURL=consoleObservable.js.map","import { initConsoleObservable, ConsoleApiName } from '@datadog/browser-core';\nexport function trackConsoleError(errorObservable) {\n    var subscription = initConsoleObservable([ConsoleApiName.error]).subscribe(function (consoleLog) {\n        return errorObservable.notify(consoleLog.error);\n    });\n    return {\n        stop: function () {\n            subscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackConsoleError.js.map","import { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { monitor } from '../../tools/monitor';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { addEventListener } from '../../browser/addEventListener';\nimport { assign, includes } from '../../tools/utils/polyfills';\nimport { safeTruncate } from '../../tools/utils/stringUtils';\nimport { ErrorSource } from '../error/error.types';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nexport var RawReportType = {\n    intervention: 'intervention',\n    deprecation: 'deprecation',\n    cspViolation: 'csp_violation',\n};\nexport function initReportObservable(configuration, apis) {\n    var observables = [];\n    if (includes(apis, RawReportType.cspViolation)) {\n        observables.push(createCspViolationReportObservable(configuration));\n    }\n    var reportTypes = apis.filter(function (api) { return api !== RawReportType.cspViolation; });\n    if (reportTypes.length) {\n        observables.push(createReportObservable(reportTypes));\n    }\n    return mergeObservables.apply(void 0, observables);\n}\nfunction createReportObservable(reportTypes) {\n    return new Observable(function (observable) {\n        if (!window.ReportingObserver) {\n            return;\n        }\n        var handleReports = monitor(function (reports, _) {\n            return reports.forEach(function (report) { return observable.notify(buildRawReportErrorFromReport(report)); });\n        });\n        var observer = new window.ReportingObserver(handleReports, {\n            types: reportTypes,\n            buffered: true,\n        });\n        observer.observe();\n        return function () {\n            observer.disconnect();\n        };\n    });\n}\nfunction createCspViolationReportObservable(configuration) {\n    return new Observable(function (observable) {\n        var stop = addEventListener(configuration, document, \"securitypolicyviolation\" /* DOM_EVENT.SECURITY_POLICY_VIOLATION */, function (event) {\n            observable.notify(buildRawReportErrorFromCspViolation(event));\n        }).stop;\n        return stop;\n    });\n}\nfunction buildRawReportErrorFromReport(report) {\n    var type = report.type, body = report.body;\n    return buildRawReportError({\n        type: body.id,\n        message: \"\".concat(type, \": \").concat(body.message),\n        originalError: report,\n        stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n    });\n}\nfunction buildRawReportErrorFromCspViolation(event) {\n    var message = \"'\".concat(event.blockedURI, \"' blocked by '\").concat(event.effectiveDirective, \"' directive\");\n    return buildRawReportError({\n        type: event.effectiveDirective,\n        message: \"\".concat(RawReportType.cspViolation, \": \").concat(message),\n        originalError: event,\n        csp: {\n            disposition: event.disposition,\n        },\n        stack: buildStack(event.effectiveDirective, event.originalPolicy\n            ? \"\".concat(message, \" of the policy \\\"\").concat(safeTruncate(event.originalPolicy, 100, '...'), \"\\\"\")\n            : 'no policy', event.sourceFile, event.lineNumber, event.columnNumber),\n    });\n}\nfunction buildRawReportError(partial) {\n    return assign({\n        startClocks: clocksNow(),\n        source: ErrorSource.REPORT,\n        handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n    }, partial);\n}\nfunction buildStack(name, message, sourceFile, lineNumber, columnNumber) {\n    return sourceFile\n        ? toStackTraceString({\n            name: name,\n            message: message,\n            stack: [\n                {\n                    func: '?',\n                    url: sourceFile,\n                    line: lineNumber !== null && lineNumber !== void 0 ? lineNumber : undefined,\n                    column: columnNumber !== null && columnNumber !== void 0 ? columnNumber : undefined,\n                },\n            ],\n        })\n        : undefined;\n}\n//# sourceMappingURL=reportObservable.js.map","import { initReportObservable, RawReportType } from '@datadog/browser-core';\nexport function trackReportError(configuration, errorObservable) {\n    var subscription = initReportObservable(configuration, [\n        RawReportType.cspViolation,\n        RawReportType.intervention,\n    ]).subscribe(function (rawError) { return errorObservable.notify(rawError); });\n    return {\n        stop: function () {\n            subscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackReportError.js.map","import { isEmptyObject, assign, ErrorSource, generateUUID, computeRawError, computeStackTrace, Observable, trackRuntimeError, isError, } from '@datadog/browser-core';\nimport { trackConsoleError } from './trackConsoleError';\nimport { trackReportError } from './trackReportError';\nexport function startErrorCollection(lifeCycle, configuration, pageStateHistory, featureFlagContexts) {\n    var errorObservable = new Observable();\n    trackConsoleError(errorObservable);\n    trackRuntimeError(errorObservable);\n    trackReportError(configuration, errorObservable);\n    errorObservable.subscribe(function (error) { return lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error: error }); });\n    return doStartErrorCollection(lifeCycle, pageStateHistory, featureFlagContexts);\n}\nexport function doStartErrorCollection(lifeCycle, pageStateHistory, featureFlagContexts) {\n    lifeCycle.subscribe(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, function (_a) {\n        var error = _a.error, customerContext = _a.customerContext, savedCommonContext = _a.savedCommonContext;\n        lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, assign({\n            customerContext: customerContext,\n            savedCommonContext: savedCommonContext,\n        }, processError(error, pageStateHistory, featureFlagContexts)));\n    });\n    return {\n        addError: function (_a, savedCommonContext) {\n            var error = _a.error, handlingStack = _a.handlingStack, startClocks = _a.startClocks, customerContext = _a.context;\n            var stackTrace = isError(error) ? computeStackTrace(error) : undefined;\n            var rawError = computeRawError({\n                stackTrace: stackTrace,\n                originalError: error,\n                handlingStack: handlingStack,\n                startClocks: startClocks,\n                nonErrorPrefix: \"Provided\" /* NonErrorPrefix.PROVIDED */,\n                source: ErrorSource.CUSTOM,\n                handling: \"handled\" /* ErrorHandling.HANDLED */,\n            });\n            lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, {\n                customerContext: customerContext,\n                savedCommonContext: savedCommonContext,\n                error: rawError,\n            });\n        },\n    };\n}\nfunction processError(error, pageStateHistory, featureFlagContexts) {\n    var rawRumEvent = {\n        date: error.startClocks.timeStamp,\n        error: {\n            id: generateUUID(),\n            message: error.message,\n            source: error.source,\n            stack: error.stack,\n            handling_stack: error.handlingStack,\n            type: error.type,\n            handling: error.handling,\n            causes: error.causes,\n            source_type: 'browser',\n            fingerprint: error.fingerprint,\n            csp: error.csp,\n        },\n        type: \"error\" /* RumEventType.ERROR */,\n        view: { in_foreground: pageStateHistory.wasInPageStateAt(\"active\" /* PageState.ACTIVE */, error.startClocks.relative) },\n    };\n    var featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(error.startClocks.relative);\n    if (featureFlagContext && !isEmptyObject(featureFlagContext)) {\n        rawRumEvent.feature_flags = featureFlagContext;\n    }\n    var domainContext = {\n        error: error.originalError,\n        handlingStack: error.handlingStack,\n    };\n    return {\n        rawRumEvent: rawRumEvent,\n        startTime: error.startClocks.relative,\n        domainContext: domainContext,\n    };\n}\n//# sourceMappingURL=errorCollection.js.map","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../browser/performanceObservable';\nexport function startLongTaskCollection(lifeCycle, configuration) {\n    var performanceLongTaskSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LONG_TASK,\n        buffered: true,\n    }).subscribe(function (entries) {\n        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n            var entry = entries_1[_i];\n            if (entry.entryType !== RumPerformanceEntryType.LONG_TASK) {\n                break;\n            }\n            if (!configuration.trackLongTasks) {\n                break;\n            }\n            var startClocks = relativeToClocks(entry.startTime);\n            var rawRumEvent = {\n                date: startClocks.timeStamp,\n                long_task: {\n                    id: generateUUID(),\n                    entry_type: \"long-task\" /* RumLongTaskEntryType.LONG_TASK */,\n                    duration: toServerDuration(entry.duration),\n                },\n                type: \"long_task\" /* RumEventType.LONG_TASK */,\n                _dd: {\n                    discarded: false,\n                },\n            };\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {\n                rawRumEvent: rawRumEvent,\n                startTime: startClocks.relative,\n                domainContext: { performanceEntry: entry },\n            });\n        }\n    });\n    return {\n        stop: function () {\n            performanceLongTaskSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=longTaskCollection.js.map","import { setTimeout, clearTimeout } from './timer';\nimport { monitor } from './monitor';\nimport { dateNow } from './utils/timeUtils';\n/**\n * 'requestIdleCallback' with a shim.\n */\nexport function requestIdleCallback(callback, opts) {\n    // Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n    if (window.requestIdleCallback && window.cancelIdleCallback) {\n        var id_1 = window.requestIdleCallback(monitor(callback), opts);\n        return function () { return window.cancelIdleCallback(id_1); };\n    }\n    return requestIdleCallbackShim(callback);\n}\nexport var MAX_TASK_TIME = 50;\n/*\n * Shim from https://developer.chrome.com/blog/using-requestidlecallback#checking_for_requestidlecallback\n * Note: there is no simple way to support the \"timeout\" option, so we ignore it.\n */\nexport function requestIdleCallbackShim(callback) {\n    var start = dateNow();\n    var timeoutId = setTimeout(function () {\n        callback({\n            didTimeout: false,\n            timeRemaining: function () { return Math.max(0, MAX_TASK_TIME - (dateNow() - start)); },\n        });\n    }, 0);\n    return function () { return clearTimeout(timeoutId); };\n}\n//# sourceMappingURL=requestIdleCallback.js.map","import { ONE_SECOND } from './utils/timeUtils';\nimport { requestIdleCallback } from './requestIdleCallback';\n/**\n * Maximum delay before starting to execute tasks in the queue. We don't want to wait too long\n * before running tasks, as it might hurt reliability (ex: if the user navigates away, we might lose\n * the opportunity to send some data). We also don't want to run tasks too often, as it might hurt\n * performance.\n */\nvar IDLE_CALLBACK_TIMEOUT = ONE_SECOND;\n/**\n * Maximum amount of time allocated to running tasks when a timeout (`IDLE_CALLBACK_TIMEOUT`) is\n * reached. We should not run tasks for too long as it will hurt performance, but we should still\n * run some tasks to avoid postponing them forever.\n *\n * Rational: Running tasks for 30ms every second (IDLE_CALLBACK_TIMEOUT) should be acceptable.\n */\nexport var MAX_EXECUTION_TIME_ON_TIMEOUT = 30;\nexport function createTaskQueue() {\n    var pendingTasks = [];\n    function run(deadline) {\n        var executionTimeRemaining;\n        if (deadline.didTimeout) {\n            var start_1 = performance.now();\n            executionTimeRemaining = function () { return MAX_EXECUTION_TIME_ON_TIMEOUT - (performance.now() - start_1); };\n        }\n        else {\n            executionTimeRemaining = deadline.timeRemaining.bind(deadline);\n        }\n        while (executionTimeRemaining() > 0 && pendingTasks.length) {\n            pendingTasks.shift()();\n        }\n        if (pendingTasks.length) {\n            scheduleNextRun();\n        }\n    }\n    function scheduleNextRun() {\n        requestIdleCallback(run, { timeout: IDLE_CALLBACK_TIMEOUT });\n    }\n    return {\n        push: function (task) {\n            if (pendingTasks.push(task) === 1) {\n                scheduleNextRun();\n            }\n        },\n    };\n}\n//# sourceMappingURL=taskQueue.js.map","import { addDuration } from '@datadog/browser-core';\nimport { WeakSet } from '../../browser/polyfills';\nimport { hasValidResourceEntryDuration, hasValidResourceEntryTimings } from './resourceUtils';\nvar alreadyMatchedEntries = new WeakSet();\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - filter out timing that were already matched to a request\n * - then, if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestResourceEntry(request) {\n    if (!performance || !('getEntriesByName' in performance)) {\n        return;\n    }\n    var sameNameEntries = performance.getEntriesByName(request.url, 'resource');\n    if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n        return;\n    }\n    var candidates = sameNameEntries\n        .filter(function (entry) { return !alreadyMatchedEntries.has(entry); })\n        .filter(function (entry) { return hasValidResourceEntryDuration(entry) && hasValidResourceEntryTimings(entry); })\n        .filter(function (entry) {\n        return isBetween(entry, request.startClocks.relative, endTime({ startTime: request.startClocks.relative, duration: request.duration }));\n    });\n    if (candidates.length === 1) {\n        alreadyMatchedEntries.add(candidates[0]);\n        return candidates[0].toJSON();\n    }\n    return;\n}\nfunction endTime(timing) {\n    return addDuration(timing.startTime, timing.duration);\n}\nfunction isBetween(timing, start, end) {\n    var errorMargin = 1;\n    return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin);\n}\n//# sourceMappingURL=matchRequestResourceEntry.js.map","import { noop } from '../tools/utils/functionUtils';\nimport { addEventListener } from './addEventListener';\nexport function runOnReadyState(configuration, expectedReadyState, callback) {\n    if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n        callback();\n        return { stop: noop };\n    }\n    var eventName = expectedReadyState === 'complete' ? \"load\" /* DOM_EVENT.LOAD */ : \"DOMContentLoaded\" /* DOM_EVENT.DOM_CONTENT_LOADED */;\n    return addEventListener(configuration, window, eventName, callback, { once: true });\n}\n//# sourceMappingURL=runOnReadyState.js.map","import { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core';\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils';\nexport var INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE;\nexport function getDocumentTraceId(document) {\n    var data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document);\n    if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n        return undefined;\n    }\n    return data.traceId;\n}\nexport function getDocumentTraceDataFromMeta(document) {\n    var traceIdMeta = document.querySelector('meta[name=dd-trace-id]');\n    var traceTimeMeta = document.querySelector('meta[name=dd-trace-time]');\n    return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content);\n}\nexport function getDocumentTraceDataFromComment(document) {\n    var comment = findTraceComment(document);\n    if (!comment) {\n        return undefined;\n    }\n    return createDocumentTraceData(findCommaSeparatedValue(comment, 'trace-id'), findCommaSeparatedValue(comment, 'trace-time'));\n}\nexport function createDocumentTraceData(traceId, rawTraceTime) {\n    var traceTime = rawTraceTime && Number(rawTraceTime);\n    if (!traceId || !traceTime) {\n        return undefined;\n    }\n    return {\n        traceId: traceId,\n        traceTime: traceTime,\n    };\n}\nexport function findTraceComment(document) {\n    // 1. Try to find the comment as a direct child of the document\n    // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n    // value is not an array or string (here, a NodeList).\n    for (var i = 0; i < document.childNodes.length; i += 1) {\n        var comment = getTraceCommentFromNode(document.childNodes[i]);\n        if (comment) {\n            return comment;\n        }\n    }\n    // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n    // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n    // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n    // reverse order, stopping if we come across a non-text node.\n    if (document.body) {\n        for (var i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n            var node = document.body.childNodes[i];\n            var comment = getTraceCommentFromNode(node);\n            if (comment) {\n                return comment;\n            }\n            if (!isTextNode(node)) {\n                break;\n            }\n        }\n    }\n}\nfunction getTraceCommentFromNode(node) {\n    if (node && isCommentNode(node)) {\n        var match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data);\n        if (match) {\n            return match[1];\n        }\n    }\n}\n//# sourceMappingURL=getDocumentTraceId.js.map","import { assign, getRelativeTime, isNumber } from '@datadog/browser-core';\nimport { RumPerformanceEntryType, supportPerformanceTimingEvent, } from './performanceObservable';\nexport function getNavigationEntry() {\n    if (supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION)) {\n        var navigationEntry = performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION)[0];\n        if (navigationEntry) {\n            return navigationEntry;\n        }\n    }\n    var timings = computeTimingsFromDeprecatedPerformanceTiming();\n    var entry = assign({\n        entryType: RumPerformanceEntryType.NAVIGATION,\n        initiatorType: 'navigation',\n        name: window.location.href,\n        startTime: 0,\n        duration: timings.responseEnd,\n        decodedBodySize: 0,\n        encodedBodySize: 0,\n        transferSize: 0,\n        workerStart: 0,\n        toJSON: function () { return assign({}, entry, { toJSON: undefined }); },\n    }, timings);\n    return entry;\n}\nexport function computeTimingsFromDeprecatedPerformanceTiming() {\n    var result = {};\n    var timing = performance.timing;\n    for (var key in timing) {\n        if (isNumber(timing[key])) {\n            var numberKey = key;\n            var timingElement = timing[numberKey];\n            result[numberKey] = timingElement === 0 ? 0 : getRelativeTime(timingElement);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=performanceUtils.js.map","import { assign, runOnReadyState } from '@datadog/browser-core';\nimport { RumPerformanceEntryType } from '../../browser/performanceObservable';\nimport { getDocumentTraceId } from '../tracing/getDocumentTraceId';\nimport { getNavigationEntry } from '../../browser/performanceUtils';\nimport { FAKE_INITIAL_DOCUMENT } from './resourceUtils';\nexport function retrieveInitialDocumentResourceTiming(configuration, callback) {\n    runOnReadyState(configuration, 'interactive', function () {\n        var entry = assign(getNavigationEntry().toJSON(), {\n            entryType: RumPerformanceEntryType.RESOURCE,\n            initiatorType: FAKE_INITIAL_DOCUMENT,\n            traceId: getDocumentTraceId(document),\n            toJSON: function () { return assign({}, entry, { toJSON: undefined }); },\n        });\n        callback(entry);\n    });\n}\n//# sourceMappingURL=retrieveInitialDocumentResourceTiming.js.map","import { combine, generateUUID, toServerDuration, relativeToClocks, assign, createTaskQueue, } from '@datadog/browser-core';\nimport { RumPerformanceEntryType, createPerformanceObservable, } from '../../browser/performanceObservable';\nimport { createSpanIdentifier } from '../tracing/identifier';\nimport { matchRequestResourceEntry } from './matchRequestResourceEntry';\nimport { computeResourceEntryDetails, computeResourceEntryDuration, computeResourceEntryType, computeResourceEntrySize, computeResourceEntryProtocol, computeResourceEntryDeliveryType, isResourceEntryRequestType, isLongDataUrl, sanitizeDataUrl, } from './resourceUtils';\nimport { retrieveInitialDocumentResourceTiming } from './retrieveInitialDocumentResourceTiming';\nexport function startResourceCollection(lifeCycle, configuration, pageStateHistory, taskQueue, retrieveInitialDocumentResourceTimingImpl) {\n    if (taskQueue === void 0) { taskQueue = createTaskQueue(); }\n    if (retrieveInitialDocumentResourceTimingImpl === void 0) { retrieveInitialDocumentResourceTimingImpl = retrieveInitialDocumentResourceTiming; }\n    lifeCycle.subscribe(8 /* LifeCycleEventType.REQUEST_COMPLETED */, function (request) {\n        handleResource(function () { return processRequest(request, configuration, pageStateHistory); });\n    });\n    var performanceResourceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.RESOURCE,\n        buffered: true,\n    }).subscribe(function (entries) {\n        var _loop_1 = function (entry) {\n            if (!isResourceEntryRequestType(entry)) {\n                handleResource(function () { return processResourceEntry(entry, configuration); });\n            }\n        };\n        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n            var entry = entries_1[_i];\n            _loop_1(entry);\n        }\n    });\n    retrieveInitialDocumentResourceTimingImpl(configuration, function (timing) {\n        handleResource(function () { return processResourceEntry(timing, configuration); });\n    });\n    function handleResource(computeRawEvent) {\n        taskQueue.push(function () {\n            var rawEvent = computeRawEvent();\n            if (rawEvent) {\n                lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, rawEvent);\n            }\n        });\n    }\n    return {\n        stop: function () {\n            performanceResourceSubscription.unsubscribe();\n        },\n    };\n}\nfunction processRequest(request, configuration, pageStateHistory) {\n    var matchingTiming = matchRequestResourceEntry(request);\n    var startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks;\n    var tracingInfo = computeRequestTracingInfo(request, configuration);\n    if (!configuration.trackResources && !tracingInfo) {\n        return;\n    }\n    var type = request.type === \"xhr\" /* RequestType.XHR */ ? \"xhr\" /* ResourceType.XHR */ : \"fetch\" /* ResourceType.FETCH */;\n    var correspondingTimingOverrides = matchingTiming ? computeResourceEntryMetrics(matchingTiming) : undefined;\n    var duration = computeRequestDuration(pageStateHistory, startClocks, request.duration);\n    var resourceEvent = combine({\n        date: startClocks.timeStamp,\n        resource: {\n            id: generateUUID(),\n            type: type,\n            duration: duration,\n            method: request.method,\n            status_code: request.status,\n            protocol: matchingTiming && computeResourceEntryProtocol(matchingTiming),\n            url: isLongDataUrl(request.url) ? sanitizeDataUrl(request.url) : request.url,\n            delivery_type: matchingTiming && computeResourceEntryDeliveryType(matchingTiming),\n        },\n        type: \"resource\" /* RumEventType.RESOURCE */,\n        _dd: {\n            discarded: !configuration.trackResources,\n        },\n    }, tracingInfo, correspondingTimingOverrides);\n    return {\n        startTime: startClocks.relative,\n        rawRumEvent: resourceEvent,\n        domainContext: {\n            performanceEntry: matchingTiming,\n            xhr: request.xhr,\n            response: request.response,\n            requestInput: request.input,\n            requestInit: request.init,\n            error: request.error,\n            isAborted: request.isAborted,\n            handlingStack: request.handlingStack,\n        },\n    };\n}\nfunction processResourceEntry(entry, configuration) {\n    var startClocks = relativeToClocks(entry.startTime);\n    var tracingInfo = computeResourceEntryTracingInfo(entry, configuration);\n    if (!configuration.trackResources && !tracingInfo) {\n        return;\n    }\n    var type = computeResourceEntryType(entry);\n    var entryMetrics = computeResourceEntryMetrics(entry);\n    var resourceEvent = combine({\n        date: startClocks.timeStamp,\n        resource: {\n            id: generateUUID(),\n            type: type,\n            url: entry.name,\n            status_code: discardZeroStatus(entry.responseStatus),\n            protocol: computeResourceEntryProtocol(entry),\n            delivery_type: computeResourceEntryDeliveryType(entry),\n        },\n        type: \"resource\" /* RumEventType.RESOURCE */,\n        _dd: {\n            discarded: !configuration.trackResources,\n        },\n    }, tracingInfo, entryMetrics);\n    return {\n        startTime: startClocks.relative,\n        rawRumEvent: resourceEvent,\n        domainContext: {\n            performanceEntry: entry,\n        },\n    };\n}\nfunction computeResourceEntryMetrics(entry) {\n    var renderBlockingStatus = entry.renderBlockingStatus;\n    return {\n        resource: assign({\n            duration: computeResourceEntryDuration(entry),\n            render_blocking_status: renderBlockingStatus,\n        }, computeResourceEntrySize(entry), computeResourceEntryDetails(entry)),\n    };\n}\nfunction computeRequestTracingInfo(request, configuration) {\n    var hasBeenTraced = request.traceSampled && request.traceId && request.spanId;\n    if (!hasBeenTraced) {\n        return undefined;\n    }\n    return {\n        _dd: {\n            span_id: request.spanId.toString(),\n            trace_id: request.traceId.toString(),\n            rule_psr: configuration.rulePsr,\n        },\n    };\n}\nfunction computeResourceEntryTracingInfo(entry, configuration) {\n    var hasBeenTraced = entry.traceId;\n    if (!hasBeenTraced) {\n        return undefined;\n    }\n    return {\n        _dd: {\n            trace_id: entry.traceId,\n            span_id: createSpanIdentifier().toString(),\n            rule_psr: configuration.rulePsr,\n        },\n    };\n}\nfunction computeRequestDuration(pageStateHistory, startClocks, duration) {\n    return !pageStateHistory.wasInPageStateDuringPeriod(\"frozen\" /* PageState.FROZEN */, startClocks.relative, duration)\n        ? toServerDuration(duration)\n        : undefined;\n}\n/**\n * The status is 0 for cross-origin resources without CORS headers, so the status is meaningless, and we shouldn't report it\n * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/responseStatus#cross-origin_response_status_codes\n */\nfunction discardZeroStatus(statusCode) {\n    return statusCode === 0 ? undefined : statusCode;\n}\n//# sourceMappingURL=resourceCollection.js.map","import { trackEventCounts } from '../trackEventCounts';\nexport function trackViewEventCounts(lifeCycle, viewId, onChange) {\n    var _a = trackEventCounts({\n        lifeCycle: lifeCycle,\n        isChildEvent: function (event) { return event.view.id === viewId; },\n        onChange: onChange,\n    }), stop = _a.stop, eventCounts = _a.eventCounts;\n    return {\n        stop: stop,\n        eventCounts: eventCounts,\n    };\n}\n//# sourceMappingURL=trackViewEventCounts.js.map","import { ONE_MINUTE, find } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable';\n// Discard FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport var FCP_MAXIMUM_DELAY = 10 * ONE_MINUTE;\nexport function trackFirstContentfulPaint(configuration, firstHidden, callback) {\n    var performanceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.PAINT,\n        buffered: true,\n    }).subscribe(function (entries) {\n        var fcpEntry = find(entries, function (entry) {\n            return entry.name === 'first-contentful-paint' &&\n                entry.startTime < firstHidden.timeStamp &&\n                entry.startTime < FCP_MAXIMUM_DELAY;\n        });\n        if (fcpEntry) {\n            callback(fcpEntry.startTime);\n        }\n    });\n    return {\n        stop: performanceSubscription.unsubscribe,\n    };\n}\n//# sourceMappingURL=trackFirstContentfulPaint.js.map","import { elapsed, find } from '@datadog/browser-core';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInput(configuration, firstHidden, callback) {\n    var performanceFirstInputSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.FIRST_INPUT,\n        buffered: true,\n    }).subscribe(function (entries) {\n        var firstInputEntry = find(entries, function (entry) { return entry.startTime < firstHidden.timeStamp; });\n        if (firstInputEntry) {\n            var firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart);\n            var firstInputTargetSelector = void 0;\n            if (firstInputEntry.target && isElementNode(firstInputEntry.target)) {\n                firstInputTargetSelector = getSelectorFromElement(firstInputEntry.target, configuration.actionNameAttribute);\n            }\n            callback({\n                // Ensure firstInputDelay to be positive, see\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n                delay: firstInputDelay >= 0 ? firstInputDelay : 0,\n                time: firstInputEntry.startTime,\n                targetSelector: firstInputTargetSelector,\n            });\n        }\n    });\n    return {\n        stop: function () {\n            performanceFirstInputSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackFirstInput.js.map","import { setTimeout, relativeNow, runOnReadyState, clearTimeout } from '@datadog/browser-core';\nimport { getNavigationEntry } from '../../../browser/performanceUtils';\nexport function trackNavigationTimings(configuration, callback, getNavigationEntryImpl) {\n    if (getNavigationEntryImpl === void 0) { getNavigationEntryImpl = getNavigationEntry; }\n    return waitAfterLoadEvent(configuration, function () {\n        var entry = getNavigationEntryImpl();\n        if (!isIncompleteNavigation(entry)) {\n            callback(processNavigationEntry(entry));\n        }\n    });\n}\nfunction processNavigationEntry(entry) {\n    return {\n        domComplete: entry.domComplete,\n        domContentLoaded: entry.domContentLoadedEventEnd,\n        domInteractive: entry.domInteractive,\n        loadEvent: entry.loadEventEnd,\n        // In some cases the value reported is negative or is larger\n        // than the current page time. Ignore these cases:\n        // https://github.com/GoogleChrome/web-vitals/issues/137\n        // https://github.com/GoogleChrome/web-vitals/issues/162\n        firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n    };\n}\nfunction isIncompleteNavigation(entry) {\n    return entry.loadEventEnd <= 0;\n}\nfunction waitAfterLoadEvent(configuration, callback) {\n    var timeoutId;\n    var stopOnReadyState = runOnReadyState(configuration, 'complete', function () {\n        // Invoke the callback a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n        timeoutId = setTimeout(function () { return callback(); });\n    }).stop;\n    return {\n        stop: function () {\n            stopOnReadyState();\n            clearTimeout(timeoutId);\n        },\n    };\n}\n//# sourceMappingURL=trackNavigationTimings.js.map","import { ONE_MINUTE, addEventListeners, findLast } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n// Discard LCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport var LCP_MAXIMUM_DELAY = 10 * ONE_MINUTE;\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/onLCP.ts\n */\nexport function trackLargestContentfulPaint(configuration, firstHidden, eventTarget, callback) {\n    // Ignore entries that come after the first user interaction. According to the documentation, the\n    // browser should not send largest-contentful-paint entries after a user interact with the page,\n    // but the web-vitals reference implementation uses this as a safeguard.\n    var firstInteractionTimestamp = Infinity;\n    var stopEventListener = addEventListeners(configuration, eventTarget, [\"pointerdown\" /* DOM_EVENT.POINTER_DOWN */, \"keydown\" /* DOM_EVENT.KEY_DOWN */], function (event) {\n        firstInteractionTimestamp = event.timeStamp;\n    }, { capture: true, once: true }).stop;\n    var biggestLcpSize = 0;\n    var performanceLcpSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,\n        buffered: true,\n    }).subscribe(function (entries) {\n        var lcpEntry = findLast(entries, function (entry) {\n            return entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT &&\n                entry.startTime < firstInteractionTimestamp &&\n                entry.startTime < firstHidden.timeStamp &&\n                entry.startTime < LCP_MAXIMUM_DELAY &&\n                // Ensure to get the LCP entry with the biggest size, see\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655\n                entry.size > biggestLcpSize;\n        });\n        if (lcpEntry) {\n            var lcpTargetSelector = void 0;\n            if (lcpEntry.element) {\n                lcpTargetSelector = getSelectorFromElement(lcpEntry.element, configuration.actionNameAttribute);\n            }\n            callback({\n                value: lcpEntry.startTime,\n                targetSelector: lcpTargetSelector,\n            });\n            biggestLcpSize = lcpEntry.size;\n        }\n    });\n    return {\n        stop: function () {\n            stopEventListener();\n            performanceLcpSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackLargestContentfulPaint.js.map","import { addEventListeners } from '@datadog/browser-core';\nexport function trackFirstHidden(configuration, eventTarget) {\n    if (eventTarget === void 0) { eventTarget = window; }\n    var timeStamp;\n    var stopListeners;\n    if (document.visibilityState === 'hidden') {\n        timeStamp = 0;\n    }\n    else {\n        timeStamp = Infinity;\n        (stopListeners = addEventListeners(configuration, eventTarget, [\"pagehide\" /* DOM_EVENT.PAGE_HIDE */, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */], function (event) {\n            if (event.type === \"pagehide\" /* DOM_EVENT.PAGE_HIDE */ || document.visibilityState === 'hidden') {\n                timeStamp = event.timeStamp;\n                stopListeners();\n            }\n        }, { capture: true }).stop);\n    }\n    return {\n        get timeStamp() {\n            return timeStamp;\n        },\n        stop: function () {\n            stopListeners === null || stopListeners === void 0 ? void 0 : stopListeners();\n        },\n    };\n}\n//# sourceMappingURL=trackFirstHidden.js.map","import { trackFirstContentfulPaint } from './trackFirstContentfulPaint';\nimport { trackFirstInput } from './trackFirstInput';\nimport { trackNavigationTimings } from './trackNavigationTimings';\nimport { trackLargestContentfulPaint } from './trackLargestContentfulPaint';\nimport { trackFirstHidden } from './trackFirstHidden';\nexport function trackInitialViewMetrics(configuration, setLoadEvent, scheduleViewUpdate) {\n    var initialViewMetrics = {};\n    var stopNavigationTracking = trackNavigationTimings(configuration, function (navigationTimings) {\n        setLoadEvent(navigationTimings.loadEvent);\n        initialViewMetrics.navigationTimings = navigationTimings;\n        scheduleViewUpdate();\n    }).stop;\n    var firstHidden = trackFirstHidden(configuration);\n    var stopFCPTracking = trackFirstContentfulPaint(configuration, firstHidden, function (firstContentfulPaint) {\n        initialViewMetrics.firstContentfulPaint = firstContentfulPaint;\n        scheduleViewUpdate();\n    }).stop;\n    var stopLCPTracking = trackLargestContentfulPaint(configuration, firstHidden, window, function (largestContentfulPaint) {\n        initialViewMetrics.largestContentfulPaint = largestContentfulPaint;\n        scheduleViewUpdate();\n    }).stop;\n    var stopFIDTracking = trackFirstInput(configuration, firstHidden, function (firstInput) {\n        initialViewMetrics.firstInput = firstInput;\n        scheduleViewUpdate();\n    }).stop;\n    function stop() {\n        stopNavigationTracking();\n        stopFCPTracking();\n        stopLCPTracking();\n        stopFIDTracking();\n        firstHidden.stop();\n    }\n    return {\n        stop: stop,\n        initialViewMetrics: initialViewMetrics,\n    };\n}\n//# sourceMappingURL=trackInitialViewMetrics.js.map","import { round, find, ONE_SECOND, noop, elapsed } from '@datadog/browser-core';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { supportPerformanceTimingEvent, RumPerformanceEntryType, createPerformanceObservable, } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nexport function trackCumulativeLayoutShift(configuration, viewStart, callback) {\n    if (!isLayoutShiftSupported()) {\n        return {\n            stop: noop,\n        };\n    }\n    var maxClsValue = 0;\n    var maxClsTarget;\n    var maxClsStartTime;\n    // if no layout shift happen the value should be reported as 0\n    callback({\n        value: 0,\n    });\n    var window = slidingSessionWindow();\n    var performanceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LAYOUT_SHIFT,\n        buffered: true,\n    }).subscribe(function (entries) {\n        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n            var entry = entries_1[_i];\n            if (entry.hadRecentInput || entry.startTime < viewStart) {\n                continue;\n            }\n            var _a = window.update(entry), cumulatedValue = _a.cumulatedValue, isMaxValue = _a.isMaxValue;\n            if (isMaxValue) {\n                var target = getTargetFromSource(entry.sources);\n                maxClsTarget = target ? new WeakRef(target) : undefined;\n                maxClsStartTime = elapsed(viewStart, entry.startTime);\n            }\n            if (cumulatedValue > maxClsValue) {\n                maxClsValue = cumulatedValue;\n                var target = maxClsTarget === null || maxClsTarget === void 0 ? void 0 : maxClsTarget.deref();\n                callback({\n                    value: round(maxClsValue, 4),\n                    targetSelector: target && getSelectorFromElement(target, configuration.actionNameAttribute),\n                    time: maxClsStartTime,\n                });\n            }\n        }\n    });\n    return {\n        stop: function () {\n            performanceSubscription.unsubscribe();\n        },\n    };\n}\nfunction getTargetFromSource(sources) {\n    var _a;\n    if (!sources) {\n        return;\n    }\n    return (_a = find(sources, function (source) { return !!source.node && isElementNode(source.node); })) === null || _a === void 0 ? void 0 : _a.node;\n}\nexport var MAX_WINDOW_DURATION = 5 * ONE_SECOND;\nvar MAX_UPDATE_GAP = ONE_SECOND;\nfunction slidingSessionWindow() {\n    var cumulatedValue = 0;\n    var startTime;\n    var endTime;\n    var maxValue = 0;\n    return {\n        update: function (entry) {\n            var shouldCreateNewWindow = startTime === undefined ||\n                entry.startTime - endTime >= MAX_UPDATE_GAP ||\n                entry.startTime - startTime >= MAX_WINDOW_DURATION;\n            var isMaxValue;\n            if (shouldCreateNewWindow) {\n                startTime = endTime = entry.startTime;\n                maxValue = cumulatedValue = entry.value;\n                isMaxValue = true;\n            }\n            else {\n                cumulatedValue += entry.value;\n                endTime = entry.startTime;\n                isMaxValue = entry.value > maxValue;\n                if (isMaxValue) {\n                    maxValue = entry.value;\n                }\n            }\n            return {\n                cumulatedValue: cumulatedValue,\n                isMaxValue: isMaxValue,\n            };\n        },\n    };\n}\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nexport function isLayoutShiftSupported() {\n    return supportPerformanceTimingEvent(RumPerformanceEntryType.LAYOUT_SHIFT) && 'WeakRef' in window;\n}\n//# sourceMappingURL=trackCumulativeLayoutShift.js.map","/**\n * performance.interactionCount polyfill\n *\n * The interactionCount is an integer which counts the total number of distinct user interactions,\n * for which there was a unique interactionId.\n *\n * The interactionCount polyfill is an estimate based on a convention specific to Chrome. Cf: https://github.com/GoogleChrome/web-vitals/pull/213\n * This is currently not an issue as the polyfill is only used for INP which is currently only supported on Chrome.\n * Hopefully when/if other browsers will support INP, they will also implement performance.interactionCount at the same time, so we won't need that polyfill.\n *\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/lib/polyfills/interactionCountPolyfill.ts\n */\nimport { monitor } from '@datadog/browser-core';\nvar observer;\nvar interactionCountEstimate = 0;\nvar minKnownInteractionId = Infinity;\nvar maxKnownInteractionId = 0;\nexport function initInteractionCountPolyfill() {\n    if ('interactionCount' in performance || observer) {\n        return;\n    }\n    observer = new window.PerformanceObserver(monitor(function (entries) {\n        entries.getEntries().forEach(function (e) {\n            var entry = e;\n            if (entry.interactionId) {\n                minKnownInteractionId = Math.min(minKnownInteractionId, entry.interactionId);\n                maxKnownInteractionId = Math.max(maxKnownInteractionId, entry.interactionId);\n                interactionCountEstimate = (maxKnownInteractionId - minKnownInteractionId) / 7 + 1;\n            }\n        });\n    }));\n    observer.observe({ type: 'event', buffered: true, durationThreshold: 0 });\n}\n/**\n * Returns the `interactionCount` value using the native API (if available)\n * or the polyfill estimate in this module.\n */\nexport var getInteractionCount = function () {\n    return observer ? interactionCountEstimate : window.performance.interactionCount || 0;\n};\n//# sourceMappingURL=interactionCountPolyfill.js.map","import { elapsed, noop, ONE_MINUTE } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType, supportPerformanceTimingEvent, } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { getInteractionSelector } from '../../action/interactionSelectorCache';\nimport { getInteractionCount, initInteractionCountPolyfill } from './interactionCountPolyfill';\n// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.\nvar MAX_INTERACTION_ENTRIES = 10;\n// Arbitrary value to cap INP outliers\nexport var MAX_INP_VALUE = (1 * ONE_MINUTE);\n/**\n * Track the interaction to next paint (INP).\n * To avoid outliers, return the p98 worst interaction of the view.\n * Documentation: https://web.dev/inp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts\n */\nexport function trackInteractionToNextPaint(configuration, viewStart, viewLoadingType) {\n    if (!isInteractionToNextPaintSupported()) {\n        return {\n            getInteractionToNextPaint: function () { return undefined; },\n            setViewEnd: noop,\n            stop: noop,\n        };\n    }\n    var _a = trackViewInteractionCount(viewLoadingType), getViewInteractionCount = _a.getViewInteractionCount, stopViewInteractionCount = _a.stopViewInteractionCount;\n    var viewEnd = Infinity;\n    var longestInteractions = trackLongestInteractions(getViewInteractionCount);\n    var interactionToNextPaint = -1;\n    var interactionToNextPaintTargetSelector;\n    var interactionToNextPaintStartTime;\n    function handleEntries(entries) {\n        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n            var entry = entries_1[_i];\n            if (entry.interactionId &&\n                // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).\n                entry.startTime >= viewStart &&\n                entry.startTime <= viewEnd) {\n                longestInteractions.process(entry);\n            }\n        }\n        var newInteraction = longestInteractions.estimateP98Interaction();\n        if (newInteraction && newInteraction.duration !== interactionToNextPaint) {\n            interactionToNextPaint = newInteraction.duration;\n            interactionToNextPaintStartTime = elapsed(viewStart, newInteraction.startTime);\n            interactionToNextPaintTargetSelector = getInteractionSelector(newInteraction.startTime);\n            if (!interactionToNextPaintTargetSelector && newInteraction.target && isElementNode(newInteraction.target)) {\n                interactionToNextPaintTargetSelector = getSelectorFromElement(newInteraction.target, configuration.actionNameAttribute);\n            }\n        }\n    }\n    var firstInputSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.FIRST_INPUT,\n        buffered: true,\n    }).subscribe(handleEntries);\n    var eventSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.EVENT,\n        // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)\n        // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L202-L210\n        durationThreshold: 40,\n        buffered: true,\n    }).subscribe(handleEntries);\n    return {\n        getInteractionToNextPaint: function () {\n            // If no INP duration where captured because of the performanceObserver 40ms threshold\n            // but the view interaction count > 0 then report 0\n            if (interactionToNextPaint >= 0) {\n                return {\n                    value: Math.min(interactionToNextPaint, MAX_INP_VALUE),\n                    targetSelector: interactionToNextPaintTargetSelector,\n                    time: interactionToNextPaintStartTime,\n                };\n            }\n            else if (getViewInteractionCount()) {\n                return {\n                    value: 0,\n                };\n            }\n        },\n        setViewEnd: function (viewEndTime) {\n            viewEnd = viewEndTime;\n            stopViewInteractionCount();\n        },\n        stop: function () {\n            eventSubscription.unsubscribe();\n            firstInputSubscription.unsubscribe();\n        },\n    };\n}\nfunction trackLongestInteractions(getViewInteractionCount) {\n    var longestInteractions = [];\n    function sortAndTrimLongestInteractions() {\n        longestInteractions.sort(function (a, b) { return b.duration - a.duration; }).splice(MAX_INTERACTION_ENTRIES);\n    }\n    return {\n        /**\n         * Process the performance entry:\n         * - if its duration is long enough, add the performance entry to the list of worst interactions\n         * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions\n         */\n        process: function (entry) {\n            var interactionIndex = longestInteractions.findIndex(function (interaction) { return entry.interactionId === interaction.interactionId; });\n            var minLongestInteraction = longestInteractions[longestInteractions.length - 1];\n            if (interactionIndex !== -1) {\n                if (entry.duration > longestInteractions[interactionIndex].duration) {\n                    longestInteractions[interactionIndex] = entry;\n                    sortAndTrimLongestInteractions();\n                }\n            }\n            else if (longestInteractions.length < MAX_INTERACTION_ENTRIES ||\n                entry.duration > minLongestInteraction.duration) {\n                longestInteractions.push(entry);\n                sortAndTrimLongestInteractions();\n            }\n        },\n        /**\n         * Compute the p98 longest interaction.\n         * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.\n         */\n        estimateP98Interaction: function () {\n            var interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50));\n            return longestInteractions[interactionIndex];\n        },\n    };\n}\nexport function trackViewInteractionCount(viewLoadingType) {\n    initInteractionCountPolyfill();\n    var previousInteractionCount = viewLoadingType === \"initial_load\" /* ViewLoadingType.INITIAL_LOAD */ ? 0 : getInteractionCount();\n    var state = { stopped: false };\n    function computeViewInteractionCount() {\n        return getInteractionCount() - previousInteractionCount;\n    }\n    return {\n        getViewInteractionCount: function () {\n            if (state.stopped) {\n                return state.interactionCount;\n            }\n            return computeViewInteractionCount();\n        },\n        stopViewInteractionCount: function () {\n            state = { stopped: true, interactionCount: computeViewInteractionCount() };\n        },\n    };\n}\nexport function isInteractionToNextPaintSupported() {\n    return (supportPerformanceTimingEvent(RumPerformanceEntryType.EVENT) &&\n        window.PerformanceEventTiming &&\n        'interactionId' in PerformanceEventTiming.prototype);\n}\n//# sourceMappingURL=trackInteractionToNextPaint.js.map","import { elapsed } from '@datadog/browser-core';\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd';\nimport { trackFirstHidden } from './trackFirstHidden';\nexport function trackLoadingTime(lifeCycle, domMutationObservable, windowOpenObservable, configuration, loadType, viewStart, callback) {\n    var isWaitingForLoadEvent = loadType === \"initial_load\" /* ViewLoadingType.INITIAL_LOAD */;\n    var isWaitingForActivityLoadingTime = true;\n    var loadingTimeCandidates = [];\n    var firstHidden = trackFirstHidden(configuration);\n    function invokeCallbackIfAllCandidatesAreReceived() {\n        if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n            var loadingTime = Math.max.apply(Math, loadingTimeCandidates);\n            if (loadingTime < firstHidden.timeStamp) {\n                callback(loadingTime);\n            }\n        }\n    }\n    var stop = waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, function (event) {\n        if (isWaitingForActivityLoadingTime) {\n            isWaitingForActivityLoadingTime = false;\n            if (event.hadActivity) {\n                loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end));\n            }\n            invokeCallbackIfAllCandidatesAreReceived();\n        }\n    }).stop;\n    return {\n        stop: function () {\n            stop();\n            firstHidden.stop();\n        },\n        setLoadEvent: function (loadEvent) {\n            if (isWaitingForLoadEvent) {\n                isWaitingForLoadEvent = false;\n                loadingTimeCandidates.push(loadEvent);\n                invokeCallbackIfAllCandidatesAreReceived();\n            }\n        },\n    };\n}\n//# sourceMappingURL=trackLoadingTime.js.map","export function getScrollX() {\n    var scrollX;\n    var visual = window.visualViewport;\n    if (visual) {\n        scrollX = visual.pageLeft - visual.offsetLeft;\n    }\n    else if (window.scrollX !== undefined) {\n        scrollX = window.scrollX;\n    }\n    else {\n        scrollX = window.pageXOffset || 0;\n    }\n    return Math.round(scrollX);\n}\nexport function getScrollY() {\n    var scrollY;\n    var visual = window.visualViewport;\n    if (visual) {\n        scrollY = visual.pageTop - visual.offsetTop;\n    }\n    else if (window.scrollY !== undefined) {\n        scrollY = window.scrollY;\n    }\n    else {\n        scrollY = window.pageYOffset || 0;\n    }\n    return Math.round(scrollY);\n}\n//# sourceMappingURL=scroll.js.map","import { Observable, throttle, addEventListener } from '@datadog/browser-core';\nvar viewportObservable;\nexport function initViewportObservable(configuration) {\n    if (!viewportObservable) {\n        viewportObservable = createViewportObservable(configuration);\n    }\n    return viewportObservable;\n}\nexport function createViewportObservable(configuration) {\n    return new Observable(function (observable) {\n        var updateDimension = throttle(function () {\n            observable.notify(getViewportDimension());\n        }, 200).throttled;\n        return addEventListener(configuration, window, \"resize\" /* DOM_EVENT.RESIZE */, updateDimension, { capture: true, passive: true })\n            .stop;\n    });\n}\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension() {\n    var visual = window.visualViewport;\n    if (visual) {\n        return {\n            width: Number(visual.width * visual.scale),\n            height: Number(visual.height * visual.scale),\n        };\n    }\n    return {\n        width: Number(window.innerWidth || 0),\n        height: Number(window.innerHeight || 0),\n    };\n}\n//# sourceMappingURL=viewportObservable.js.map","import { Observable, ONE_SECOND, elapsed, relativeNow, throttle, addEventListener, monitor, } from '@datadog/browser-core';\nimport { getScrollY } from '../../../browser/scroll';\nimport { getViewportDimension } from '../../../browser/viewportObservable';\n/** Arbitrary scroll throttle duration */\nexport var THROTTLE_SCROLL_DURATION = ONE_SECOND;\nexport function trackScrollMetrics(configuration, viewStart, callback, scrollValues) {\n    if (scrollValues === void 0) { scrollValues = createScrollValuesObservable(configuration); }\n    var maxScrollDepth = 0;\n    var maxScrollHeight = 0;\n    var maxScrollHeightTime = 0;\n    var subscription = scrollValues.subscribe(function (_a) {\n        var scrollDepth = _a.scrollDepth, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight;\n        var shouldUpdate = false;\n        if (scrollDepth > maxScrollDepth) {\n            maxScrollDepth = scrollDepth;\n            shouldUpdate = true;\n        }\n        if (scrollHeight > maxScrollHeight) {\n            maxScrollHeight = scrollHeight;\n            var now = relativeNow();\n            maxScrollHeightTime = elapsed(viewStart.relative, now);\n            shouldUpdate = true;\n        }\n        if (shouldUpdate) {\n            callback({\n                maxDepth: Math.min(maxScrollDepth, maxScrollHeight),\n                maxDepthScrollTop: scrollTop,\n                maxScrollHeight: maxScrollHeight,\n                maxScrollHeightTime: maxScrollHeightTime,\n            });\n        }\n    });\n    return {\n        stop: function () { return subscription.unsubscribe(); },\n    };\n}\nexport function computeScrollValues() {\n    var scrollTop = getScrollY();\n    var height = getViewportDimension().height;\n    var scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight);\n    var scrollDepth = Math.round(height + scrollTop);\n    return {\n        scrollHeight: scrollHeight,\n        scrollDepth: scrollDepth,\n        scrollTop: scrollTop,\n    };\n}\nexport function createScrollValuesObservable(configuration, throttleDuration) {\n    if (throttleDuration === void 0) { throttleDuration = THROTTLE_SCROLL_DURATION; }\n    return new Observable(function (observable) {\n        function notify() {\n            observable.notify(computeScrollValues());\n        }\n        if (window.ResizeObserver) {\n            var throttledNotify_1 = throttle(notify, throttleDuration, {\n                leading: false,\n                trailing: true,\n            });\n            var observerTarget = document.scrollingElement || document.documentElement;\n            var resizeObserver_1 = new ResizeObserver(monitor(throttledNotify_1.throttled));\n            if (observerTarget) {\n                resizeObserver_1.observe(observerTarget);\n            }\n            var eventListener_1 = addEventListener(configuration, window, \"scroll\" /* DOM_EVENT.SCROLL */, throttledNotify_1.throttled, {\n                passive: true,\n            });\n            return function () {\n                throttledNotify_1.cancel();\n                resizeObserver_1.disconnect();\n                eventListener_1.stop();\n            };\n        }\n    });\n}\n//# sourceMappingURL=trackScrollMetrics.js.map","import { trackCumulativeLayoutShift } from './trackCumulativeLayoutShift';\nimport { trackInteractionToNextPaint } from './trackInteractionToNextPaint';\nimport { trackLoadingTime } from './trackLoadingTime';\nimport { trackScrollMetrics } from './trackScrollMetrics';\nexport function trackCommonViewMetrics(lifeCycle, domMutationObservable, windowOpenObservable, configuration, scheduleViewUpdate, loadingType, viewStart) {\n    var commonViewMetrics = {};\n    var _a = trackLoadingTime(lifeCycle, domMutationObservable, windowOpenObservable, configuration, loadingType, viewStart, function (newLoadingTime) {\n        commonViewMetrics.loadingTime = newLoadingTime;\n        scheduleViewUpdate();\n    }), stopLoadingTimeTracking = _a.stop, setLoadEvent = _a.setLoadEvent;\n    var stopScrollMetricsTracking = trackScrollMetrics(configuration, viewStart, function (newScrollMetrics) {\n        commonViewMetrics.scroll = newScrollMetrics;\n    }).stop;\n    var stopCLSTracking = trackCumulativeLayoutShift(configuration, viewStart.relative, function (cumulativeLayoutShift) {\n        commonViewMetrics.cumulativeLayoutShift = cumulativeLayoutShift;\n        scheduleViewUpdate();\n    }).stop;\n    var _b = trackInteractionToNextPaint(configuration, viewStart.relative, loadingType), stopINPTracking = _b.stop, getInteractionToNextPaint = _b.getInteractionToNextPaint, setViewEnd = _b.setViewEnd;\n    return {\n        stop: function () {\n            stopLoadingTimeTracking();\n            stopCLSTracking();\n            stopScrollMetricsTracking();\n        },\n        stopINPTracking: stopINPTracking,\n        setLoadEvent: setLoadEvent,\n        setViewEnd: setViewEnd,\n        getCommonViewMetrics: function () {\n            commonViewMetrics.interactionToNextPaint = getInteractionToNextPaint();\n            return commonViewMetrics;\n        },\n    };\n}\n//# sourceMappingURL=trackCommonViewMetrics.js.map","import { noop, PageExitReason, shallowClone, elapsed, generateUUID, ONE_MINUTE, throttle, clocksNow, clocksOrigin, timeStampNow, display, looksLikeRelativeTime, setInterval, clearInterval, setTimeout, Observable, createContextManager, } from '@datadog/browser-core';\nimport { trackViewEventCounts } from './trackViewEventCounts';\nimport { trackInitialViewMetrics } from './viewMetrics/trackInitialViewMetrics';\nimport { trackCommonViewMetrics } from './viewMetrics/trackCommonViewMetrics';\nexport var THROTTLE_VIEW_UPDATE_PERIOD = 3000;\nexport var SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE;\n// Some events or metrics can be captured after the end of the view. To avoid missing those;\n// an arbitrary delay is added for stopping their tracking after the view ends.\n//\n// Ideally, we would not stop and keep tracking events or metrics until the end of the session.\n// But this might have a small performance impact if there are many many views.\n// So let's have a fairly short delay improving the situation in most cases and avoid impacting performances too much.\nexport var KEEP_TRACKING_AFTER_VIEW_DELAY = 5 * ONE_MINUTE;\nexport function trackViews(location, lifeCycle, domMutationObservable, windowOpenObservable, configuration, locationChangeObservable, areViewsTrackedAutomatically, initialViewOptions) {\n    var activeViews = new Set();\n    var currentView = startNewView(\"initial_load\" /* ViewLoadingType.INITIAL_LOAD */, clocksOrigin(), initialViewOptions);\n    startViewLifeCycle();\n    var locationChangeSubscription;\n    if (areViewsTrackedAutomatically) {\n        locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable);\n    }\n    function startNewView(loadingType, startClocks, viewOptions) {\n        var newlyCreatedView = newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, location, loadingType, startClocks, viewOptions);\n        activeViews.add(newlyCreatedView);\n        newlyCreatedView.stopObservable.subscribe(function () {\n            activeViews.delete(newlyCreatedView);\n        });\n        return newlyCreatedView;\n    }\n    function startViewLifeCycle() {\n        lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, function () {\n            // Renew view on session renewal\n            currentView = startNewView(\"route_change\" /* ViewLoadingType.ROUTE_CHANGE */, undefined, {\n                name: currentView.name,\n                service: currentView.service,\n                version: currentView.version,\n                context: currentView.contextManager.getContext(),\n            });\n        });\n        lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, function () {\n            currentView.end({ sessionIsActive: false });\n        });\n        // End the current view on page unload\n        lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, function (pageExitEvent) {\n            if (pageExitEvent.reason === PageExitReason.UNLOADING) {\n                currentView.end();\n            }\n        });\n    }\n    function renewViewOnLocationChange(locationChangeObservable) {\n        return locationChangeObservable.subscribe(function (_a) {\n            var oldLocation = _a.oldLocation, newLocation = _a.newLocation;\n            if (areDifferentLocation(oldLocation, newLocation)) {\n                currentView.end();\n                currentView = startNewView(\"route_change\" /* ViewLoadingType.ROUTE_CHANGE */);\n            }\n        });\n    }\n    return {\n        addTiming: function (name, time) {\n            if (time === void 0) { time = timeStampNow(); }\n            currentView.addTiming(name, time);\n        },\n        startView: function (options, startClocks) {\n            currentView.end({ endClocks: startClocks });\n            currentView = startNewView(\"route_change\" /* ViewLoadingType.ROUTE_CHANGE */, startClocks, options);\n        },\n        setViewContext: function (context) {\n            currentView.contextManager.setContext(context);\n        },\n        setViewContextProperty: function (key, value) {\n            currentView.contextManager.setContextProperty(key, value);\n        },\n        setViewName: function (name) {\n            currentView.setViewName(name);\n        },\n        stop: function () {\n            if (locationChangeSubscription) {\n                locationChangeSubscription.unsubscribe();\n            }\n            currentView.end();\n            activeViews.forEach(function (view) { return view.stop(); });\n        },\n    };\n}\nfunction newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, initialLocation, loadingType, startClocks, viewOptions) {\n    if (startClocks === void 0) { startClocks = clocksNow(); }\n    // Setup initial values\n    var id = generateUUID();\n    var stopObservable = new Observable();\n    var customTimings = {};\n    var documentVersion = 0;\n    var endClocks;\n    var location = shallowClone(initialLocation);\n    var contextManager = createContextManager();\n    var sessionIsActive = true;\n    var name;\n    var service;\n    var version;\n    var context;\n    if (viewOptions) {\n        name = viewOptions.name;\n        service = viewOptions.service || undefined;\n        version = viewOptions.version || undefined;\n        if (viewOptions.context) {\n            context = viewOptions.context;\n            // use ContextManager to update the context so we always sanitize it\n            contextManager.setContext(context);\n        }\n    }\n    var viewCreatedEvent = {\n        id: id,\n        name: name,\n        startClocks: startClocks,\n        service: service,\n        version: version,\n        context: context,\n    };\n    lifeCycle.notify(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, viewCreatedEvent);\n    lifeCycle.notify(2 /* LifeCycleEventType.VIEW_CREATED */, viewCreatedEvent);\n    // Update the view every time the measures are changing\n    var _a = throttle(triggerViewUpdate, THROTTLE_VIEW_UPDATE_PERIOD, {\n        leading: false,\n    }), scheduleViewUpdate = _a.throttled, cancelScheduleViewUpdate = _a.cancel;\n    var _b = trackCommonViewMetrics(lifeCycle, domMutationObservable, windowOpenObservable, configuration, scheduleViewUpdate, loadingType, startClocks), setLoadEvent = _b.setLoadEvent, setViewEnd = _b.setViewEnd, stopCommonViewMetricsTracking = _b.stop, stopINPTracking = _b.stopINPTracking, getCommonViewMetrics = _b.getCommonViewMetrics;\n    var _c = loadingType === \"initial_load\" /* ViewLoadingType.INITIAL_LOAD */\n        ? trackInitialViewMetrics(configuration, setLoadEvent, scheduleViewUpdate)\n        : { stop: noop, initialViewMetrics: {} }, stopInitialViewMetricsTracking = _c.stop, initialViewMetrics = _c.initialViewMetrics;\n    var _d = trackViewEventCounts(lifeCycle, id, scheduleViewUpdate), stopEventCountsTracking = _d.stop, eventCounts = _d.eventCounts;\n    // Session keep alive\n    var keepAliveIntervalId = setInterval(triggerViewUpdate, SESSION_KEEP_ALIVE_INTERVAL);\n    // Initial view update\n    triggerViewUpdate();\n    // View context update should always be throttled\n    contextManager.changeObservable.subscribe(function () {\n        lifeCycle.notify(3 /* LifeCycleEventType.BEFORE_VIEW_UPDATED */, {\n            id: id,\n            name: name,\n            context: contextManager.getContext(),\n            startClocks: startClocks,\n        });\n        scheduleViewUpdate();\n    });\n    function triggerViewUpdate() {\n        cancelScheduleViewUpdate();\n        documentVersion += 1;\n        var currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp;\n        lifeCycle.notify(4 /* LifeCycleEventType.VIEW_UPDATED */, {\n            customTimings: customTimings,\n            documentVersion: documentVersion,\n            id: id,\n            name: name,\n            service: service,\n            version: version,\n            context: contextManager.getContext(),\n            loadingType: loadingType,\n            location: location,\n            startClocks: startClocks,\n            commonViewMetrics: getCommonViewMetrics(),\n            initialViewMetrics: initialViewMetrics,\n            duration: elapsed(startClocks.timeStamp, currentEnd),\n            isActive: endClocks === undefined,\n            sessionIsActive: sessionIsActive,\n            eventCounts: eventCounts,\n        });\n    }\n    return {\n        get name() {\n            return name;\n        },\n        service: service,\n        version: version,\n        contextManager: contextManager,\n        stopObservable: stopObservable,\n        end: function (options) {\n            var _this = this;\n            var _a, _b;\n            if (options === void 0) { options = {}; }\n            if (endClocks) {\n                // view already ended\n                return;\n            }\n            endClocks = (_a = options.endClocks) !== null && _a !== void 0 ? _a : clocksNow();\n            sessionIsActive = (_b = options.sessionIsActive) !== null && _b !== void 0 ? _b : true;\n            lifeCycle.notify(5 /* LifeCycleEventType.VIEW_ENDED */, { endClocks: endClocks });\n            lifeCycle.notify(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, { endClocks: endClocks });\n            clearInterval(keepAliveIntervalId);\n            setViewEnd(endClocks.relative);\n            stopCommonViewMetricsTracking();\n            triggerViewUpdate();\n            setTimeout(function () {\n                _this.stop();\n            }, KEEP_TRACKING_AFTER_VIEW_DELAY);\n        },\n        stop: function () {\n            stopInitialViewMetricsTracking();\n            stopEventCountsTracking();\n            stopINPTracking();\n            stopObservable.notify();\n        },\n        addTiming: function (name, time) {\n            if (endClocks) {\n                return;\n            }\n            var relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time);\n            customTimings[sanitizeTiming(name)] = relativeTime;\n            scheduleViewUpdate();\n        },\n        setViewName: function (updatedName) {\n            name = updatedName;\n            triggerViewUpdate();\n        },\n    };\n}\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name) {\n    var sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_');\n    if (sanitized !== name) {\n        display.warn(\"Invalid timing name: \".concat(name, \", sanitized to: \").concat(sanitized));\n    }\n    return sanitized;\n}\nfunction areDifferentLocation(currentLocation, otherLocation) {\n    return (currentLocation.pathname !== otherLocation.pathname ||\n        (!isHashAnAnchor(otherLocation.hash) &&\n            getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash)));\n}\nfunction isHashAnAnchor(hash) {\n    var correspondingId = hash.substring(1);\n    // check if the correspondingId is empty because on Firefox an empty string passed to getElementById() prints a consol warning\n    return correspondingId !== '' && !!document.getElementById(correspondingId);\n}\nfunction getPathFromHash(hash) {\n    var index = hash.indexOf('?');\n    return index < 0 ? hash : hash.slice(0, index);\n}\n//# sourceMappingURL=trackViews.js.map","import { isEmptyObject, mapValues, toServerDuration } from '@datadog/browser-core';\nimport { discardNegativeDuration } from '../discardNegativeDuration';\nimport { trackViews } from './trackViews';\nexport function startViewCollection(lifeCycle, configuration, location, domMutationObservable, pageOpenObserable, locationChangeObservable, featureFlagContexts, pageStateHistory, recorderApi, initialViewOptions) {\n    lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_UPDATED */, function (view) {\n        return lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processViewUpdate(view, configuration, featureFlagContexts, recorderApi, pageStateHistory));\n    });\n    return trackViews(location, lifeCycle, domMutationObservable, pageOpenObserable, configuration, locationChangeObservable, !configuration.trackViewsManually, initialViewOptions);\n}\nfunction processViewUpdate(view, configuration, featureFlagContexts, recorderApi, pageStateHistory) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n    var replayStats = recorderApi.getReplayStats(view.id);\n    var featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(view.startClocks.relative);\n    var pageStates = pageStateHistory.findAll(view.startClocks.relative, view.duration);\n    var viewEvent = {\n        _dd: {\n            document_version: view.documentVersion,\n            replay_stats: replayStats,\n            page_states: pageStates,\n            configuration: {\n                start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n            },\n        },\n        date: view.startClocks.timeStamp,\n        type: \"view\" /* RumEventType.VIEW */,\n        view: {\n            action: {\n                count: view.eventCounts.actionCount,\n            },\n            frustration: {\n                count: view.eventCounts.frustrationCount,\n            },\n            cumulative_layout_shift: (_a = view.commonViewMetrics.cumulativeLayoutShift) === null || _a === void 0 ? void 0 : _a.value,\n            cumulative_layout_shift_time: toServerDuration((_b = view.commonViewMetrics.cumulativeLayoutShift) === null || _b === void 0 ? void 0 : _b.time),\n            cumulative_layout_shift_target_selector: (_c = view.commonViewMetrics.cumulativeLayoutShift) === null || _c === void 0 ? void 0 : _c.targetSelector,\n            first_byte: toServerDuration((_d = view.initialViewMetrics.navigationTimings) === null || _d === void 0 ? void 0 : _d.firstByte),\n            dom_complete: toServerDuration((_e = view.initialViewMetrics.navigationTimings) === null || _e === void 0 ? void 0 : _e.domComplete),\n            dom_content_loaded: toServerDuration((_f = view.initialViewMetrics.navigationTimings) === null || _f === void 0 ? void 0 : _f.domContentLoaded),\n            dom_interactive: toServerDuration((_g = view.initialViewMetrics.navigationTimings) === null || _g === void 0 ? void 0 : _g.domInteractive),\n            error: {\n                count: view.eventCounts.errorCount,\n            },\n            first_contentful_paint: toServerDuration(view.initialViewMetrics.firstContentfulPaint),\n            first_input_delay: toServerDuration((_h = view.initialViewMetrics.firstInput) === null || _h === void 0 ? void 0 : _h.delay),\n            first_input_time: toServerDuration((_j = view.initialViewMetrics.firstInput) === null || _j === void 0 ? void 0 : _j.time),\n            first_input_target_selector: (_k = view.initialViewMetrics.firstInput) === null || _k === void 0 ? void 0 : _k.targetSelector,\n            interaction_to_next_paint: toServerDuration((_l = view.commonViewMetrics.interactionToNextPaint) === null || _l === void 0 ? void 0 : _l.value),\n            interaction_to_next_paint_time: toServerDuration((_m = view.commonViewMetrics.interactionToNextPaint) === null || _m === void 0 ? void 0 : _m.time),\n            interaction_to_next_paint_target_selector: (_o = view.commonViewMetrics.interactionToNextPaint) === null || _o === void 0 ? void 0 : _o.targetSelector,\n            is_active: view.isActive,\n            name: view.name,\n            largest_contentful_paint: toServerDuration((_p = view.initialViewMetrics.largestContentfulPaint) === null || _p === void 0 ? void 0 : _p.value),\n            largest_contentful_paint_target_selector: (_q = view.initialViewMetrics.largestContentfulPaint) === null || _q === void 0 ? void 0 : _q.targetSelector,\n            load_event: toServerDuration((_r = view.initialViewMetrics.navigationTimings) === null || _r === void 0 ? void 0 : _r.loadEvent),\n            loading_time: discardNegativeDuration(toServerDuration(view.commonViewMetrics.loadingTime)),\n            loading_type: view.loadingType,\n            long_task: {\n                count: view.eventCounts.longTaskCount,\n            },\n            resource: {\n                count: view.eventCounts.resourceCount,\n            },\n            time_spent: toServerDuration(view.duration),\n        },\n        feature_flags: featureFlagContext && !isEmptyObject(featureFlagContext) ? featureFlagContext : undefined,\n        display: view.commonViewMetrics.scroll\n            ? {\n                scroll: {\n                    max_depth: view.commonViewMetrics.scroll.maxDepth,\n                    max_depth_scroll_top: view.commonViewMetrics.scroll.maxDepthScrollTop,\n                    max_scroll_height: view.commonViewMetrics.scroll.maxScrollHeight,\n                    max_scroll_height_time: toServerDuration(view.commonViewMetrics.scroll.maxScrollHeightTime),\n                },\n            }\n            : undefined,\n        session: {\n            has_replay: replayStats ? true : undefined,\n            is_active: view.sessionIsActive ? undefined : false,\n        },\n        privacy: {\n            replay_level: configuration.defaultPrivacyLevel,\n        },\n    };\n    if (!isEmptyObject(view.customTimings)) {\n        viewEvent.view.custom_timings = mapValues(view.customTimings, toServerDuration);\n    }\n    return {\n        rawRumEvent: viewEvent,\n        startTime: view.startClocks.relative,\n        domainContext: {\n            location: view.location,\n        },\n    };\n}\n//# sourceMappingURL=viewCollection.js.map","import { Observable } from '../../tools/observable';\nimport { createValueHistory } from '../../tools/valueHistory';\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { addEventListener, addEventListeners } from '../../browser/addEventListener';\nimport { clearInterval, setInterval } from '../../tools/timer';\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { startSessionStore } from './sessionStore';\nexport var VISIBILITY_CHECK_DELAY = ONE_MINUTE;\nvar SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY;\nvar stopCallbacks = [];\nexport function startSessionManager(configuration, productKey, computeSessionState, trackingConsentState) {\n    var renewObservable = new Observable();\n    var expireObservable = new Observable();\n    // TODO - Improve configuration type and remove assertion\n    var sessionStore = startSessionStore(configuration.sessionStoreStrategyType, productKey, computeSessionState);\n    stopCallbacks.push(function () { return sessionStore.stop(); });\n    var sessionContextHistory = createValueHistory({\n        expireDelay: SESSION_CONTEXT_TIMEOUT_DELAY,\n    });\n    stopCallbacks.push(function () { return sessionContextHistory.stop(); });\n    sessionStore.renewObservable.subscribe(function () {\n        sessionContextHistory.add(buildSessionContext(), relativeNow());\n        renewObservable.notify();\n    });\n    sessionStore.expireObservable.subscribe(function () {\n        expireObservable.notify();\n        sessionContextHistory.closeActive(relativeNow());\n    });\n    // We expand/renew session unconditionally as tracking consent is always granted when the session\n    // manager is started.\n    sessionStore.expandOrRenewSession();\n    sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative);\n    trackingConsentState.observable.subscribe(function () {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n        else {\n            sessionStore.expire();\n        }\n    });\n    trackActivity(configuration, function () {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n    });\n    trackVisibility(configuration, function () { return sessionStore.expandSession(); });\n    trackResume(configuration, function () { return sessionStore.restartSession(); });\n    function buildSessionContext() {\n        return {\n            id: sessionStore.getSession().id,\n            trackingType: sessionStore.getSession()[productKey],\n            isReplayForced: !!sessionStore.getSession().forcedReplay,\n            anonymousId: sessionStore.getSession().anonymousId,\n        };\n    }\n    return {\n        findSession: function (startTime, options) { return sessionContextHistory.find(startTime, options); },\n        renewObservable: renewObservable,\n        expireObservable: expireObservable,\n        sessionStateUpdateObservable: sessionStore.sessionStateUpdateObservable,\n        expire: sessionStore.expire,\n        updateSessionState: sessionStore.updateSessionState,\n    };\n}\nexport function stopSessionManager() {\n    stopCallbacks.forEach(function (e) { return e(); });\n    stopCallbacks = [];\n}\nfunction trackActivity(configuration, expandOrRenewSession) {\n    var stop = addEventListeners(configuration, window, [\"click\" /* DOM_EVENT.CLICK */, \"touchstart\" /* DOM_EVENT.TOUCH_START */, \"keydown\" /* DOM_EVENT.KEY_DOWN */, \"scroll\" /* DOM_EVENT.SCROLL */], expandOrRenewSession, { capture: true, passive: true }).stop;\n    stopCallbacks.push(stop);\n}\nfunction trackVisibility(configuration, expandSession) {\n    var expandSessionWhenVisible = function () {\n        if (document.visibilityState === 'visible') {\n            expandSession();\n        }\n    };\n    var stop = addEventListener(configuration, document, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, expandSessionWhenVisible).stop;\n    stopCallbacks.push(stop);\n    var visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);\n    stopCallbacks.push(function () {\n        clearInterval(visibilityCheckInterval);\n    });\n}\nfunction trackResume(configuration, cb) {\n    var stop = addEventListener(configuration, window, \"resume\" /* DOM_EVENT.RESUME */, cb, { capture: true }).stop;\n    stopCallbacks.push(stop);\n}\n//# sourceMappingURL=sessionManager.js.map","import { Observable, bridgeSupports, noop, performDraw, startSessionManager, } from '@datadog/browser-core';\nexport var RUM_SESSION_KEY = 'rum';\nexport function startRumSessionManager(configuration, lifeCycle, trackingConsentState) {\n    var sessionManager = startSessionManager(configuration, RUM_SESSION_KEY, function (rawTrackingType) { return computeSessionState(configuration, rawTrackingType); }, trackingConsentState);\n    sessionManager.expireObservable.subscribe(function () {\n        lifeCycle.notify(9 /* LifeCycleEventType.SESSION_EXPIRED */);\n    });\n    sessionManager.renewObservable.subscribe(function () {\n        lifeCycle.notify(10 /* LifeCycleEventType.SESSION_RENEWED */);\n    });\n    sessionManager.sessionStateUpdateObservable.subscribe(function (_a) {\n        var previousState = _a.previousState, newState = _a.newState;\n        if (!previousState.forcedReplay && newState.forcedReplay) {\n            var sessionEntity = sessionManager.findSession();\n            if (sessionEntity) {\n                sessionEntity.isReplayForced = true;\n            }\n        }\n    });\n    return {\n        findTrackedSession: function (startTime) {\n            var session = sessionManager.findSession(startTime);\n            if (!session || !isTypeTracked(session.trackingType)) {\n                return;\n            }\n            return {\n                id: session.id,\n                sessionReplay: session.trackingType === \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */\n                    ? 1 /* SessionReplayState.SAMPLED */\n                    : session.isReplayForced\n                        ? 2 /* SessionReplayState.FORCED */\n                        : 0 /* SessionReplayState.OFF */,\n                anonymousId: session.anonymousId,\n            };\n        },\n        expire: sessionManager.expire,\n        expireObservable: sessionManager.expireObservable,\n        setForcedReplay: function () { return sessionManager.updateSessionState({ forcedReplay: '1' }); },\n    };\n}\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub() {\n    var session = {\n        id: '00000000-aaaa-0000-aaaa-000000000000',\n        sessionReplay: bridgeSupports(\"records\" /* BridgeCapability.RECORDS */) ? 1 /* SessionReplayState.SAMPLED */ : 0 /* SessionReplayState.OFF */,\n    };\n    return {\n        findTrackedSession: function () { return session; },\n        expire: noop,\n        expireObservable: new Observable(),\n        setForcedReplay: noop,\n    };\n}\nfunction computeSessionState(configuration, rawTrackingType) {\n    var trackingType;\n    if (hasValidRumSession(rawTrackingType)) {\n        trackingType = rawTrackingType;\n    }\n    else if (!performDraw(configuration.sessionSampleRate)) {\n        trackingType = \"0\" /* RumTrackingType.NOT_TRACKED */;\n    }\n    else if (!performDraw(configuration.sessionReplaySampleRate)) {\n        trackingType = \"2\" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */;\n    }\n    else {\n        trackingType = \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */;\n    }\n    return {\n        trackingType: trackingType,\n        isTracked: isTypeTracked(trackingType),\n    };\n}\nfunction hasValidRumSession(trackingType) {\n    return (trackingType === \"0\" /* RumTrackingType.NOT_TRACKED */ ||\n        trackingType === \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */ ||\n        trackingType === \"2\" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */);\n}\nfunction isTypeTracked(rumSessionType) {\n    return (rumSessionType === \"2\" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */ ||\n        rumSessionType === \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */);\n}\n//# sourceMappingURL=rumSessionManager.js.map","import { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../tools/display';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { isPageExitReason } from '../browser/pageExitObservable';\nimport { jsonStringify } from '../tools/serialisation/jsonStringify';\nimport { computeBytesCount } from '../tools/utils/byteUtils';\nexport function createBatch(_a) {\n    var encoder = _a.encoder, request = _a.request, flushController = _a.flushController, messageBytesLimit = _a.messageBytesLimit;\n    var upsertBuffer = {};\n    var flushSubscription = flushController.flushObservable.subscribe(function (event) { return flush(event); });\n    function push(serializedMessage, estimatedMessageBytesCount, key) {\n        flushController.notifyBeforeAddMessage(estimatedMessageBytesCount);\n        if (key !== undefined) {\n            upsertBuffer[key] = serializedMessage;\n            flushController.notifyAfterAddMessage();\n        }\n        else {\n            encoder.write(encoder.isEmpty ? serializedMessage : \"\\n\".concat(serializedMessage), function (realMessageBytesCount) {\n                flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount);\n            });\n        }\n    }\n    function hasMessageFor(key) {\n        return key !== undefined && upsertBuffer[key] !== undefined;\n    }\n    function remove(key) {\n        var removedMessage = upsertBuffer[key];\n        delete upsertBuffer[key];\n        var messageBytesCount = encoder.estimateEncodedBytesCount(removedMessage);\n        flushController.notifyAfterRemoveMessage(messageBytesCount);\n    }\n    function addOrUpdate(message, key) {\n        var serializedMessage = jsonStringify(message);\n        var estimatedMessageBytesCount = encoder.estimateEncodedBytesCount(serializedMessage);\n        if (estimatedMessageBytesCount >= messageBytesLimit) {\n            display.warn(\"Discarded a message whose size was bigger than the maximum allowed size \".concat(messageBytesLimit, \"KB. \").concat(MORE_DETAILS, \" \").concat(DOCS_TROUBLESHOOTING, \"/#technical-limitations\"));\n            return;\n        }\n        if (hasMessageFor(key)) {\n            remove(key);\n        }\n        push(serializedMessage, estimatedMessageBytesCount, key);\n    }\n    function flush(event) {\n        var upsertMessages = objectValues(upsertBuffer).join('\\n');\n        upsertBuffer = {};\n        var isPageExit = isPageExitReason(event.reason);\n        var send = isPageExit ? request.sendOnExit : request.send;\n        if (isPageExit &&\n            // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n            // if the encoder is async we need to send two requests in some cases (one for encoded data\n            // and the other for non-encoded data). But if it's not async, we don't have to worry about\n            // it and always send a single request.\n            encoder.isAsync) {\n            var encoderResult = encoder.finishSync();\n            // Send encoded messages\n            if (encoderResult.outputBytesCount) {\n                send(formatPayloadFromEncoder(encoderResult));\n            }\n            // Send messages that are not yet encoded at this point\n            var pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n');\n            if (pendingMessages) {\n                send({\n                    data: pendingMessages,\n                    bytesCount: computeBytesCount(pendingMessages),\n                });\n            }\n        }\n        else {\n            if (upsertMessages) {\n                encoder.write(encoder.isEmpty ? upsertMessages : \"\\n\".concat(upsertMessages));\n            }\n            encoder.finish(function (encoderResult) {\n                send(formatPayloadFromEncoder(encoderResult));\n            });\n        }\n    }\n    return {\n        flushController: flushController,\n        add: addOrUpdate,\n        upsert: addOrUpdate,\n        stop: flushSubscription.unsubscribe,\n    };\n}\nfunction formatPayloadFromEncoder(encoderResult) {\n    var data;\n    if (typeof encoderResult.output === 'string') {\n        data = encoderResult.output;\n    }\n    else {\n        data = new Blob([encoderResult.output], {\n            // This will set the 'Content-Type: text/plain' header. Reasoning:\n            // * The intake rejects the request if there is no content type.\n            // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n            // could induce higher intake load (and maybe has other impacts).\n            // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n            // new lines.\n            type: 'text/plain',\n        });\n    }\n    return {\n        data: data,\n        bytesCount: encoderResult.outputBytesCount,\n        encoding: encoderResult.encoding,\n    };\n}\n//# sourceMappingURL=batch.js.map","import { setTimeout } from '../tools/timer';\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils';\nimport { isServerError } from '../tools/utils/responseUtils';\nimport { ErrorSource } from '../domain/error/error.types';\nexport var MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;\nexport var MAX_ONGOING_REQUESTS = 32;\nexport var MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE;\nexport var MAX_BACKOFF_TIME = ONE_MINUTE;\nexport var INITIAL_BACKOFF_TIME = ONE_SECOND;\nexport function sendWithRetryStrategy(payload, state, sendStrategy, trackType, reportError) {\n    if (state.transportStatus === 0 /* TransportStatus.UP */ &&\n        state.queuedPayloads.size() === 0 &&\n        state.bandwidthMonitor.canHandle(payload)) {\n        send(payload, state, sendStrategy, {\n            onSuccess: function () { return retryQueuedPayloads(0 /* RetryReason.AFTER_SUCCESS */, state, sendStrategy, trackType, reportError); },\n            onFailure: function () {\n                state.queuedPayloads.enqueue(payload);\n                scheduleRetry(state, sendStrategy, trackType, reportError);\n            },\n        });\n    }\n    else {\n        state.queuedPayloads.enqueue(payload);\n    }\n}\nfunction scheduleRetry(state, sendStrategy, trackType, reportError) {\n    if (state.transportStatus !== 2 /* TransportStatus.DOWN */) {\n        return;\n    }\n    setTimeout(function () {\n        var payload = state.queuedPayloads.first();\n        send(payload, state, sendStrategy, {\n            onSuccess: function () {\n                state.queuedPayloads.dequeue();\n                state.currentBackoffTime = INITIAL_BACKOFF_TIME;\n                retryQueuedPayloads(1 /* RetryReason.AFTER_RESUME */, state, sendStrategy, trackType, reportError);\n            },\n            onFailure: function () {\n                state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);\n                scheduleRetry(state, sendStrategy, trackType, reportError);\n            },\n        });\n    }, state.currentBackoffTime);\n}\nfunction send(payload, state, sendStrategy, _a) {\n    var onSuccess = _a.onSuccess, onFailure = _a.onFailure;\n    state.bandwidthMonitor.add(payload);\n    sendStrategy(payload, function (response) {\n        state.bandwidthMonitor.remove(payload);\n        if (!shouldRetryRequest(response)) {\n            state.transportStatus = 0 /* TransportStatus.UP */;\n            onSuccess();\n        }\n        else {\n            // do not consider transport down if another ongoing request could succeed\n            state.transportStatus =\n                state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 /* TransportStatus.FAILURE_DETECTED */ : 2 /* TransportStatus.DOWN */;\n            payload.retry = {\n                count: payload.retry ? payload.retry.count + 1 : 1,\n                lastFailureStatus: response.status,\n            };\n            onFailure();\n        }\n    });\n}\nfunction retryQueuedPayloads(reason, state, sendStrategy, trackType, reportError) {\n    if (reason === 0 /* RetryReason.AFTER_SUCCESS */ && state.queuedPayloads.isFull() && !state.queueFullReported) {\n        reportError({\n            message: \"Reached max \".concat(trackType, \" events size queued for upload: \").concat(MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE, \"MiB\"),\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n        });\n        state.queueFullReported = true;\n    }\n    var previousQueue = state.queuedPayloads;\n    state.queuedPayloads = newPayloadQueue();\n    while (previousQueue.size() > 0) {\n        sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, trackType, reportError);\n    }\n}\nfunction shouldRetryRequest(response) {\n    return (response.type !== 'opaque' &&\n        ((response.status === 0 && !navigator.onLine) ||\n            response.status === 408 ||\n            response.status === 429 ||\n            isServerError(response.status)));\n}\nexport function newRetryState() {\n    return {\n        transportStatus: 0 /* TransportStatus.UP */,\n        currentBackoffTime: INITIAL_BACKOFF_TIME,\n        bandwidthMonitor: newBandwidthMonitor(),\n        queuedPayloads: newPayloadQueue(),\n        queueFullReported: false,\n    };\n}\nfunction newPayloadQueue() {\n    var queue = [];\n    return {\n        bytesCount: 0,\n        enqueue: function (payload) {\n            if (this.isFull()) {\n                return;\n            }\n            queue.push(payload);\n            this.bytesCount += payload.bytesCount;\n        },\n        first: function () {\n            return queue[0];\n        },\n        dequeue: function () {\n            var payload = queue.shift();\n            if (payload) {\n                this.bytesCount -= payload.bytesCount;\n            }\n            return payload;\n        },\n        size: function () {\n            return queue.length;\n        },\n        isFull: function () {\n            return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;\n        },\n    };\n}\nfunction newBandwidthMonitor() {\n    return {\n        ongoingRequestCount: 0,\n        ongoingByteCount: 0,\n        canHandle: function (payload) {\n            return (this.ongoingRequestCount === 0 ||\n                (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n                    this.ongoingRequestCount < MAX_ONGOING_REQUESTS));\n        },\n        add: function (payload) {\n            this.ongoingRequestCount += 1;\n            this.ongoingByteCount += payload.bytesCount;\n        },\n        remove: function (payload) {\n            this.ongoingRequestCount -= 1;\n            this.ongoingByteCount -= payload.bytesCount;\n        },\n    };\n}\n//# sourceMappingURL=sendWithRetryStrategy.js.map","import { addTelemetryError } from '../domain/telemetry';\nimport { monitor } from '../tools/monitor';\nimport { addEventListener } from '../browser/addEventListener';\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy';\nexport function createHttpRequest(endpointBuilder, bytesLimit, reportError) {\n    var retryState = newRetryState();\n    var sendStrategyForRetry = function (payload, onResponse) {\n        return fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);\n    };\n    return {\n        send: function (payload) {\n            sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError);\n        },\n        /**\n         * Since fetch keepalive behaves like regular fetch on Firefox,\n         * keep using sendBeaconStrategy on exit\n         */\n        sendOnExit: function (payload) {\n            sendBeaconStrategy(endpointBuilder, bytesLimit, payload);\n        },\n    };\n}\nfunction sendBeaconStrategy(endpointBuilder, bytesLimit, payload) {\n    var canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;\n    if (canUseBeacon) {\n        try {\n            var beaconUrl = endpointBuilder.build('beacon', payload);\n            var isQueued = navigator.sendBeacon(beaconUrl, payload.data);\n            if (isQueued) {\n                return;\n            }\n        }\n        catch (e) {\n            reportBeaconError(e);\n        }\n    }\n    var xhrUrl = endpointBuilder.build('xhr', payload);\n    sendXHR(xhrUrl, payload.data);\n}\nvar hasReportedBeaconError = false;\nfunction reportBeaconError(e) {\n    if (!hasReportedBeaconError) {\n        hasReportedBeaconError = true;\n        addTelemetryError(e);\n    }\n}\nexport function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse) {\n    var canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;\n    if (canUseKeepAlive) {\n        var fetchUrl = endpointBuilder.build('fetch', payload);\n        fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' }).then(monitor(function (response) { return onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type }); }), monitor(function () {\n            var xhrUrl = endpointBuilder.build('xhr', payload);\n            // failed to queue the request\n            sendXHR(xhrUrl, payload.data, onResponse);\n        }));\n    }\n    else {\n        var xhrUrl = endpointBuilder.build('xhr', payload);\n        sendXHR(xhrUrl, payload.data, onResponse);\n    }\n}\nfunction isKeepAliveSupported() {\n    // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n    try {\n        return window.Request && 'keepalive' in new Request('http://a');\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function sendXHR(url, data, onResponse) {\n    var request = new XMLHttpRequest();\n    request.open('POST', url, true);\n    if (data instanceof Blob) {\n        // When using a Blob instance, IE does not use its 'type' to define the 'Content-Type' header\n        // automatically, so the intake request ends up being rejected with an HTTP status 415\n        // Defining the header manually fixes this issue.\n        request.setRequestHeader('Content-Type', data.type);\n    }\n    addEventListener(\n    // allow untrusted event to acount for synthetic event dispatched by third party xhr wrapper\n    { allowUntrustedEvents: true }, request, 'loadend', function () {\n        onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: request.status });\n    }, {\n        // prevent multiple onResponse callbacks\n        // if the xhr instance is reused by a third party\n        once: true,\n    });\n    request.send(data);\n}\n//# sourceMappingURL=httpRequest.js.map","import { Observable } from '../tools/observable';\nimport { clearTimeout, setTimeout } from '../tools/timer';\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController(_a) {\n    var messagesLimit = _a.messagesLimit, bytesLimit = _a.bytesLimit, durationLimit = _a.durationLimit, pageExitObservable = _a.pageExitObservable, sessionExpireObservable = _a.sessionExpireObservable;\n    var pageExitSubscription = pageExitObservable.subscribe(function (event) { return flush(event.reason); });\n    var sessionExpireSubscription = sessionExpireObservable.subscribe(function () { return flush('session_expire'); });\n    var flushObservable = new Observable(function () { return function () {\n        pageExitSubscription.unsubscribe();\n        sessionExpireSubscription.unsubscribe();\n    }; });\n    var currentBytesCount = 0;\n    var currentMessagesCount = 0;\n    function flush(flushReason) {\n        if (currentMessagesCount === 0) {\n            return;\n        }\n        var messagesCount = currentMessagesCount;\n        var bytesCount = currentBytesCount;\n        currentMessagesCount = 0;\n        currentBytesCount = 0;\n        cancelDurationLimitTimeout();\n        flushObservable.notify({\n            reason: flushReason,\n            messagesCount: messagesCount,\n            bytesCount: bytesCount,\n        });\n    }\n    var durationLimitTimeoutId;\n    function scheduleDurationLimitTimeout() {\n        if (durationLimitTimeoutId === undefined) {\n            durationLimitTimeoutId = setTimeout(function () {\n                flush('duration_limit');\n            }, durationLimit);\n        }\n    }\n    function cancelDurationLimitTimeout() {\n        clearTimeout(durationLimitTimeoutId);\n        durationLimitTimeoutId = undefined;\n    }\n    return {\n        flushObservable: flushObservable,\n        get messagesCount() {\n            return currentMessagesCount;\n        },\n        /**\n         * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right before adding the message, so no flush\n         * event can happen after `notifyBeforeAddMessage` and before adding the message.\n         *\n         * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n         * actually added.\n         */\n        notifyBeforeAddMessage: function (estimatedMessageBytesCount) {\n            if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n                flush('bytes_limit');\n            }\n            // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n            // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n            // to notify when a flush is needed (for example on page exit).\n            currentMessagesCount += 1;\n            currentBytesCount += estimatedMessageBytesCount;\n            scheduleDurationLimitTimeout();\n        },\n        /**\n         * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n         *\n         * This function can be called asynchronously after the message was added, but in this case it\n         * should not be called if a flush event occurred in between.\n         *\n         * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n         * its actual bytes count once added to the pool.\n         */\n        notifyAfterAddMessage: function (messageBytesCountDiff) {\n            if (messageBytesCountDiff === void 0) { messageBytesCountDiff = 0; }\n            currentBytesCount += messageBytesCountDiff;\n            if (currentMessagesCount >= messagesLimit) {\n                flush('messages_limit');\n            }\n            else if (currentBytesCount >= bytesLimit) {\n                flush('bytes_limit');\n            }\n        },\n        /**\n         * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right after removing the message, so no flush\n         * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n         *\n         * @param messageBytesCount: the message bytes count that was added to the pool. Should\n         * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n         * `notifyAfterAddMessage`.\n         */\n        notifyAfterRemoveMessage: function (messageBytesCount) {\n            currentBytesCount -= messageBytesCount;\n            currentMessagesCount -= 1;\n            if (currentMessagesCount === 0) {\n                cancelDurationLimitTimeout();\n            }\n        },\n    };\n}\n//# sourceMappingURL=flushController.js.map","import { createBatch } from './batch';\nimport { createHttpRequest } from './httpRequest';\nimport { createFlushController } from './flushController';\nexport function startBatchWithReplica(configuration, primary, replica, reportError, pageExitObservable, sessionExpireObservable, batchFactoryImp) {\n    if (batchFactoryImp === void 0) { batchFactoryImp = createBatch; }\n    var primaryBatch = createBatchFromConfig(configuration, primary);\n    var replicaBatch = replica && createBatchFromConfig(configuration, replica);\n    function createBatchFromConfig(configuration, _a) {\n        var endpoint = _a.endpoint, encoder = _a.encoder;\n        return batchFactoryImp({\n            encoder: encoder,\n            request: createHttpRequest(endpoint, configuration.batchBytesLimit, reportError),\n            flushController: createFlushController({\n                messagesLimit: configuration.batchMessagesLimit,\n                bytesLimit: configuration.batchBytesLimit,\n                durationLimit: configuration.flushTimeout,\n                pageExitObservable: pageExitObservable,\n                sessionExpireObservable: sessionExpireObservable,\n            }),\n            messageBytesLimit: configuration.messageBytesLimit,\n        });\n    }\n    return {\n        flushObservable: primaryBatch.flushController.flushObservable,\n        add: function (message, replicated) {\n            if (replicated === void 0) { replicated = true; }\n            primaryBatch.add(message);\n            if (replicaBatch && replicated) {\n                replicaBatch.add(replica.transformMessage ? replica.transformMessage(message) : message);\n            }\n        },\n        upsert: function (message, key) {\n            primaryBatch.upsert(message, key);\n            if (replicaBatch) {\n                replicaBatch.upsert(replica.transformMessage ? replica.transformMessage(message) : message, key);\n            }\n        },\n        stop: function () {\n            primaryBatch.stop();\n            if (replicaBatch) {\n                replicaBatch.stop();\n            }\n        },\n    };\n}\n//# sourceMappingURL=startBatchWithReplica.js.map","import { combine, isTelemetryReplicationAllowed, startBatchWithReplica, } from '@datadog/browser-core';\nexport function startRumBatch(configuration, lifeCycle, telemetryEventObservable, reportError, pageExitObservable, sessionExpireObservable, createEncoder) {\n    var replica = configuration.replica;\n    var batch = startBatchWithReplica(configuration, {\n        endpoint: configuration.rumEndpointBuilder,\n        encoder: createEncoder(2 /* DeflateEncoderStreamId.RUM */),\n    }, replica && {\n        endpoint: replica.rumEndpointBuilder,\n        transformMessage: function (message) { return combine(message, { application: { id: replica.applicationId } }); },\n        encoder: createEncoder(3 /* DeflateEncoderStreamId.RUM_REPLICA */),\n    }, reportError, pageExitObservable, sessionExpireObservable);\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (serverRumEvent) {\n        if (serverRumEvent.type === \"view\" /* RumEventType.VIEW */) {\n            batch.upsert(serverRumEvent, serverRumEvent.view.id);\n        }\n        else {\n            batch.add(serverRumEvent);\n        }\n    });\n    telemetryEventObservable.subscribe(function (event) { return batch.add(event, isTelemetryReplicationAllowed(configuration)); });\n    return batch;\n}\n//# sourceMappingURL=startRumBatch.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startRumEventBridge(lifeCycle) {\n    var bridge = getEventBridge();\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (serverRumEvent) {\n        bridge.send('rum', serverRumEvent);\n    });\n}\n//# sourceMappingURL=startRumEventBridge.js.map","import { SESSION_TIME_OUT_DELAY, relativeNow, createValueHistory } from '@datadog/browser-core';\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\nexport var URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport function startUrlContexts(lifeCycle, locationChangeObservable, location) {\n    var urlContextHistory = createValueHistory({ expireDelay: URL_CONTEXT_TIME_OUT_DELAY });\n    var previousViewUrl;\n    lifeCycle.subscribe(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, function (_a) {\n        var startClocks = _a.startClocks;\n        var viewUrl = location.href;\n        urlContextHistory.add(buildUrlContext({\n            url: viewUrl,\n            referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n        }), startClocks.relative);\n        previousViewUrl = viewUrl;\n    });\n    lifeCycle.subscribe(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, function (_a) {\n        var endClocks = _a.endClocks;\n        urlContextHistory.closeActive(endClocks.relative);\n    });\n    var locationChangeSubscription = locationChangeObservable.subscribe(function (_a) {\n        var newLocation = _a.newLocation;\n        var current = urlContextHistory.find();\n        if (current) {\n            var changeTime = relativeNow();\n            urlContextHistory.closeActive(changeTime);\n            urlContextHistory.add(buildUrlContext({\n                url: newLocation.href,\n                referrer: current.referrer,\n            }), changeTime);\n        }\n    });\n    function buildUrlContext(_a) {\n        var url = _a.url, referrer = _a.referrer;\n        return {\n            url: url,\n            referrer: referrer,\n        };\n    }\n    return {\n        findUrl: function (startTime) { return urlContextHistory.find(startTime); },\n        stop: function () {\n            locationChangeSubscription.unsubscribe();\n            urlContextHistory.stop();\n        },\n    };\n}\n//# sourceMappingURL=urlContexts.js.map","import { addEventListener, instrumentMethod, Observable, shallowClone } from '@datadog/browser-core';\nexport function createLocationChangeObservable(configuration, location) {\n    var currentLocation = shallowClone(location);\n    return new Observable(function (observable) {\n        var stopHistoryTracking = trackHistory(configuration, onLocationChange).stop;\n        var stopHashTracking = trackHash(configuration, onLocationChange).stop;\n        function onLocationChange() {\n            if (currentLocation.href === location.href) {\n                return;\n            }\n            var newLocation = shallowClone(location);\n            observable.notify({\n                newLocation: newLocation,\n                oldLocation: currentLocation,\n            });\n            currentLocation = newLocation;\n        }\n        return function () {\n            stopHistoryTracking();\n            stopHashTracking();\n        };\n    });\n}\nfunction trackHistory(configuration, onHistoryChange) {\n    var stopInstrumentingPushState = instrumentMethod(getHistoryInstrumentationTarget('pushState'), 'pushState', function (_a) {\n        var onPostCall = _a.onPostCall;\n        onPostCall(onHistoryChange);\n    }).stop;\n    var stopInstrumentingReplaceState = instrumentMethod(getHistoryInstrumentationTarget('replaceState'), 'replaceState', function (_a) {\n        var onPostCall = _a.onPostCall;\n        onPostCall(onHistoryChange);\n    }).stop;\n    var removeListener = addEventListener(configuration, window, \"popstate\" /* DOM_EVENT.POP_STATE */, onHistoryChange).stop;\n    return {\n        stop: function () {\n            stopInstrumentingPushState();\n            stopInstrumentingReplaceState();\n            removeListener();\n        },\n    };\n}\nfunction trackHash(configuration, onHashChange) {\n    return addEventListener(configuration, window, \"hashchange\" /* DOM_EVENT.HASH_CHANGE */, onHashChange);\n}\nfunction getHistoryInstrumentationTarget(methodName) {\n    // Ideally we should always instument the method on the prototype, however some frameworks (e.g [Next.js](https://github.com/vercel/next.js/blob/d3f5532065f3e3bb84fb54bd2dfd1a16d0f03a21/packages/next/src/client/components/app-router.tsx#L429))\n    // are wrapping the instance method. In that case we should also wrap the instance method.\n    return Object.prototype.hasOwnProperty.call(history, methodName) ? history : History.prototype;\n}\n//# sourceMappingURL=locationChangeObservable.js.map","import { SESSION_TIME_OUT_DELAY, createValueHistory } from '@datadog/browser-core';\nexport var FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport var BYTES_COMPUTATION_THROTTLING_DELAY = 200;\n/**\n * Start feature flag contexts\n *\n * Feature flag contexts follow the life of views.\n * A new context is added when a view is created and ended when the view is ended\n *\n * Note: we choose not to add a new context at each evaluation to save memory\n */\nexport function startFeatureFlagContexts(lifeCycle, customerDataTracker) {\n    var featureFlagContexts = createValueHistory({\n        expireDelay: FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY,\n    });\n    lifeCycle.subscribe(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, function (_a) {\n        var startClocks = _a.startClocks;\n        featureFlagContexts.add({}, startClocks.relative);\n        customerDataTracker.resetCustomerData();\n    });\n    lifeCycle.subscribe(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, function (_a) {\n        var endClocks = _a.endClocks;\n        featureFlagContexts.closeActive(endClocks.relative);\n    });\n    return {\n        findFeatureFlagEvaluations: function (startTime) { return featureFlagContexts.find(startTime); },\n        addFeatureFlagEvaluation: function (key, value) {\n            var currentContext = featureFlagContexts.find();\n            if (currentContext) {\n                currentContext[key] = value;\n                customerDataTracker.updateCustomerData(currentContext);\n            }\n        },\n        stop: function () { return customerDataTracker.stop(); },\n    };\n}\n//# sourceMappingURL=featureFlagContext.js.map","import { includes, performDraw, ONE_SECOND, addTelemetryDebug, setInterval, } from '@datadog/browser-core';\nexport var MEASURES_PERIOD_DURATION = 10 * ONE_SECOND;\nvar currentPeriodMeasures;\nvar currentBatchMeasures;\nvar batchHasRumEvent;\nexport function startCustomerDataTelemetry(configuration, telemetry, lifeCycle, customerDataTrackerManager, batchFlushObservable) {\n    var customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate);\n    if (!customerDataTelemetryEnabled) {\n        return;\n    }\n    initCurrentPeriodMeasures();\n    initCurrentBatchMeasures();\n    // We measure the data of every view updates even if there could only be one per batch due to the upsert\n    // It means that contexts bytes count sums can be higher than it really is\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (event) {\n        batchHasRumEvent = true;\n        updateMeasure(currentBatchMeasures.globalContextBytes, customerDataTrackerManager.getOrCreateTracker(2 /* CustomerDataType.GlobalContext */).getBytesCount());\n        updateMeasure(currentBatchMeasures.userContextBytes, customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */).getBytesCount());\n        updateMeasure(currentBatchMeasures.featureFlagBytes, includes([\"view\" /* RumEventType.VIEW */, \"error\" /* RumEventType.ERROR */], event.type)\n            ? customerDataTrackerManager.getOrCreateTracker(0 /* CustomerDataType.FeatureFlag */).getBytesCount()\n            : 0);\n    });\n    batchFlushObservable.subscribe(function (_a) {\n        var bytesCount = _a.bytesCount, messagesCount = _a.messagesCount;\n        // Don't measure batch that only contains telemetry events to avoid batch sending loop\n        // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n        if (!batchHasRumEvent) {\n            return;\n        }\n        currentPeriodMeasures.batchCount += 1;\n        updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount);\n        updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount);\n        mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes);\n        mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes);\n        mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes);\n        initCurrentBatchMeasures();\n    });\n    setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION);\n}\nfunction sendCurrentPeriodMeasures() {\n    if (currentPeriodMeasures.batchCount === 0) {\n        return;\n    }\n    addTelemetryDebug('Customer data measures', currentPeriodMeasures);\n    initCurrentPeriodMeasures();\n}\nfunction createMeasure() {\n    return { min: Infinity, max: 0, sum: 0 };\n}\nfunction updateMeasure(measure, value) {\n    measure.sum += value;\n    measure.min = Math.min(measure.min, value);\n    measure.max = Math.max(measure.max, value);\n}\nfunction mergeMeasure(target, source) {\n    target.sum += source.sum;\n    target.min = Math.min(target.min, source.min);\n    target.max = Math.max(target.max, source.max);\n}\nfunction initCurrentPeriodMeasures() {\n    currentPeriodMeasures = {\n        batchCount: 0,\n        batchBytesCount: createMeasure(),\n        batchMessagesCount: createMeasure(),\n        globalContextBytes: createMeasure(),\n        userContextBytes: createMeasure(),\n        featureFlagBytes: createMeasure(),\n    };\n}\nfunction initCurrentBatchMeasures() {\n    batchHasRumEvent = false;\n    currentBatchMeasures = {\n        globalContextBytes: createMeasure(),\n        userContextBytes: createMeasure(),\n        featureFlagBytes: createMeasure(),\n    };\n}\n//# sourceMappingURL=startCustomerDataTelemetry.js.map","import { elapsed, createValueHistory, SESSION_TIME_OUT_DELAY, toServerDuration, addEventListeners, relativeNow, } from '@datadog/browser-core';\n// Arbitrary value to cap number of element for memory consumption in the browser\nexport var MAX_PAGE_STATE_ENTRIES = 4000;\n// Arbitrary value to cap number of element for backend & to save bandwidth\nexport var MAX_PAGE_STATE_ENTRIES_SELECTABLE = 500;\nexport var PAGE_STATE_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport function startPageStateHistory(configuration, maxPageStateEntriesSelectable) {\n    if (maxPageStateEntriesSelectable === void 0) { maxPageStateEntriesSelectable = MAX_PAGE_STATE_ENTRIES_SELECTABLE; }\n    var pageStateEntryHistory = createValueHistory({\n        expireDelay: PAGE_STATE_CONTEXT_TIME_OUT_DELAY,\n        maxEntries: MAX_PAGE_STATE_ENTRIES,\n    });\n    var currentPageState;\n    addPageState(getPageState(), relativeNow());\n    var stopEventListeners = addEventListeners(configuration, window, [\n        \"pageshow\" /* DOM_EVENT.PAGE_SHOW */,\n        \"focus\" /* DOM_EVENT.FOCUS */,\n        \"blur\" /* DOM_EVENT.BLUR */,\n        \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */,\n        \"resume\" /* DOM_EVENT.RESUME */,\n        \"freeze\" /* DOM_EVENT.FREEZE */,\n        \"pagehide\" /* DOM_EVENT.PAGE_HIDE */,\n    ], function (event) {\n        addPageState(computePageState(event), event.timeStamp);\n    }, { capture: true }).stop;\n    function addPageState(nextPageState, startTime) {\n        if (startTime === void 0) { startTime = relativeNow(); }\n        if (nextPageState === currentPageState) {\n            return;\n        }\n        currentPageState = nextPageState;\n        pageStateEntryHistory.closeActive(startTime);\n        pageStateEntryHistory.add({ state: currentPageState, startTime: startTime }, startTime);\n    }\n    var pageStateHistory = {\n        findAll: function (eventStartTime, duration) {\n            var pageStateEntries = pageStateEntryHistory.findAll(eventStartTime, duration);\n            if (pageStateEntries.length === 0) {\n                return;\n            }\n            var pageStateServerEntries = [];\n            // limit the number of entries to return\n            var limit = Math.max(0, pageStateEntries.length - maxPageStateEntriesSelectable);\n            // loop page state entries backward to return the selected ones in desc order\n            for (var index = pageStateEntries.length - 1; index >= limit; index--) {\n                var pageState = pageStateEntries[index];\n                // compute the start time relative to the event start time (ex: to be relative to the view start time)\n                var relativeStartTime = elapsed(eventStartTime, pageState.startTime);\n                pageStateServerEntries.push({\n                    state: pageState.state,\n                    start: toServerDuration(relativeStartTime),\n                });\n            }\n            return pageStateServerEntries;\n        },\n        wasInPageStateAt: function (state, startTime) {\n            return pageStateHistory.wasInPageStateDuringPeriod(state, startTime, 0);\n        },\n        wasInPageStateDuringPeriod: function (state, startTime, duration) {\n            return pageStateEntryHistory.findAll(startTime, duration).some(function (pageState) { return pageState.state === state; });\n        },\n        addPageState: addPageState,\n        stop: function () {\n            stopEventListeners();\n            pageStateEntryHistory.stop();\n        },\n    };\n    return pageStateHistory;\n}\nfunction computePageState(event) {\n    if (event.type === \"freeze\" /* DOM_EVENT.FREEZE */) {\n        return \"frozen\" /* PageState.FROZEN */;\n    }\n    else if (event.type === \"pagehide\" /* DOM_EVENT.PAGE_HIDE */) {\n        return event.persisted ? \"frozen\" /* PageState.FROZEN */ : \"terminated\" /* PageState.TERMINATED */;\n    }\n    return getPageState();\n}\nfunction getPageState() {\n    if (document.visibilityState === 'hidden') {\n        return \"hidden\" /* PageState.HIDDEN */;\n    }\n    if (document.hasFocus()) {\n        return \"active\" /* PageState.ACTIVE */;\n    }\n    return \"passive\" /* PageState.PASSIVE */;\n}\n//# sourceMappingURL=pageStateHistory.js.map","import { ExperimentalFeature, isExperimentalFeatureEnabled } from '@datadog/browser-core';\nimport { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable';\nexport function startDisplayContext(configuration) {\n    var viewport;\n    var animationFrameId;\n    if (isExperimentalFeatureEnabled(ExperimentalFeature.DELAY_VIEWPORT_COLLECTION)) {\n        // Use requestAnimationFrame to delay the calculation of viewport dimensions until after SDK initialization, preventing long tasks.\n        animationFrameId = requestAnimationFrame(function () {\n            viewport = getViewportDimension();\n        });\n    }\n    else {\n        viewport = getViewportDimension();\n    }\n    var unsubscribeViewport = initViewportObservable(configuration).subscribe(function (viewportDimension) {\n        viewport = viewportDimension;\n    }).unsubscribe;\n    return {\n        get: function () { return (viewport ? { viewport: viewport } : undefined); },\n        stop: function () {\n            unsubscribeViewport();\n            if (animationFrameId) {\n                cancelAnimationFrame(animationFrameId);\n            }\n        },\n    };\n}\n//# sourceMappingURL=displayContext.js.map","import { setInterval, clearInterval, Observable, addEventListener, ONE_SECOND, findCommaSeparatedValue, find, } from '@datadog/browser-core';\nexport function createCookieObservable(configuration, cookieName) {\n    var detectCookieChangeStrategy = window.cookieStore\n        ? listenToCookieStoreChange(configuration)\n        : watchCookieFallback;\n    return new Observable(function (observable) {\n        return detectCookieChangeStrategy(cookieName, function (event) { return observable.notify(event); });\n    });\n}\nfunction listenToCookieStoreChange(configuration) {\n    return function (cookieName, callback) {\n        var listener = addEventListener(configuration, window.cookieStore, \"change\" /* DOM_EVENT.CHANGE */, function (event) {\n            // Based on our experimentation, we're assuming that entries for the same cookie cannot be in both the 'changed' and 'deleted' arrays.\n            // However, due to ambiguity in the specification, we asked for clarification: https://github.com/WICG/cookie-store/issues/226\n            var changeEvent = find(event.changed, function (event) { return event.name === cookieName; }) ||\n                find(event.deleted, function (event) { return event.name === cookieName; });\n            if (changeEvent) {\n                callback(changeEvent.value);\n            }\n        });\n        return listener.stop;\n    };\n}\nexport var WATCH_COOKIE_INTERVAL_DELAY = ONE_SECOND;\nfunction watchCookieFallback(cookieName, callback) {\n    var previousCookieValue = findCommaSeparatedValue(document.cookie, cookieName);\n    var watchCookieIntervalId = setInterval(function () {\n        var cookieValue = findCommaSeparatedValue(document.cookie, cookieName);\n        if (cookieValue !== previousCookieValue) {\n            callback(cookieValue);\n        }\n    }, WATCH_COOKIE_INTERVAL_DELAY);\n    return function () {\n        clearInterval(watchCookieIntervalId);\n    };\n}\n//# sourceMappingURL=cookieObservable.js.map","import { getInitCookie } from '@datadog/browser-core';\nimport { createCookieObservable } from '../../browser/cookieObservable';\nexport var CI_VISIBILITY_TEST_ID_COOKIE_NAME = 'datadog-ci-visibility-test-execution-id';\nexport function startCiVisibilityContext(configuration, cookieObservable) {\n    var _a;\n    if (cookieObservable === void 0) { cookieObservable = createCookieObservable(configuration, CI_VISIBILITY_TEST_ID_COOKIE_NAME); }\n    var testExecutionId = getInitCookie(CI_VISIBILITY_TEST_ID_COOKIE_NAME) || ((_a = window.Cypress) === null || _a === void 0 ? void 0 : _a.env('traceId'));\n    var cookieObservableSubscription = cookieObservable.subscribe(function (value) {\n        testExecutionId = value;\n    });\n    return {\n        get: function () {\n            if (typeof testExecutionId === 'string') {\n                return {\n                    test_execution_id: testExecutionId,\n                };\n            }\n        },\n        stop: function () { return cookieObservableSubscription.unsubscribe(); },\n    };\n}\n//# sourceMappingURL=ciVisibilityContext.js.map","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../browser/performanceObservable';\nexport function startLongAnimationFrameCollection(lifeCycle, configuration) {\n    var performanceResourceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LONG_ANIMATION_FRAME,\n        buffered: true,\n    }).subscribe(function (entries) {\n        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n            var entry = entries_1[_i];\n            var startClocks = relativeToClocks(entry.startTime);\n            var rawRumEvent = {\n                date: startClocks.timeStamp,\n                long_task: {\n                    id: generateUUID(),\n                    entry_type: \"long-animation-frame\" /* RumLongTaskEntryType.LONG_ANIMATION_FRAME */,\n                    duration: toServerDuration(entry.duration),\n                    blocking_duration: toServerDuration(entry.blockingDuration),\n                    first_ui_event_timestamp: toServerDuration(entry.firstUIEventTimestamp),\n                    render_start: toServerDuration(entry.renderStart),\n                    style_and_layout_start: toServerDuration(entry.styleAndLayoutStart),\n                    start_time: toServerDuration(entry.startTime),\n                    scripts: entry.scripts.map(function (script) { return ({\n                        duration: toServerDuration(script.duration),\n                        pause_duration: toServerDuration(script.pauseDuration),\n                        forced_style_and_layout_duration: toServerDuration(script.forcedStyleAndLayoutDuration),\n                        start_time: toServerDuration(script.startTime),\n                        execution_start: toServerDuration(script.executionStart),\n                        source_url: script.sourceURL,\n                        source_function_name: script.sourceFunctionName,\n                        source_char_position: script.sourceCharPosition,\n                        invoker: script.invoker,\n                        invoker_type: script.invokerType,\n                        window_attribution: script.windowAttribution,\n                    }); }),\n                },\n                type: \"long_task\" /* RumEventType.LONG_TASK */,\n                _dd: {\n                    discarded: false,\n                },\n            };\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {\n                rawRumEvent: rawRumEvent,\n                startTime: startClocks.relative,\n                domainContext: { performanceEntry: entry },\n            });\n        }\n    });\n    return {\n        stop: function () { return performanceResourceSubscription.unsubscribe(); },\n    };\n}\n//# sourceMappingURL=longAnimationFrameCollection.js.map","import { sendToExtension, createPageExitObservable, startTelemetry, canUseEventBridge, getEventBridge, addTelemetryDebug, drainPreStartTelemetry, isExperimentalFeatureEnabled, ExperimentalFeature, } from '@datadog/browser-core';\nimport { createDOMMutationObservable } from '../browser/domMutationObservable';\nimport { createWindowOpenObservable } from '../browser/windowOpenObservable';\nimport { startRumAssembly } from '../domain/assembly';\nimport { startInternalContext } from '../domain/contexts/internalContext';\nimport { LifeCycle } from '../domain/lifeCycle';\nimport { startViewHistory } from '../domain/contexts/viewHistory';\nimport { startRequestCollection } from '../domain/requestCollection';\nimport { startActionCollection } from '../domain/action/actionCollection';\nimport { startErrorCollection } from '../domain/error/errorCollection';\nimport { startLongTaskCollection } from '../domain/longTask/longTaskCollection';\nimport { startResourceCollection } from '../domain/resource/resourceCollection';\nimport { startViewCollection } from '../domain/view/viewCollection';\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager';\nimport { startRumBatch } from '../transport/startRumBatch';\nimport { startRumEventBridge } from '../transport/startRumEventBridge';\nimport { startUrlContexts } from '../domain/contexts/urlContexts';\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable';\nimport { startFeatureFlagContexts } from '../domain/contexts/featureFlagContext';\nimport { startCustomerDataTelemetry } from '../domain/startCustomerDataTelemetry';\nimport { startPageStateHistory } from '../domain/contexts/pageStateHistory';\nimport { startDisplayContext } from '../domain/contexts/displayContext';\nimport { startVitalCollection } from '../domain/vital/vitalCollection';\nimport { startCiVisibilityContext } from '../domain/contexts/ciVisibilityContext';\nimport { startLongAnimationFrameCollection } from '../domain/longAnimationFrame/longAnimationFrameCollection';\nexport function startRum(configuration, recorderApi, customerDataTrackerManager, getCommonContext, initialViewOptions, createEncoder, \n// `startRum` and its subcomponents assume tracking consent is granted initially and starts\n// collecting logs unconditionally. As such, `startRum` should be called with a\n// `trackingConsentState` set to \"granted\".\ntrackingConsentState, customVitalsState) {\n    var cleanupTasks = [];\n    var lifeCycle = new LifeCycle();\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (event) { return sendToExtension('rum', event); });\n    var telemetry = startRumTelemetry(configuration);\n    telemetry.setContextProvider(function () {\n        var _a, _b;\n        return ({\n            application: {\n                id: configuration.applicationId,\n            },\n            session: {\n                id: (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id,\n            },\n            view: {\n                id: (_b = viewHistory.findView()) === null || _b === void 0 ? void 0 : _b.id,\n            },\n            action: {\n                id: actionContexts.findActionId(),\n            },\n        });\n    });\n    var reportError = function (error) {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error: error });\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    var featureFlagContexts = startFeatureFlagContexts(lifeCycle, customerDataTrackerManager.getOrCreateTracker(0 /* CustomerDataType.FeatureFlag */));\n    var pageExitObservable = createPageExitObservable(configuration);\n    var pageExitSubscription = pageExitObservable.subscribe(function (event) {\n        lifeCycle.notify(11 /* LifeCycleEventType.PAGE_EXITED */, event);\n    });\n    cleanupTasks.push(function () { return pageExitSubscription.unsubscribe(); });\n    var session = !canUseEventBridge()\n        ? startRumSessionManager(configuration, lifeCycle, trackingConsentState)\n        : startRumSessionManagerStub();\n    if (!canUseEventBridge()) {\n        var batch_1 = startRumBatch(configuration, lifeCycle, telemetry.observable, reportError, pageExitObservable, session.expireObservable, createEncoder);\n        cleanupTasks.push(function () { return batch_1.stop(); });\n        startCustomerDataTelemetry(configuration, telemetry, lifeCycle, customerDataTrackerManager, batch_1.flushObservable);\n    }\n    else {\n        startRumEventBridge(lifeCycle);\n    }\n    var domMutationObservable = createDOMMutationObservable();\n    var locationChangeObservable = createLocationChangeObservable(configuration, location);\n    var pageStateHistory = startPageStateHistory(configuration);\n    var _a = createWindowOpenObservable(), windowOpenObservable = _a.observable, stopWindowOpen = _a.stop;\n    cleanupTasks.push(stopWindowOpen);\n    var _b = startRumEventCollection(lifeCycle, configuration, location, session, pageStateHistory, locationChangeObservable, domMutationObservable, windowOpenObservable, getCommonContext, reportError), viewHistory = _b.viewHistory, urlContexts = _b.urlContexts, actionContexts = _b.actionContexts, addAction = _b.addAction, stopRumEventCollection = _b.stop;\n    cleanupTasks.push(stopRumEventCollection);\n    drainPreStartTelemetry();\n    var _c = startViewCollection(lifeCycle, configuration, location, domMutationObservable, windowOpenObservable, locationChangeObservable, featureFlagContexts, pageStateHistory, recorderApi, initialViewOptions), addTiming = _c.addTiming, startView = _c.startView, setViewName = _c.setViewName, setViewContext = _c.setViewContext, setViewContextProperty = _c.setViewContextProperty, stopViewCollection = _c.stop;\n    cleanupTasks.push(stopViewCollection);\n    var stopResourceCollection = startResourceCollection(lifeCycle, configuration, pageStateHistory).stop;\n    cleanupTasks.push(stopResourceCollection);\n    if (isExperimentalFeatureEnabled(ExperimentalFeature.LONG_ANIMATION_FRAME)) {\n        if (configuration.trackLongTasks) {\n            var stopLongAnimationFrameCollection = startLongAnimationFrameCollection(lifeCycle, configuration).stop;\n            cleanupTasks.push(stopLongAnimationFrameCollection);\n        }\n    }\n    else {\n        startLongTaskCollection(lifeCycle, configuration);\n    }\n    var addError = startErrorCollection(lifeCycle, configuration, pageStateHistory, featureFlagContexts).addError;\n    startRequestCollection(lifeCycle, configuration, session);\n    var vitalCollection = startVitalCollection(lifeCycle, pageStateHistory, customVitalsState);\n    var internalContext = startInternalContext(configuration.applicationId, session, viewHistory, actionContexts, urlContexts);\n    return {\n        addAction: addAction,\n        addError: addError,\n        addTiming: addTiming,\n        addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,\n        startView: startView,\n        setViewContext: setViewContext,\n        setViewContextProperty: setViewContextProperty,\n        setViewName: setViewName,\n        lifeCycle: lifeCycle,\n        viewHistory: viewHistory,\n        session: session,\n        stopSession: function () { return session.expire(); },\n        getInternalContext: internalContext.get,\n        startDurationVital: vitalCollection.startDurationVital,\n        stopDurationVital: vitalCollection.stopDurationVital,\n        addDurationVital: vitalCollection.addDurationVital,\n        stop: function () {\n            cleanupTasks.forEach(function (task) { return task(); });\n        },\n    };\n}\nfunction startRumTelemetry(configuration) {\n    var telemetry = startTelemetry(\"browser-rum-sdk\" /* TelemetryService.RUM */, configuration);\n    if (canUseEventBridge()) {\n        var bridge_1 = getEventBridge();\n        telemetry.observable.subscribe(function (event) { return bridge_1.send('internal_telemetry', event); });\n    }\n    return telemetry;\n}\nexport function startRumEventCollection(lifeCycle, configuration, location, sessionManager, pageStateHistory, locationChangeObservable, domMutationObservable, windowOpenObservable, getCommonContext, reportError) {\n    var viewHistory = startViewHistory(lifeCycle);\n    var urlContexts = startUrlContexts(lifeCycle, locationChangeObservable, location);\n    var actionCollection = startActionCollection(lifeCycle, domMutationObservable, windowOpenObservable, configuration, pageStateHistory);\n    var displayContext = startDisplayContext(configuration);\n    var ciVisibilityContext = startCiVisibilityContext(configuration);\n    startRumAssembly(configuration, lifeCycle, sessionManager, viewHistory, urlContexts, actionCollection.actionContexts, displayContext, ciVisibilityContext, getCommonContext, reportError);\n    return {\n        viewHistory: viewHistory,\n        pageStateHistory: pageStateHistory,\n        urlContexts: urlContexts,\n        addAction: actionCollection.addAction,\n        actionContexts: actionCollection.actionContexts,\n        stop: function () {\n            actionCollection.stop();\n            ciVisibilityContext.stop();\n            displayContext.stop();\n            urlContexts.stop();\n            viewHistory.stop();\n            pageStateHistory.stop();\n        },\n    };\n}\n//# sourceMappingURL=startRum.js.map","import { INTAKE_SITE_STAGING, INTAKE_SITE_US1, INTAKE_SITE_EU1 } from '@datadog/browser-core';\nexport function getSessionReplayUrl(configuration, _a) {\n    var session = _a.session, viewContext = _a.viewContext, errorType = _a.errorType;\n    var sessionId = session ? session.id : 'no-session-id';\n    var parameters = [];\n    if (errorType !== undefined) {\n        parameters.push(\"error-type=\".concat(errorType));\n    }\n    if (viewContext) {\n        parameters.push(\"seed=\".concat(viewContext.id));\n        parameters.push(\"from=\".concat(viewContext.startClocks.timeStamp));\n    }\n    var origin = getDatadogSiteUrl(configuration);\n    var path = \"/rum/replay/sessions/\".concat(sessionId);\n    return \"\".concat(origin).concat(path, \"?\").concat(parameters.join('&'));\n}\nexport function getDatadogSiteUrl(rumConfiguration) {\n    var site = rumConfiguration.site;\n    var subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration);\n    return \"https://\".concat(subdomain ? \"\".concat(subdomain, \".\") : '').concat(site);\n}\nfunction getSiteDefaultSubdomain(configuration) {\n    switch (configuration.site) {\n        case INTAKE_SITE_US1:\n        case INTAKE_SITE_EU1:\n            return 'app';\n        case INTAKE_SITE_STAGING:\n            return 'dd';\n        default:\n            return undefined;\n    }\n}\n//# sourceMappingURL=getSessionReplayUrl.js.map","export { makeRumPublicApi } from './boot/rumPublicApi';\nexport { startRum } from './boot/startRum';\nexport { LifeCycle } from './domain/lifeCycle';\nexport { startViewHistory } from './domain/contexts/viewHistory';\nexport { getMutationObserverConstructor } from './browser/domMutationObservable';\nexport { initViewportObservable, getViewportDimension } from './browser/viewportObservable';\nexport { getScrollX, getScrollY } from './browser/scroll';\nexport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './domain/action/getActionNameFromElement';\nexport { STABLE_ATTRIBUTES } from './domain/getSelectorFromElement';\nexport * from './browser/htmlDomUtils';\nexport * from './browser/polyfills';\nexport { getSessionReplayUrl } from './domain/getSessionReplayUrl';\nexport { isLongDataUrl, sanitizeDataUrl, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH } from './domain/resource/resourceUtils';\nexport * from './domain/privacy';\n//# sourceMappingURL=index.js.map","export var MAX_STATS_HISTORY = 10;\nvar statsPerView;\nexport function getSegmentsCount(viewId) {\n    return getOrCreateReplayStats(viewId).segments_count;\n}\nexport function addSegment(viewId) {\n    getOrCreateReplayStats(viewId).segments_count += 1;\n}\nexport function addRecord(viewId) {\n    getOrCreateReplayStats(viewId).records_count += 1;\n}\nexport function addWroteData(viewId, additionalBytesCount) {\n    getOrCreateReplayStats(viewId).segments_total_raw_size += additionalBytesCount;\n}\nexport function getReplayStats(viewId) {\n    return statsPerView === null || statsPerView === void 0 ? void 0 : statsPerView.get(viewId);\n}\nexport function resetReplayStats() {\n    statsPerView = undefined;\n}\nfunction getOrCreateReplayStats(viewId) {\n    if (!statsPerView) {\n        statsPerView = new Map();\n    }\n    var replayStats;\n    if (statsPerView.has(viewId)) {\n        replayStats = statsPerView.get(viewId);\n    }\n    else {\n        replayStats = {\n            records_count: 0,\n            segments_count: 0,\n            segments_total_raw_size: 0,\n        };\n        statsPerView.set(viewId, replayStats);\n        if (statsPerView.size > MAX_STATS_HISTORY) {\n            deleteOldestStats();\n        }\n    }\n    return replayStats;\n}\nfunction deleteOldestStats() {\n    if (!statsPerView) {\n        return;\n    }\n    if (statsPerView.keys) {\n        var toDelete = statsPerView.keys().next().value;\n        if (toDelete) {\n            statsPerView.delete(toDelete);\n        }\n    }\n    else {\n        // IE11 doesn't support map.keys\n        var isFirst_1 = true;\n        statsPerView.forEach(function (_value, key) {\n            if (isFirst_1) {\n                statsPerView.delete(key);\n                isFirst_1 = false;\n            }\n        });\n    }\n}\n//# sourceMappingURL=replayStats.js.map","import { buildUrl } from '@datadog/browser-core';\nimport { getParentNode, isNodeShadowRoot, CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core';\nvar serializedNodeIds = new WeakMap();\nexport function hasSerializedNode(node) {\n    return serializedNodeIds.has(node);\n}\nexport function nodeAndAncestorsHaveSerializedNode(node) {\n    var current = node;\n    while (current) {\n        if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n            return false;\n        }\n        current = getParentNode(current);\n    }\n    return true;\n}\nexport function getSerializedNodeId(node) {\n    return serializedNodeIds.get(node);\n}\nexport function setSerializedNodeId(node, serializeNodeId) {\n    serializedNodeIds.set(node, serializeNodeId);\n}\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element, nodePrivacyLevel) {\n    /*\n     BROWSER SPEC NOTE: <input>, <select>\n     For some <input> elements, the `value` is an exceptional property/attribute that has the\n     value synced between el.value and el.getAttribute()\n     input[type=button,checkbox,hidden,image,radio,reset,submit]\n     */\n    var tagName = element.tagName;\n    var value = element.value;\n    if (shouldMaskNode(element, nodePrivacyLevel)) {\n        var type = element.type;\n        if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n            // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n            // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n            return value;\n        }\n        else if (!value || tagName === 'OPTION') {\n            // <Option> value provides no benefit\n            return;\n        }\n        return CENSORED_STRING_MARK;\n    }\n    if (tagName === 'OPTION' || tagName === 'SELECT') {\n        return element.value;\n    }\n    if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n        return;\n    }\n    return value;\n}\nexport var URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nexport var ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//;\nexport var DATA_URI = /^data:.*,/i;\nexport function switchToAbsoluteUrl(cssText, cssHref) {\n    return cssText.replace(URL_IN_CSS_REF, function (matchingSubstring, singleQuote, urlWrappedInSingleQuotes, doubleQuote, urlWrappedInDoubleQuotes, urlNotWrappedInQuotes) {\n        var url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes;\n        if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n            return matchingSubstring;\n        }\n        var quote = singleQuote || doubleQuote || '';\n        return \"url(\".concat(quote).concat(makeUrlAbsolute(url, cssHref)).concat(quote, \")\");\n    });\n}\nexport function makeUrlAbsolute(url, baseUrl) {\n    try {\n        return buildUrl(url, baseUrl).href;\n    }\n    catch (_a) {\n        return url;\n    }\n}\nvar TAG_NAME_REGEX = /[^a-z1-6-_]/;\nexport function getValidTagName(tagName) {\n    var processedTagName = tagName.toLowerCase().trim();\n    if (TAG_NAME_REGEX.test(processedTagName)) {\n        // if the tag name is odd and we cannot extract\n        // anything from the string, then we return a\n        // generic div\n        return 'div';\n    }\n    return processedTagName;\n}\nexport function censoredImageForSize(width, height) {\n    return \"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='\".concat(width, \"' height='\").concat(height, \"' style='background-color:silver'%3E%3C/svg%3E\");\n}\n//# sourceMappingURL=serializationUtils.js.map","export var RecordType = {\n    FullSnapshot: 2,\n    IncrementalSnapshot: 3,\n    Meta: 4,\n    Focus: 6,\n    ViewEnd: 7,\n    VisualViewport: 8,\n    FrustrationRecord: 9,\n};\nexport var NodeType = {\n    Document: 0,\n    DocumentType: 1,\n    Element: 2,\n    Text: 3,\n    CDATA: 4,\n    DocumentFragment: 11,\n};\nexport var IncrementalSource = {\n    Mutation: 0,\n    MouseMove: 1,\n    MouseInteraction: 2,\n    Scroll: 3,\n    ViewportResize: 4,\n    Input: 5,\n    TouchMove: 6,\n    MediaInteraction: 7,\n    StyleSheetRule: 8,\n    // CanvasMutation : 9,\n    // Font : 10,\n};\nexport var MouseInteractionType = {\n    MouseUp: 0,\n    MouseDown: 1,\n    Click: 2,\n    ContextMenu: 3,\n    DblClick: 4,\n    Focus: 5,\n    Blur: 6,\n    TouchStart: 7,\n    TouchEnd: 9,\n};\nexport var MediaInteractionType = {\n    Play: 0,\n    Pause: 1,\n};\n//# sourceMappingURL=sessionReplayConstants.js.map","export * from './sessionReplay';\nexport * from './sessionReplayConstants';\n//# sourceMappingURL=index.js.map","export function serializeStyleSheets(cssStyleSheets) {\n    if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n        return undefined;\n    }\n    return cssStyleSheets.map(function (cssStyleSheet) {\n        var rules = cssStyleSheet.cssRules || cssStyleSheet.rules;\n        var cssRules = Array.from(rules, function (cssRule) { return cssRule.cssText; });\n        var styleSheet = {\n            cssRules: cssRules,\n            disabled: cssStyleSheet.disabled || undefined,\n            media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n        };\n        return styleSheet;\n    });\n}\n//# sourceMappingURL=serializeStyleSheets.js.map","import { startsWith } from '@datadog/browser-core';\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, CENSORED_STRING_MARK, CENSORED_IMG_MARK, STABLE_ATTRIBUTES, isLongDataUrl, sanitizeDataUrl, } from '@datadog/browser-rum-core';\nimport { censoredImageForSize } from './serializationUtils';\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // dup condition for direct access case\n        return null;\n    }\n    var attributeValue = element.getAttribute(attributeName);\n    if (nodePrivacyLevel === NodePrivacyLevel.MASK &&\n        attributeName !== PRIVACY_ATTR_NAME &&\n        !STABLE_ATTRIBUTES.includes(attributeName) &&\n        attributeName !== configuration.actionNameAttribute) {\n        var tagName = element.tagName;\n        switch (attributeName) {\n            // Mask Attribute text content\n            case 'title':\n            case 'alt':\n            case 'placeholder':\n                return CENSORED_STRING_MARK;\n        }\n        // mask image URLs\n        if (tagName === 'IMG' && (attributeName === 'src' || attributeName === 'srcset')) {\n            // generate image with similar dimension than the original to have the same rendering behaviour\n            var image = element;\n            if (image.naturalWidth > 0) {\n                return censoredImageForSize(image.naturalWidth, image.naturalHeight);\n            }\n            var _a = element.getBoundingClientRect(), width = _a.width, height = _a.height;\n            if (width > 0 || height > 0) {\n                return censoredImageForSize(width, height);\n            }\n            // if we can't get the image size, fallback to the censored image\n            return CENSORED_IMG_MARK;\n        }\n        // mask source URLs\n        if (tagName === 'SOURCE' && (attributeName === 'src' || attributeName === 'srcset')) {\n            return CENSORED_IMG_MARK;\n        }\n        // mask <a> URLs\n        if (tagName === 'A' && attributeName === 'href') {\n            return CENSORED_STRING_MARK;\n        }\n        // mask data-* attributes\n        if (attributeValue && startsWith(attributeName, 'data-')) {\n            // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n            return CENSORED_STRING_MARK;\n        }\n        // mask iframe srcdoc\n        if (tagName === 'IFRAME' && attributeName === 'srcdoc') {\n            return CENSORED_STRING_MARK;\n        }\n    }\n    if (!attributeValue || typeof attributeValue !== 'string') {\n        return attributeValue;\n    }\n    // Minimum Fix for customer.\n    if (isLongDataUrl(attributeValue)) {\n        return sanitizeDataUrl(attributeValue);\n    }\n    return attributeValue;\n}\n//# sourceMappingURL=serializeAttribute.js.map","import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { isSafari } from '@datadog/browser-core';\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils';\nimport { serializeAttribute } from './serializeAttribute';\nexport function serializeAttributes(element, nodePrivacyLevel, options) {\n    var _a;\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return {};\n    }\n    var safeAttrs = {};\n    var tagName = getValidTagName(element.tagName);\n    var doc = element.ownerDocument;\n    for (var i = 0; i < element.attributes.length; i += 1) {\n        var attribute = element.attributes.item(i);\n        var attributeName = attribute.name;\n        var attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);\n        if (attributeValue !== null) {\n            safeAttrs[attributeName] = attributeValue;\n        }\n    }\n    if (element.value &&\n        (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n        var formValue = getElementInputValue(element, nodePrivacyLevel);\n        if (formValue !== undefined) {\n            safeAttrs.value = formValue;\n        }\n    }\n    /**\n     * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n     */\n    if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n        // For privacy=`MASK`, all the values would be the same, so skip.\n        var optionElement = element;\n        if (optionElement.selected) {\n            safeAttrs.selected = optionElement.selected;\n        }\n    }\n    // remote css\n    if (tagName === 'link') {\n        var stylesheet = Array.from(doc.styleSheets).find(function (s) { return s.href === element.href; });\n        var cssText = getCssRulesString(stylesheet);\n        if (cssText && stylesheet) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    // dynamic stylesheet\n    if (tagName === 'style' && element.sheet) {\n        var cssText = getCssRulesString(element.sheet);\n        if (cssText) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    /**\n     * Forms: input[type=checkbox,radio]\n     * The `checked` property for <input> is a little bit special:\n     * 1. el.checked is a setter that returns if truthy.\n     * 2. getAttribute returns the string value\n     * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n     * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n     */\n    var inputElement = element;\n    if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n        if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n            safeAttrs.checked = !!inputElement.checked;\n        }\n        else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n            delete safeAttrs.checked;\n        }\n    }\n    /**\n     * Serialize the media playback state\n     */\n    if (tagName === 'audio' || tagName === 'video') {\n        var mediaElement = element;\n        safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n    }\n    /**\n     * Serialize the scroll state for each element only for full snapshot\n     */\n    var scrollTop;\n    var scrollLeft;\n    var serializationContext = options.serializationContext;\n    switch (serializationContext.status) {\n        case 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */:\n            scrollTop = Math.round(element.scrollTop);\n            scrollLeft = Math.round(element.scrollLeft);\n            if (scrollTop || scrollLeft) {\n                serializationContext.elementsScrollPositions.set(element, { scrollTop: scrollTop, scrollLeft: scrollLeft });\n            }\n            break;\n        case 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */:\n            if (serializationContext.elementsScrollPositions.has(element)) {\n                ;\n                (_a = serializationContext.elementsScrollPositions.get(element), scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft);\n            }\n            break;\n    }\n    if (scrollLeft) {\n        safeAttrs.rr_scrollLeft = scrollLeft;\n    }\n    if (scrollTop) {\n        safeAttrs.rr_scrollTop = scrollTop;\n    }\n    return safeAttrs;\n}\nexport function getCssRulesString(cssStyleSheet) {\n    if (!cssStyleSheet) {\n        return null;\n    }\n    var rules;\n    try {\n        rules = cssStyleSheet.rules || cssStyleSheet.cssRules;\n    }\n    catch (_a) {\n        // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n    }\n    if (!rules) {\n        return null;\n    }\n    var styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('');\n    return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href);\n}\nfunction getCssRuleStringForSafari(rule) {\n    // Safari does not escape attribute selectors containing : properly\n    // https://bugs.webkit.org/show_bug.cgi?id=184604\n    if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n        // This regex replaces [foo:bar] by [foo\\\\:bar]\n        var escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g;\n        return rule.cssText.replace(escapeColon, '$1\\\\$2');\n    }\n    return getCssRuleString(rule);\n}\nfunction getCssRuleString(rule) {\n    // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n    // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n    // to the @import rule CSS text.\n    return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction isCSSStyleRule(rule) {\n    return 'selectorText' in rule;\n}\n//# sourceMappingURL=serializeAttributes.js.map","import { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent, isNodeShadowRoot, hasChildNodes, forEachChildNodes, NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, } from '@datadog/browser-rum-core';\nimport { assign } from '@datadog/browser-core';\nimport { NodeType } from '../../../types';\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils';\nimport { serializeStyleSheets } from './serializeStyleSheets';\nimport { serializeAttributes } from './serializeAttributes';\nexport function serializeNodeWithId(node, options) {\n    var serializedNode = serializeNode(node, options);\n    if (!serializedNode) {\n        return null;\n    }\n    // Try to reuse the previous id\n    var id = getSerializedNodeId(node) || generateNextId();\n    var serializedNodeWithId = serializedNode;\n    serializedNodeWithId.id = id;\n    setSerializedNodeId(node, id);\n    if (options.serializedNodeIds) {\n        options.serializedNodeIds.add(id);\n    }\n    return serializedNodeWithId;\n}\nvar _nextId = 1;\nexport function generateNextId() {\n    return _nextId++;\n}\nexport function serializeChildNodes(node, options) {\n    var result = [];\n    forEachChildNodes(node, function (childNode) {\n        var serializedChildNode = serializeNodeWithId(childNode, options);\n        if (serializedChildNode) {\n            result.push(serializedChildNode);\n        }\n    });\n    return result;\n}\nfunction serializeNode(node, options) {\n    switch (node.nodeType) {\n        case node.DOCUMENT_NODE:\n            return serializeDocumentNode(node, options);\n        case node.DOCUMENT_FRAGMENT_NODE:\n            return serializeDocumentFragmentNode(node, options);\n        case node.DOCUMENT_TYPE_NODE:\n            return serializeDocumentTypeNode(node);\n        case node.ELEMENT_NODE:\n            return serializeElementNode(node, options);\n        case node.TEXT_NODE:\n            return serializeTextNode(node, options);\n        case node.CDATA_SECTION_NODE:\n            return serializeCDataNode();\n    }\n}\nexport function serializeDocumentNode(document, options) {\n    return {\n        type: NodeType.Document,\n        childNodes: serializeChildNodes(document, options),\n        adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n    };\n}\nfunction serializeDocumentFragmentNode(element, options) {\n    var isShadowRoot = isNodeShadowRoot(element);\n    if (isShadowRoot) {\n        options.serializationContext.shadowRootsController.addShadowRoot(element);\n    }\n    return {\n        type: NodeType.DocumentFragment,\n        childNodes: serializeChildNodes(element, options),\n        isShadowRoot: isShadowRoot,\n        adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n    };\n}\nfunction serializeDocumentTypeNode(documentType) {\n    return {\n        type: NodeType.DocumentType,\n        name: documentType.name,\n        publicId: documentType.publicId,\n        systemId: documentType.systemId,\n    };\n}\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nfunction serializeElementNode(element, options) {\n    var _a;\n    var tagName = getValidTagName(element.tagName);\n    var isSVG = isSVGElement(element) || undefined;\n    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n    // parentNodePrivacyLevel option to avoid iterating over all parents\n    var nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        var _b = element.getBoundingClientRect(), width = _b.width, height = _b.height;\n        return {\n            type: NodeType.Element,\n            tagName: tagName,\n            attributes: (_a = {\n                    rr_width: \"\".concat(width, \"px\"),\n                    rr_height: \"\".concat(height, \"px\")\n                },\n                _a[PRIVACY_ATTR_NAME] = PRIVACY_ATTR_VALUE_HIDDEN,\n                _a),\n            childNodes: [],\n            isSVG: isSVG,\n        };\n    }\n    // Ignore Elements like Script and some Link, Metas\n    if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n        return;\n    }\n    var attributes = serializeAttributes(element, nodePrivacyLevel, options);\n    var childNodes = [];\n    if (hasChildNodes(element) &&\n        // Do not serialize style children as the css rules are already in the _cssText attribute\n        tagName !== 'style') {\n        // OBJECT POOLING OPTIMIZATION:\n        // We should not create a new object systematically as it could impact performances. Try to reuse\n        // the same object as much as possible, and clone it only if we need to.\n        var childNodesSerializationOptions = void 0;\n        if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n            childNodesSerializationOptions = options;\n        }\n        else {\n            childNodesSerializationOptions = assign({}, options, {\n                parentNodePrivacyLevel: nodePrivacyLevel,\n                ignoreWhiteSpace: tagName === 'head',\n            });\n        }\n        childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n    }\n    return {\n        type: NodeType.Element,\n        tagName: tagName,\n        attributes: attributes,\n        childNodes: childNodes,\n        isSVG: isSVG,\n    };\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, options) {\n    var textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n    if (textContent === undefined) {\n        return;\n    }\n    return {\n        type: NodeType.Text,\n        textContent: textContent,\n    };\n}\nfunction serializeCDataNode() {\n    return {\n        type: NodeType.CDATA,\n        textContent: '',\n    };\n}\n//# sourceMappingURL=serializeNode.js.map","import { serializeNodeWithId } from './serializeNode';\nexport function serializeDocument(document, configuration, serializationContext) {\n    // We are sure that Documents are never ignored, so this function never returns null\n    return serializeNodeWithId(document, {\n        serializationContext: serializationContext,\n        parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n        configuration: configuration,\n    });\n}\n//# sourceMappingURL=serializeDocument.js.map","export { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode, } from './serializationUtils';\nexport { serializeDocument } from './serializeDocument';\nexport { serializeNodeWithId } from './serializeNode';\nexport { serializeAttribute } from './serializeAttribute';\n//# sourceMappingURL=index.js.map","import { isNodeShadowHost } from '@datadog/browser-rum-core';\nexport function isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nexport function getEventTarget(event) {\n    if (event.composed === true && isNodeShadowHost(event.target)) {\n        return event.composedPath()[0];\n    }\n    return event.target;\n}\n//# sourceMappingURL=eventsUtils.js.map","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n// Scrollbar widths vary across properties on different devices and browsers\nvar TOLERANCE = 25;\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport) {\n    return (Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n        Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE);\n}\nexport var convertMouseEventToLayoutCoordinates = function (clientX, clientY) {\n    var visualViewport = window.visualViewport;\n    var normalized = {\n        layoutViewportX: clientX,\n        layoutViewportY: clientY,\n        visualViewportX: clientX,\n        visualViewportY: clientY,\n    };\n    if (!visualViewport) {\n        // On old browsers, we cannot normalize, so fallback to clientX/Y\n        return normalized;\n    }\n    else if (isVisualViewportFactoredIn(visualViewport)) {\n        // Typically Mobile Devices\n        normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);\n        normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);\n    }\n    else {\n        // Typically Desktop Devices\n        normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);\n        normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);\n    }\n    return normalized;\n};\nexport var getVisualViewport = function (visualViewport) { return ({\n    scale: visualViewport.scale,\n    offsetLeft: visualViewport.offsetLeft,\n    offsetTop: visualViewport.offsetTop,\n    pageLeft: visualViewport.pageLeft,\n    pageTop: visualViewport.pageTop,\n    height: visualViewport.height,\n    width: visualViewport.width,\n}); };\n//# sourceMappingURL=viewports.js.map","import { assign, timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nexport function assembleIncrementalSnapshot(source, data) {\n    return {\n        data: assign({\n            source: source,\n        }, data),\n        type: RecordType.IncrementalSnapshot,\n        timestamp: timeStampNow(),\n    };\n}\n//# sourceMappingURL=assembly.js.map","import { addEventListeners, addTelemetryDebug, throttle } from '@datadog/browser-core';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget, isTouchEvent } from '../eventsUtils';\nimport { convertMouseEventToLayoutCoordinates } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nvar MOUSE_MOVE_OBSERVER_THRESHOLD = 50;\nexport function trackMove(configuration, moveCb) {\n    var _a = throttle(function (event) {\n        var target = getEventTarget(event);\n        if (hasSerializedNode(target)) {\n            var coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            var position = {\n                id: getSerializedNodeId(target),\n                timeOffset: 0,\n                x: coordinates.x,\n                y: coordinates.y,\n            };\n            moveCb(assembleIncrementalSnapshot(isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove, { positions: [position] }));\n        }\n    }, MOUSE_MOVE_OBSERVER_THRESHOLD, {\n        trailing: false,\n    }), updatePosition = _a.throttled, cancelThrottle = _a.cancel;\n    var removeListener = addEventListeners(configuration, document, [\"mousemove\" /* DOM_EVENT.MOUSE_MOVE */, \"touchmove\" /* DOM_EVENT.TOUCH_MOVE */], updatePosition, {\n        capture: true,\n        passive: true,\n    }).stop;\n    return {\n        stop: function () {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\nexport function tryToComputeCoordinates(event) {\n    var _a = isTouchEvent(event) ? event.changedTouches[0] : event, x = _a.clientX, y = _a.clientY;\n    if (window.visualViewport) {\n        var _b = convertMouseEventToLayoutCoordinates(x, y), visualViewportX = _b.visualViewportX, visualViewportY = _b.visualViewportY;\n        x = visualViewportX;\n        y = visualViewportY;\n    }\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n        if (event.isTrusted) {\n            addTelemetryDebug('mouse/touch event without x/y');\n        }\n        return undefined;\n    }\n    return { x: x, y: y };\n}\n//# sourceMappingURL=trackMove.js.map","var _a;\nimport { assign, addEventListeners } from '@datadog/browser-core';\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MouseInteractionType } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { tryToComputeCoordinates } from './trackMove';\nvar eventTypeToMouseInteraction = (_a = {},\n    // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n    // allows to reference such records from Frustration records.\n    //\n    // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n    // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n    // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n    // convey such interaction. This would cleanly solve the issue since we would have\n    // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n    _a[\"pointerup\" /* DOM_EVENT.POINTER_UP */] = MouseInteractionType.MouseUp,\n    _a[\"mousedown\" /* DOM_EVENT.MOUSE_DOWN */] = MouseInteractionType.MouseDown,\n    _a[\"click\" /* DOM_EVENT.CLICK */] = MouseInteractionType.Click,\n    _a[\"contextmenu\" /* DOM_EVENT.CONTEXT_MENU */] = MouseInteractionType.ContextMenu,\n    _a[\"dblclick\" /* DOM_EVENT.DBL_CLICK */] = MouseInteractionType.DblClick,\n    _a[\"focus\" /* DOM_EVENT.FOCUS */] = MouseInteractionType.Focus,\n    _a[\"blur\" /* DOM_EVENT.BLUR */] = MouseInteractionType.Blur,\n    _a[\"touchstart\" /* DOM_EVENT.TOUCH_START */] = MouseInteractionType.TouchStart,\n    _a[\"touchend\" /* DOM_EVENT.TOUCH_END */] = MouseInteractionType.TouchEnd,\n    _a);\nexport function trackMouseInteraction(configuration, mouseInteractionCb, recordIds) {\n    var handler = function (event) {\n        var target = getEventTarget(event);\n        if (getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        var id = getSerializedNodeId(target);\n        var type = eventTypeToMouseInteraction[event.type];\n        var interaction;\n        if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n            var coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            interaction = { id: id, type: type, x: coordinates.x, y: coordinates.y };\n        }\n        else {\n            interaction = { id: id, type: type };\n        }\n        var record = assign({ id: recordIds.getIdForEvent(event) }, assembleIncrementalSnapshot(IncrementalSource.MouseInteraction, interaction));\n        mouseInteractionCb(record);\n    };\n    return addEventListeners(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMouseInteraction.js.map","import { throttle, addEventListener } from '@datadog/browser-core';\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nvar SCROLL_OBSERVER_THRESHOLD = 100;\nexport function trackScroll(configuration, scrollCb, elementsScrollPositions, target) {\n    if (target === void 0) { target = document; }\n    var _a = throttle(function (event) {\n        var target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        var id = getSerializedNodeId(target);\n        var scrollPositions = target === document\n            ? {\n                scrollTop: getScrollY(),\n                scrollLeft: getScrollX(),\n            }\n            : {\n                scrollTop: Math.round(target.scrollTop),\n                scrollLeft: Math.round(target.scrollLeft),\n            };\n        elementsScrollPositions.set(target, scrollPositions);\n        scrollCb(assembleIncrementalSnapshot(IncrementalSource.Scroll, {\n            id: id,\n            x: scrollPositions.scrollLeft,\n            y: scrollPositions.scrollTop,\n        }));\n    }, SCROLL_OBSERVER_THRESHOLD), updatePosition = _a.throttled, cancelThrottle = _a.cancel;\n    var removeListener = addEventListener(configuration, target, \"scroll\" /* DOM_EVENT.SCROLL */, updatePosition, {\n        capture: true,\n        passive: true,\n    }).stop;\n    return {\n        stop: function () {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackScroll.js.map","import { throttle, addEventListeners, timeStampNow, noop } from '@datadog/browser-core';\nimport { initViewportObservable } from '@datadog/browser-rum-core';\nimport { IncrementalSource, RecordType } from '../../../types';\nimport { getVisualViewport } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nvar VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;\nexport function trackViewportResize(configuration, viewportResizeCb) {\n    var viewportResizeSubscription = initViewportObservable(configuration).subscribe(function (data) {\n        viewportResizeCb(assembleIncrementalSnapshot(IncrementalSource.ViewportResize, data));\n    });\n    return {\n        stop: function () {\n            viewportResizeSubscription.unsubscribe();\n        },\n    };\n}\nexport function trackVisualViewportResize(configuration, visualViewportResizeCb) {\n    var visualViewport = window.visualViewport;\n    if (!visualViewport) {\n        return { stop: noop };\n    }\n    var _a = throttle(function () {\n        visualViewportResizeCb({\n            data: getVisualViewport(visualViewport),\n            type: RecordType.VisualViewport,\n            timestamp: timeStampNow(),\n        });\n    }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {\n        trailing: false,\n    }), updateDimension = _a.throttled, cancelThrottle = _a.cancel;\n    var removeListener = addEventListeners(configuration, visualViewport, [\"resize\" /* DOM_EVENT.RESIZE */, \"scroll\" /* DOM_EVENT.SCROLL */], updateDimension, {\n        capture: true,\n        passive: true,\n    }).stop;\n    return {\n        stop: function () {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackViewportResize.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MediaInteractionType } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackMediaInteraction(configuration, mediaInteractionCb) {\n    return addEventListeners(configuration, document, [\"play\" /* DOM_EVENT.PLAY */, \"pause\" /* DOM_EVENT.PAUSE */], function (event) {\n        var target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        mediaInteractionCb(assembleIncrementalSnapshot(IncrementalSource.MediaInteraction, {\n            id: getSerializedNodeId(target),\n            type: event.type === \"play\" /* DOM_EVENT.PLAY */ ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        }));\n    }, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMediaInteraction.js.map","import { instrumentMethod } from '@datadog/browser-core';\nimport { IncrementalSource } from '../../../types';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackStyleSheet(styleSheetCb) {\n    function checkStyleSheetAndCallback(styleSheet, callback) {\n        if (styleSheet && hasSerializedNode(styleSheet.ownerNode)) {\n            callback(getSerializedNodeId(styleSheet.ownerNode));\n        }\n    }\n    var instrumentationStoppers = [\n        instrumentMethod(CSSStyleSheet.prototype, 'insertRule', function (_a) {\n            var styleSheet = _a.target, _b = _a.parameters, rule = _b[0], index = _b[1];\n            checkStyleSheetAndCallback(styleSheet, function (id) {\n                return styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                    id: id,\n                    adds: [{ rule: rule, index: index }],\n                }));\n            });\n        }),\n        instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', function (_a) {\n            var styleSheet = _a.target, index = _a.parameters[0];\n            checkStyleSheetAndCallback(styleSheet, function (id) {\n                return styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                    id: id,\n                    removes: [{ index: index }],\n                }));\n            });\n        }),\n    ];\n    if (typeof CSSGroupingRule !== 'undefined') {\n        instrumentGroupingCSSRuleClass(CSSGroupingRule);\n    }\n    else {\n        instrumentGroupingCSSRuleClass(CSSMediaRule);\n        instrumentGroupingCSSRuleClass(CSSSupportsRule);\n    }\n    function instrumentGroupingCSSRuleClass(cls) {\n        instrumentationStoppers.push(instrumentMethod(cls.prototype, 'insertRule', function (_a) {\n            var styleSheet = _a.target, _b = _a.parameters, rule = _b[0], index = _b[1];\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, function (id) {\n                var path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index || 0);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id: id,\n                        adds: [{ rule: rule, index: path }],\n                    }));\n                }\n            });\n        }), instrumentMethod(cls.prototype, 'deleteRule', function (_a) {\n            var styleSheet = _a.target, index = _a.parameters[0];\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, function (id) {\n                var path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id: id,\n                        removes: [{ index: path }],\n                    }));\n                }\n            });\n        }));\n    }\n    return {\n        stop: function () {\n            instrumentationStoppers.forEach(function (stopper) { return stopper.stop(); });\n        },\n    };\n}\nexport function getPathToNestedCSSRule(rule) {\n    var path = [];\n    var currentRule = rule;\n    while (currentRule.parentRule) {\n        var rules_1 = Array.from(currentRule.parentRule.cssRules);\n        var index_1 = rules_1.indexOf(currentRule);\n        path.unshift(index_1);\n        currentRule = currentRule.parentRule;\n    }\n    // A rule may not be attached to a stylesheet\n    if (!currentRule.parentStyleSheet) {\n        return;\n    }\n    var rules = Array.from(currentRule.parentStyleSheet.cssRules);\n    var index = rules.indexOf(currentRule);\n    path.unshift(index);\n    return path;\n}\n//# sourceMappingURL=trackStyleSheet.js.map","import { addEventListeners, timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackFocus(configuration, focusCb) {\n    return addEventListeners(configuration, window, [\"focus\" /* DOM_EVENT.FOCUS */, \"blur\" /* DOM_EVENT.BLUR */], function () {\n        focusCb({\n            data: { has_focus: document.hasFocus() },\n            type: RecordType.Focus,\n            timestamp: timeStampNow(),\n        });\n    });\n}\n//# sourceMappingURL=trackFocus.js.map","import { RecordType } from '../../../types';\nexport function trackFrustration(lifeCycle, frustrationCb, recordIds) {\n    var frustrationSubscription = lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, function (data) {\n        var _a, _b;\n        if (data.rawRumEvent.type === \"action\" /* RumEventType.ACTION */ &&\n            data.rawRumEvent.action.type === \"click\" /* ActionType.CLICK */ &&\n            ((_b = (_a = data.rawRumEvent.action.frustration) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.length) &&\n            'events' in data.domainContext &&\n            data.domainContext.events &&\n            data.domainContext.events.length) {\n            frustrationCb({\n                timestamp: data.rawRumEvent.date,\n                type: RecordType.FrustrationRecord,\n                data: {\n                    frustrationTypes: data.rawRumEvent.action.frustration.type,\n                    recordIds: data.domainContext.events.map(function (e) { return recordIds.getIdForEvent(e); }),\n                },\n            });\n        }\n    });\n    return {\n        stop: function () {\n            frustrationSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackFrustration.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackViewEnd(lifeCycle, viewEndCb) {\n    var viewEndSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, function () {\n        viewEndCb({\n            timestamp: timeStampNow(),\n            type: RecordType.ViewEnd,\n        });\n    });\n    return {\n        stop: function () {\n            viewEndSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackViewEnd.js.map","import { instrumentSetter, assign, addEventListeners, forEach, noop } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode, cssEscape } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackInput(configuration, inputCb, target) {\n    if (target === void 0) { target = document; }\n    var defaultPrivacyLevel = configuration.defaultPrivacyLevel;\n    var lastInputStateMap = new WeakMap();\n    var isShadowRoot = target !== document;\n    var stopEventListeners = addEventListeners(configuration, target, \n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [\"change\" /* DOM_EVENT.CHANGE */] : [\"input\" /* DOM_EVENT.INPUT */, \"change\" /* DOM_EVENT.CHANGE */], function (event) {\n        var target = getEventTarget(event);\n        if (target instanceof HTMLInputElement ||\n            target instanceof HTMLTextAreaElement ||\n            target instanceof HTMLSelectElement) {\n            onElementChange(target);\n        }\n    }, {\n        capture: true,\n        passive: true,\n    }).stop;\n    var stopPropertySetterInstrumentation;\n    if (!isShadowRoot) {\n        var instrumentationStoppers_1 = [\n            instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n        ];\n        stopPropertySetterInstrumentation = function () {\n            instrumentationStoppers_1.forEach(function (stopper) { return stopper.stop(); });\n        };\n    }\n    else {\n        stopPropertySetterInstrumentation = noop;\n    }\n    return {\n        stop: function () {\n            stopPropertySetterInstrumentation();\n            stopEventListeners();\n        },\n    };\n    function onElementChange(target) {\n        var nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);\n        if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        var type = target.type;\n        var inputState;\n        if (type === 'radio' || type === 'checkbox') {\n            if (shouldMaskNode(target, nodePrivacyLevel)) {\n                return;\n            }\n            inputState = { isChecked: target.checked };\n        }\n        else {\n            var value = getElementInputValue(target, nodePrivacyLevel);\n            if (value === undefined) {\n                return;\n            }\n            inputState = { text: value };\n        }\n        // Can be multiple changes on the same node within the same batched mutation observation.\n        cbWithDedup(target, inputState);\n        // If a radio was checked, other radios with the same name attribute will be unchecked.\n        var name = target.name;\n        if (type === 'radio' && name && target.checked) {\n            forEach(document.querySelectorAll(\"input[type=\\\"radio\\\"][name=\\\"\".concat(cssEscape(name), \"\\\"]\")), function (el) {\n                if (el !== target) {\n                    // TODO: Consider the privacy implications for various differing input privacy levels\n                    cbWithDedup(el, { isChecked: false });\n                }\n            });\n        }\n    }\n    /**\n     * There can be multiple changes on the same node within the same batched mutation observation.\n     */\n    function cbWithDedup(target, inputState) {\n        if (!hasSerializedNode(target)) {\n            return;\n        }\n        var lastInputState = lastInputStateMap.get(target);\n        if (!lastInputState ||\n            lastInputState.text !== inputState.text ||\n            lastInputState.isChecked !== inputState.isChecked) {\n            lastInputStateMap.set(target, inputState);\n            inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, assign({\n                id: getSerializedNodeId(target),\n            }, inputState)));\n        }\n    }\n}\n//# sourceMappingURL=trackInput.js.map","import { noop, throttle, requestIdleCallback } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nvar MUTATION_PROCESS_MAX_DELAY = 100;\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport var MUTATION_PROCESS_MIN_DELAY = 16;\nexport function createMutationBatch(processMutationBatch) {\n    var cancelScheduledFlush = noop;\n    var pendingMutations = [];\n    function flush() {\n        cancelScheduledFlush();\n        processMutationBatch(pendingMutations);\n        pendingMutations = [];\n    }\n    var _a = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n        leading: false,\n    }), throttledFlush = _a.throttled, cancelThrottle = _a.cancel;\n    return {\n        addMutations: function (mutations) {\n            if (pendingMutations.length === 0) {\n                cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY });\n            }\n            pendingMutations.push.apply(pendingMutations, mutations);\n        },\n        flush: flush,\n        stop: function () {\n            cancelScheduledFlush();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=mutationBatch.js.map","import { monitor, noop } from '@datadog/browser-core';\nimport { isNodeShadowHost, getMutationObserverConstructor, getParentNode, forEachChildNodes, getNodePrivacyLevel, getTextContent, NodePrivacyLevel, } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode, serializeNodeWithId, serializeAttribute, } from '../serialization';\nimport { createMutationBatch } from '../mutationBatch';\nimport { assembleIncrementalSnapshot } from '../assembly';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(mutationCallback, configuration, shadowRootsController, target) {\n    var MutationObserver = getMutationObserverConstructor();\n    if (!MutationObserver) {\n        return { stop: noop, flush: noop };\n    }\n    var mutationBatch = createMutationBatch(function (mutations) {\n        processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController);\n    });\n    var observer = new MutationObserver(monitor(mutationBatch.addMutations));\n    observer.observe(target, {\n        attributeOldValue: true,\n        attributes: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true,\n    });\n    return {\n        stop: function () {\n            observer.disconnect();\n            mutationBatch.stop();\n        },\n        flush: function () {\n            mutationBatch.flush();\n        },\n    };\n}\nfunction processMutations(mutations, mutationCallback, configuration, shadowRootsController) {\n    var nodePrivacyLevelCache = new Map();\n    mutations\n        .filter(function (mutation) { return mutation.type === 'childList'; })\n        .forEach(function (mutation) {\n        mutation.removedNodes.forEach(function (removedNode) {\n            traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);\n        });\n    });\n    // Discard any mutation with a 'target' node that:\n    // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n    // part of a mutation occurring in a parent Node\n    // * should be hidden or ignored\n    var filteredMutations = mutations.filter(function (mutation) {\n        return mutation.target.isConnected &&\n            nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n            getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n                NodePrivacyLevel.HIDDEN;\n    });\n    var _a = processChildListMutations(filteredMutations.filter(function (mutation) { return mutation.type === 'childList'; }), configuration, shadowRootsController, nodePrivacyLevelCache), adds = _a.adds, removes = _a.removes, hasBeenSerialized = _a.hasBeenSerialized;\n    var texts = processCharacterDataMutations(filteredMutations.filter(function (mutation) {\n        return mutation.type === 'characterData' && !hasBeenSerialized(mutation.target);\n    }), configuration, nodePrivacyLevelCache);\n    var attributes = processAttributesMutations(filteredMutations.filter(function (mutation) {\n        return mutation.type === 'attributes' && !hasBeenSerialized(mutation.target);\n    }), configuration, nodePrivacyLevelCache);\n    if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n        return;\n    }\n    mutationCallback(assembleIncrementalSnapshot(IncrementalSource.Mutation, { adds: adds, removes: removes, texts: texts, attributes: attributes }));\n}\nfunction processChildListMutations(mutations, configuration, shadowRootsController, nodePrivacyLevelCache) {\n    // First, we iterate over mutations to collect:\n    //\n    // * nodes that have been added in the document and not removed by a subsequent mutation\n    // * nodes that have been removed from the document but were not added in a previous mutation\n    //\n    // For this second category, we also collect their previous parent (mutation.target) because we'll\n    // need it to emit a 'remove' mutation.\n    //\n    // Those two categories may overlap: if a node moved from a position to another, it is reported as\n    // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n    // the node will be in both sets.\n    var addedAndMovedNodes = new Set();\n    var removedNodes = new Map();\n    var _loop_1 = function (mutation) {\n        mutation.addedNodes.forEach(function (node) {\n            addedAndMovedNodes.add(node);\n        });\n        mutation.removedNodes.forEach(function (node) {\n            if (!addedAndMovedNodes.has(node)) {\n                removedNodes.set(node, mutation.target);\n            }\n            addedAndMovedNodes.delete(node);\n        });\n    };\n    for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n        var mutation = mutations_1[_i];\n        _loop_1(mutation);\n    }\n    // Then, we sort nodes that are still in the document by topological order, for two reasons:\n    //\n    // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n    // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n    // a precedent node.\n    //\n    // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n    // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n    // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n    // already serialized and have an id.\n    var sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n    sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n    // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n    // node ids in a set to be able to skip subsequent related mutations.\n    var serializedNodeIds = new Set();\n    var addedNodeMutations = [];\n    for (var _a = 0, sortedAddedAndMovedNodes_1 = sortedAddedAndMovedNodes; _a < sortedAddedAndMovedNodes_1.length; _a++) {\n        var node = sortedAddedAndMovedNodes_1[_a];\n        if (hasBeenSerialized(node)) {\n            continue;\n        }\n        var parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        var serializedNode = serializeNodeWithId(node, {\n            serializedNodeIds: serializedNodeIds,\n            parentNodePrivacyLevel: parentNodePrivacyLevel,\n            serializationContext: { status: 2 /* SerializationContextStatus.MUTATION */, shadowRootsController: shadowRootsController },\n            configuration: configuration,\n        });\n        if (!serializedNode) {\n            continue;\n        }\n        var parentNode = getParentNode(node);\n        addedNodeMutations.push({\n            nextId: getNextSibling(node),\n            parentId: getSerializedNodeId(parentNode),\n            node: serializedNode,\n        });\n    }\n    // Finally, we emit remove mutations.\n    var removedNodeMutations = [];\n    removedNodes.forEach(function (parent, node) {\n        if (hasSerializedNode(node)) {\n            removedNodeMutations.push({\n                parentId: getSerializedNodeId(parent),\n                id: getSerializedNodeId(node),\n            });\n        }\n    });\n    return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized: hasBeenSerialized };\n    function hasBeenSerialized(node) {\n        return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n    }\n    function getNextSibling(node) {\n        var nextSibling = node.nextSibling;\n        while (nextSibling) {\n            if (hasSerializedNode(nextSibling)) {\n                return getSerializedNodeId(nextSibling);\n            }\n            nextSibling = nextSibling.nextSibling;\n        }\n        return null;\n    }\n}\nfunction processCharacterDataMutations(mutations, configuration, nodePrivacyLevelCache) {\n    var _a;\n    var textMutations = [];\n    // Deduplicate mutations based on their target node\n    var handledNodes = new Set();\n    var filteredMutations = mutations.filter(function (mutation) {\n        if (handledNodes.has(mutation.target)) {\n            return false;\n        }\n        handledNodes.add(mutation.target);\n        return true;\n    });\n    // Emit mutations\n    for (var _i = 0, filteredMutations_1 = filteredMutations; _i < filteredMutations_1.length; _i++) {\n        var mutation = filteredMutations_1[_i];\n        var value = mutation.target.textContent;\n        if (value === mutation.oldValue) {\n            continue;\n        }\n        var parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        textMutations.push({\n            id: getSerializedNodeId(mutation.target),\n            // TODO: pass a valid \"ignoreWhiteSpace\" argument\n            value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null,\n        });\n    }\n    return textMutations;\n}\nfunction processAttributesMutations(mutations, configuration, nodePrivacyLevelCache) {\n    var attributeMutations = [];\n    // Deduplicate mutations based on their target node and changed attribute\n    var handledElements = new Map();\n    var filteredMutations = mutations.filter(function (mutation) {\n        var handledAttributes = handledElements.get(mutation.target);\n        if (handledAttributes && handledAttributes.has(mutation.attributeName)) {\n            return false;\n        }\n        if (!handledAttributes) {\n            handledElements.set(mutation.target, new Set([mutation.attributeName]));\n        }\n        else {\n            handledAttributes.add(mutation.attributeName);\n        }\n        return true;\n    });\n    // Emit mutations\n    var emittedMutations = new Map();\n    for (var _i = 0, filteredMutations_2 = filteredMutations; _i < filteredMutations_2.length; _i++) {\n        var mutation = filteredMutations_2[_i];\n        var uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n        if (uncensoredValue === mutation.oldValue) {\n            continue;\n        }\n        var privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        var attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);\n        var transformedValue = void 0;\n        if (mutation.attributeName === 'value') {\n            var inputValue = getElementInputValue(mutation.target, privacyLevel);\n            if (inputValue === undefined) {\n                continue;\n            }\n            transformedValue = inputValue;\n        }\n        else if (typeof attributeValue === 'string') {\n            transformedValue = attributeValue;\n        }\n        else {\n            transformedValue = null;\n        }\n        var emittedMutation = emittedMutations.get(mutation.target);\n        if (!emittedMutation) {\n            emittedMutation = {\n                id: getSerializedNodeId(mutation.target),\n                attributes: {},\n            };\n            attributeMutations.push(emittedMutation);\n            emittedMutations.set(mutation.target, emittedMutation);\n        }\n        emittedMutation.attributes[mutation.attributeName] = transformedValue;\n    }\n    return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n    nodes.sort(function (a, b) {\n        var position = a.compareDocumentPosition(b);\n        /* eslint-disable no-bitwise */\n        if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return -1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n            return -1;\n        }\n        /* eslint-enable no-bitwise */\n        return 0;\n    });\n}\nfunction traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {\n    if (isNodeShadowHost(removedNode)) {\n        shadowDomRemovedCallback(removedNode.shadowRoot);\n    }\n    forEachChildNodes(removedNode, function (childNode) { return traverseRemovedShadowDom(childNode, shadowDomRemovedCallback); });\n}\n//# sourceMappingURL=trackMutation.js.map","export { trackMove } from './trackMove';\nexport { trackMouseInteraction } from './trackMouseInteraction';\nexport { trackScroll } from './trackScroll';\nexport { trackViewportResize, trackVisualViewportResize } from './trackViewportResize';\nexport { trackMediaInteraction } from './trackMediaInteraction';\nexport { trackStyleSheet } from './trackStyleSheet';\nexport { trackFocus } from './trackFocus';\nexport { trackFrustration } from './trackFrustration';\nexport { trackViewEnd } from './trackViewEnd';\nexport { trackInput } from './trackInput';\nexport { trackMutation } from './trackMutation';\n//# sourceMappingURL=index.js.map","export function createElementsScrollPositions() {\n    var scrollPositionsByElement = new WeakMap();\n    return {\n        set: function (element, scrollPositions) {\n            if (element === document && !document.scrollingElement) {\n                // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n                // in some cases scrolling elements can not be defined, we don't support those for now\n                return;\n            }\n            scrollPositionsByElement.set(element === document ? document.scrollingElement : element, scrollPositions);\n        },\n        get: function (element) {\n            return scrollPositionsByElement.get(element);\n        },\n        has: function (element) {\n            return scrollPositionsByElement.has(element);\n        },\n    };\n}\n//# sourceMappingURL=elementsScrollPositions.js.map","import { trackInput, trackMutation, trackScroll } from './trackers';\nexport var initShadowRootsController = function (configuration, callback, elementsScrollPositions) {\n    var controllerByShadowRoot = new Map();\n    var shadowRootsController = {\n        addShadowRoot: function (shadowRoot) {\n            if (controllerByShadowRoot.has(shadowRoot)) {\n                return;\n            }\n            var mutationTracker = trackMutation(callback, configuration, shadowRootsController, shadowRoot);\n            // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n            var inputTracker = trackInput(configuration, callback, shadowRoot);\n            // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n            var scrollTracker = trackScroll(configuration, callback, elementsScrollPositions, shadowRoot);\n            controllerByShadowRoot.set(shadowRoot, {\n                flush: function () { return mutationTracker.flush(); },\n                stop: function () {\n                    mutationTracker.stop();\n                    inputTracker.stop();\n                    scrollTracker.stop();\n                },\n            });\n        },\n        removeShadowRoot: function (shadowRoot) {\n            var entry = controllerByShadowRoot.get(shadowRoot);\n            if (!entry) {\n                // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n                return;\n            }\n            entry.stop();\n            controllerByShadowRoot.delete(shadowRoot);\n        },\n        stop: function () {\n            controllerByShadowRoot.forEach(function (_a) {\n                var stop = _a.stop;\n                return stop();\n            });\n        },\n        flush: function () {\n            controllerByShadowRoot.forEach(function (_a) {\n                var flush = _a.flush;\n                return flush();\n            });\n        },\n    };\n    return shadowRootsController;\n};\n//# sourceMappingURL=shadowRootsController.js.map","import { getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core';\nimport { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport { serializeDocument } from './serialization';\nimport { getVisualViewport } from './viewports';\nexport function startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, fullSnapshotCallback) {\n    var takeFullSnapshot = function (timestamp, serializationContext) {\n        if (timestamp === void 0) { timestamp = timeStampNow(); }\n        if (serializationContext === void 0) { serializationContext = {\n            status: 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */,\n            elementsScrollPositions: elementsScrollPositions,\n            shadowRootsController: shadowRootsController,\n        }; }\n        var _a = getViewportDimension(), width = _a.width, height = _a.height;\n        var records = [\n            {\n                data: {\n                    height: height,\n                    href: window.location.href,\n                    width: width,\n                },\n                type: RecordType.Meta,\n                timestamp: timestamp,\n            },\n            {\n                data: {\n                    has_focus: document.hasFocus(),\n                },\n                type: RecordType.Focus,\n                timestamp: timestamp,\n            },\n            {\n                data: {\n                    node: serializeDocument(document, configuration, serializationContext),\n                    initialOffset: {\n                        left: getScrollX(),\n                        top: getScrollY(),\n                    },\n                },\n                type: RecordType.FullSnapshot,\n                timestamp: timestamp,\n            },\n        ];\n        if (window.visualViewport) {\n            records.push({\n                data: getVisualViewport(window.visualViewport),\n                type: RecordType.VisualViewport,\n                timestamp: timestamp,\n            });\n        }\n        return records;\n    };\n    fullSnapshotCallback(takeFullSnapshot());\n    var unsubscribe = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, function (view) {\n        flushMutations();\n        fullSnapshotCallback(takeFullSnapshot(view.startClocks.timeStamp, {\n            shadowRootsController: shadowRootsController,\n            status: 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */,\n            elementsScrollPositions: elementsScrollPositions,\n        }));\n    }).unsubscribe;\n    return {\n        stop: unsubscribe,\n    };\n}\n//# sourceMappingURL=startFullSnapshots.js.map","export function initRecordIds() {\n    var recordIds = new WeakMap();\n    var nextId = 1;\n    return {\n        getIdForEvent: function (event) {\n            if (!recordIds.has(event)) {\n                recordIds.set(event, nextId++);\n            }\n            return recordIds.get(event);\n        },\n    };\n}\n//# sourceMappingURL=recordIds.js.map","import { sendToExtension } from '@datadog/browser-core';\nimport * as replayStats from '../replayStats';\nimport { trackFocus, trackFrustration, trackInput, trackMediaInteraction, trackMouseInteraction, trackMove, trackMutation, trackScroll, trackStyleSheet, trackViewEnd, trackViewportResize, trackVisualViewportResize, } from './trackers';\nimport { createElementsScrollPositions } from './elementsScrollPositions';\nimport { initShadowRootsController } from './shadowRootsController';\nimport { startFullSnapshots } from './startFullSnapshots';\nimport { initRecordIds } from './recordIds';\nexport function record(options) {\n    var emit = options.emit, configuration = options.configuration, lifeCycle = options.lifeCycle;\n    // runtime checks for user options\n    if (!emit) {\n        throw new Error('emit function is required');\n    }\n    var emitAndComputeStats = function (record) {\n        emit(record);\n        sendToExtension('record', { record: record });\n        var view = options.viewHistory.findView();\n        replayStats.addRecord(view.id);\n    };\n    var elementsScrollPositions = createElementsScrollPositions();\n    var shadowRootsController = initShadowRootsController(configuration, emitAndComputeStats, elementsScrollPositions);\n    var stopFullSnapshots = startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, function (records) { return records.forEach(function (record) { return emitAndComputeStats(record); }); }).stop;\n    function flushMutations() {\n        shadowRootsController.flush();\n        mutationTracker.flush();\n    }\n    var recordIds = initRecordIds();\n    var mutationTracker = trackMutation(emitAndComputeStats, configuration, shadowRootsController, document);\n    var trackers = [\n        mutationTracker,\n        trackMove(configuration, emitAndComputeStats),\n        trackMouseInteraction(configuration, emitAndComputeStats, recordIds),\n        trackScroll(configuration, emitAndComputeStats, elementsScrollPositions, document),\n        trackViewportResize(configuration, emitAndComputeStats),\n        trackInput(configuration, emitAndComputeStats),\n        trackMediaInteraction(configuration, emitAndComputeStats),\n        trackStyleSheet(emitAndComputeStats),\n        trackFocus(configuration, emitAndComputeStats),\n        trackVisualViewportResize(configuration, emitAndComputeStats),\n        trackFrustration(lifeCycle, emitAndComputeStats, recordIds),\n        trackViewEnd(lifeCycle, function (viewEndRecord) {\n            flushMutations();\n            emitAndComputeStats(viewEndRecord);\n        }),\n    ];\n    return {\n        stop: function () {\n            shadowRootsController.stop();\n            trackers.forEach(function (tracker) { return tracker.stop(); });\n            stopFullSnapshots();\n        },\n        flushMutations: flushMutations,\n        shadowRootsController: shadowRootsController,\n    };\n}\n//# sourceMappingURL=record.js.map","export { record } from './record';\nexport { serializeNodeWithId, serializeDocument } from './serialization';\nexport { createElementsScrollPositions } from './elementsScrollPositions';\n//# sourceMappingURL=index.js.map","import { assign } from '@datadog/browser-core';\nexport function buildReplayPayload(data, metadata, rawSegmentBytesCount) {\n    var formData = new FormData();\n    formData.append('segment', new Blob([data], {\n        type: 'application/octet-stream',\n    }), \"\".concat(metadata.session.id, \"-\").concat(metadata.start));\n    var metadataAndSegmentSizes = assign({\n        raw_segment_size: rawSegmentBytesCount,\n        compressed_segment_size: data.byteLength,\n    }, metadata);\n    var serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes);\n    formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }));\n    return { data: formData, bytesCount: data.byteLength };\n}\n//# sourceMappingURL=buildReplayPayload.js.map","import { assign } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nexport function createSegment(_a) {\n    var context = _a.context, creationReason = _a.creationReason, encoder = _a.encoder;\n    var encodedBytesCount = 0;\n    var viewId = context.view.id;\n    var metadata = assign({\n        start: Infinity,\n        end: -Infinity,\n        creation_reason: creationReason,\n        records_count: 0,\n        has_full_snapshot: false,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser',\n    }, context);\n    replayStats.addSegment(viewId);\n    function addRecord(record, callback) {\n        metadata.start = Math.min(metadata.start, record.timestamp);\n        metadata.end = Math.max(metadata.end, record.timestamp);\n        metadata.records_count += 1;\n        metadata.has_full_snapshot || (metadata.has_full_snapshot = record.type === RecordType.FullSnapshot);\n        var prefix = encoder.isEmpty ? '{\"records\":[' : ',';\n        encoder.write(prefix + JSON.stringify(record), function (additionalEncodedBytesCount) {\n            encodedBytesCount += additionalEncodedBytesCount;\n            callback(encodedBytesCount);\n        });\n    }\n    function flush(callback) {\n        if (encoder.isEmpty) {\n            throw new Error('Empty segment flushed');\n        }\n        encoder.write(\"],\".concat(JSON.stringify(metadata).slice(1), \"\\n\"));\n        encoder.finish(function (encoderResult) {\n            replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount);\n            callback(metadata, encoderResult);\n        });\n    }\n    return { addRecord: addRecord, flush: flush };\n}\n//# sourceMappingURL=segment.js.map","import { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nimport { buildReplayPayload } from './buildReplayPayload';\nimport { createSegment } from './segment';\nexport var SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND;\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport var SEGMENT_BYTES_LIMIT = 60000;\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\nexport function startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, httpRequest, encoder) {\n    return doStartSegmentCollection(lifeCycle, function () { return computeSegmentContext(configuration.applicationId, sessionManager, viewHistory); }, httpRequest, encoder);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {\n    var state = {\n        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n        nextSegmentCreationReason: 'init',\n    };\n    var unsubscribeViewCreated = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, function () {\n        flushSegment('view_change');\n    }).unsubscribe;\n    var unsubscribePageExited = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, function (pageExitEvent) {\n        flushSegment(pageExitEvent.reason);\n    }).unsubscribe;\n    function flushSegment(flushReason) {\n        if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {\n            state.segment.flush(function (metadata, encoderResult) {\n                var payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount);\n                if (isPageExitReason(flushReason)) {\n                    httpRequest.sendOnExit(payload);\n                }\n                else {\n                    httpRequest.send(payload);\n                }\n            });\n            clearTimeout(state.expirationTimeoutId);\n        }\n        if (flushReason !== 'stop') {\n            state = {\n                status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n                nextSegmentCreationReason: flushReason,\n            };\n        }\n        else {\n            state = {\n                status: 2 /* SegmentCollectionStatus.Stopped */,\n            };\n        }\n    }\n    return {\n        addRecord: function (record) {\n            if (state.status === 2 /* SegmentCollectionStatus.Stopped */) {\n                return;\n            }\n            if (state.status === 0 /* SegmentCollectionStatus.WaitingForInitialRecord */) {\n                var context = getSegmentContext();\n                if (!context) {\n                    return;\n                }\n                state = {\n                    status: 1 /* SegmentCollectionStatus.SegmentPending */,\n                    segment: createSegment({ encoder: encoder, context: context, creationReason: state.nextSegmentCreationReason }),\n                    expirationTimeoutId: setTimeout(function () {\n                        flushSegment('segment_duration_limit');\n                    }, SEGMENT_DURATION_LIMIT),\n                };\n            }\n            state.segment.addRecord(record, function (encodedBytesCount) {\n                if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n                    flushSegment('segment_bytes_limit');\n                }\n            });\n        },\n        stop: function () {\n            flushSegment('stop');\n            unsubscribeViewCreated();\n            unsubscribePageExited();\n        },\n    };\n}\nexport function computeSegmentContext(applicationId, sessionManager, viewHistory) {\n    var session = sessionManager.findTrackedSession();\n    var viewContext = viewHistory.findView();\n    if (!session || !viewContext) {\n        return undefined;\n    }\n    return {\n        application: {\n            id: applicationId,\n        },\n        session: {\n            id: session.id,\n        },\n        view: {\n            id: viewContext.id,\n        },\n    };\n}\nexport function setSegmentBytesLimit(newSegmentBytesLimit) {\n    if (newSegmentBytesLimit === void 0) { newSegmentBytesLimit = 60000; }\n    SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;\n}\n//# sourceMappingURL=segmentCollection.js.map","export { startSegmentCollection, setSegmentBytesLimit } from './segmentCollection';\nexport { SEGMENT_BYTES_LIMIT } from './segmentCollection';\n//# sourceMappingURL=index.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startRecordBridge(viewHistory) {\n    var bridge = getEventBridge();\n    return {\n        addRecord: function (record) {\n            // Get the current active view, not at the time of the record, aligning with the segment logic.\n            // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n            // However the risk is minimal. We could address the issue when potential negative impact are identified.\n            var view = viewHistory.findView();\n            bridge.send('record', record, view.id);\n        },\n    };\n}\n//# sourceMappingURL=startRecordBridge.js.map","import { createHttpRequest, addTelemetryDebug, canUseEventBridge } from '@datadog/browser-core';\nimport { record } from '../domain/record';\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection';\nimport { startRecordBridge } from '../domain/startRecordBridge';\nexport function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, httpRequest) {\n    var cleanupTasks = [];\n    var reportError = function (error) {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error: error });\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    var replayRequest = httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError);\n    var addRecord;\n    if (!canUseEventBridge()) {\n        var segmentCollection = startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);\n        addRecord = segmentCollection.addRecord;\n        cleanupTasks.push(segmentCollection.stop);\n    }\n    else {\n        ;\n        (addRecord = startRecordBridge(viewHistory).addRecord);\n    }\n    var stopRecording = record({\n        emit: addRecord,\n        configuration: configuration,\n        lifeCycle: lifeCycle,\n        viewHistory: viewHistory,\n    }).stop;\n    cleanupTasks.push(stopRecording);\n    return {\n        stop: function () {\n            cleanupTasks.forEach(function (task) { return task(); });\n        },\n    };\n}\n//# sourceMappingURL=startRecording.js.map","import { addEventListener, addTelemetryDebug, assign, concatBuffers } from '@datadog/browser-core';\nexport function createDeflateEncoder(configuration, worker, streamId) {\n    var rawBytesCount = 0;\n    var compressedData = [];\n    var compressedDataTrailer;\n    var nextWriteActionId = 0;\n    var pendingWriteActions = [];\n    var removeMessageListener = addEventListener(configuration, worker, 'message', function (_a) {\n        var workerResponse = _a.data;\n        if (workerResponse.type !== 'wrote' || workerResponse.streamId !== streamId) {\n            return;\n        }\n        rawBytesCount += workerResponse.additionalBytesCount;\n        compressedData.push(workerResponse.result);\n        compressedDataTrailer = workerResponse.trailer;\n        var nextPendingAction = pendingWriteActions.shift();\n        if (nextPendingAction && nextPendingAction.id === workerResponse.id) {\n            if (nextPendingAction.writeCallback) {\n                nextPendingAction.writeCallback(workerResponse.result.byteLength);\n            }\n            else if (nextPendingAction.finishCallback) {\n                nextPendingAction.finishCallback();\n            }\n        }\n        else {\n            removeMessageListener();\n            addTelemetryDebug('Worker responses received out of order.');\n        }\n    }).stop;\n    function consumeResult() {\n        var output = compressedData.length === 0 ? new Uint8Array(0) : concatBuffers(compressedData.concat(compressedDataTrailer));\n        var result = {\n            rawBytesCount: rawBytesCount,\n            output: output,\n            outputBytesCount: output.byteLength,\n            encoding: 'deflate',\n        };\n        rawBytesCount = 0;\n        compressedData = [];\n        return result;\n    }\n    function sendResetIfNeeded() {\n        if (nextWriteActionId > 0) {\n            worker.postMessage({\n                action: 'reset',\n                streamId: streamId,\n            });\n            nextWriteActionId = 0;\n        }\n    }\n    return {\n        isAsync: true,\n        get isEmpty() {\n            return nextWriteActionId === 0;\n        },\n        write: function (data, callback) {\n            worker.postMessage({\n                action: 'write',\n                id: nextWriteActionId,\n                data: data,\n                streamId: streamId,\n            });\n            pendingWriteActions.push({\n                id: nextWriteActionId,\n                writeCallback: callback,\n                data: data,\n            });\n            nextWriteActionId += 1;\n        },\n        finish: function (callback) {\n            sendResetIfNeeded();\n            if (!pendingWriteActions.length) {\n                callback(consumeResult());\n            }\n            else {\n                // Make sure we do not call any write callback\n                pendingWriteActions.forEach(function (pendingWriteAction) {\n                    delete pendingWriteAction.writeCallback;\n                });\n                // Wait for the last action to finish before calling the finish callback\n                pendingWriteActions[pendingWriteActions.length - 1].finishCallback = function () { return callback(consumeResult()); };\n            }\n        },\n        finishSync: function () {\n            sendResetIfNeeded();\n            var pendingData = pendingWriteActions\n                .map(function (pendingWriteAction) {\n                // Make sure we do not call any write or finish callback\n                delete pendingWriteAction.writeCallback;\n                delete pendingWriteAction.finishCallback;\n                return pendingWriteAction.data;\n            })\n                .join('');\n            return assign(consumeResult(), {\n                pendingData: pendingData,\n            });\n        },\n        estimateEncodedBytesCount: function (data) {\n            // This is a rough estimation of the data size once it'll be encoded by deflate. We observed\n            // that if it's the first chunk of data pushed to the stream, the ratio is lower (3-4), but\n            // after that the ratio is greater (10+). We chose 8 here, which (on average) seems to produce\n            // requests of the expected size.\n            return data.length / 8;\n        },\n        stop: function () {\n            removeMessageListener();\n        },\n    };\n}\n//# sourceMappingURL=deflateEncoder.js.map","import { addTelemetryError, display, includes, addEventListener, setTimeout, ONE_SECOND, DOCS_ORIGIN, } from '@datadog/browser-core';\nexport var INITIALIZATION_TIME_OUT_DELAY = 30 * ONE_SECOND;\nfunction createDeflateWorker(configuration) {\n    return new Worker(configuration.workerUrl || URL.createObjectURL(new Blob([\"!function(){\\\"use strict\\\";function t(t){for(var e=t.reduce((function(t,e){return t+e.length}),0),a=new Uint8Array(e),n=0,r=0,i=t;r<i.length;r++){var s=i[r];a.set(s,n),n+=s.length}return a}function e(t){for(var e=t.length;--e>=0;)t[e]=0}var a=256,n=286,r=30,i=15,s=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),h=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),l=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),_=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=new Array(576);e(o);var d=new Array(60);e(d);var u=new Array(512);e(u);var f=new Array(256);e(f);var c=new Array(29);e(c);var p,g,w,v=new Array(r);function b(t,e,a,n,r){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=n,this.max_length=r,this.has_stree=t&&t.length}function m(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}e(v);var y=function(t){return t<256?u[t]:u[256+(t>>>7)]},k=function(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},z=function(t,e,a){t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,k(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},x=function(t,e,a){z(t,a[2*e],a[2*e+1])},A=function(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},U=function(t,e,a){var n,r,s=new Array(16),h=0;for(n=1;n<=i;n++)s[n]=h=h+a[n-1]<<1;for(r=0;r<=e;r++){var l=t[2*r+1];0!==l&&(t[2*r]=A(s[l]++,l))}},I=function(t){var e;for(e=0;e<n;e++)t.dyn_ltree[2*e]=0;for(e=0;e<r;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0},B=function(t){t.bi_valid>8?k(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},E=function(t,e,a,n){var r=2*e,i=2*a;return t[r]<t[i]||t[r]===t[i]&&n[e]<=n[a]},S=function(t,e,a){for(var n=t.heap[a],r=a<<1;r<=t.heap_len&&(r<t.heap_len&&E(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!E(e,n,t.heap[r],t.depth));)t.heap[a]=t.heap[r],a=r,r<<=1;t.heap[a]=n},C=function(t,e,n){var r,i,l,_,o=0;if(0!==t.last_lit)do{r=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],i=t.pending_buf[t.l_buf+o],o++,0===r?x(t,i,e):(l=f[i],x(t,l+a+1,e),0!==(_=s[l])&&(i-=c[l],z(t,i,_)),r--,l=y(r),x(t,l,n),0!==(_=h[l])&&(r-=v[l],z(t,r,_)))}while(o<t.last_lit);x(t,256,e)},D=function(t,e){var a,n,r,s=e.dyn_tree,h=e.stat_desc.static_tree,l=e.stat_desc.has_stree,_=e.stat_desc.elems,o=-1;for(t.heap_len=0,t.heap_max=573,a=0;a<_;a++)0!==s[2*a]?(t.heap[++t.heap_len]=o=a,t.depth[a]=0):s[2*a+1]=0;for(;t.heap_len<2;)s[2*(r=t.heap[++t.heap_len]=o<2?++o:0)]=1,t.depth[r]=0,t.opt_len--,l&&(t.static_len-=h[2*r+1]);for(e.max_code=o,a=t.heap_len>>1;a>=1;a--)S(t,s,a);r=_;do{a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],S(t,s,1),n=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=n,s[2*r]=s[2*a]+s[2*n],t.depth[r]=(t.depth[a]>=t.depth[n]?t.depth[a]:t.depth[n])+1,s[2*a+1]=s[2*n+1]=r,t.heap[1]=r++,S(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var a,n,r,s,h,l,_=e.dyn_tree,o=e.max_code,d=e.stat_desc.static_tree,u=e.stat_desc.has_stree,f=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,g=0;for(s=0;s<=i;s++)t.bl_count[s]=0;for(_[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<573;a++)(s=_[2*_[2*(n=t.heap[a])+1]+1]+1)>p&&(s=p,g++),_[2*n+1]=s,n>o||(t.bl_count[s]++,h=0,n>=c&&(h=f[n-c]),l=_[2*n],t.opt_len+=l*(s+h),u&&(t.static_len+=l*(d[2*n+1]+h)));if(0!==g){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,g-=2}while(g>0);for(s=p;0!==s;s--)for(n=t.bl_count[s];0!==n;)(r=t.heap[--a])>o||(_[2*r+1]!==s&&(t.opt_len+=(s-_[2*r+1])*_[2*r],_[2*r+1]=s),n--)}}(t,e),U(s,o,t.bl_count)},j=function(t,e,a){var n,r,i=-1,s=e[1],h=0,l=7,_=4;for(0===s&&(l=138,_=3),e[2*(a+1)+1]=65535,n=0;n<=a;n++)r=s,s=e[2*(n+1)+1],++h<l&&r===s||(h<_?t.bl_tree[2*r]+=h:0!==r?(r!==i&&t.bl_tree[2*r]++,t.bl_tree[32]++):h<=10?t.bl_tree[34]++:t.bl_tree[36]++,h=0,i=r,0===s?(l=138,_=3):r===s?(l=6,_=3):(l=7,_=4))},M=function(t,e,a){var n,r,i=-1,s=e[1],h=0,l=7,_=4;for(0===s&&(l=138,_=3),n=0;n<=a;n++)if(r=s,s=e[2*(n+1)+1],!(++h<l&&r===s)){if(h<_)do{x(t,r,t.bl_tree)}while(0!=--h);else 0!==r?(r!==i&&(x(t,r,t.bl_tree),h--),x(t,16,t.bl_tree),z(t,h-3,2)):h<=10?(x(t,17,t.bl_tree),z(t,h-3,3)):(x(t,18,t.bl_tree),z(t,h-11,7));h=0,i=r,0===s?(l=138,_=3):r===s?(l=6,_=3):(l=7,_=4)}},L=!1,T=function(t,e,a,n){z(t,0+(n?1:0),3),function(t,e,a,n){B(t),n&&(k(t,a),k(t,~a)),t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a}(t,e,a,!0)},H=function(t,e,n,r){var i,s,h=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,n=4093624447;for(e=0;e<=31;e++,n>>>=1)if(1&n&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<a;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0}(t)),D(t,t.l_desc),D(t,t.d_desc),h=function(t){var e;for(j(t,t.dyn_ltree,t.l_desc.max_code),j(t,t.dyn_dtree,t.d_desc.max_code),D(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*_[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),i=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=i&&(i=s)):i=s=n+5,n+4<=i&&-1!==e?T(t,e,n,r):4===t.strategy||s===i?(z(t,2+(r?1:0),3),C(t,o,d)):(z(t,4+(r?1:0),3),function(t,e,a,n){var r;for(z(t,e-257,5),z(t,a-1,5),z(t,n-4,4),r=0;r<n;r++)z(t,t.bl_tree[2*_[r]+1],3);M(t,t.dyn_ltree,e-1),M(t,t.dyn_dtree,a-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,h+1),C(t,t.dyn_ltree,t.dyn_dtree)),I(t),r&&B(t)},R={_tr_init:function(t){L||(!function(){var t,e,a,_,m,y=new Array(16);for(a=0,_=0;_<28;_++)for(c[_]=a,t=0;t<1<<s[_];t++)f[a++]=_;for(f[a-1]=_,m=0,_=0;_<16;_++)for(v[_]=m,t=0;t<1<<h[_];t++)u[m++]=_;for(m>>=7;_<r;_++)for(v[_]=m<<7,t=0;t<1<<h[_]-7;t++)u[256+m++]=_;for(e=0;e<=i;e++)y[e]=0;for(t=0;t<=143;)o[2*t+1]=8,t++,y[8]++;for(;t<=255;)o[2*t+1]=9,t++,y[9]++;for(;t<=279;)o[2*t+1]=7,t++,y[7]++;for(;t<=287;)o[2*t+1]=8,t++,y[8]++;for(U(o,287,y),t=0;t<r;t++)d[2*t+1]=5,d[2*t]=A(t,5);p=new b(o,s,257,n,i),g=new b(d,h,0,r,i),w=new b(new Array(0),l,0,19,7)}(),L=!0),t.l_desc=new m(t.dyn_ltree,p),t.d_desc=new m(t.dyn_dtree,g),t.bl_desc=new m(t.bl_tree,w),t.bi_buf=0,t.bi_valid=0,I(t)},_tr_stored_block:T,_tr_flush_block:H,_tr_tally:function(t,e,n){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&n,t.last_lit++,0===e?t.dyn_ltree[2*n]++:(t.matches++,e--,t.dyn_ltree[2*(f[n]+a+1)]++,t.dyn_dtree[2*y(e)]++),t.last_lit===t.lit_bufsize-1},_tr_align:function(t){z(t,2,3),x(t,256,o),function(t){16===t.bi_valid?(k(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},K=function(t,e,a,n){for(var r=65535&t,i=t>>>16&65535,s=0;0!==a;){a-=s=a>2e3?2e3:a;do{i=i+(r=r+e[n++]|0)|0}while(--s);r%=65521,i%=65521}return r|i<<16},N=new Uint32Array(function(){for(var t,e=[],a=0;a<256;a++){t=a;for(var n=0;n<8;n++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}()),O=function(t,e,a,n){var r=N,i=n+a;t^=-1;for(var s=n;s<i;s++)t=t>>>8^r[255&(t^e[s])];return~t},q={2:\\\"need dictionary\\\",1:\\\"stream end\\\",0:\\\"\\\",\\\"-1\\\":\\\"file error\\\",\\\"-2\\\":\\\"stream error\\\",\\\"-3\\\":\\\"data error\\\",\\\"-4\\\":\\\"insufficient memory\\\",\\\"-5\\\":\\\"buffer error\\\",\\\"-6\\\":\\\"incompatible version\\\"},F=0,G=2,J=3,P=4,Q=0,V=1,W=-1,X=0,Y=8,Z=R._tr_init,$=R._tr_stored_block,tt=R._tr_flush_block,et=R._tr_tally,at=R._tr_align,nt=F,rt=1,it=J,st=P,ht=5,lt=Q,_t=V,ot=-2,dt=-3,ut=-5,ft=W,ct=1,pt=2,gt=3,wt=4,vt=X,bt=2,mt=Y,yt=258,kt=262,zt=103,xt=113,At=666,Ut=function(t,e){return t.msg=q[e],e},It=function(t){return(t<<1)-(t>4?9:0)},Bt=function(t){for(var e=t.length;--e>=0;)t[e]=0},Et=function(t,e,a){return(e<<t.hash_shift^a)&t.hash_mask},St=function(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},Ct=function(t,e){tt(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,St(t.strm)},Dt=function(t,e){t.pending_buf[t.pending++]=e},jt=function(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},Mt=function(t,e){var a,n,r=t.max_chain_length,i=t.strstart,s=t.prev_length,h=t.nice_match,l=t.strstart>t.w_size-kt?t.strstart-(t.w_size-kt):0,_=t.window,o=t.w_mask,d=t.prev,u=t.strstart+yt,f=_[i+s-1],c=_[i+s];t.prev_length>=t.good_match&&(r>>=2),h>t.lookahead&&(h=t.lookahead);do{if(_[(a=e)+s]===c&&_[a+s-1]===f&&_[a]===_[i]&&_[++a]===_[i+1]){i+=2,a++;do{}while(_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&i<u);if(n=yt-(u-i),i=u-yt,n>s){if(t.match_start=e,s=n,n>=h)break;f=_[i+s-1],c=_[i+s]}}}while((e=d[e&o])>l&&0!=--r);return s<=t.lookahead?s:t.lookahead},Lt=function(t){var e,a,n,r,i,s,h,l,_,o,d=t.w_size;do{if(r=t.window_size-t.lookahead-t.strstart,t.strstart>=d+(d-kt)){t.window.set(t.window.subarray(d,d+d),0),t.match_start-=d,t.strstart-=d,t.block_start-=d,e=a=t.hash_size;do{n=t.head[--e],t.head[e]=n>=d?n-d:0}while(--a);e=a=d;do{n=t.prev[--e],t.prev[e]=n>=d?n-d:0}while(--a);r+=d}if(0===t.strm.avail_in)break;if(s=t.strm,h=t.window,l=t.strstart+t.lookahead,_=r,o=void 0,(o=s.avail_in)>_&&(o=_),a=0===o?0:(s.avail_in-=o,h.set(s.input.subarray(s.next_in,s.next_in+o),l),1===s.state.wrap?s.adler=K(s.adler,h,o,l):2===s.state.wrap&&(s.adler=O(s.adler,h,o,l)),s.next_in+=o,s.total_in+=o,o),t.lookahead+=a,t.lookahead+t.insert>=3)for(i=t.strstart-t.insert,t.ins_h=t.window[i],t.ins_h=Et(t,t.ins_h,t.window[i+1]);t.insert&&(t.ins_h=Et(t,t.ins_h,t.window[i+3-1]),t.prev[i&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=i,i++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<kt&&0!==t.strm.avail_in)},Tt=function(t,e){for(var a,n;;){if(t.lookahead<kt){if(Lt(t),t.lookahead<kt&&e===nt)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-kt&&(t.match_length=Mt(t,a)),t.match_length>=3)if(n=et(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=Et(t,t.ins_h,t.window[t.strstart+1]);else n=et(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2},Ht=function(t,e){for(var a,n,r;;){if(t.lookahead<kt){if(Lt(t),t.lookahead<kt&&e===nt)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-kt&&(t.match_length=Mt(t,a),t.match_length<=5&&(t.strategy===ct||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,n=et(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,n&&(Ct(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if((n=et(t,0,t.window[t.strstart-1]))&&Ct(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=et(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2};function Rt(t,e,a,n,r){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=n,this.func=r}var Kt=[new Rt(0,0,0,0,(function(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(Lt(t),0===t.lookahead&&e===nt)return 1;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var n=t.block_start+a;if((0===t.strstart||t.strstart>=n)&&(t.lookahead=t.strstart-n,t.strstart=n,Ct(t,!1),0===t.strm.avail_out))return 1;if(t.strstart-t.block_start>=t.w_size-kt&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):(t.strstart>t.block_start&&(Ct(t,!1),t.strm.avail_out),1)})),new Rt(4,4,8,4,Tt),new Rt(4,5,16,8,Tt),new Rt(4,6,32,32,Tt),new Rt(4,4,16,16,Ht),new Rt(8,16,32,32,Ht),new Rt(8,16,128,128,Ht),new Rt(8,32,128,256,Ht),new Rt(32,128,258,1024,Ht),new Rt(32,258,258,4096,Ht)];function Nt(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=mt,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),Bt(this.dyn_ltree),Bt(this.dyn_dtree),Bt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),Bt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),Bt(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}var Ot=function(t){if(!t||!t.state)return Ut(t,ot);t.total_in=t.total_out=0,t.data_type=bt;var e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?42:xt,t.adler=2===e.wrap?0:1,e.last_flush=nt,Z(e),lt},qt=function(t){var e,a=Ot(t);return a===lt&&((e=t.state).window_size=2*e.w_size,Bt(e.head),e.max_lazy_match=Kt[e.level].max_lazy,e.good_match=Kt[e.level].good_length,e.nice_match=Kt[e.level].nice_length,e.max_chain_length=Kt[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0),a},Ft=function(t,e,a,n,r,i){if(!t)return ot;var s=1;if(e===ft&&(e=6),n<0?(s=0,n=-n):n>15&&(s=2,n-=16),r<1||r>9||a!==mt||n<8||n>15||e<0||e>9||i<0||i>wt)return Ut(t,ot);8===n&&(n=9);var h=new Nt;return t.state=h,h.strm=t,h.wrap=s,h.gzhead=null,h.w_bits=n,h.w_size=1<<h.w_bits,h.w_mask=h.w_size-1,h.hash_bits=r+7,h.hash_size=1<<h.hash_bits,h.hash_mask=h.hash_size-1,h.hash_shift=~~((h.hash_bits+3-1)/3),h.window=new Uint8Array(2*h.w_size),h.head=new Uint16Array(h.hash_size),h.prev=new Uint16Array(h.w_size),h.lit_bufsize=1<<r+6,h.pending_buf_size=4*h.lit_bufsize,h.pending_buf=new Uint8Array(h.pending_buf_size),h.d_buf=1*h.lit_bufsize,h.l_buf=3*h.lit_bufsize,h.level=e,h.strategy=i,h.method=a,qt(t)},Gt={deflateInit:function(t,e){return Ft(t,e,mt,15,8,vt)},deflateInit2:Ft,deflateReset:qt,deflateResetKeep:Ot,deflateSetHeader:function(t,e){return t&&t.state?2!==t.state.wrap?ot:(t.state.gzhead=e,lt):ot},deflate:function(t,e){var a,n;if(!t||!t.state||e>ht||e<0)return t?Ut(t,ot):ot;var r=t.state;if(!t.output||!t.input&&0!==t.avail_in||r.status===At&&e!==st)return Ut(t,0===t.avail_out?ut:ot);r.strm=t;var i=r.last_flush;if(r.last_flush=e,42===r.status)if(2===r.wrap)t.adler=0,Dt(r,31),Dt(r,139),Dt(r,8),r.gzhead?(Dt(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),Dt(r,255&r.gzhead.time),Dt(r,r.gzhead.time>>8&255),Dt(r,r.gzhead.time>>16&255),Dt(r,r.gzhead.time>>24&255),Dt(r,9===r.level?2:r.strategy>=pt||r.level<2?4:0),Dt(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(Dt(r,255&r.gzhead.extra.length),Dt(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(t.adler=O(t.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69):(Dt(r,0),Dt(r,0),Dt(r,0),Dt(r,0),Dt(r,0),Dt(r,9===r.level?2:r.strategy>=pt||r.level<2?4:0),Dt(r,3),r.status=xt);else{var s=mt+(r.w_bits-8<<4)<<8;s|=(r.strategy>=pt||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6,0!==r.strstart&&(s|=32),s+=31-s%31,r.status=xt,jt(r,s),0!==r.strstart&&(jt(r,t.adler>>>16),jt(r,65535&t.adler)),t.adler=1}if(69===r.status)if(r.gzhead.extra){for(a=r.pending;r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),St(t),a=r.pending,r.pending!==r.pending_buf_size));)Dt(r,255&r.gzhead.extra[r.gzindex]),r.gzindex++;r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),r.gzindex===r.gzhead.extra.length&&(r.gzindex=0,r.status=73)}else r.status=73;if(73===r.status)if(r.gzhead.name){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),St(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,Dt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.gzindex=0,r.status=91)}else r.status=91;if(91===r.status)if(r.gzhead.comment){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),St(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,Dt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.status=zt)}else r.status=zt;if(r.status===zt&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&St(t),r.pending+2<=r.pending_buf_size&&(Dt(r,255&t.adler),Dt(r,t.adler>>8&255),t.adler=0,r.status=xt)):r.status=xt),0!==r.pending){if(St(t),0===t.avail_out)return r.last_flush=-1,lt}else if(0===t.avail_in&&It(e)<=It(i)&&e!==st)return Ut(t,ut);if(r.status===At&&0!==t.avail_in)return Ut(t,ut);if(0!==t.avail_in||0!==r.lookahead||e!==nt&&r.status!==At){var h=r.strategy===pt?function(t,e){for(var a;;){if(0===t.lookahead&&(Lt(t),0===t.lookahead)){if(e===nt)return 1;break}if(t.match_length=0,a=et(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2}(r,e):r.strategy===gt?function(t,e){for(var a,n,r,i,s=t.window;;){if(t.lookahead<=yt){if(Lt(t),t.lookahead<=yt&&e===nt)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=s[r=t.strstart-1])===s[++r]&&n===s[++r]&&n===s[++r]){i=t.strstart+yt;do{}while(n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&r<i);t.match_length=yt-(i-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=et(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=et(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2}(r,e):Kt[r.level].func(r,e);if(3!==h&&4!==h||(r.status=At),1===h||3===h)return 0===t.avail_out&&(r.last_flush=-1),lt;if(2===h&&(e===rt?at(r):e!==ht&&($(r,0,0,!1),e===it&&(Bt(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),St(t),0===t.avail_out))return r.last_flush=-1,lt}return e!==st?lt:r.wrap<=0?_t:(2===r.wrap?(Dt(r,255&t.adler),Dt(r,t.adler>>8&255),Dt(r,t.adler>>16&255),Dt(r,t.adler>>24&255),Dt(r,255&t.total_in),Dt(r,t.total_in>>8&255),Dt(r,t.total_in>>16&255),Dt(r,t.total_in>>24&255)):(jt(r,t.adler>>>16),jt(r,65535&t.adler)),St(t),r.wrap>0&&(r.wrap=-r.wrap),0!==r.pending?lt:_t)},deflateEnd:function(t){if(!t||!t.state)return ot;var e=t.state.status;return 42!==e&&69!==e&&73!==e&&91!==e&&e!==zt&&e!==xt&&e!==At?Ut(t,ot):(t.state=null,e===xt?Ut(t,dt):lt)},deflateSetDictionary:function(t,e){var a=e.length;if(!t||!t.state)return ot;var n=t.state,r=n.wrap;if(2===r||1===r&&42!==n.status||n.lookahead)return ot;if(1===r&&(t.adler=K(t.adler,e,a,0)),n.wrap=0,a>=n.w_size){0===r&&(Bt(n.head),n.strstart=0,n.block_start=0,n.insert=0);var i=new Uint8Array(n.w_size);i.set(e.subarray(a-n.w_size,a),0),e=i,a=n.w_size}var s=t.avail_in,h=t.next_in,l=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,Lt(n);n.lookahead>=3;){var _=n.strstart,o=n.lookahead-2;do{n.ins_h=Et(n,n.ins_h,n.window[_+3-1]),n.prev[_&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=_,_++}while(--o);n.strstart=_,n.lookahead=2,Lt(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,t.next_in=h,t.input=l,t.avail_in=s,n.wrap=r,lt},deflateInfo:\\\"pako deflate (from Nodeca project)\\\"};for(var Jt=new Uint8Array(256),Pt=0;Pt<256;Pt++)Jt[Pt]=Pt>=252?6:Pt>=248?5:Pt>=240?4:Pt>=224?3:Pt>=192?2:1;Jt[254]=Jt[254]=1;var Qt=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\\\"\\\",this.state=null,this.data_type=2,this.adler=0},Vt=Object.prototype.toString,Wt=F,Xt=G,Yt=J,Zt=P,$t=Q,te=V,ee=W,ae=X,ne=Y;function re(){this.options={level:ee,method:ne,chunkSize:16384,windowBits:15,memLevel:8,strategy:ae};var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new Qt,this.strm.avail_out=0;var e=Gt.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(e!==$t)throw new Error(q[e]);if(t.header&&Gt.deflateSetHeader(this.strm,t.header),t.dictionary){var a;if(a=\\\"[object ArrayBuffer]\\\"===Vt.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(e=Gt.deflateSetDictionary(this.strm,a))!==$t)throw new Error(q[e]);this._dict_set=!0}}function ie(t,e,a){try{t.postMessage({type:\\\"errored\\\",error:e,streamId:a})}catch(n){t.postMessage({type:\\\"errored\\\",error:String(e),streamId:a})}}function se(t){var e=t.strm.adler;return new Uint8Array([3,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e])}re.prototype.push=function(t,e){var a,n,r=this.strm,i=this.options.chunkSize;if(this.ended)return!1;for(n=e===~~e?e:!0===e?Zt:Wt,\\\"[object ArrayBuffer]\\\"===Vt.call(t)?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(i),r.next_out=0,r.avail_out=i),(n===Xt||n===Yt)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if((a=Gt.deflate(r,n))===te)return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),a=Gt.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===$t;if(0!==r.avail_out){if(n>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},re.prototype.onData=function(t){this.chunks.push(t)},re.prototype.onEnd=function(t){t===$t&&(this.result=function(t){for(var e=0,a=0,n=t.length;a<n;a++)e+=t[a].length;for(var r=new Uint8Array(e),i=0,s=0,h=t.length;i<h;i++){var l=t[i];r.set(l,s),s+=l.length}return r}(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},function(e){void 0===e&&(e=self);try{var a=new Map;e.addEventListener(\\\"message\\\",(function(n){try{var r=function(e,a){switch(a.action){case\\\"init\\\":return{type:\\\"initialized\\\",version:\\\"5.35.1\\\"};case\\\"write\\\":var n=e.get(a.streamId);n||(n=new re,e.set(a.streamId,n));var r=n.chunks.length,i=function(t){if(\\\"function\\\"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);var e,a,n,r,i,s=t.length,h=0;for(r=0;r<s;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),h+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(h),i=0,r=0;i<h;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),a<128?e[i++]=a:a<2048?(e[i++]=192|a>>>6,e[i++]=128|63&a):a<65536?(e[i++]=224|a>>>12,e[i++]=128|a>>>6&63,e[i++]=128|63&a):(e[i++]=240|a>>>18,e[i++]=128|a>>>12&63,e[i++]=128|a>>>6&63,e[i++]=128|63&a);return e}(a.data);return n.push(i,G),{type:\\\"wrote\\\",id:a.id,streamId:a.streamId,result:t(n.chunks.slice(r)),trailer:se(n),additionalBytesCount:i.length};case\\\"reset\\\":e.delete(a.streamId)}}(a,n.data);r&&e.postMessage(r)}catch(t){ie(e,t,n.data&&\\\"streamId\\\"in n.data?n.data.streamId:void 0)}}))}catch(t){ie(e,t)}}()}();\"])));\n}\nvar state = { status: 0 /* DeflateWorkerStatus.Nil */ };\nexport function startDeflateWorker(configuration, source, onInitializationFailure, createDeflateWorkerImpl) {\n    if (createDeflateWorkerImpl === void 0) { createDeflateWorkerImpl = createDeflateWorker; }\n    if (state.status === 0 /* DeflateWorkerStatus.Nil */) {\n        // doStartDeflateWorker updates the state to \"loading\" or \"error\"\n        doStartDeflateWorker(configuration, source, createDeflateWorkerImpl);\n    }\n    switch (state.status) {\n        case 1 /* DeflateWorkerStatus.Loading */:\n            state.initializationFailureCallbacks.push(onInitializationFailure);\n            return state.worker;\n        case 3 /* DeflateWorkerStatus.Initialized */:\n            return state.worker;\n    }\n}\nexport function resetDeflateWorkerState() {\n    if (state.status === 3 /* DeflateWorkerStatus.Initialized */ || state.status === 1 /* DeflateWorkerStatus.Loading */) {\n        state.stop();\n    }\n    state = { status: 0 /* DeflateWorkerStatus.Nil */ };\n}\nexport function getDeflateWorkerStatus() {\n    return state.status;\n}\n/**\n * Starts the deflate worker and handle messages and errors\n *\n * The spec allow browsers to handle worker errors differently:\n * - Chromium throws an exception\n * - Firefox fires an error event\n *\n * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2\n */\nexport function doStartDeflateWorker(configuration, source, createDeflateWorkerImpl) {\n    if (createDeflateWorkerImpl === void 0) { createDeflateWorkerImpl = createDeflateWorker; }\n    try {\n        var worker = createDeflateWorkerImpl(configuration);\n        var removeErrorListener_1 = addEventListener(configuration, worker, 'error', function (error) {\n            onError(configuration, source, error);\n        }).stop;\n        var removeMessageListener_1 = addEventListener(configuration, worker, 'message', function (_a) {\n            var data = _a.data;\n            if (data.type === 'errored') {\n                onError(configuration, source, data.error, data.streamId);\n            }\n            else if (data.type === 'initialized') {\n                onInitialized(data.version);\n            }\n        }).stop;\n        worker.postMessage({ action: 'init' });\n        setTimeout(function () { return onTimeout(source); }, INITIALIZATION_TIME_OUT_DELAY);\n        var stop_1 = function () {\n            removeErrorListener_1();\n            removeMessageListener_1();\n        };\n        state = { status: 1 /* DeflateWorkerStatus.Loading */, worker: worker, stop: stop_1, initializationFailureCallbacks: [] };\n    }\n    catch (error) {\n        onError(configuration, source, error);\n    }\n}\nfunction onTimeout(source) {\n    if (state.status === 1 /* DeflateWorkerStatus.Loading */) {\n        display.error(\"\".concat(source, \" failed to start: a timeout occurred while initializing the Worker\"));\n        state.initializationFailureCallbacks.forEach(function (callback) { return callback(); });\n        state = { status: 2 /* DeflateWorkerStatus.Error */ };\n    }\n}\nfunction onInitialized(version) {\n    if (state.status === 1 /* DeflateWorkerStatus.Loading */) {\n        state = { status: 3 /* DeflateWorkerStatus.Initialized */, worker: state.worker, stop: state.stop, version: version };\n    }\n}\nfunction onError(configuration, source, error, streamId) {\n    if (state.status === 1 /* DeflateWorkerStatus.Loading */ || state.status === 0 /* DeflateWorkerStatus.Nil */) {\n        display.error(\"\".concat(source, \" failed to start: an error occurred while creating the Worker:\"), error);\n        if (error instanceof Event || (error instanceof Error && isMessageCspRelated(error.message))) {\n            var baseMessage = void 0;\n            if (configuration.workerUrl) {\n                baseMessage = \"Please make sure the Worker URL \".concat(configuration.workerUrl, \" is correct and CSP is correctly configured.\");\n            }\n            else {\n                baseMessage = 'Please make sure CSP is correctly configured.';\n            }\n            display.error(\"\".concat(baseMessage, \" See documentation at \").concat(DOCS_ORIGIN, \"/integrations/content_security_policy_logs/#use-csp-with-real-user-monitoring-and-session-replay\"));\n        }\n        else {\n            addTelemetryError(error);\n        }\n        if (state.status === 1 /* DeflateWorkerStatus.Loading */) {\n            state.initializationFailureCallbacks.forEach(function (callback) { return callback(); });\n        }\n        state = { status: 2 /* DeflateWorkerStatus.Error */ };\n    }\n    else {\n        addTelemetryError(error, {\n            worker_version: state.status === 3 /* DeflateWorkerStatus.Initialized */ && state.version,\n            stream_id: streamId,\n        });\n    }\n}\nfunction isMessageCspRelated(message) {\n    return (includes(message, 'Content Security Policy') ||\n        // Related to `require-trusted-types-for` CSP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted-types-for\n        includes(message, \"requires 'TrustedScriptURL'\"));\n}\n//# sourceMappingURL=deflateWorker.js.map","export { createDeflateEncoder } from './deflateEncoder';\nexport { startDeflateWorker, getDeflateWorkerStatus, resetDeflateWorkerState, } from './deflateWorker';\n//# sourceMappingURL=index.js.map","/**\n * Test for Browser features used while recording\n */\nexport function isBrowserSupported() {\n    return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' &&\n        typeof CSSSupportsRule === 'function' &&\n        typeof URL.createObjectURL === 'function' &&\n        'forEach' in NodeList.prototype);\n}\n//# sourceMappingURL=isBrowserSupported.js.map","import { getSessionReplayUrl } from '@datadog/browser-rum-core';\nimport { isBrowserSupported } from '../boot/isBrowserSupported';\nexport function getSessionReplayLink(configuration, sessionManager, viewHistory, isRecordingStarted) {\n    var session = sessionManager.findTrackedSession();\n    var errorType = getErrorType(session, isRecordingStarted);\n    var viewContext = viewHistory.findView();\n    return getSessionReplayUrl(configuration, {\n        viewContext: viewContext,\n        errorType: errorType,\n        session: session,\n    });\n}\nfunction getErrorType(session, isRecordingStarted) {\n    if (!isBrowserSupported()) {\n        return 'browser-not-supported';\n    }\n    if (!session) {\n        // possibilities:\n        // - rum sampled out\n        // - session expired (edge case)\n        return 'rum-not-tracked';\n    }\n    if (session.sessionReplay === 0 /* SessionReplayState.OFF */) {\n        // possibilities\n        // - replay sampled out\n        return 'incorrect-session-plan';\n    }\n    if (!isRecordingStarted) {\n        return 'replay-not-started';\n    }\n}\n//# sourceMappingURL=getSessionReplayLink.js.map","import { PageExitReason, runOnReadyState } from '@datadog/browser-core';\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink';\nexport function createPostStartStrategy(configuration, lifeCycle, sessionManager, viewHistory, startRecordingImpl, getOrCreateDeflateEncoder) {\n    var status = 0 /* RecorderStatus.Stopped */;\n    lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, function () {\n        if (status === 2 /* RecorderStatus.Starting */ || status === 3 /* RecorderStatus.Started */) {\n            stop();\n            status = 1 /* RecorderStatus.IntentToStart */;\n        }\n    });\n    // Stop the recorder on page unload to avoid sending records after the page is ended.\n    lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, function (pageExitEvent) {\n        if (pageExitEvent.reason === PageExitReason.UNLOADING) {\n            stop();\n        }\n    });\n    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, function () {\n        if (status === 1 /* RecorderStatus.IntentToStart */) {\n            start();\n        }\n    });\n    function start(options) {\n        var session = sessionManager.findTrackedSession();\n        if (canStartRecording(session, options)) {\n            status = 1 /* RecorderStatus.IntentToStart */;\n            return;\n        }\n        if (isRecordingInProgress(status)) {\n            return;\n        }\n        status = 2 /* RecorderStatus.Starting */;\n        runOnReadyState(configuration, 'interactive', function () {\n            if (status !== 2 /* RecorderStatus.Starting */) {\n                return;\n            }\n            var deflateEncoder = getOrCreateDeflateEncoder();\n            if (!deflateEncoder) {\n                status = 0 /* RecorderStatus.Stopped */;\n                return;\n            }\n            ;\n            (stopRecording = startRecordingImpl(lifeCycle, configuration, sessionManager, viewHistory, deflateEncoder).stop);\n            status = 3 /* RecorderStatus.Started */;\n        });\n        if (shouldForceReplay(session, options)) {\n            sessionManager.setForcedReplay();\n        }\n    }\n    function stop() {\n        if (status !== 0 /* RecorderStatus.Stopped */ && status === 3 /* RecorderStatus.Started */) {\n            stopRecording === null || stopRecording === void 0 ? void 0 : stopRecording();\n        }\n        status = 0 /* RecorderStatus.Stopped */;\n    }\n    var stopRecording;\n    return {\n        start: start,\n        stop: stop,\n        getSessionReplayLink: function () {\n            return getSessionReplayLink(configuration, sessionManager, viewHistory, status !== 0 /* RecorderStatus.Stopped */);\n        },\n        isRecording: function () { return status === 3 /* RecorderStatus.Started */; },\n    };\n}\nfunction canStartRecording(session, options) {\n    return !session || (session.sessionReplay === 0 /* SessionReplayState.OFF */ && (!options || !options.force));\n}\nfunction isRecordingInProgress(status) {\n    return status === 2 /* RecorderStatus.Starting */ || status === 3 /* RecorderStatus.Started */;\n}\nfunction shouldForceReplay(session, options) {\n    return options && options.force && session.sessionReplay === 0 /* SessionReplayState.OFF */;\n}\n//# sourceMappingURL=postStartStrategy.js.map","import { noop } from '@datadog/browser-core';\nexport function createPreStartStrategy() {\n    var status = 0 /* PreStartRecorderStatus.None */;\n    return {\n        strategy: {\n            start: function () {\n                status = 1 /* PreStartRecorderStatus.HadManualStart */;\n            },\n            stop: function () {\n                status = 2 /* PreStartRecorderStatus.HadManualStop */;\n            },\n            isRecording: function () { return false; },\n            getSessionReplayLink: noop,\n        },\n        shouldStartImmediately: function (configuration) {\n            return (status === 1 /* PreStartRecorderStatus.HadManualStart */ ||\n                (status === 0 /* PreStartRecorderStatus.None */ && !configuration.startSessionReplayRecordingManually));\n        },\n    };\n}\n//# sourceMappingURL=preStartStrategy.js.map","import { canUseEventBridge, noop, bridgeSupports, } from '@datadog/browser-core';\nimport { getReplayStats as getReplayStatsImpl } from '../domain/replayStats';\nimport { createDeflateEncoder, getDeflateWorkerStatus, startDeflateWorker, } from '../domain/deflate';\nimport { isBrowserSupported } from './isBrowserSupported';\nimport { createPostStartStrategy } from './postStartStrategy';\nimport { createPreStartStrategy } from './preStartStrategy';\nexport function makeRecorderApi(startRecordingImpl, createDeflateWorkerImpl) {\n    if ((canUseEventBridge() && !bridgeSupports(\"records\" /* BridgeCapability.RECORDS */)) || !isBrowserSupported()) {\n        return {\n            start: noop,\n            stop: noop,\n            getReplayStats: function () { return undefined; },\n            onRumStart: noop,\n            isRecording: function () { return false; },\n            getSessionReplayLink: function () { return undefined; },\n        };\n    }\n    // eslint-disable-next-line prefer-const\n    var _a = createPreStartStrategy(), strategy = _a.strategy, shouldStartImmediately = _a.shouldStartImmediately;\n    return {\n        start: function (options) { return strategy.start(options); },\n        stop: function () { return strategy.stop(); },\n        getSessionReplayLink: function () { return strategy.getSessionReplayLink(); },\n        onRumStart: onRumStart,\n        isRecording: function () {\n            // The worker is started optimistically, meaning we could have started to record but its\n            // initialization fails a bit later. This could happen when:\n            // * the worker URL (blob or plain URL) is blocked by CSP in Firefox only (Chromium and Safari\n            // throw an exception when instantiating the worker, and IE doesn't care about CSP)\n            // * the browser fails to load the worker in case the workerUrl is used\n            // * an unexpected error occurs in the Worker before initialization, ex:\n            //   * a runtime exception collected by monitor()\n            //   * a syntax error notified by the browser via an error event\n            // * the worker is unresponsive for some reason and timeouts\n            //\n            // It is not expected to happen often. Nonetheless, the \"replayable\" status on RUM events is\n            // an important part of the Datadog App:\n            // * If we have a false positive (we set has_replay: true even if no replay data is present),\n            // we might display broken links to the Session Replay player.\n            // * If we have a false negative (we don't set has_replay: true even if replay data is\n            // available), it is less noticeable because no link will be displayed.\n            //\n            // Thus, it is better to have false negative, so let's make sure the worker is correctly\n            // initialized before advertizing that we are recording.\n            //\n            // In the future, when the compression worker will also be used for RUM data, this will be\n            // less important since no RUM event will be sent when the worker fails to initialize.\n            return getDeflateWorkerStatus() === 3 /* DeflateWorkerStatus.Initialized */ && strategy.isRecording();\n        },\n        getReplayStats: function (viewId) {\n            return getDeflateWorkerStatus() === 3 /* DeflateWorkerStatus.Initialized */ ? getReplayStatsImpl(viewId) : undefined;\n        },\n    };\n    function onRumStart(lifeCycle, configuration, sessionManager, viewHistory, worker) {\n        var cachedDeflateEncoder;\n        function getOrCreateDeflateEncoder() {\n            if (!cachedDeflateEncoder) {\n                worker !== null && worker !== void 0 ? worker : (worker = startDeflateWorker(configuration, 'Datadog Session Replay', function () {\n                    strategy.stop();\n                }, createDeflateWorkerImpl));\n                if (worker) {\n                    cachedDeflateEncoder = createDeflateEncoder(configuration, worker, 1 /* DeflateEncoderStreamId.REPLAY */);\n                }\n            }\n            return cachedDeflateEncoder;\n        }\n        strategy = createPostStartStrategy(configuration, lifeCycle, sessionManager, viewHistory, startRecordingImpl, getOrCreateDeflateEncoder);\n        if (shouldStartImmediately(configuration)) {\n            strategy.start();\n        }\n    }\n}\n//# sourceMappingURL=recorderApi.js.map","// Keep the following in sync with packages/rum-slim/src/entries/main.ts\nimport { defineGlobal, getGlobalObject } from '@datadog/browser-core';\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core';\nimport { startRecording } from '../boot/startRecording';\nimport { makeRecorderApi } from '../boot/recorderApi';\nimport { createDeflateEncoder, startDeflateWorker } from '../domain/deflate';\nexport { DefaultPrivacyLevel } from '@datadog/browser-core';\nvar recorderApi = makeRecorderApi(startRecording);\nexport var datadogRum = makeRumPublicApi(startRum, recorderApi, { startDeflateWorker: startDeflateWorker, createDeflateEncoder: createDeflateEncoder });\ndefineGlobal(getGlobalObject(), 'DD_RUM', datadogRum);\n//# sourceMappingURL=main.js.map","// Cache utility stub\r\n// TODO: Implement proper caching after migration\r\n\r\nexport interface CacheInterface {\r\n  get(key: string): Promise<any>;\r\n  set(key: string, value: any, ttl?: number): Promise<void>;\r\n  delete(key: string): Promise<void>;\r\n  clear(): Promise<void>;\r\n}\r\n\r\nclass MemoryCache implements CacheInterface {\r\n  private store = new Map<string, { value: any; expires?: number }>();\r\n\r\n  async get(key: string): Promise<any> {\r\n    const item = this.store.get(key);\r\n    if (!item) return null;\r\n\r\n    if (item.expires && Date.now() > item.expires) {\r\n      this.store.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return item.value;\r\n  }\r\n\r\n  async set(key: string, value: any, ttl?: number): Promise<void> {\r\n    const expires = ttl ? Date.now() + ttl * 1000 : undefined;\r\n    this.store.set(key, { value, expires });\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    this.store.delete(key);\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    this.store.clear();\r\n  }\r\n}\r\n\r\nexport const cache = new MemoryCache();\r\n","import { datadogRum } from '@datadog/browser-rum';\r\n\r\nimport { cache } from '../cache';\r\nimport { getSupabaseClient } from '../supabase/client';\r\n\r\nconst EVENT_BATCH_SIZE = 50;\r\nconst EVENT_BATCH_INTERVAL = 5000; // 5 seconds\r\nconst PERFORMANCE_SAMPLE_RATE = 0.1; // 10% of requests\r\n\r\n// Event queue for batching\r\nlet eventQueue: AnalyticsEvent[] = [];\r\nlet batchTimeout: NodeJS.Timeout | null = null;\r\n\r\n// Initialize monitoring\r\nexport function initializeMonitoring() {\r\n  if (process.env.NEXT_PUBLIC_DATADOG_APP_ID && process.env.NEXT_PUBLIC_DATADOG_CLIENT_TOKEN) {\r\n    datadogRum.init({\r\n      applicationId: process.env.NEXT_PUBLIC_DATADOG_APP_ID,\r\n      clientToken: process.env.NEXT_PUBLIC_DATADOG_CLIENT_TOKEN,\r\n      site: 'datadoghq.com',\r\n      service: 'hijraah',\r\n      env: process.env.NODE_ENV,\r\n      sessionSampleRate: 100,\r\n      sessionReplaySampleRate: 20,\r\n      trackUserInteractions: true,\r\n      trackResources: true,\r\n      trackLongTasks: true,\r\n      defaultPrivacyLevel: 'mask-user-input',\r\n      allowedTracingUrls: [\r\n        process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\r\n        'https://hijraah.vercel.app',\r\n      ],\r\n    });\r\n  }\r\n\r\n  // Start event batch processing\r\n  processBatchedEvents();\r\n}\r\n\r\n// Analytics event types\r\nexport type AnalyticsEvent = {\r\n  name: string;\r\n  properties?: Record<string, unknown>;\r\n  userId?: string;\r\n  timestamp?: string;\r\n  sessionId?: string;\r\n};\r\n\r\n// Process batched events\r\nasync function processBatchedEvents() {\r\n  if (batchTimeout) {\r\n    clearTimeout(batchTimeout);\r\n  }\r\n\r\n  if (eventQueue.length === 0) {\r\n    batchTimeout = setTimeout(processBatchedEvents, EVENT_BATCH_INTERVAL);\r\n    return;\r\n  }\r\n\r\n  const events = eventQueue.splice(0, EVENT_BATCH_SIZE);\r\n  \r\n  try {\r\n    const supabase = await getSupabaseClient();\r\n    await supabase.from('analytics_events').insert(\r\n      events.map(event => ({\r\n        event_name: event.name,\r\n        properties: event.properties,\r\n        user_id: event.userId,\r\n        timestamp: event.timestamp || new Date().toISOString(),\r\n        session_id: event.sessionId,\r\n      }))\r\n    );\r\n  } catch (error) {\r\n    console.error('Failed to process event batch:', error);\r\n    // Re-queue failed events\r\n    eventQueue = [...events, ...eventQueue];\r\n  }\r\n\r\n  batchTimeout = setTimeout(processBatchedEvents, EVENT_BATCH_INTERVAL);\r\n}\r\n\r\n// Track analytics event\r\nexport async function trackEvent(event: AnalyticsEvent) {\r\n  try {\r\n    const context = datadogRum.getInternalContext();\r\n    // Add to Datadog\r\n    if (context) {\r\n      datadogRum.addAction(event.name, {\r\n        ...event.properties,\r\n        timestamp: event.timestamp,\r\n        session_id: event.sessionId,\r\n      });\r\n    }\r\n\r\n    // Add to batch queue\r\n    eventQueue.push({\r\n      ...event,\r\n      timestamp: event.timestamp || new Date().toISOString(),\r\n      sessionId: event.sessionId || context?.session_id,\r\n    });\r\n\r\n    // Process immediately if queue is full\r\n    if (eventQueue.length >= EVENT_BATCH_SIZE) {\r\n      processBatchedEvents();\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to track event:', error);\r\n  }\r\n}\r\n\r\n// Performance monitoring with sampling\r\nexport function startPerformanceTracking(name: string, options: {\r\n  sampleRate?: number;\r\n  threshold?: number;\r\n} = {}): () => void {\r\n  const shouldTrack = Math.random() < (options.sampleRate || PERFORMANCE_SAMPLE_RATE);\r\n  if (!shouldTrack) return () => {};\r\n\r\n  const startTime = performance.now();\r\n  const threshold = options.threshold || 1000; // 1 second default threshold\r\n\r\n  return () => {\r\n    const duration = performance.now() - startTime;\r\n    const context = datadogRum.getInternalContext();\r\n    \r\n    if (context) {\r\n      datadogRum.addTiming(name, duration);\r\n      \r\n      // Track slow operations\r\n      if (duration > threshold) {\r\n        trackEvent({\r\n          name: 'slow_operation',\r\n          properties: {\r\n            operation: name,\r\n            duration,\r\n            threshold,\r\n          },\r\n        });\r\n      }\r\n    }\r\n\r\n    // Cache performance metrics\r\n    try {\r\n      const cacheKey = `perf:${name}:${new Date().toISOString().split('T')[0]}`;\r\n      cache.get(cacheKey).then(existing => {\r\n        const metrics = existing ? JSON.parse(existing) : { count: 0, total: 0, max: 0 };\r\n        metrics.count++;\r\n        metrics.total += duration;\r\n        metrics.max = Math.max(metrics.max, duration);\r\n        cache.set(cacheKey, JSON.stringify(metrics), 86400); // 24 hours\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to cache performance metrics:', error);\r\n    }\r\n  };\r\n}\r\n\r\n// Enhanced error tracking\r\nexport function trackError(error: Error, context?: Record<string, unknown>) {\r\n  console.error(error);\r\n  const rumContext = datadogRum.getInternalContext();\r\n  \r\n  const errorContext = {\r\n    ...context,\r\n    stack: error.stack,\r\n    timestamp: new Date().toISOString(),\r\n    session_id: rumContext?.session_id,\r\n  };\r\n  \r\n  if (rumContext) {\r\n    datadogRum.addError(error, errorContext);\r\n  }\r\n\r\n  // Track in analytics\r\n  trackEvent({\r\n    name: 'error',\r\n    properties: {\r\n      error_name: error.name,\r\n      error_message: error.message,\r\n      ...errorContext,\r\n    },\r\n  });\r\n}\r\n\r\n// User session tracking with persistence\r\nexport function identifyUser(userId: string, traits?: Record<string, unknown>) {\r\n  const context = datadogRum.getInternalContext();\r\n  if (context) {\r\n    const sessionId = context.session_id;\r\n    \r\n    datadogRum.setUser({\r\n      id: userId,\r\n      session_id: sessionId,\r\n      ...traits,\r\n    });\r\n\r\n    // Track user identification\r\n    trackEvent({\r\n      name: 'user_identified',\r\n      userId,\r\n      sessionId,\r\n      properties: traits,\r\n    });\r\n  }\r\n}\r\n\r\n// Enhanced page view tracking\r\nexport function trackPageView(path: string, properties?: Record<string, unknown>) {\r\n  const startTime = performance.now();\r\n  \r\n  trackEvent({\r\n    name: 'page_view',\r\n    properties: {\r\n      path,\r\n      referrer: document.referrer,\r\n      user_agent: navigator.userAgent,\r\n      screen_size: `${window.innerWidth}x${window.innerHeight}`,\r\n      ...properties,\r\n    },\r\n  });\r\n\r\n  // Track page load performance\r\n  return () => {\r\n    const duration = performance.now() - startTime;\r\n    trackEvent({\r\n      name: 'page_load_complete',\r\n      properties: {\r\n        path,\r\n        duration,\r\n        ...properties,\r\n      },\r\n    });\r\n  };\r\n}\r\n\r\n// Feature usage tracking with metadata\r\nexport function trackFeatureUsage(featureName: string, properties?: Record<string, unknown>) {\r\n  const context = datadogRum.getInternalContext();\r\n  trackEvent({\r\n    name: 'feature_used',\r\n    properties: {\r\n      feature: featureName,\r\n      timestamp: new Date().toISOString(),\r\n      session_id: context?.session_id,\r\n      ...properties,\r\n    },\r\n  });\r\n} ","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar headers_exports = {};\n__export(headers_exports, {\n  CITY_HEADER_NAME: () => CITY_HEADER_NAME,\n  COUNTRY_HEADER_NAME: () => COUNTRY_HEADER_NAME,\n  EMOJI_FLAG_UNICODE_STARTING_POSITION: () => EMOJI_FLAG_UNICODE_STARTING_POSITION,\n  IP_HEADER_NAME: () => IP_HEADER_NAME,\n  LATITUDE_HEADER_NAME: () => LATITUDE_HEADER_NAME,\n  LONGITUDE_HEADER_NAME: () => LONGITUDE_HEADER_NAME,\n  POSTAL_CODE_HEADER_NAME: () => POSTAL_CODE_HEADER_NAME,\n  REGION_HEADER_NAME: () => REGION_HEADER_NAME,\n  REQUEST_ID_HEADER_NAME: () => REQUEST_ID_HEADER_NAME,\n  geolocation: () => geolocation,\n  ipAddress: () => ipAddress\n});\nmodule.exports = __toCommonJS(headers_exports);\nconst CITY_HEADER_NAME = \"x-vercel-ip-city\";\nconst COUNTRY_HEADER_NAME = \"x-vercel-ip-country\";\nconst IP_HEADER_NAME = \"x-real-ip\";\nconst LATITUDE_HEADER_NAME = \"x-vercel-ip-latitude\";\nconst LONGITUDE_HEADER_NAME = \"x-vercel-ip-longitude\";\nconst REGION_HEADER_NAME = \"x-vercel-ip-country-region\";\nconst POSTAL_CODE_HEADER_NAME = \"x-vercel-ip-postal-code\";\nconst REQUEST_ID_HEADER_NAME = \"x-vercel-id\";\nconst EMOJI_FLAG_UNICODE_STARTING_POSITION = 127397;\nfunction getHeader(headers, key) {\n  return headers.get(key) ?? void 0;\n}\nfunction getHeaderWithDecode(request, key) {\n  const header = getHeader(request.headers, key);\n  return header ? decodeURIComponent(header) : void 0;\n}\nfunction getFlag(countryCode) {\n  const regex = new RegExp(\"^[A-Z]{2}$\").test(countryCode);\n  if (!countryCode || !regex)\n    return void 0;\n  return String.fromCodePoint(\n    ...countryCode.split(\"\").map((char) => EMOJI_FLAG_UNICODE_STARTING_POSITION + char.charCodeAt(0))\n  );\n}\nfunction ipAddress(input) {\n  const headers = \"headers\" in input ? input.headers : input;\n  return getHeader(headers, IP_HEADER_NAME);\n}\nfunction getRegionFromRequestId(requestId) {\n  if (!requestId) {\n    return \"dev1\";\n  }\n  return requestId.split(\":\")[0];\n}\nfunction geolocation(request) {\n  return {\n    // city name may be encoded to support multi-byte characters\n    city: getHeaderWithDecode(request, CITY_HEADER_NAME),\n    country: getHeader(request.headers, COUNTRY_HEADER_NAME),\n    flag: getFlag(getHeader(request.headers, COUNTRY_HEADER_NAME)),\n    countryRegion: getHeader(request.headers, REGION_HEADER_NAME),\n    region: getRegionFromRequestId(\n      getHeader(request.headers, REQUEST_ID_HEADER_NAME)\n    ),\n    latitude: getHeader(request.headers, LATITUDE_HEADER_NAME),\n    longitude: getHeader(request.headers, LONGITUDE_HEADER_NAME),\n    postalCode: getHeader(request.headers, POSTAL_CODE_HEADER_NAME)\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  CITY_HEADER_NAME,\n  COUNTRY_HEADER_NAME,\n  EMOJI_FLAG_UNICODE_STARTING_POSITION,\n  IP_HEADER_NAME,\n  LATITUDE_HEADER_NAME,\n  LONGITUDE_HEADER_NAME,\n  POSTAL_CODE_HEADER_NAME,\n  REGION_HEADER_NAME,\n  REQUEST_ID_HEADER_NAME,\n  geolocation,\n  ipAddress\n});\n","module.exports = require(\"module\");","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar wait_until_exports = {};\n__export(wait_until_exports, {\n  waitUntil: () => waitUntil\n});\nmodule.exports = __toCommonJS(wait_until_exports);\nvar import_get_context = require(\"./get-context\");\nconst waitUntil = (promise) => {\n  if (promise === null || typeof promise !== \"object\" || typeof promise.then !== \"function\") {\n    throw new TypeError(\n      `waitUntil can only be called with a Promise, got ${typeof promise}`\n    );\n  }\n  return (0, import_get_context.getContext)().waitUntil?.(promise);\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  waitUntil\n});\n","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","module.exports = require(\"punycode\");","module.exports = require(\"process\");","/**\r\n * Utility functions for the application\r\n */\r\n\r\nimport { generateId as generateIdFromAI } from \"ai\"; // Renaming import to avoid conflict\r\nimport { genSaltSync, hashSync } from \"bcrypt-ts\";\r\nimport { type ClassValue, clsx } from \"clsx\";\r\nimport { customAlphabet } from \"nanoid\";\r\nimport { twMerge } from \"tailwind-merge\";\r\n\r\n/**\r\n * Utility function to merge Tailwind CSS classes with clsx conditionals\r\n * @param inputs - Class values to merge\r\n * @returns Merged class string\r\n */\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\n/**\r\n * Generates a unique ID of a specified length\r\n * @param length - Length of the ID to generate (default is 16)\r\n * @returns Generated ID\r\n */\r\nexport function generateId(length: number = 16) {\r\n  return customAlphabet(\r\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\r\n    length\r\n  )();\r\n}\r\n\r\n/**\r\n * Generates a UUID\r\n * @returns Generated UUID\r\n */\r\nexport function generateUUID(): string {\r\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\r\n    return crypto.randomUUID();\r\n  }\r\n  // Fallback for environments where crypto.randomUUID is not available (e.g., older Node.js versions in certain contexts)\r\n  // This is a simple v4 UUID implementation, not cryptographically secure for all uses but sufficient for unique IDs.\r\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\r\n    const r = (Math.random() * 16) | 0;\r\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\r\n    return v.toString(16);\r\n  });\r\n}\r\n\r\n/**\r\n * Formats a date into a readable string\r\n * @param date - The date to format\r\n * @returns Formatted date string\r\n */\r\nexport function formatDate(date: Date): string {\r\n  return new Intl.DateTimeFormat(\"en-US\", {\r\n    month: \"long\",\r\n    day: \"numeric\",\r\n    year: \"numeric\",\r\n  }).format(date);\r\n}\r\n\r\n/**\r\n * Truncates a string to a specified length\r\n * @param str - The string to truncate\r\n * @param length - Max length\r\n * @returns Truncated string with ellipsis if needed\r\n */\r\nexport function truncate(str: string, length: number): string {\r\n  if (!str || str.length <= length) return str;\r\n  return `${str.slice(0, length)}...`;\r\n}\r\n\r\n// Function to convert bytes to a readable format (KB, MB, GB)\r\nexport function bytesToSize(bytes: number): string {\r\n  if (bytes === 0) return \"0 Bytes\";\r\n  const k = 1024;\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\r\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\r\n}\r\n\r\n/**\r\n * Application specific error structure for fetcher\r\n */\r\ninterface ApplicationError extends Error {\r\n  info: string;\r\n  status: number;\r\n}\r\n\r\n/**\r\n * Fetches data from a URL and handles errors.\r\n * @param url - The URL to fetch.\r\n * @returns The JSON response.\r\n * @throws ApplicationError if the fetch fails.\r\n */\r\nexport const fetcher = async (url: string) => {\r\n  const res = await fetch(url);\r\n\r\n  if (!res.ok) {\r\n    const error = new Error(\r\n      \"An error occurred while fetching the data.\"\r\n    ) as ApplicationError;\r\n    // Attempt to parse error info, but don't fail if it's not JSON\r\n    try {\r\n      error.info = await res.json();\r\n    } catch (e) {\r\n      error.info = res.statusText; // Fallback to status text\r\n    }\r\n    error.status = res.status;\r\n    throw error;\r\n  }\r\n  return res.json();\r\n};\r\n\r\n/**\r\n * Retrieves an item from localStorage.\r\n * @param key - The key of the item to retrieve.\r\n * @returns The parsed JSON object or an empty array if not found or in a non-browser environment.\r\n */\r\nexport function getLocalStorage(key: string): any[] | Record<string, any> {\r\n  if (typeof window !== \"undefined\" && window.localStorage) {\r\n    const item = localStorage.getItem(key);\r\n    try {\r\n      return item ? JSON.parse(item) : []; // Default to empty array if null, or parse\r\n    } catch (error) {\r\n      console.error(\r\n        `Error parsing localStorage item with key \"${key}\":`,\r\n        error\r\n      );\r\n      return []; // Return empty array on parsing error\r\n    }\r\n  }\r\n  return []; // Return empty array if not in browser or localStorage not available\r\n}\r\n\r\n/**\r\n * Sanitizes text by removing specific placeholder strings.\r\n * Currently removes \"<has_function_call>\".\r\n * @param text - The input string to sanitize.\r\n * @returns The sanitized string.\r\n */\r\nexport function sanitizeText(text: string): string {\r\n  if (typeof text !== \"string\") return \"\";\r\n  return text.replace(/<has_function_call>/g, \"\");\r\n}\r\n\r\n/**\r\n * Sanitizes UI messages by cleaning their content.\r\n * Used to process messages before displaying them in the UI.\r\n * @param messages - Array of UI/Chat messages to sanitize\r\n * @returns The sanitized messages array\r\n */\r\nexport function sanitizeUIMessages<T extends { content: string }>(\r\n  messages: T[]\r\n): T[] {\r\n  return messages.map((message) => ({\r\n    ...message,\r\n    content: sanitizeText(message.content),\r\n  }));\r\n}\r\n\r\nexport function generateHashedPassword(password: string): string {\r\n  const salt = genSaltSync(10);\r\n  const hash = hashSync(password, salt);\r\n\r\n  return hash;\r\n}\r\n\r\nexport function generateDummyPassword(): string {\r\n  const password = generateIdFromAI(12); // Using the renamed import\r\n  const hashedPassword = generateHashedPassword(password);\r\n\r\n  return hashedPassword;\r\n}\r\n","// TEMPORARY STUB: OpenTelemetry dependencies temporarily disabled for build completion\r\n// TODO: Restore full OpenTelemetry functionality after migration cleanup\r\n\r\n// Stub types and interfaces to maintain API compatibility\r\ntype MockSpan = {\r\n  setAttributes: (attrs: any) => void;\r\n  setStatus: (status: any) => void;\r\n  recordException: (error: any) => void;\r\n  end: () => void;\r\n  spanContext: () => { traceId: string };\r\n};\r\n\r\ntype MockTracer = {\r\n  startSpan: (name: string, options?: any) => MockSpan;\r\n};\r\n\r\ntype MockMeter = {\r\n  createCounter: (\r\n    name: string,\r\n    options?: any\r\n  ) => { add: (value: number, attrs?: any) => void };\r\n  createHistogram: (\r\n    name: string,\r\n    options?: any\r\n  ) => { record: (value: number, attrs?: any) => void };\r\n};\r\n\r\n// Stub SpanKind enum\r\nexport const SpanKind = {\r\n  INTERNAL: 0,\r\n  SERVER: 1,\r\n  CLIENT: 2,\r\n  PRODUCER: 3,\r\n  CONSUMER: 4,\r\n} as const;\r\n\r\nexport const SpanStatusCode = {\r\n  OK: 1,\r\n  ERROR: 2,\r\n} as const;\r\n\r\n// Context7 - Observability: Distributed tracing configuration\r\ninterface TracingConfig {\r\n  serviceName: string;\r\n  serviceVersion: string;\r\n  environment: string;\r\n  enableConsoleExporter: boolean;\r\n  enableMetrics: boolean;\r\n  sampleRate: number;\r\n}\r\n\r\n// Context7 - Data-as-Code: Environment-driven configuration\r\nconst tracingConfig: TracingConfig = {\r\n  serviceName: process.env.OTEL_SERVICE_NAME || \"hijraah-chat-api\",\r\n  serviceVersion: process.env.OTEL_SERVICE_VERSION || \"1.0.0\",\r\n  environment: process.env.NODE_ENV || \"development\",\r\n  enableConsoleExporter: process.env.OTEL_CONSOLE_EXPORTER === \"true\",\r\n  enableMetrics: process.env.OTEL_METRICS_ENABLED !== \"false\",\r\n  sampleRate: parseFloat(process.env.OTEL_SAMPLE_RATE || \"1.0\"),\r\n};\r\n\r\n// Mock implementations\r\nlet initialized = false;\r\nlet tracer: MockTracer;\r\nlet meter: MockMeter;\r\n\r\nconst createMockSpan = (): MockSpan => ({\r\n  setAttributes: () => {},\r\n  setStatus: () => {},\r\n  recordException: () => {},\r\n  end: () => {},\r\n  spanContext: () => ({ traceId: `mock-trace-${Date.now()}` }),\r\n});\r\n\r\nconst createMockTracer = (): MockTracer => ({\r\n  startSpan: () => createMockSpan(),\r\n});\r\n\r\nconst createMockMeter = (): MockMeter => ({\r\n  createCounter: () => ({ add: () => {} }),\r\n  createHistogram: () => ({ record: () => {} }),\r\n});\r\n\r\n/**\r\n * Initialize OpenTelemetry SDK with Context7 configuration (STUBBED)\r\n */\r\nexport function initializeTracing(): void {\r\n  if (initialized) return;\r\n\r\n  tracer = createMockTracer();\r\n  meter = createMockMeter();\r\n  initialized = true;\r\n\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    console.log(\r\n      `[STUB] OpenTelemetry tracing disabled for ${tracingConfig.serviceName}`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Get tracer instance (STUBBED)\r\n */\r\nexport function getTracer() {\r\n  if (!initialized) {\r\n    initializeTracing();\r\n  }\r\n  return tracer;\r\n}\r\n\r\n/**\r\n * Get meter instance for metrics (STUBBED)\r\n */\r\nexport function getMeter() {\r\n  if (!initialized) {\r\n    initializeTracing();\r\n  }\r\n  return meter;\r\n}\r\n\r\n// Context7 - Observability: Custom metrics (STUBBED)\r\nexport const chatMetrics = {\r\n  requestCounter: getMeter().createCounter(\"chat_requests_total\", {\r\n    description: \"Total number of chat API requests\",\r\n  }),\r\n  requestDuration: getMeter().createHistogram(\"chat_request_duration_ms\", {\r\n    description: \"Duration of chat API requests in milliseconds\",\r\n  }),\r\n  tokenUsage: getMeter().createHistogram(\"chat_tokens_used\", {\r\n    description: \"Number of tokens used in chat completions\",\r\n  }),\r\n  authCounter: getMeter().createCounter(\"auth_attempts_total\", {\r\n    description: \"Total number of authentication attempts\",\r\n  }),\r\n  guestSessionCounter: getMeter().createCounter(\"guest_sessions_total\", {\r\n    description: \"Total number of guest sessions created\",\r\n  }),\r\n  errorCounter: getMeter().createCounter(\"errors_total\", {\r\n    description: \"Total number of errors by type\",\r\n  }),\r\n};\r\n\r\n/**\r\n * Context7 - Tracing: Enhanced span creation with standardized attributes\r\n */\r\nexport interface SpanOptions {\r\n  name: string;\r\n  kind?: (typeof SpanKind)[keyof typeof SpanKind];\r\n  attributes?: Record<string, string | number | boolean>;\r\n  userId?: string;\r\n  sessionId?: string;\r\n  chatId?: string;\r\n  isGuest?: boolean;\r\n}\r\n\r\n/**\r\n * Create a traced operation with Context7 compliance (STUBBED)\r\n */\r\nexport async function createTracedOperation<T>(\r\n  options: SpanOptions,\r\n  operation: (span: MockSpan) => Promise<T>\r\n): Promise<T> {\r\n  const span = createMockSpan();\r\n\r\n  try {\r\n    const result = await operation(span);\r\n    span.setStatus({ code: SpanStatusCode.OK });\r\n    return result;\r\n  } catch (error) {\r\n    span.recordException(\r\n      error instanceof Error ? error : new Error(String(error))\r\n    );\r\n    span.setStatus({\r\n      code: SpanStatusCode.ERROR,\r\n      message: error instanceof Error ? error.message : String(error),\r\n    });\r\n    throw error;\r\n  } finally {\r\n    span.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Context7 - Tracing: HTTP request tracing middleware (STUBBED)\r\n */\r\nexport function createHttpTraceMiddleware() {\r\n  return async (request: any, context: any, next: () => Promise<any>) => {\r\n    const pathname = new URL(request.url).pathname;\r\n\r\n    return createTracedOperation(\r\n      {\r\n        name: `HTTP ${request.method} ${pathname}`,\r\n        kind: SpanKind.SERVER,\r\n        attributes: {\r\n          \"http.method\": request.method,\r\n          \"http.url\": request.url,\r\n          \"http.route\": pathname,\r\n          \"http.user_agent\": request.headers.get(\"user-agent\") || \"\",\r\n          \"http.client_ip\":\r\n            request.headers.get(\"x-forwarded-for\") ||\r\n            request.headers.get(\"x-real-ip\") ||\r\n            \"\",\r\n        },\r\n      },\r\n      async (span) => {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n          const response = await next();\r\n          const duration = Date.now() - startTime;\r\n\r\n          // Mock metrics recording\r\n          chatMetrics.requestCounter.add(1, {\r\n            method: request.method,\r\n            route: pathname,\r\n            status: String(response.status || 200),\r\n          });\r\n\r\n          chatMetrics.requestDuration.record(duration, {\r\n            method: request.method,\r\n            route: pathname,\r\n          });\r\n\r\n          return response;\r\n        } catch (error) {\r\n          chatMetrics.errorCounter.add(1, {\r\n            error_type: error instanceof Error ? error.name : \"unknown\",\r\n            route: pathname,\r\n          });\r\n          throw error;\r\n        }\r\n      }\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * Context7 - Tracing: Authentication tracing utilities (STUBBED)\r\n */\r\nexport const authTracing = {\r\n  traceAuthAttempt: (method: string, userId?: string, isGuest?: boolean) =>\r\n    createTracedOperation(\r\n      {\r\n        name: `auth.${method}`,\r\n        kind: SpanKind.INTERNAL,\r\n        userId,\r\n        isGuest,\r\n        attributes: {\r\n          \"auth.method\": method,\r\n        },\r\n      },\r\n      async (span) => {\r\n        chatMetrics.authCounter.add(1, {\r\n          method,\r\n          is_guest: String(isGuest || false),\r\n        });\r\n\r\n        if (isGuest) {\r\n          chatMetrics.guestSessionCounter.add(1);\r\n        }\r\n      }\r\n    ),\r\n\r\n  tracePermissionCheck: (\r\n    permission: string,\r\n    userId: string,\r\n    allowed: boolean\r\n  ) =>\r\n    createTracedOperation(\r\n      {\r\n        name: \"auth.permission_check\",\r\n        kind: SpanKind.INTERNAL,\r\n        userId,\r\n        attributes: {\r\n          \"auth.permission\": permission,\r\n          \"auth.allowed\": allowed,\r\n        },\r\n      },\r\n      async (span) => {\r\n        // Just for tracing, no additional logic needed\r\n      }\r\n    ),\r\n};\r\n\r\n/**\r\n * Context7 - Tracing: Chat operation tracing utilities (STUBBED)\r\n */\r\nexport const chatTracing = {\r\n  traceChatCompletion: (\r\n    chatId: string,\r\n    userId: string,\r\n    model: string,\r\n    isGuest?: boolean\r\n  ) =>\r\n    createTracedOperation(\r\n      {\r\n        name: \"chat.completion\",\r\n        kind: SpanKind.INTERNAL,\r\n        chatId,\r\n        userId,\r\n        isGuest,\r\n        attributes: {\r\n          \"ai.model\": model,\r\n          \"chat.operation\": \"completion\",\r\n        },\r\n      },\r\n      async (span) => {\r\n        // Span setup for chat completion\r\n      }\r\n    ),\r\n\r\n  traceTokenUsage: (tokens: number, model: string, operation: string) => {\r\n    chatMetrics.tokenUsage.record(tokens, {\r\n      model,\r\n      operation,\r\n    });\r\n  },\r\n\r\n  traceRAGRetrieval: (\r\n    queryType: string,\r\n    documentsFound: number,\r\n    userId: string\r\n  ) =>\r\n    createTracedOperation(\r\n      {\r\n        name: \"rag.retrieval\",\r\n        kind: SpanKind.INTERNAL,\r\n        userId,\r\n        attributes: {\r\n          \"rag.query_type\": queryType,\r\n          \"rag.documents_found\": documentsFound,\r\n        },\r\n      },\r\n      async (span) => {\r\n        // RAG retrieval tracing\r\n      }\r\n    ),\r\n};\r\n\r\n/**\r\n * Context7 - Tracing: Database operation tracing (STUBBED)\r\n */\r\nexport const dbTracing = {\r\n  traceQuery: (operation: string, table: string, userId?: string) =>\r\n    createTracedOperation(\r\n      {\r\n        name: `db.${operation}`,\r\n        kind: SpanKind.CLIENT,\r\n        userId,\r\n        attributes: {\r\n          \"db.operation\": operation,\r\n          \"db.table\": table,\r\n          \"db.system\": \"postgresql\",\r\n        },\r\n      },\r\n      async (span) => {\r\n        // Database operation tracing\r\n      }\r\n    ),\r\n};\r\n\r\n/**\r\n * Context7 - Observability: Correlation ID utilities (STUBBED)\r\n */\r\nexport function generateCorrelationId(): string {\r\n  return `${Date.now()}-${Math.random().toString(36).substring(2)}`;\r\n}\r\n\r\nexport function getCorrelationId(): string | undefined {\r\n  return `mock-trace-${Date.now()}`;\r\n}\r\n\r\n/**\r\n * Context7 - Provider Isolation: External service tracing (STUBBED)\r\n */\r\nexport const externalTracing = {\r\n  traceApiCall: (service: string, operation: string, url?: string) =>\r\n    createTracedOperation(\r\n      {\r\n        name: `external.${service}.${operation}`,\r\n        kind: SpanKind.CLIENT,\r\n        attributes: {\r\n          \"external.service\": service,\r\n          \"external.operation\": operation,\r\n          ...(url && { \"external.url\": url }),\r\n        },\r\n      },\r\n      async (span) => {\r\n        // External API call tracing\r\n      }\r\n    ),\r\n};\r\n\r\n// Context7 - Modular exports for clean dependency management\r\nexport const hijraahTracing = {\r\n  initialize: initializeTracing,\r\n  getTracer,\r\n  getMeter,\r\n  createTracedOperation,\r\n  createHttpTraceMiddleware,\r\n  authTracing,\r\n  chatTracing,\r\n  dbTracing,\r\n  externalTracing,\r\n  metrics: chatMetrics,\r\n  generateCorrelationId,\r\n  getCorrelationId,\r\n  config: tracingConfig,\r\n};\r\n\r\n// Auto-initialize in production\r\nif (process.env.NODE_ENV === \"production\" && !initialized) {\r\n  initializeTracing();\r\n}\r\n\r\nexport default hijraahTracing;\r\n","import { NextRequest } from \"next/server\";\r\nimport {\r\n  getAuthenticatedUser,\r\n  createSupabaseServiceClient,\r\n} from \"@/lib/auth-config\";\r\nimport { getGuestSessionFromCookies, UserWithGuest } from \"@/lib/auth/guest\";\r\nimport { logger } from \"@/lib/logger\";\r\nimport {\r\n  authTracing,\r\n  createTracedOperation,\r\n  generateCorrelationId,\r\n} from \"@/lib/observability/tracing\";\r\n\r\n// Context7 - Provider Isolation: Authentication result interface\r\nexport interface AuthResult {\r\n  user: UserWithGuest;\r\n  token?: string;\r\n  isGuest: boolean;\r\n  permissions: string[];\r\n  correlationId: string; // Context7 - Tracing: Request correlation\r\n}\r\n\r\n// Context7 - Provider Isolation: Authentication error types\r\nexport class AuthenticationError extends Error {\r\n  public correlationId: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    public statusCode: number = 401,\r\n    correlationId?: string\r\n  ) {\r\n    super(message);\r\n    this.name = \"AuthenticationError\";\r\n    this.correlationId = correlationId || generateCorrelationId();\r\n  }\r\n}\r\n\r\n/**\r\n * Unified authentication adapter for (ai-unified) chat API\r\n * Context7 - Modularity: Clean adapter pattern with distributed tracing\r\n */\r\nexport async function authenticateRequest(\r\n  request: NextRequest\r\n): Promise<AuthResult> {\r\n  const correlationId = generateCorrelationId();\r\n\r\n  return createTracedOperation(\r\n    {\r\n      name: \"auth.authenticate_request\",\r\n      attributes: {\r\n        \"auth.correlation_id\": correlationId,\r\n        \"http.user_agent\": request.headers.get(\"user-agent\") || \"\",\r\n        \"http.client_ip\":\r\n          request.headers.get(\"x-forwarded-for\") ||\r\n          request.headers.get(\"x-real-ip\") ||\r\n          \"\",\r\n      },\r\n    },\r\n    async (span) => {\r\n      try {\r\n        // Method 1: Bearer token authentication (existing API clients)\r\n        const authHeader = request.headers.get(\"Authorization\");\r\n        if (authHeader?.startsWith(\"Bearer \")) {\r\n          span.setAttributes({ \"auth.method\": \"bearer_token\" });\r\n          return await authenticateWithBearerToken(authHeader, correlationId);\r\n        }\r\n\r\n        // Method 2: Cookie-based authentication (web app)\r\n        const cookieAuth = await authenticateWithCookies(\r\n          request,\r\n          correlationId\r\n        );\r\n        if (cookieAuth) {\r\n          span.setAttributes({ \"auth.method\": \"cookies\" });\r\n          return cookieAuth;\r\n        }\r\n\r\n        // Method 3: Guest session authentication\r\n        const guestAuth = await authenticateGuestSession(\r\n          request,\r\n          correlationId\r\n        );\r\n        if (guestAuth) {\r\n          span.setAttributes({ \"auth.method\": \"guest_session\" });\r\n          return guestAuth;\r\n        }\r\n\r\n        throw new AuthenticationError(\r\n          \"No valid authentication method found\",\r\n          401,\r\n          correlationId\r\n        );\r\n      } catch (error) {\r\n        // Context7 - Observability: Enhanced error logging with tracing\r\n        logger.error(\"Authentication failed\", {\r\n          error: error instanceof Error ? error.message : String(error),\r\n          correlationId,\r\n          userAgent: request.headers.get(\"user-agent\"),\r\n          ip:\r\n            request.headers.get(\"x-forwarded-for\") ||\r\n            request.headers.get(\"x-real-ip\"),\r\n          traceId: span.spanContext().traceId,\r\n        });\r\n\r\n        if (error instanceof AuthenticationError) {\r\n          throw error;\r\n        }\r\n\r\n        throw new AuthenticationError(\r\n          \"Authentication service error\",\r\n          500,\r\n          correlationId\r\n        );\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Authenticate using Bearer token (for API clients)\r\n * Context7 - Provider Isolation with tracing\r\n */\r\nasync function authenticateWithBearerToken(\r\n  authHeader: string,\r\n  correlationId: string\r\n): Promise<AuthResult> {\r\n  return createTracedOperation(\r\n    {\r\n      name: \"auth.bearer_token\",\r\n      attributes: {\r\n        \"auth.correlation_id\": correlationId,\r\n      },\r\n    },\r\n    async (span) => {\r\n      const token = authHeader.split(\" \")[1];\r\n      if (!token) {\r\n        throw new AuthenticationError(\r\n          \"Invalid bearer token format\",\r\n          401,\r\n          correlationId\r\n        );\r\n      }\r\n\r\n      // Context7 - Tracing: External service call\r\n      return createTracedOperation(\r\n        {\r\n          name: \"auth.supabase.get_user\",\r\n          attributes: {\r\n            \"external.service\": \"supabase\",\r\n            \"external.operation\": \"get_user\",\r\n          },\r\n        },\r\n        async (supabaseSpan) => {\r\n          const supabase = createSupabaseServiceClient();\r\n\r\n          const {\r\n            data: { user },\r\n            error,\r\n          } = await supabase.auth.getUser(token);\r\n\r\n          if (error || !user) {\r\n            throw new AuthenticationError(\r\n              \"Invalid or expired token\",\r\n              401,\r\n              correlationId\r\n            );\r\n          }\r\n\r\n          // Convert to UserWithGuest format\r\n          const userWithGuest: UserWithGuest = {\r\n            ...user,\r\n            fullName:\r\n              user.user_metadata?.full_name ||\r\n              user.email?.split(\"@\")[0] ||\r\n              \"User\",\r\n            avatarUrl: user.user_metadata?.avatar_url || \"\",\r\n            role: user.user_metadata?.role || \"client\",\r\n            userType: \"regular\",\r\n            isGuest: false,\r\n          };\r\n\r\n          // Context7 - Tracing: User context\r\n          span.setAttributes({\r\n            \"user.id\": user.id,\r\n            \"user.role\": userWithGuest.role,\r\n            \"user.is_guest\": false,\r\n          });\r\n\r\n          // Context7 - Observability: Track successful auth\r\n          await authTracing.traceAuthAttempt(\"bearer_token\", user.id, false);\r\n\r\n          return {\r\n            user: userWithGuest,\r\n            token,\r\n            isGuest: false,\r\n            permissions: getUserPermissions(userWithGuest),\r\n            correlationId,\r\n          };\r\n        }\r\n      );\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Authenticate using cookies (for web app)\r\n * Context7 - Unified authentication flow with tracing\r\n */\r\nasync function authenticateWithCookies(\r\n  request: NextRequest,\r\n  correlationId: string\r\n): Promise<AuthResult | null> {\r\n  return createTracedOperation(\r\n    {\r\n      name: \"auth.cookies\",\r\n      attributes: {\r\n        \"auth.correlation_id\": correlationId,\r\n      },\r\n    },\r\n    async (span) => {\r\n      try {\r\n        const auth = await getAuthenticatedUser(request);\r\n\r\n        if (!auth.isAuthenticated || !auth.user) {\r\n          return null;\r\n        }\r\n\r\n        // Context7 - Tracing: User context\r\n        span.setAttributes({\r\n          \"user.id\": auth.user.id,\r\n          \"user.role\": auth.user.role,\r\n          \"user.is_guest\": auth.isGuest,\r\n        });\r\n\r\n        // Context7 - Observability: Track successful auth\r\n        await authTracing.traceAuthAttempt(\r\n          \"cookies\",\r\n          auth.user.id,\r\n          auth.isGuest\r\n        );\r\n\r\n        return {\r\n          user: auth.user,\r\n          isGuest: auth.isGuest,\r\n          permissions: auth.permissions,\r\n          correlationId,\r\n        };\r\n      } catch (error) {\r\n        // Context7 - Observability: Log but don't throw for cookie auth failures\r\n        logger.warn(\"Cookie authentication failed\", {\r\n          error,\r\n          correlationId,\r\n          traceId: span.spanContext().traceId,\r\n        });\r\n        return null;\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Authenticate guest session\r\n * Context7 - Guest user support with tracing\r\n */\r\nasync function authenticateGuestSession(\r\n  request: NextRequest,\r\n  correlationId: string\r\n): Promise<AuthResult | null> {\r\n  return createTracedOperation(\r\n    {\r\n      name: \"auth.guest_session\",\r\n      attributes: {\r\n        \"auth.correlation_id\": correlationId,\r\n      },\r\n    },\r\n    async (span) => {\r\n      try {\r\n        const cookieStore = {\r\n          get: (name: string) => request.cookies.get(name),\r\n        };\r\n\r\n        const guestUser = getGuestSessionFromCookies(cookieStore);\r\n\r\n        if (!guestUser) {\r\n          return null;\r\n        }\r\n\r\n        // Context7 - Tracing: Guest user context\r\n        span.setAttributes({\r\n          \"user.id\": guestUser.id,\r\n          \"user.is_guest\": true,\r\n          \"user.session_id\": guestUser.guestSessionId || \"\",\r\n        });\r\n\r\n        // Context7 - Observability: Track guest session\r\n        await authTracing.traceAuthAttempt(\"guest_session\", guestUser.id, true);\r\n\r\n        return {\r\n          user: guestUser,\r\n          isGuest: true,\r\n          permissions: getUserPermissions(guestUser),\r\n          correlationId,\r\n        };\r\n      } catch (error) {\r\n        logger.warn(\"Guest authentication failed\", {\r\n          error,\r\n          correlationId,\r\n          traceId: span.spanContext().traceId,\r\n        });\r\n        return null;\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Get user permissions based on role and guest status\r\n * Context7 - Data-as-Code: Permission resolution with tracing\r\n */\r\nfunction getUserPermissions(user: UserWithGuest): string[] {\r\n  if (user.isGuest) {\r\n    return [\r\n      \"chat:create\",\r\n      \"chat:read:own\",\r\n      \"artifacts:create\",\r\n      \"artifacts:read:own\",\r\n      \"session:temporary\",\r\n    ];\r\n  }\r\n\r\n  const role = user.role as string;\r\n\r\n  switch (role) {\r\n    case \"admin\":\r\n      return [\r\n        \"chat:read:all\",\r\n        \"chat:update:all\",\r\n        \"chat:delete:all\",\r\n        \"artifacts:read:all\",\r\n        \"artifacts:update:all\",\r\n        \"artifacts:delete:all\",\r\n        \"users:read:all\",\r\n        \"users:update:all\",\r\n        \"system:admin\",\r\n      ];\r\n    case \"moderator\":\r\n      return [\r\n        \"chat:read:all\",\r\n        \"chat:moderate\",\r\n        \"artifacts:read:all\",\r\n        \"artifacts:moderate\",\r\n        \"users:read\",\r\n        \"reports:create\",\r\n      ];\r\n    default: // client\r\n      return [\r\n        \"chat:create\",\r\n        \"chat:read\",\r\n        \"chat:update:own\",\r\n        \"chat:delete:own\",\r\n        \"artifacts:create\",\r\n        \"artifacts:read\",\r\n        \"artifacts:update:own\",\r\n        \"artifacts:delete:own\",\r\n        \"profile:read:own\",\r\n        \"profile:update:own\",\r\n      ];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user has specific permission\r\n * Context7 - Authorization helper with tracing\r\n */\r\nexport function hasPermission(auth: AuthResult, permission: string): boolean {\r\n  const hasAccess = auth.permissions.includes(permission);\r\n\r\n  // Context7 - Tracing: Permission check\r\n  authTracing.tracePermissionCheck(permission, auth.user.id, hasAccess);\r\n\r\n  return hasAccess;\r\n}\r\n\r\n/**\r\n * Require specific permission for operation\r\n * Context7 - Authorization guard with enhanced error context\r\n */\r\nexport function requirePermission(auth: AuthResult, permission: string): void {\r\n  if (!hasPermission(auth, permission)) {\r\n    throw new AuthenticationError(\r\n      `Permission required: ${permission}`,\r\n      403,\r\n      auth.correlationId\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Create response for authentication errors\r\n * Context7 - Standardized error responses with tracing context\r\n */\r\nexport function createAuthErrorResponse(error: AuthenticationError): Response {\r\n  return new Response(\r\n    JSON.stringify({\r\n      error: error.message,\r\n      code: error.statusCode,\r\n      correlationId: error.correlationId,\r\n      timestamp: new Date().toISOString(),\r\n    }),\r\n    {\r\n      status: error.statusCode,\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        \"X-Correlation-ID\": error.correlationId,\r\n      },\r\n    }\r\n  );\r\n}\r\n\r\n// Context7 - Modular exports with enhanced tracing\r\nexport const authAdapter = {\r\n  authenticateRequest,\r\n  hasPermission,\r\n  requirePermission,\r\n  createAuthErrorResponse,\r\n  AuthenticationError,\r\n};\r\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n","import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n","module.exports = require(\"os\");","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar src_exports = {};\n__export(src_exports, {\n  geolocation: () => import_headers.geolocation,\n  getCache: () => import_cache.getCache,\n  getEnv: () => import_get_env.getEnv,\n  ipAddress: () => import_headers.ipAddress,\n  next: () => import_middleware.next,\n  rewrite: () => import_middleware.rewrite,\n  waitUntil: () => import_wait_until.waitUntil\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_headers = require(\"./headers\");\nvar import_get_env = require(\"./get-env\");\nvar import_wait_until = require(\"./wait-until\");\nvar import_middleware = require(\"./middleware\");\nvar import_cache = require(\"./cache\");\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  geolocation,\n  getCache,\n  getEnv,\n  ipAddress,\n  next,\n  rewrite,\n  waitUntil\n});\n","module.exports = require(\"stream\");","module.exports = require(\"util\");","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");","/**\r\n * Centralized Rate Limiting Configuration\r\n *\r\n * Consolidates all rate limiting configurations and exports reusable limiters\r\n * Based on Upstash Redis best practices from Context7\r\n */\r\n\r\nimport { Ratelimit } from \"@upstash/ratelimit\";\r\nimport { Redis } from \"@upstash/redis\";\r\n\r\n// Initialize Redis client following Context7 best practices\r\nconst redis = Redis.fromEnv();\r\n\r\n// Type definitions - centralized to avoid duplication\r\nexport type RateLimitAction =\r\n  | \"ocr\"\r\n  | \"documentQA\"\r\n  | \"batchProcessing\"\r\n  | \"api\"\r\n  | \"caseManagement\"\r\n  | \"documentUpload\";\r\nexport type UserTier = \"standard\" | \"premium\" | \"enterprise\";\r\n\r\n// Rate limit configurations with consistent structure\r\nexport const rateLimitConfigs = {\r\n  // OCR API limits\r\n  ocr: {\r\n    standard: { requests: 50, window: \"1 d\", tokens: 3 },\r\n    premium: { requests: 500, window: \"1 d\", tokens: 2 },\r\n    enterprise: { requests: 5000, window: \"1 d\", tokens: 1 },\r\n  },\r\n\r\n  // Document understanding API limits\r\n  documentQA: {\r\n    standard: { requests: 20, window: \"1 d\", tokens: 5 },\r\n    premium: { requests: 200, window: \"1 d\", tokens: 3 },\r\n    enterprise: { requests: 2000, window: \"1 d\", tokens: 2 },\r\n  },\r\n\r\n  // Batch processing limits\r\n  batchProcessing: {\r\n    standard: { requests: 5, window: \"1 d\", tokens: 10 },\r\n    premium: { requests: 50, window: \"1 d\", tokens: 5 },\r\n    enterprise: { requests: 500, window: \"1 d\", tokens: 3 },\r\n  },\r\n\r\n  // General API limits\r\n  api: {\r\n    standard: { requests: 100, window: \"1 m\", tokens: 1 },\r\n    premium: { requests: 500, window: \"1 m\", tokens: 1 },\r\n    enterprise: { requests: 2000, window: \"1 m\", tokens: 1 },\r\n  },\r\n\r\n  // Case management limits\r\n  caseManagement: {\r\n    standard: { requests: 100, window: \"1 m\", tokens: 1 },\r\n    premium: { requests: 500, window: \"1 m\", tokens: 1 },\r\n    enterprise: { requests: 2000, window: \"1 m\", tokens: 1 },\r\n  },\r\n\r\n  // Document upload limits\r\n  documentUpload: {\r\n    standard: { requests: 30, window: \"1 m\", tokens: 2 },\r\n    premium: { requests: 100, window: \"1 m\", tokens: 1 },\r\n    enterprise: { requests: 500, window: \"1 m\", tokens: 1 },\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Create a rate limiter for a specific action and tier\r\n * Following Context7 best practices for sliding window implementation\r\n */\r\nfunction createRateLimiter(action: RateLimitAction, tier: UserTier): Ratelimit {\r\n  const config = rateLimitConfigs[action][tier];\r\n  return new Ratelimit({\r\n    redis,\r\n    limiter: Ratelimit.slidingWindow(config.requests, config.window),\r\n    analytics: true,\r\n    prefix: `hijraah:ratelimit:${action}:${tier}`,\r\n    ephemeralCache: new Map(), // Context7 recommendation for edge environments\r\n  });\r\n}\r\n\r\n// Pre-create all limiters to avoid runtime overhead\r\nexport const limiters: Record<RateLimitAction, Record<UserTier, Ratelimit>> = {\r\n  ocr: {\r\n    standard: createRateLimiter(\"ocr\", \"standard\"),\r\n    premium: createRateLimiter(\"ocr\", \"premium\"),\r\n    enterprise: createRateLimiter(\"ocr\", \"enterprise\"),\r\n  },\r\n  documentQA: {\r\n    standard: createRateLimiter(\"documentQA\", \"standard\"),\r\n    premium: createRateLimiter(\"documentQA\", \"premium\"),\r\n    enterprise: createRateLimiter(\"documentQA\", \"enterprise\"),\r\n  },\r\n  batchProcessing: {\r\n    standard: createRateLimiter(\"batchProcessing\", \"standard\"),\r\n    premium: createRateLimiter(\"batchProcessing\", \"premium\"),\r\n    enterprise: createRateLimiter(\"batchProcessing\", \"enterprise\"),\r\n  },\r\n  api: {\r\n    standard: createRateLimiter(\"api\", \"standard\"),\r\n    premium: createRateLimiter(\"api\", \"premium\"),\r\n    enterprise: createRateLimiter(\"api\", \"enterprise\"),\r\n  },\r\n  caseManagement: {\r\n    standard: createRateLimiter(\"caseManagement\", \"standard\"),\r\n    premium: createRateLimiter(\"caseManagement\", \"premium\"),\r\n    enterprise: createRateLimiter(\"caseManagement\", \"enterprise\"),\r\n  },\r\n  documentUpload: {\r\n    standard: createRateLimiter(\"documentUpload\", \"standard\"),\r\n    premium: createRateLimiter(\"documentUpload\", \"premium\"),\r\n    enterprise: createRateLimiter(\"documentUpload\", \"enterprise\"),\r\n  },\r\n};\r\n\r\n// Export rate limit helper functions\r\nexport { createRateLimiter };\r\n","/**\r\n * Rate Limit Service\r\n *\r\n * Unified service layer for rate limiting with enhanced functionality\r\n * Based on Context7 best practices and Upstash Redis patterns\r\n */\r\n\r\nimport { type Ratelimit } from \"@upstash/ratelimit\";\r\nimport {\r\n  limiters,\r\n  type RateLimitAction,\r\n  type UserTier,\r\n  rateLimitConfigs,\r\n} from \"@/_infrastructure/rate-limit/config\";\r\n\r\nexport interface RateLimitResult {\r\n  success: boolean;\r\n  limit: number;\r\n  remaining: number;\r\n  reset: Date;\r\n  pending?: Promise<void>;\r\n  reason?: string;\r\n}\r\n\r\nexport class RateLimitService {\r\n  /**\r\n   * Check if a request is allowed based on the identifier, action, and tier\r\n   * Enhanced with Context7 best practices\r\n   */\r\n  static async isAllowed(\r\n    identifier: string,\r\n    action: RateLimitAction,\r\n    tier: UserTier = \"standard\"\r\n  ): Promise<RateLimitResult> {\r\n    try {\r\n      const limiter = limiters[action]?.[tier];\r\n\r\n      if (!limiter) {\r\n        throw new Error(\r\n          `No rate limiter found for action: ${action}, tier: ${tier}`\r\n        );\r\n      }\r\n\r\n      const result = await limiter.limit(identifier);\r\n\r\n      return {\r\n        success: result.success,\r\n        limit: result.limit,\r\n        remaining: result.remaining,\r\n        reset: new Date(Date.now() + result.reset),\r\n        pending: result.pending as Promise<void>,\r\n        reason: result.reason,\r\n      };\r\n    } catch (error) {\r\n      console.error(\r\n        `Rate limit check failed for ${action}:${tier}:${identifier}`,\r\n        error\r\n      );\r\n\r\n      // Fail open - allow request if rate limiting system fails\r\n      const config = rateLimitConfigs[action]?.[tier];\r\n      return {\r\n        success: true,\r\n        limit: config?.requests ?? 0,\r\n        remaining: config?.requests ?? 0,\r\n        reset: new Date(Date.now() + 60000), // 1 minute fallback\r\n        reason: \"rate_limit_error\",\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the remaining limit for a specific identifier, action, and tier\r\n   */\r\n  static async getRemainingLimit(\r\n    identifier: string,\r\n    action: RateLimitAction,\r\n    tier: UserTier = \"standard\"\r\n  ): Promise<number> {\r\n    const response = await this.isAllowed(identifier, action, tier);\r\n    return response.remaining;\r\n  }\r\n\r\n  /**\r\n   * Get the reset time for a specific identifier, action, and tier\r\n   */\r\n  static async getResetTime(\r\n    identifier: string,\r\n    action: RateLimitAction,\r\n    tier: UserTier = \"standard\"\r\n  ): Promise<Date> {\r\n    const response = await this.isAllowed(identifier, action, tier);\r\n    return response.reset;\r\n  }\r\n\r\n  /**\r\n   * Check multiple rate limits at once\r\n   * Useful for complex operations that consume multiple quotas\r\n   */\r\n  static async checkMultiple(\r\n    identifier: string,\r\n    checks: Array<{ action: RateLimitAction; tier: UserTier }>\r\n  ): Promise<Record<string, RateLimitResult>> {\r\n    const results = await Promise.all(\r\n      checks.map(async ({ action, tier }) => {\r\n        const result = await this.isAllowed(identifier, action, tier);\r\n        return [`${action}:${tier}`, result] as const;\r\n      })\r\n    );\r\n\r\n    return Object.fromEntries(results);\r\n  }\r\n\r\n  /**\r\n   * Get rate limit headers for HTTP responses\r\n   * Following Context7 recommended header format\r\n   */\r\n  static getRateLimitHeaders(result: RateLimitResult): Record<string, string> {\r\n    return {\r\n      \"X-RateLimit-Limit\": String(result.limit),\r\n      \"X-RateLimit-Remaining\": String(result.remaining),\r\n      \"X-RateLimit-Reset\": String(Math.floor(result.reset.getTime() / 1000)),\r\n      \"X-RateLimit-Success\": String(result.success),\r\n    };\r\n  }\r\n}\r\n","type LogLevel = 'debug' | 'info' | 'warn' | 'error';\r\n\r\ninterface LogEntry {\r\n  level: LogLevel;\r\n  message: string;\r\n  timestamp: string;\r\n  context?: Record<string, unknown>;\r\n}\r\n\r\nclass Logger {\r\n  private static instance: Logger;\r\n  private logLevel: LogLevel = 'info';\r\n  private buffer: LogEntry[] = [];\r\n  private readonly maxBufferSize = 1000;\r\n\r\n  private constructor() {\r\n    // Set log level from environment\r\n    const envLogLevel = process.env.LOG_LEVEL as LogLevel;\r\n    if (envLogLevel && ['debug', 'info', 'warn', 'error'].includes(envLogLevel)) {\r\n      this.logLevel = envLogLevel;\r\n    }\r\n  }\r\n\r\n  public static getInstance(): Logger {\r\n    if (!Logger.instance) {\r\n      Logger.instance = new Logger();\r\n    }\r\n    return Logger.instance;\r\n  }\r\n\r\n  private shouldLog(level: LogLevel): boolean {\r\n    const levels: Record<LogLevel, number> = {\r\n      debug: 0,\r\n      info: 1,\r\n      warn: 2,\r\n      error: 3,\r\n    };\r\n    return levels[level] >= levels[this.logLevel];\r\n  }\r\n\r\n  private formatMessage(entry: LogEntry): string {\r\n    const context = entry.context ? ` ${JSON.stringify(entry.context)}` : '';\r\n    return `[${entry.timestamp}] ${entry.level.toUpperCase()}: ${entry.message}${context}`;\r\n  }\r\n\r\n  private addToBuffer(entry: LogEntry) {\r\n    this.buffer.push(entry);\r\n    if (this.buffer.length > this.maxBufferSize) {\r\n      this.buffer.shift();\r\n    }\r\n  }\r\n\r\n  private createLogEntry(level: LogLevel, message: string, context?: Record<string, unknown>): LogEntry {\r\n    return {\r\n      level,\r\n      message,\r\n      timestamp: new Date().toISOString(),\r\n      context,\r\n    };\r\n  }\r\n\r\n  public debug(message: string, context?: Record<string, unknown>) {\r\n    if (this.shouldLog('debug')) {\r\n      const entry = this.createLogEntry('debug', message, context);\r\n      this.addToBuffer(entry);\r\n      if (process.env.NODE_ENV === 'development') {\r\n        console.debug(this.formatMessage(entry));\r\n      }\r\n    }\r\n  }\r\n\r\n  public info(message: string, context?: Record<string, unknown>) {\r\n    if (this.shouldLog('info')) {\r\n      const entry = this.createLogEntry('info', message, context);\r\n      this.addToBuffer(entry);\r\n      console.info(this.formatMessage(entry));\r\n    }\r\n  }\r\n\r\n  public warn(message: string, context?: Record<string, unknown>) {\r\n    if (this.shouldLog('warn')) {\r\n      const entry = this.createLogEntry('warn', message, context);\r\n      this.addToBuffer(entry);\r\n      console.warn(this.formatMessage(entry));\r\n    }\r\n  }\r\n\r\n  public error(message: string, error?: Error, context?: Record<string, unknown>) {\r\n    if (this.shouldLog('error')) {\r\n      const errorContext = error ? {\r\n        ...context,\r\n        error: {\r\n          name: error.name,\r\n          message: error.message,\r\n          stack: error.stack,\r\n        },\r\n      } : context;\r\n\r\n      const entry = this.createLogEntry('error', message, errorContext);\r\n      this.addToBuffer(entry);\r\n      console.error(this.formatMessage(entry));\r\n    }\r\n  }\r\n\r\n  public getBuffer(): LogEntry[] {\r\n    return [...this.buffer];\r\n  }\r\n\r\n  public clearBuffer() {\r\n    this.buffer = [];\r\n  }\r\n\r\n  public setLogLevel(level: LogLevel) {\r\n    this.logLevel = level;\r\n  }\r\n}\r\n\r\nexport const logger = Logger.getInstance(); ","module.exports = require(\"path\");","module.exports = require(\"tls\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:stream/web\");","module.exports = require(\"node:zlib\");","module.exports = require(\"node:tls\");","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar get_env_exports = {};\n__export(get_env_exports, {\n  getEnv: () => getEnv\n});\nmodule.exports = __toCommonJS(get_env_exports);\nconst getEnv = (env = process.env) => ({\n  /**\n   * An indicator to show that System Environment Variables have been exposed to your project's Deployments.\n   * @example \"1\"\n   */\n  VERCEL: get(env, \"VERCEL\"),\n  /**\n   * An indicator that the code is running in a Continuous Integration environment.\n   * @example \"1\"\n   */\n  CI: get(env, \"CI\"),\n  /**\n   * The Environment that the app is deployed and running on.\n   * @example \"production\"\n   */\n  VERCEL_ENV: get(env, \"VERCEL_ENV\"),\n  /**\n   * The domain name of the generated deployment URL. The value does not include the protocol scheme https://.\n   * NOTE: This Variable cannot be used in conjunction with Standard Deployment Protection.\n   * @example \"*.vercel.app\"\n   */\n  VERCEL_URL: get(env, \"VERCEL_URL\"),\n  /**\n   * The domain name of the generated Git branch URL. The value does not include the protocol scheme https://.\n   * @example \"*-git-*.vercel.app\"\n   */\n  VERCEL_BRANCH_URL: get(env, \"VERCEL_BRANCH_URL\"),\n  /**\n   * A production domain name of the project. This is useful to reliably generate links that point to production such as OG-image URLs.\n   * The value does not include the protocol scheme https://.\n   * @example \"myproject.vercel.app\"\n   */\n  VERCEL_PROJECT_PRODUCTION_URL: get(env, \"VERCEL_PROJECT_PRODUCTION_URL\"),\n  /**\n   * The ID of the Region where the app is running.\n   *\n   * Possible values:\n   * - arn1 (Stockholm, Sweden)\n   * - bom1 (Mumbai, India)\n   * - cdg1 (Paris, France)\n   * - cle1 (Cleveland, USA)\n   * - cpt1 (Cape Town, South Africa)\n   * - dub1 (Dublin, Ireland)\n   * - fra1 (Frankfurt, Germany)\n   * - gru1 (São Paulo, Brazil)\n   * - hkg1 (Hong Kong)\n   * - hnd1 (Tokyo, Japan)\n   * - iad1 (Washington, D.C., USA)\n   * - icn1 (Seoul, South Korea)\n   * - kix1 (Osaka, Japan)\n   * - lhr1 (London, United Kingdom)\n   * - pdx1 (Portland, USA)\n   * - sfo1 (San Francisco, USA)\n   * - sin1 (Singapore)\n   * - syd1 (Sydney, Australia)\n   * - dev1 (Development Region)\n   *\n   * @example \"iad1\"\n   */\n  VERCEL_REGION: get(env, \"VERCEL_REGION\"),\n  /**\n   * The unique identifier for the deployment, which can be used to implement Skew Protection.\n   * @example \"dpl_7Gw5ZMBpQA8h9GF832KGp7nwbuh3\"\n   */\n  VERCEL_DEPLOYMENT_ID: get(env, \"VERCEL_DEPLOYMENT_ID\"),\n  /**\n   * When Skew Protection is enabled in Project Settings, this value is set to 1.\n   * @example \"1\"\n   */\n  VERCEL_SKEW_PROTECTION_ENABLED: get(env, \"VERCEL_SKEW_PROTECTION_ENABLED\"),\n  /**\n   * The Protection Bypass for Automation value, if the secret has been generated in the project's Deployment Protection settings.\n   */\n  VERCEL_AUTOMATION_BYPASS_SECRET: get(env, \"VERCEL_AUTOMATION_BYPASS_SECRET\"),\n  /**\n   * The Git Provider the deployment is triggered from.\n   * @example \"github\"\n   */\n  VERCEL_GIT_PROVIDER: get(env, \"VERCEL_GIT_PROVIDER\"),\n  /**\n   * The origin repository the deployment is triggered from.\n   * @example \"my-site\"\n   */\n  VERCEL_GIT_REPO_SLUG: get(env, \"VERCEL_GIT_REPO_SLUG\"),\n  /**\n   * The account that owns the repository the deployment is triggered from.\n   * @example \"acme\"\n   */\n  VERCEL_GIT_REPO_OWNER: get(env, \"VERCEL_GIT_REPO_OWNER\"),\n  /**\n   * The ID of the repository the deployment is triggered from.\n   * @example \"117716146\"\n   */\n  VERCEL_GIT_REPO_ID: get(env, \"VERCEL_GIT_REPO_ID\"),\n  /**\n   * The git branch of the commit the deployment was triggered by.\n   * @example \"improve-about-page\"\n   */\n  VERCEL_GIT_COMMIT_REF: get(env, \"VERCEL_GIT_COMMIT_REF\"),\n  /**\n   * The git SHA of the commit the deployment was triggered by.\n   * @example \"fa1eade47b73733d6312d5abfad33ce9e4068081\"\n   */\n  VERCEL_GIT_COMMIT_SHA: get(env, \"VERCEL_GIT_COMMIT_SHA\"),\n  /**\n   * The message attached to the commit the deployment was triggered by.\n   * @example \"Update about page\"\n   */\n  VERCEL_GIT_COMMIT_MESSAGE: get(env, \"VERCEL_GIT_COMMIT_MESSAGE\"),\n  /**\n   * The username attached to the author of the commit that the project was deployed by.\n   * @example \"johndoe\"\n   */\n  VERCEL_GIT_COMMIT_AUTHOR_LOGIN: get(env, \"VERCEL_GIT_COMMIT_AUTHOR_LOGIN\"),\n  /**\n   * The name attached to the author of the commit that the project was deployed by.\n   * @example \"John Doe\"\n   */\n  VERCEL_GIT_COMMIT_AUTHOR_NAME: get(env, \"VERCEL_GIT_COMMIT_AUTHOR_NAME\"),\n  /**\n   * The git SHA of the last successful deployment for the project and branch.\n   * NOTE: This Variable is only exposed when an Ignored Build Step is provided.\n   * @example \"fa1eade47b73733d6312d5abfad33ce9e4068080\"\n   */\n  VERCEL_GIT_PREVIOUS_SHA: get(env, \"VERCEL_GIT_PREVIOUS_SHA\"),\n  /**\n   * The pull request id the deployment was triggered by. If a deployment is created on a branch before a pull request is made, this value will be an empty string.\n   * @example \"23\"\n   */\n  VERCEL_GIT_PULL_REQUEST_ID: get(env, \"VERCEL_GIT_PULL_REQUEST_ID\")\n});\nconst get = (env, key) => {\n  const value = env[key];\n  return value === \"\" ? void 0 : value;\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  getEnv\n});\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar cache_exports = {};\n__export(cache_exports, {\n  getCache: () => getCache\n});\nmodule.exports = __toCommonJS(cache_exports);\nvar import_get_context = require(\"../get-context\");\nvar import_in_memory_cache = require(\"./in-memory-cache\");\nconst defaultKeyHashFunction = (key) => {\n  let hash = 5381;\n  for (let i = 0; i < key.length; i++) {\n    hash = hash * 33 ^ key.charCodeAt(i);\n  }\n  return (hash >>> 0).toString(16);\n};\nconst defaultNamespaceSeparator = \"$\";\nlet inMemoryCacheInstance = null;\nconst getCache = (cacheOptions) => {\n  const resolveCache = () => {\n    const ctxCache = (0, import_get_context.getContext)().cache;\n    if (ctxCache)\n      return ctxCache;\n    if (!inMemoryCacheInstance) {\n      inMemoryCacheInstance = new import_in_memory_cache.InMemoryCache();\n      console.warn(\n        \"Runtime Cache unavailable in this environment. Falling back to in-memory cache.\"\n      );\n    }\n    return inMemoryCacheInstance;\n  };\n  const hashFunction = cacheOptions?.keyHashFunction || defaultKeyHashFunction;\n  const makeKey = (key) => {\n    let prefix = \"\";\n    if (cacheOptions?.namespace) {\n      const namespaceSeparator = cacheOptions.namespaceSeparator || defaultNamespaceSeparator;\n      prefix = `${cacheOptions.namespace}${namespaceSeparator}`;\n    }\n    return `${prefix}${hashFunction(key)}`;\n  };\n  return {\n    get: (key, options) => {\n      return resolveCache().get(makeKey(key), options);\n    },\n    set: (key, value, options) => {\n      return resolveCache().set(makeKey(key), value, options);\n    },\n    delete: (key) => {\n      return resolveCache().delete(makeKey(key));\n    },\n    expireTag: (tag) => {\n      return resolveCache().expireTag(tag);\n    }\n  };\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  getCache\n});\n","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","module.exports = require(\"node:os\");","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\(ai-unified)\\\\api\\\\chat\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/(ai-unified)/api/chat/route\",\n        pathname: \"/api/chat\",\n        filename: \"route\",\n        bundlePath: \"app/(ai-unified)/api/chat/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\(ai-unified)\\\\api\\\\chat\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","module.exports = require(\"node:diagnostics_channel\");","module.exports = require(\"crypto\");","module.exports = require(\"https\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","// src/openai-compatible-chat-language-model.ts\nimport {\n  InvalidResponseDataError\n} from \"@ai-sdk/provider\";\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  isParsableJson,\n  postJsonToApi\n} from \"@ai-sdk/provider-utils\";\nimport { z as z2 } from \"zod\";\n\n// src/convert-to-openai-compatible-chat-messages.ts\nimport {\n  UnsupportedFunctionalityError\n} from \"@ai-sdk/provider\";\nimport { convertUint8ArrayToBase64 } from \"@ai-sdk/provider-utils\";\nfunction getOpenAIMetadata(message) {\n  var _a, _b;\n  return (_b = (_a = message == null ? void 0 : message.providerMetadata) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};\n}\nfunction convertToOpenAICompatibleChatMessages(prompt) {\n  const messages = [];\n  for (const { role, content, ...message } of prompt) {\n    const metadata = getOpenAIMetadata({ ...message });\n    switch (role) {\n      case \"system\": {\n        messages.push({ role: \"system\", content, ...metadata });\n        break;\n      }\n      case \"user\": {\n        if (content.length === 1 && content[0].type === \"text\") {\n          messages.push({\n            role: \"user\",\n            content: content[0].text,\n            ...getOpenAIMetadata(content[0])\n          });\n          break;\n        }\n        messages.push({\n          role: \"user\",\n          content: content.map((part) => {\n            var _a;\n            const partMetadata = getOpenAIMetadata(part);\n            switch (part.type) {\n              case \"text\": {\n                return { type: \"text\", text: part.text, ...partMetadata };\n              }\n              case \"image\": {\n                return {\n                  type: \"image_url\",\n                  image_url: {\n                    url: part.image instanceof URL ? part.image.toString() : `data:${(_a = part.mimeType) != null ? _a : \"image/jpeg\"};base64,${convertUint8ArrayToBase64(part.image)}`\n                  },\n                  ...partMetadata\n                };\n              }\n              case \"file\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"File content parts in user messages\"\n                });\n              }\n            }\n          }),\n          ...metadata\n        });\n        break;\n      }\n      case \"assistant\": {\n        let text = \"\";\n        const toolCalls = [];\n        for (const part of content) {\n          const partMetadata = getOpenAIMetadata(part);\n          switch (part.type) {\n            case \"text\": {\n              text += part.text;\n              break;\n            }\n            case \"tool-call\": {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: \"function\",\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args)\n                },\n                ...partMetadata\n              });\n              break;\n            }\n          }\n        }\n        messages.push({\n          role: \"assistant\",\n          content: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,\n          ...metadata\n        });\n        break;\n      }\n      case \"tool\": {\n        for (const toolResponse of content) {\n          const toolResponseMetadata = getOpenAIMetadata(toolResponse);\n          messages.push({\n            role: \"tool\",\n            tool_call_id: toolResponse.toolCallId,\n            content: JSON.stringify(toolResponse.result),\n            ...toolResponseMetadata\n          });\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return messages;\n}\n\n// src/get-response-metadata.ts\nfunction getResponseMetadata({\n  id,\n  model,\n  created\n}) {\n  return {\n    id: id != null ? id : void 0,\n    modelId: model != null ? model : void 0,\n    timestamp: created != null ? new Date(created * 1e3) : void 0\n  };\n}\n\n// src/map-openai-compatible-finish-reason.ts\nfunction mapOpenAICompatibleFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\n\n// src/openai-compatible-error.ts\nimport { z } from \"zod\";\nvar openaiCompatibleErrorDataSchema = z.object({\n  error: z.object({\n    message: z.string(),\n    // The additional information below is handled loosely to support\n    // OpenAI-compatible providers that have slightly different error\n    // responses:\n    type: z.string().nullish(),\n    param: z.any().nullish(),\n    code: z.union([z.string(), z.number()]).nullish()\n  })\n});\nvar defaultOpenAICompatibleErrorStructure = {\n  errorSchema: openaiCompatibleErrorDataSchema,\n  errorToMessage: (data) => data.error.message\n};\n\n// src/openai-compatible-prepare-tools.ts\nimport {\n  UnsupportedFunctionalityError as UnsupportedFunctionalityError2\n} from \"@ai-sdk/provider\";\nfunction prepareTools({\n  mode,\n  structuredOutputs\n}) {\n  var _a;\n  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  if (tools == null) {\n    return { tools: void 0, tool_choice: void 0, toolWarnings };\n  }\n  const toolChoice = mode.toolChoice;\n  const openaiCompatTools = [];\n  for (const tool of tools) {\n    if (tool.type === \"provider-defined\") {\n      toolWarnings.push({ type: \"unsupported-tool\", tool });\n    } else {\n      openaiCompatTools.push({\n        type: \"function\",\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters\n        }\n      });\n    }\n  }\n  if (toolChoice == null) {\n    return { tools: openaiCompatTools, tool_choice: void 0, toolWarnings };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return { tools: openaiCompatTools, tool_choice: type, toolWarnings };\n    case \"tool\":\n      return {\n        tools: openaiCompatTools,\n        tool_choice: {\n          type: \"function\",\n          function: {\n            name: toolChoice.toolName\n          }\n        },\n        toolWarnings\n      };\n    default: {\n      const _exhaustiveCheck = type;\n      throw new UnsupportedFunctionalityError2({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n      });\n    }\n  }\n}\n\n// src/openai-compatible-chat-language-model.ts\nvar OpenAICompatibleChatLanguageModel = class {\n  // type inferred via constructor\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    var _a, _b;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n    const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;\n    this.chunkSchema = createOpenAICompatibleChatChunkSchema(\n      errorStructure.errorSchema\n    );\n    this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure);\n    this.supportsStructuredOutputs = (_b = config.supportsStructuredOutputs) != null ? _b : false;\n  }\n  get defaultObjectGenerationMode() {\n    return this.config.defaultObjectGenerationMode;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get providerOptionsName() {\n    return this.config.provider.split(\".\")[0].trim();\n  }\n  getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    providerMetadata,\n    stopSequences,\n    responseFormat,\n    seed\n  }) {\n    var _a, _b, _c, _d, _e;\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if ((responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null && !this.supportsStructuredOutputs) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format schema is only supported with structuredOutputs\"\n      });\n    }\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      user: this.settings.user,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      response_format: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? this.supportsStructuredOutputs === true && responseFormat.schema != null ? {\n        type: \"json_schema\",\n        json_schema: {\n          schema: responseFormat.schema,\n          name: (_a = responseFormat.name) != null ? _a : \"response\",\n          description: responseFormat.description\n        }\n      } : { type: \"json_object\" } : void 0,\n      stop: stopSequences,\n      seed,\n      ...providerMetadata == null ? void 0 : providerMetadata[this.providerOptionsName],\n      reasoning_effort: (_d = (_b = providerMetadata == null ? void 0 : providerMetadata[this.providerOptionsName]) == null ? void 0 : _b.reasoningEffort) != null ? _d : (_c = providerMetadata == null ? void 0 : providerMetadata[\"openai-compatible\"]) == null ? void 0 : _c.reasoningEffort,\n      // messages:\n      messages: convertToOpenAICompatibleChatMessages(prompt)\n    };\n    switch (type) {\n      case \"regular\": {\n        const { tools, tool_choice, toolWarnings } = prepareTools({\n          mode,\n          structuredOutputs: this.supportsStructuredOutputs\n        });\n        return {\n          args: { ...baseArgs, tools, tool_choice },\n          warnings: [...warnings, ...toolWarnings]\n        };\n      }\n      case \"object-json\": {\n        return {\n          args: {\n            ...baseArgs,\n            response_format: this.supportsStructuredOutputs === true && mode.schema != null ? {\n              type: \"json_schema\",\n              json_schema: {\n                schema: mode.schema,\n                name: (_e = mode.name) != null ? _e : \"response\",\n                description: mode.description\n              }\n            } : { type: \"json_object\" }\n          },\n          warnings\n        };\n      }\n      case \"object-tool\": {\n        return {\n          args: {\n            ...baseArgs,\n            tool_choice: {\n              type: \"function\",\n              function: { name: mode.tool.name }\n            },\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: mode.tool.name,\n                  description: mode.tool.description,\n                  parameters: mode.tool.parameters\n                }\n              }\n            ]\n          },\n          warnings\n        };\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  async doGenerate(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const { args, warnings } = this.getArgs({ ...options });\n    const body = JSON.stringify(args);\n    const {\n      responseHeaders,\n      value: responseBody,\n      rawValue: rawResponse\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: this.failedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenAICompatibleChatResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { messages: rawPrompt, ...rawSettings } = args;\n    const choice = responseBody.choices[0];\n    const providerMetadata = {\n      [this.providerOptionsName]: {},\n      ...(_b = (_a = this.config.metadataExtractor) == null ? void 0 : _a.extractMetadata) == null ? void 0 : _b.call(_a, {\n        parsedBody: rawResponse\n      })\n    };\n    const completionTokenDetails = (_c = responseBody.usage) == null ? void 0 : _c.completion_tokens_details;\n    const promptTokenDetails = (_d = responseBody.usage) == null ? void 0 : _d.prompt_tokens_details;\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null) {\n      providerMetadata[this.providerOptionsName].reasoningTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens;\n    }\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {\n      providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;\n    }\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {\n      providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;\n    }\n    if ((promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null) {\n      providerMetadata[this.providerOptionsName].cachedPromptTokens = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens;\n    }\n    return {\n      text: (_e = choice.message.content) != null ? _e : void 0,\n      reasoning: (_f = choice.message.reasoning_content) != null ? _f : void 0,\n      toolCalls: (_g = choice.message.tool_calls) == null ? void 0 : _g.map((toolCall) => {\n        var _a2;\n        return {\n          toolCallType: \"function\",\n          toolCallId: (_a2 = toolCall.id) != null ? _a2 : generateId(),\n          toolName: toolCall.function.name,\n          args: toolCall.function.arguments\n        };\n      }),\n      finishReason: mapOpenAICompatibleFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: (_i = (_h = responseBody.usage) == null ? void 0 : _h.prompt_tokens) != null ? _i : NaN,\n        completionTokens: (_k = (_j = responseBody.usage) == null ? void 0 : _j.completion_tokens) != null ? _k : NaN\n      },\n      providerMetadata,\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(responseBody),\n      warnings,\n      request: { body }\n    };\n  }\n  async doStream(options) {\n    var _a;\n    if (this.settings.simulateStreaming) {\n      const result = await this.doGenerate(options);\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          if (result.reasoning) {\n            if (Array.isArray(result.reasoning)) {\n              for (const part of result.reasoning) {\n                if (part.type === \"text\") {\n                  controller.enqueue({\n                    type: \"reasoning\",\n                    textDelta: part.text\n                  });\n                }\n              }\n            } else {\n              controller.enqueue({\n                type: \"reasoning\",\n                textDelta: result.reasoning\n              });\n            }\n          }\n          if (result.text) {\n            controller.enqueue({\n              type: \"text-delta\",\n              textDelta: result.text\n            });\n          }\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: \"tool-call\",\n                ...toolCall\n              });\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings\n      };\n    }\n    const { args, warnings } = this.getArgs({ ...options });\n    const body = {\n      ...args,\n      stream: true,\n      // only include stream_options when in strict compatibility mode:\n      stream_options: this.config.includeUsage ? { include_usage: true } : void 0\n    };\n    const metadataExtractor = (_a = this.config.metadataExtractor) == null ? void 0 : _a.createStreamExtractor();\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: this.failedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        this.chunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { messages: rawPrompt, ...rawSettings } = args;\n    const toolCalls = [];\n    let finishReason = \"unknown\";\n    let usage = {\n      completionTokens: void 0,\n      completionTokensDetails: {\n        reasoningTokens: void 0,\n        acceptedPredictionTokens: void 0,\n        rejectedPredictionTokens: void 0\n      },\n      promptTokens: void 0,\n      promptTokensDetails: {\n        cachedTokens: void 0\n      }\n    };\n    let isFirstChunk = true;\n    let providerOptionsName = this.providerOptionsName;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          // TODO we lost type safety on Chunk, most likely due to the error schema. MUST FIX\n          transform(chunk, controller) {\n            var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            metadataExtractor == null ? void 0 : metadataExtractor.processChunk(chunk.rawValue);\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error.message });\n              return;\n            }\n            if (isFirstChunk) {\n              isFirstChunk = false;\n              controller.enqueue({\n                type: \"response-metadata\",\n                ...getResponseMetadata(value)\n              });\n            }\n            if (value.usage != null) {\n              const {\n                prompt_tokens,\n                completion_tokens,\n                prompt_tokens_details,\n                completion_tokens_details\n              } = value.usage;\n              usage.promptTokens = prompt_tokens != null ? prompt_tokens : void 0;\n              usage.completionTokens = completion_tokens != null ? completion_tokens : void 0;\n              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {\n                usage.completionTokensDetails.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;\n              }\n              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {\n                usage.completionTokensDetails.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;\n              }\n              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {\n                usage.completionTokensDetails.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;\n              }\n              if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {\n                usage.promptTokensDetails.cachedTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;\n              }\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenAICompatibleFinishReason(\n                choice.finish_reason\n              );\n            }\n            if ((choice == null ? void 0 : choice.delta) == null) {\n              return;\n            }\n            const delta = choice.delta;\n            if (delta.reasoning_content != null) {\n              controller.enqueue({\n                type: \"reasoning\",\n                textDelta: delta.reasoning_content\n              });\n            }\n            if (delta.content != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: delta.content\n              });\n            }\n            if (delta.tool_calls != null) {\n              for (const toolCallDelta of delta.tool_calls) {\n                const index = toolCallDelta.index;\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== \"function\") {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`\n                    });\n                  }\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`\n                    });\n                  }\n                  if (((_a2 = toolCallDelta.function) == null ? void 0 : _a2.name) == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`\n                    });\n                  }\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: \"function\",\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: (_b = toolCallDelta.function.arguments) != null ? _b : \"\"\n                    },\n                    hasFinished: false\n                  };\n                  const toolCall2 = toolCalls[index];\n                  if (((_c = toolCall2.function) == null ? void 0 : _c.name) != null && ((_d = toolCall2.function) == null ? void 0 : _d.arguments) != null) {\n                    if (toolCall2.function.arguments.length > 0) {\n                      controller.enqueue({\n                        type: \"tool-call-delta\",\n                        toolCallType: \"function\",\n                        toolCallId: toolCall2.id,\n                        toolName: toolCall2.function.name,\n                        argsTextDelta: toolCall2.function.arguments\n                      });\n                    }\n                    if (isParsableJson(toolCall2.function.arguments)) {\n                      controller.enqueue({\n                        type: \"tool-call\",\n                        toolCallType: \"function\",\n                        toolCallId: (_e = toolCall2.id) != null ? _e : generateId(),\n                        toolName: toolCall2.function.name,\n                        args: toolCall2.function.arguments\n                      });\n                      toolCall2.hasFinished = true;\n                    }\n                  }\n                  continue;\n                }\n                const toolCall = toolCalls[index];\n                if (toolCall.hasFinished) {\n                  continue;\n                }\n                if (((_f = toolCallDelta.function) == null ? void 0 : _f.arguments) != null) {\n                  toolCall.function.arguments += (_h = (_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null ? _h : \"\";\n                }\n                controller.enqueue({\n                  type: \"tool-call-delta\",\n                  toolCallType: \"function\",\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: (_i = toolCallDelta.function.arguments) != null ? _i : \"\"\n                });\n                if (((_j = toolCall.function) == null ? void 0 : _j.name) != null && ((_k = toolCall.function) == null ? void 0 : _k.arguments) != null && isParsableJson(toolCall.function.arguments)) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallType: \"function\",\n                    toolCallId: (_l = toolCall.id) != null ? _l : generateId(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments\n                  });\n                  toolCall.hasFinished = true;\n                }\n              }\n            }\n          },\n          flush(controller) {\n            var _a2, _b;\n            const providerMetadata = {\n              [providerOptionsName]: {},\n              ...metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata()\n            };\n            if (usage.completionTokensDetails.reasoningTokens != null) {\n              providerMetadata[providerOptionsName].reasoningTokens = usage.completionTokensDetails.reasoningTokens;\n            }\n            if (usage.completionTokensDetails.acceptedPredictionTokens != null) {\n              providerMetadata[providerOptionsName].acceptedPredictionTokens = usage.completionTokensDetails.acceptedPredictionTokens;\n            }\n            if (usage.completionTokensDetails.rejectedPredictionTokens != null) {\n              providerMetadata[providerOptionsName].rejectedPredictionTokens = usage.completionTokensDetails.rejectedPredictionTokens;\n            }\n            if (usage.promptTokensDetails.cachedTokens != null) {\n              providerMetadata[providerOptionsName].cachedPromptTokens = usage.promptTokensDetails.cachedTokens;\n            }\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage: {\n                promptTokens: (_a2 = usage.promptTokens) != null ? _a2 : NaN,\n                completionTokens: (_b = usage.completionTokens) != null ? _b : NaN\n              },\n              providerMetadata\n            });\n          }\n        })\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) }\n    };\n  }\n};\nvar openaiCompatibleTokenUsageSchema = z2.object({\n  prompt_tokens: z2.number().nullish(),\n  completion_tokens: z2.number().nullish(),\n  prompt_tokens_details: z2.object({\n    cached_tokens: z2.number().nullish()\n  }).nullish(),\n  completion_tokens_details: z2.object({\n    reasoning_tokens: z2.number().nullish(),\n    accepted_prediction_tokens: z2.number().nullish(),\n    rejected_prediction_tokens: z2.number().nullish()\n  }).nullish()\n}).nullish();\nvar OpenAICompatibleChatResponseSchema = z2.object({\n  id: z2.string().nullish(),\n  created: z2.number().nullish(),\n  model: z2.string().nullish(),\n  choices: z2.array(\n    z2.object({\n      message: z2.object({\n        role: z2.literal(\"assistant\").nullish(),\n        content: z2.string().nullish(),\n        reasoning_content: z2.string().nullish(),\n        tool_calls: z2.array(\n          z2.object({\n            id: z2.string().nullish(),\n            type: z2.literal(\"function\"),\n            function: z2.object({\n              name: z2.string(),\n              arguments: z2.string()\n            })\n          })\n        ).nullish()\n      }),\n      finish_reason: z2.string().nullish()\n    })\n  ),\n  usage: openaiCompatibleTokenUsageSchema\n});\nvar createOpenAICompatibleChatChunkSchema = (errorSchema) => z2.union([\n  z2.object({\n    id: z2.string().nullish(),\n    created: z2.number().nullish(),\n    model: z2.string().nullish(),\n    choices: z2.array(\n      z2.object({\n        delta: z2.object({\n          role: z2.enum([\"assistant\"]).nullish(),\n          content: z2.string().nullish(),\n          reasoning_content: z2.string().nullish(),\n          tool_calls: z2.array(\n            z2.object({\n              index: z2.number(),\n              id: z2.string().nullish(),\n              type: z2.literal(\"function\").nullish(),\n              function: z2.object({\n                name: z2.string().nullish(),\n                arguments: z2.string().nullish()\n              })\n            })\n          ).nullish()\n        }).nullish(),\n        finish_reason: z2.string().nullish()\n      })\n    ),\n    usage: openaiCompatibleTokenUsageSchema\n  }),\n  errorSchema\n]);\n\n// src/openai-compatible-completion-language-model.ts\nimport {\n  UnsupportedFunctionalityError as UnsupportedFunctionalityError4\n} from \"@ai-sdk/provider\";\nimport {\n  combineHeaders as combineHeaders2,\n  createEventSourceResponseHandler as createEventSourceResponseHandler2,\n  createJsonErrorResponseHandler as createJsonErrorResponseHandler2,\n  createJsonResponseHandler as createJsonResponseHandler2,\n  postJsonToApi as postJsonToApi2\n} from \"@ai-sdk/provider-utils\";\nimport { z as z3 } from \"zod\";\n\n// src/convert-to-openai-compatible-completion-prompt.ts\nimport {\n  InvalidPromptError,\n  UnsupportedFunctionalityError as UnsupportedFunctionalityError3\n} from \"@ai-sdk/provider\";\nfunction convertToOpenAICompatibleCompletionPrompt({\n  prompt,\n  inputFormat,\n  user = \"user\",\n  assistant = \"assistant\"\n}) {\n  if (inputFormat === \"prompt\" && prompt.length === 1 && prompt[0].role === \"user\" && prompt[0].content.length === 1 && prompt[0].content[0].type === \"text\") {\n    return { prompt: prompt[0].content[0].text };\n  }\n  let text = \"\";\n  if (prompt[0].role === \"system\") {\n    text += `${prompt[0].content}\n\n`;\n    prompt = prompt.slice(1);\n  }\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        throw new InvalidPromptError({\n          message: \"Unexpected system message in prompt: ${content}\",\n          prompt\n        });\n      }\n      case \"user\": {\n        const userMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"image\": {\n              throw new UnsupportedFunctionalityError3({\n                functionality: \"images\"\n              });\n            }\n          }\n        }).join(\"\");\n        text += `${user}:\n${userMessage}\n\n`;\n        break;\n      }\n      case \"assistant\": {\n        const assistantMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"tool-call\": {\n              throw new UnsupportedFunctionalityError3({\n                functionality: \"tool-call messages\"\n              });\n            }\n          }\n        }).join(\"\");\n        text += `${assistant}:\n${assistantMessage}\n\n`;\n        break;\n      }\n      case \"tool\": {\n        throw new UnsupportedFunctionalityError3({\n          functionality: \"tool messages\"\n        });\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  text += `${assistant}:\n`;\n  return {\n    prompt: text,\n    stopSequences: [`\n${user}:`]\n  };\n}\n\n// src/openai-compatible-completion-language-model.ts\nvar OpenAICompatibleCompletionLanguageModel = class {\n  // type inferred via constructor\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = void 0;\n    var _a;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n    const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;\n    this.chunkSchema = createOpenAICompatibleCompletionChunkSchema(\n      errorStructure.errorSchema\n    );\n    this.failedResponseHandler = createJsonErrorResponseHandler2(errorStructure);\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get providerOptionsName() {\n    return this.config.provider.split(\".\")[0].trim();\n  }\n  getArgs({\n    mode,\n    inputFormat,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    seed,\n    providerMetadata\n  }) {\n    var _a;\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type !== \"text\") {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format is not supported.\"\n      });\n    }\n    const { prompt: completionPrompt, stopSequences } = convertToOpenAICompatibleCompletionPrompt({ prompt, inputFormat });\n    const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      echo: this.settings.echo,\n      logit_bias: this.settings.logitBias,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      ...providerMetadata == null ? void 0 : providerMetadata[this.providerOptionsName],\n      // prompt:\n      prompt: completionPrompt,\n      // stop sequences:\n      stop: stop.length > 0 ? stop : void 0\n    };\n    switch (type) {\n      case \"regular\": {\n        if ((_a = mode.tools) == null ? void 0 : _a.length) {\n          throw new UnsupportedFunctionalityError4({\n            functionality: \"tools\"\n          });\n        }\n        if (mode.toolChoice) {\n          throw new UnsupportedFunctionalityError4({\n            functionality: \"toolChoice\"\n          });\n        }\n        return { args: baseArgs, warnings };\n      }\n      case \"object-json\": {\n        throw new UnsupportedFunctionalityError4({\n          functionality: \"object-json mode\"\n        });\n      }\n      case \"object-tool\": {\n        throw new UnsupportedFunctionalityError4({\n          functionality: \"object-tool mode\"\n        });\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  async doGenerate(options) {\n    var _a, _b, _c, _d;\n    const { args, warnings } = this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: this.failedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler2(\n        openaiCompatibleCompletionResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n    return {\n      text: choice.text,\n      usage: {\n        promptTokens: (_b = (_a = response.usage) == null ? void 0 : _a.prompt_tokens) != null ? _b : NaN,\n        completionTokens: (_d = (_c = response.usage) == null ? void 0 : _c.completion_tokens) != null ? _d : NaN\n      },\n      finishReason: mapOpenAICompatibleFinishReason(choice.finish_reason),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(response),\n      warnings,\n      request: { body: JSON.stringify(args) }\n    };\n  }\n  async doStream(options) {\n    const { args, warnings } = this.getArgs(options);\n    const body = {\n      ...args,\n      stream: true,\n      // only include stream_options when in strict compatibility mode:\n      stream_options: this.config.includeUsage ? { include_usage: true } : void 0\n    };\n    const { responseHeaders, value: response } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: this.failedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler2(\n        this.chunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    let finishReason = \"unknown\";\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    let isFirstChunk = true;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (isFirstChunk) {\n              isFirstChunk = false;\n              controller.enqueue({\n                type: \"response-metadata\",\n                ...getResponseMetadata(value)\n              });\n            }\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens\n              };\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenAICompatibleFinishReason(\n                choice.finish_reason\n              );\n            }\n            if ((choice == null ? void 0 : choice.text) != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: choice.text\n              });\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage\n            });\n          }\n        })\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) }\n    };\n  }\n};\nvar openaiCompatibleCompletionResponseSchema = z3.object({\n  id: z3.string().nullish(),\n  created: z3.number().nullish(),\n  model: z3.string().nullish(),\n  choices: z3.array(\n    z3.object({\n      text: z3.string(),\n      finish_reason: z3.string()\n    })\n  ),\n  usage: z3.object({\n    prompt_tokens: z3.number(),\n    completion_tokens: z3.number()\n  }).nullish()\n});\nvar createOpenAICompatibleCompletionChunkSchema = (errorSchema) => z3.union([\n  z3.object({\n    id: z3.string().nullish(),\n    created: z3.number().nullish(),\n    model: z3.string().nullish(),\n    choices: z3.array(\n      z3.object({\n        text: z3.string(),\n        finish_reason: z3.string().nullish(),\n        index: z3.number()\n      })\n    ),\n    usage: z3.object({\n      prompt_tokens: z3.number(),\n      completion_tokens: z3.number()\n    }).nullish()\n  }),\n  errorSchema\n]);\n\n// src/openai-compatible-embedding-model.ts\nimport {\n  TooManyEmbeddingValuesForCallError\n} from \"@ai-sdk/provider\";\nimport {\n  combineHeaders as combineHeaders3,\n  createJsonErrorResponseHandler as createJsonErrorResponseHandler3,\n  createJsonResponseHandler as createJsonResponseHandler3,\n  postJsonToApi as postJsonToApi3\n} from \"@ai-sdk/provider-utils\";\nimport { z as z4 } from \"zod\";\nvar OpenAICompatibleEmbeddingModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get maxEmbeddingsPerCall() {\n    var _a;\n    return (_a = this.config.maxEmbeddingsPerCall) != null ? _a : 2048;\n  }\n  get supportsParallelCalls() {\n    var _a;\n    return (_a = this.config.supportsParallelCalls) != null ? _a : true;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal\n  }) {\n    var _a;\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values\n      });\n    }\n    const { responseHeaders, value: response } = await postJsonToApi3({\n      url: this.config.url({\n        path: \"/embeddings\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders3(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: \"float\",\n        dimensions: this.settings.dimensions,\n        user: this.settings.user\n      },\n      failedResponseHandler: createJsonErrorResponseHandler3(\n        (_a = this.config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure\n      ),\n      successfulResponseHandler: createJsonResponseHandler3(\n        openaiTextEmbeddingResponseSchema\n      ),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      embeddings: response.data.map((item) => item.embedding),\n      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,\n      rawResponse: { headers: responseHeaders }\n    };\n  }\n};\nvar openaiTextEmbeddingResponseSchema = z4.object({\n  data: z4.array(z4.object({ embedding: z4.array(z4.number()) })),\n  usage: z4.object({ prompt_tokens: z4.number() }).nullish()\n});\n\n// src/openai-compatible-image-model.ts\nimport {\n  combineHeaders as combineHeaders4,\n  createJsonErrorResponseHandler as createJsonErrorResponseHandler4,\n  createJsonResponseHandler as createJsonResponseHandler4,\n  postJsonToApi as postJsonToApi4\n} from \"@ai-sdk/provider-utils\";\nimport { z as z5 } from \"zod\";\nvar OpenAICompatibleImageModel = class {\n  constructor(modelId, settings, config) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n    this.specificationVersion = \"v1\";\n  }\n  get maxImagesPerCall() {\n    var _a;\n    return (_a = this.settings.maxImagesPerCall) != null ? _a : 10;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal\n  }) {\n    var _a, _b, _c, _d, _e;\n    const warnings = [];\n    if (aspectRatio != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"aspectRatio\",\n        details: \"This model does not support aspect ratio. Use `size` instead.\"\n      });\n    }\n    if (seed != null) {\n      warnings.push({ type: \"unsupported-setting\", setting: \"seed\" });\n    }\n    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();\n    const { value: response, responseHeaders } = await postJsonToApi4({\n      url: this.config.url({\n        path: \"/images/generations\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders4(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        prompt,\n        n,\n        size,\n        ...(_d = providerOptions.openai) != null ? _d : {},\n        response_format: \"b64_json\",\n        ...this.settings.user ? { user: this.settings.user } : {}\n      },\n      failedResponseHandler: createJsonErrorResponseHandler4(\n        (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure\n      ),\n      successfulResponseHandler: createJsonResponseHandler4(\n        openaiCompatibleImageResponseSchema\n      ),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      images: response.data.map((item) => item.b64_json),\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders\n      }\n    };\n  }\n};\nvar openaiCompatibleImageResponseSchema = z5.object({\n  data: z5.array(z5.object({ b64_json: z5.string() }))\n});\n\n// src/openai-compatible-provider.ts\nimport { withoutTrailingSlash } from \"@ai-sdk/provider-utils\";\nfunction createOpenAICompatible(options) {\n  const baseURL = withoutTrailingSlash(options.baseURL);\n  const providerName = options.name;\n  const getHeaders = () => ({\n    ...options.apiKey && { Authorization: `Bearer ${options.apiKey}` },\n    ...options.headers\n  });\n  const getCommonModelConfig = (modelType) => ({\n    provider: `${providerName}.${modelType}`,\n    url: ({ path }) => {\n      const url = new URL(`${baseURL}${path}`);\n      if (options.queryParams) {\n        url.search = new URLSearchParams(options.queryParams).toString();\n      }\n      return url.toString();\n    },\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createLanguageModel = (modelId, settings = {}) => createChatModel(modelId, settings);\n  const createChatModel = (modelId, settings = {}) => new OpenAICompatibleChatLanguageModel(modelId, settings, {\n    ...getCommonModelConfig(\"chat\"),\n    defaultObjectGenerationMode: \"tool\"\n  });\n  const createCompletionModel = (modelId, settings = {}) => new OpenAICompatibleCompletionLanguageModel(\n    modelId,\n    settings,\n    getCommonModelConfig(\"completion\")\n  );\n  const createEmbeddingModel = (modelId, settings = {}) => new OpenAICompatibleEmbeddingModel(\n    modelId,\n    settings,\n    getCommonModelConfig(\"embedding\")\n  );\n  const createImageModel = (modelId, settings = {}) => new OpenAICompatibleImageModel(\n    modelId,\n    settings,\n    getCommonModelConfig(\"image\")\n  );\n  const provider = (modelId, settings) => createLanguageModel(modelId, settings);\n  provider.languageModel = createLanguageModel;\n  provider.chatModel = createChatModel;\n  provider.completionModel = createCompletionModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  provider.imageModel = createImageModel;\n  return provider;\n}\nexport {\n  OpenAICompatibleChatLanguageModel,\n  OpenAICompatibleCompletionLanguageModel,\n  OpenAICompatibleEmbeddingModel,\n  OpenAICompatibleImageModel,\n  createOpenAICompatible\n};\n//# sourceMappingURL=index.mjs.map","// src/fireworks-provider.ts\nimport {\n  OpenAICompatibleChatLanguageModel,\n  OpenAICompatibleCompletionLanguageModel,\n  OpenAICompatibleEmbeddingModel\n} from \"@ai-sdk/openai-compatible\";\nimport {\n  loadApiKey,\n  withoutTrailingSlash\n} from \"@ai-sdk/provider-utils\";\nimport { z } from \"zod\";\n\n// src/fireworks-image-model.ts\nimport {\n  combineHeaders,\n  createBinaryResponseHandler,\n  createStatusCodeErrorResponseHandler,\n  postJsonToApi\n} from \"@ai-sdk/provider-utils\";\nvar modelToBackendConfig = {\n  \"accounts/fireworks/models/flux-1-dev-fp8\": {\n    urlFormat: \"workflows\"\n  },\n  \"accounts/fireworks/models/flux-1-schnell-fp8\": {\n    urlFormat: \"workflows\"\n  },\n  \"accounts/fireworks/models/playground-v2-5-1024px-aesthetic\": {\n    urlFormat: \"image_generation\",\n    supportsSize: true\n  },\n  \"accounts/fireworks/models/japanese-stable-diffusion-xl\": {\n    urlFormat: \"image_generation\",\n    supportsSize: true\n  },\n  \"accounts/fireworks/models/playground-v2-1024px-aesthetic\": {\n    urlFormat: \"image_generation\",\n    supportsSize: true\n  },\n  \"accounts/fireworks/models/stable-diffusion-xl-1024-v1-0\": {\n    urlFormat: \"image_generation\",\n    supportsSize: true\n  },\n  \"accounts/fireworks/models/SSD-1B\": {\n    urlFormat: \"image_generation\",\n    supportsSize: true\n  }\n};\nfunction getUrlForModel(baseUrl, modelId) {\n  var _a;\n  switch ((_a = modelToBackendConfig[modelId]) == null ? void 0 : _a.urlFormat) {\n    case \"image_generation\":\n      return `${baseUrl}/image_generation/${modelId}`;\n    case \"workflows\":\n    default:\n      return `${baseUrl}/workflows/${modelId}/text_to_image`;\n  }\n}\nvar FireworksImageModel = class {\n  constructor(modelId, settings, config) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n    this.specificationVersion = \"v1\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get maxImagesPerCall() {\n    var _a;\n    return (_a = this.settings.maxImagesPerCall) != null ? _a : 1;\n  }\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal\n  }) {\n    var _a, _b, _c, _d;\n    const warnings = [];\n    const backendConfig = modelToBackendConfig[this.modelId];\n    if (!(backendConfig == null ? void 0 : backendConfig.supportsSize) && size != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"size\",\n        details: \"This model does not support the `size` option. Use `aspectRatio` instead.\"\n      });\n    }\n    if ((backendConfig == null ? void 0 : backendConfig.supportsSize) && aspectRatio != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"aspectRatio\",\n        details: \"This model does not support the `aspectRatio` option.\"\n      });\n    }\n    const splitSize = size == null ? void 0 : size.split(\"x\");\n    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: getUrlForModel(this.config.baseURL, this.modelId),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        prompt,\n        aspect_ratio: aspectRatio,\n        seed,\n        samples: n,\n        ...splitSize && { width: splitSize[0], height: splitSize[1] },\n        ...(_d = providerOptions.fireworks) != null ? _d : {}\n      },\n      failedResponseHandler: createStatusCodeErrorResponseHandler(),\n      successfulResponseHandler: createBinaryResponseHandler(),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      images: [response],\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders\n      }\n    };\n  }\n};\n\n// src/fireworks-provider.ts\nvar fireworksErrorSchema = z.object({\n  error: z.string()\n});\nvar fireworksErrorStructure = {\n  errorSchema: fireworksErrorSchema,\n  errorToMessage: (data) => data.error\n};\nvar defaultBaseURL = \"https://api.fireworks.ai/inference/v1\";\nfunction createFireworks(options = {}) {\n  var _a;\n  const baseURL = withoutTrailingSlash((_a = options.baseURL) != null ? _a : defaultBaseURL);\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: \"FIREWORKS_API_KEY\",\n      description: \"Fireworks API key\"\n    })}`,\n    ...options.headers\n  });\n  const getCommonModelConfig = (modelType) => ({\n    provider: `fireworks.${modelType}`,\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createChatModel = (modelId, settings = {}) => {\n    return new OpenAICompatibleChatLanguageModel(modelId, settings, {\n      ...getCommonModelConfig(\"chat\"),\n      errorStructure: fireworksErrorStructure,\n      defaultObjectGenerationMode: \"json\"\n    });\n  };\n  const createCompletionModel = (modelId, settings = {}) => new OpenAICompatibleCompletionLanguageModel(modelId, settings, {\n    ...getCommonModelConfig(\"completion\"),\n    errorStructure: fireworksErrorStructure\n  });\n  const createTextEmbeddingModel = (modelId, settings = {}) => new OpenAICompatibleEmbeddingModel(modelId, settings, {\n    ...getCommonModelConfig(\"embedding\"),\n    errorStructure: fireworksErrorStructure\n  });\n  const createImageModel = (modelId, settings = {}) => new FireworksImageModel(modelId, settings, {\n    ...getCommonModelConfig(\"image\"),\n    baseURL: baseURL != null ? baseURL : defaultBaseURL\n  });\n  const provider = (modelId, settings) => createChatModel(modelId, settings);\n  provider.completionModel = createCompletionModel;\n  provider.chatModel = createChatModel;\n  provider.languageModel = createChatModel;\n  provider.textEmbeddingModel = createTextEmbeddingModel;\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n  return provider;\n}\nvar fireworks = createFireworks();\nexport {\n  createFireworks,\n  fireworks\n};\n//# sourceMappingURL=index.mjs.map","/**\n * AI-Unified Chat API Route - AI SDK v5 Beta Compliant\n *\n * Features full AI SDK v5 beta compliance with Context7 principles:\n * - Tool call streaming with enhanced callbacks (onInputStart, onInputDelta, onInputAvailable)\n * - Modern UI message streams (.toUIMessageStreamResponse())\n * - Enhanced step callbacks (onStepFinish, onChunk)\n * - stopWhen conditions instead of maxSteps\n * - Reasoning content support\n * - Structured output capabilities\n * - Start/Delta/End streaming patterns\n * - Context7 observability & tracing\n */\n\nimport { geolocation } from \"@vercel/functions\";\nimport {\n  streamText,\n  type Message as AIMessage,\n  convertToModelMessages,\n  stepCountIs,\n  hasToolCall,\n  tool,\n} from \"ai\";\nimport { after } from \"next/server\";\nimport {\n  createResumableStreamContext,\n  type ResumableStreamContext,\n} from \"resumable-stream\";\nimport { z } from \"zod\";\nimport { v4 as uuidv4, validate as validateUuid } from \"uuid\";\n\n// Core imports\nimport { logger } from \"@/lib/logger\";\nimport { trackEvent } from \"@/lib/monitoring\";\nimport { ChatModelType } from \"@/_core/chat/entities/chat\";\nimport {\n  Chat,\n  type ChatVisibility as ChatVisibilityType,\n} from \"@/_core/chat/entities/chat\";\nimport {\n  ChatRepository,\n  DBChatSessionInsert,\n} from \"@/_infrastructure/repositories/chat-repository\";\nimport { RateLimitService } from \"@/services/rate-limit-service\";\n\n// AI & Tools\nimport {\n  type RequestHints,\n  systemPrompt as genericSystemPrompt,\n} from \"@/lib/ai/prompts\";\nimport { myProvider } from \"@/lib/ai/providers\";\n\n// Database & Auth\nimport { createSupabaseServiceClient } from \"@/lib/supabase/client\";\nimport { createClient } from \"@supabase/supabase-js\";\nimport { generateUUID } from \"@/lib/utils\";\nimport { Json } from \"@/types/database.types\";\nimport type { User as SupabaseUser } from \"@supabase/supabase-js\";\nimport { dbMessageToAIMessage } from \"@/lib/ai-sdk-adapter\";\n\n// RAG\nimport { HybridRetriever } from \"@/lib/rag/retrieval/hybrid-retriever\";\nimport { ContextAwareGenerator } from \"@/lib/rag/generation/context-generator\";\nimport OpenAI from \"openai\";\nimport * as fetchPonyfill from \"fetch-ponyfill\";\n\nconst { fetch: ponyfetch } = fetchPonyfill.default();\n\n// Configuration\nexport const maxDuration = 60;\nexport const runtime = \"nodejs\";\n\n// Enhanced Tool Definitions - AI SDK v5 Beta Compliant\nconst getWeatherTool = tool({\n  description: \"Get the current weather at a specific location\",\n  inputSchema: z.object({\n    latitude: z.number().describe(\"Latitude coordinate\"),\n    longitude: z.number().describe(\"Longitude coordinate\"),\n  }),\n  outputSchema: z.object({\n    current: z.object({\n      temperature_2m: z.number(),\n      time: z.string(),\n    }),\n    daily: z.object({\n      sunrise: z.array(z.string()),\n      sunset: z.array(z.string()),\n    }),\n    hourly: z.object({\n      temperature_2m: z.array(z.number()),\n    }),\n  }),\n  // Enhanced tool callbacks for streaming\n  onInputStart: ({ toolCallId }) => {\n    logger.info(\"Weather tool input streaming started\", { toolCallId });\n  },\n  onInputDelta: ({ inputTextDelta, toolCallId }) => {\n    logger.debug(\"Weather tool input delta\", {\n      toolCallId,\n      delta: inputTextDelta,\n    });\n  },\n  onInputAvailable: ({ input, toolCallId }) => {\n    logger.info(\"Weather tool input ready\", { toolCallId, input });\n  },\n  execute: async ({ latitude, longitude }) => {\n    const response = await fetch(\n      `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m&hourly=temperature_2m&daily=sunrise,sunset&timezone=auto`\n    );\n    const weatherData = await response.json();\n    return weatherData;\n  },\n});\n\nconst createDocumentTool = (session: any) =>\n  tool({\n    description: \"Create a new document with specified content and metadata\",\n    inputSchema: z.object({\n      title: z.string().describe(\"Document title\"),\n      content: z.string().describe(\"Document content\"),\n      type: z.enum([\"text\", \"markdown\", \"code\"]).describe(\"Document type\"),\n      tags: z.array(z.string()).optional().describe(\"Document tags\"),\n    }),\n    outputSchema: z.object({\n      id: z.string(),\n      title: z.string(),\n      createdAt: z.string(),\n      success: z.boolean(),\n    }),\n    onInputStart: ({ toolCallId }) => {\n      logger.info(\"Document creation tool started\", {\n        toolCallId,\n        userId: session?.id,\n      });\n    },\n    onInputDelta: ({ inputTextDelta, toolCallId }) => {\n      logger.debug(\"Document creation input delta\", {\n        toolCallId,\n        delta: inputTextDelta,\n      });\n    },\n    onInputAvailable: ({ input, toolCallId }) => {\n      logger.info(\"Document creation input ready\", {\n        toolCallId,\n        input: input.title,\n      });\n    },\n    execute: async ({ title, content, type, tags }) => {\n      // Simulate document creation\n      const documentId = generateUUID();\n      return {\n        id: documentId,\n        title,\n        createdAt: new Date().toISOString(),\n        success: true,\n      };\n    },\n  });\n\nconst updateDocumentTool = (session: any) =>\n  tool({\n    description: \"Update an existing document with new content\",\n    inputSchema: z.object({\n      documentId: z.string().describe(\"Document ID to update\"),\n      content: z.string().describe(\"New document content\"),\n      title: z.string().optional().describe(\"New document title\"),\n    }),\n    outputSchema: z.object({\n      id: z.string(),\n      updatedAt: z.string(),\n      success: z.boolean(),\n    }),\n    onInputStart: ({ toolCallId }) => {\n      logger.info(\"Document update tool started\", {\n        toolCallId,\n        userId: session?.id,\n      });\n    },\n    onInputDelta: ({ inputTextDelta, toolCallId }) => {\n      logger.debug(\"Document update input delta\", {\n        toolCallId,\n        delta: inputTextDelta,\n      });\n    },\n    onInputAvailable: ({ input, toolCallId }) => {\n      logger.info(\"Document update input ready\", {\n        toolCallId,\n        documentId: input.documentId,\n      });\n    },\n    execute: async ({ documentId, content, title }) => {\n      // Simulate document update\n      return {\n        id: documentId,\n        updatedAt: new Date().toISOString(),\n        success: true,\n      };\n    },\n  });\n\n// Validation schemas - simplified but complete\nconst chatVisibilityEnumValues: [ChatVisibilityType, ...ChatVisibilityType[]] =\n  [\"private\", \"public\", \"team\"];\n\nconst postRequestSchema = z.object({\n  id: z.string().uuid().optional(),\n  messages: z.array(\n    z.object({\n      id: z.string(),\n      role: z.enum([\"user\", \"assistant\", \"system\"]),\n      content: z.string().min(1).max(10000),\n      createdAt: z.date().optional(),\n    })\n  ),\n  selectedChatModel: z.nativeEnum(ChatModelType),\n  visibility: z.enum(chatVisibilityEnumValues).optional(),\n  description: z.string().max(1000).optional(),\n  caseId: z.string().uuid().optional(),\n  countryCode: z.string().length(2).optional(),\n});\n\nconst updateChatSchema = z.object({\n  title: z.string().min(1).max(200).optional(),\n  description: z.string().max(1000).optional().nullable(),\n  modelType: z.nativeEnum(ChatModelType).optional(),\n  caseId: z.string().uuid().optional().nullable(),\n  visibility: z.enum(chatVisibilityEnumValues).optional(),\n});\n\n// Global stream context\nlet globalStreamContext: ResumableStreamContext | null = null;\n\nfunction getStreamContext() {\n  if (!globalStreamContext) {\n    try {\n      globalStreamContext = createResumableStreamContext({ waitUntil: after });\n    } catch (error: any) {\n      if (!error.message.includes(\"REDIS_URL\")) {\n        logger.error(\"Failed to initialize resumable stream context\", error);\n      }\n    }\n  }\n  return globalStreamContext;\n}\n\n// Helper functions\nfunction extractChatIdFromPath(pathname: string): string | null {\n  const parts = pathname.split(\"/\");\n  if (parts.length > 3 && parts[1] === \"api\" && parts[2] === \"chat\") {\n    const potentialId = parts[3];\n    return validateUuid(potentialId) ? potentialId : null;\n  }\n  return null;\n}\n\nfunction extractTextFromMessage(message: any): string | undefined {\n  if (typeof message.content === \"string\") return message.content;\n  const textPart = message.parts?.find((p: any) => p.type === \"text\");\n  return textPart?.text;\n}\n\n// Import our new authentication adapter\nimport {\n  authenticateRequest as authenticateRequestAdapter,\n  createAuthErrorResponse,\n  requirePermission,\n  AuthenticationError,\n  type AuthResult,\n} from \"./auth-adapter\";\n\nasync function enhanceWithRAGContext(\n  userMessage: string,\n  userId: string\n): Promise<string | null> {\n  try {\n    const supabaseClient = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n    const openaiClient = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n      fetch: ponyfetch as unknown as typeof fetch,\n    });\n\n    const retriever = new HybridRetriever(supabaseClient, openaiClient);\n    const generator = new ContextAwareGenerator();\n\n    const searchResults = await retriever.search(userMessage, { userId });\n    const context = generator.buildContext(\n      searchResults,\n      (searchResults as any).userContext\n    );\n    return generator.createSystemPrompt(context);\n  } catch (error) {\n    logger.error(\n      \"RAG context enhancement failed\",\n      error instanceof Error ? error : new Error(String(error))\n    );\n    return null;\n  }\n}\n\n// Main POST handler - AI SDK v5 Beta compliant\nexport async function POST(request: Request) {\n  const startTime = Date.now();\n  const { pathname } = new URL(request.url);\n  const extractedChatId = extractChatIdFromPath(pathname);\n\n  try {\n    // Authentication - Context7 compliant with guest support\n    let authResult: AuthResult;\n    try {\n      authResult = await authenticateRequestAdapter(request as any);\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return createAuthErrorResponse(error);\n      }\n      throw error;\n    }\n\n    const { user: userFromAuth, isGuest } = authResult;\n    const userId = userFromAuth.id;\n\n    // Context7 - Observability: Log request with user context\n    logger.info(\"Chat API request\", {\n      userId,\n      isGuest,\n      pathname,\n      userAgent: request.headers.get(\"user-agent\"),\n    });\n\n    // Rate limiting\n    const rateLimitResult = await RateLimitService.isAllowed(\n      userId,\n      \"api\",\n      \"standard\"\n    );\n    if (!rateLimitResult.success) {\n      return new Response(\"Rate limit exceeded\", {\n        status: 429,\n        headers: {\n          \"X-RateLimit-Reset\": rateLimitResult.reset.toString(),\n          \"X-RateLimit-Remaining\": rateLimitResult.remaining.toString(),\n        },\n      });\n    }\n\n    const chatRepository = new ChatRepository();\n\n    // Handle different endpoints\n    if (extractedChatId && pathname.endsWith(\"/generate-title\")) {\n      return await handleGenerateTitle(extractedChatId, userId, chatRepository);\n    }\n\n    // Main chat endpoint\n    if (pathname === \"/api/chat\" || pathname === \"/api/chat/\") {\n      const body = await request.json();\n\n      // Simple validation with normalization\n      const normalizedBody = {\n        ...body,\n        id: body.id && validateUuid(body.id) ? body.id : uuidv4(),\n        messages: body.messages || (body.message ? [body.message] : []),\n        visibility: body.visibility || body.selectedVisibilityType || \"private\",\n      };\n\n      const validatedData = postRequestSchema.parse(normalizedBody);\n      const {\n        id: chatIdFromRequest,\n        messages: clientMessages,\n        selectedChatModel,\n        visibility = \"private\",\n        description,\n        caseId,\n        countryCode,\n      } = validatedData;\n\n      // Ensure chatIdFromRequest is defined after normalization\n      const chatId = chatIdFromRequest || uuidv4();\n\n      const userMessage = clientMessages[\n        clientMessages.length - 1\n      ] as AIMessage;\n      const userMessageContent = extractTextFromMessage(userMessage) || \"\";\n\n      // Get or create chat\n      let chatEntity = await chatRepository.getChatById(chatId);\n\n      if (!chatEntity) {\n        const title = userMessageContent.substring(0, 100) || \"New Chat\";\n        const newChatData: DBChatSessionInsert = {\n          id: chatId,\n          user_id: userId,\n          title,\n          model: selectedChatModel,\n          visibility,\n          case_id: caseId || null,\n          metadata: {\n            ...(countryCode && { countryCode }),\n            ...(description && { description }),\n            createdAt: new Date().toISOString(),\n          },\n        };\n\n        const newChatRecord = await chatRepository.create(newChatData);\n        chatEntity = Chat.fromDatabase(newChatRecord);\n        logger.info(\"Created new chat\", { chatId, userId });\n      } else if (chatEntity.userId !== userId) {\n        return new Response(\"Forbidden\", { status: 403 });\n      }\n\n      // Get existing messages and prepare for AI\n      const existingMessages = await chatRepository.getMessages(chatId);\n      const allMessages = [\n        ...existingMessages.map(dbMessageToAIMessage),\n        userMessage,\n      ];\n\n      // Enhanced context\n      const { longitude, latitude, city, country } = geolocation(request);\n      const requestHints: RequestHints = { longitude, latitude, city, country };\n\n      let systemPrompt =\n        chatEntity?.systemPrompt ||\n        genericSystemPrompt({ selectedChatModel, requestHints });\n\n      // RAG enhancement\n      try {\n        const ragContext = await enhanceWithRAGContext(\n          userMessageContent,\n          userId\n        );\n        if (ragContext) {\n          systemPrompt = `${systemPrompt}\\n\\n${ragContext}`;\n        }\n      } catch (error) {\n        logger.warn(\"RAG integration failed, continuing without context\", {\n          error,\n        });\n      }\n\n      // Save user message first\n      await chatRepository.addMessage(chatId, {\n        id: userMessage.id,\n        role: \"user\",\n        content: userMessageContent,\n        metadata: {\n          requestHints,\n          timestamp: new Date().toISOString(),\n          userAgent: request.headers.get(\"User-Agent\"),\n        } as unknown as Json,\n        user_id: userId,\n      });\n\n      // AI SDK v5 Beta - Enhanced streamText with all features\n      const result = streamText({\n        model: myProvider.languageModel(selectedChatModel),\n        system: systemPrompt,\n        messages: convertToModelMessages(allMessages),\n\n        // AI SDK v5 Beta - Modern stopping conditions\n        stopWhen: [\n          stepCountIs(5), // Maximum 5 steps\n          hasToolCall(\"finalizeTask\"), // Stop on finalization\n          // Custom condition for content completion\n          ({ steps }) => {\n            const lastStep = steps[steps.length - 1];\n            return lastStep?.text?.includes(\"TASK_COMPLETE\") || false;\n          },\n        ],\n\n        // AI SDK v5 Beta - Enhanced tool definitions with streaming\n        tools:\n          selectedChatModel === ChatModelType.GPT_3_5\n            ? undefined\n            : {\n                getWeather: getWeatherTool,\n                createDocument: createDocumentTool(userFromAuth),\n                updateDocument: updateDocumentTool(userFromAuth),\n              },\n\n        // AI SDK v5 Beta - Enhanced step callback\n        onStepFinish: async ({\n          stepType,\n          text,\n          toolCalls,\n          toolResults,\n          finishReason,\n          usage,\n          reasoning,\n          sources,\n          files,\n        }) => {\n          const stepTime = Date.now() - startTime;\n\n          // Context7 - Observability: Log each step completion\n          logger.info(\"AI step finished\", {\n            chatId,\n            stepType,\n            finishReason,\n            textLength: text.length,\n            toolCallsCount: toolCalls?.length || 0,\n            toolResultsCount: toolResults?.length || 0,\n            tokensUsed: usage?.totalTokens || 0,\n            stepTime,\n            hasReasoning: !!reasoning,\n            sourcesCount: sources?.length || 0,\n            filesCount: files?.length || 0,\n          });\n\n          // Track tool usage for analytics\n          if (toolCalls && toolCalls.length > 0) {\n            trackEvent({\n              name: \"tool_calls_executed\",\n              properties: {\n                chatId,\n                toolNames: toolCalls.map((tc) => tc.toolName),\n                stepType,\n                userId,\n              },\n            });\n          }\n        },\n\n        // AI SDK v5 Beta - Enhanced chunk processing\n        onChunk: async ({ chunk }) => {\n          switch (chunk.type) {\n            case \"text\":\n              // Context7 - Observability: Log text streaming\n              logger.debug(\"Text chunk received\", {\n                chatId,\n                textLength: chunk.text.length,\n              });\n              break;\n\n            case \"reasoning\":\n              // AI SDK v5 Beta - Reasoning content support\n              logger.info(\"Reasoning chunk received\", {\n                chatId,\n                reasoningLength: chunk.text.length,\n              });\n              break;\n\n            case \"source\":\n              // AI SDK v5 Beta - Source information handling\n              logger.info(\"Source chunk received\", {\n                chatId,\n                sourceType: chunk.source.sourceType,\n                sourceId: chunk.source.id,\n              });\n              break;\n\n            case \"tool-call\":\n              // AI SDK v5 Beta - Enhanced tool call logging\n              logger.info(\"Tool call chunk received\", {\n                chatId,\n                toolName: chunk.toolName,\n                toolCallId: chunk.toolCallId,\n              });\n              break;\n\n            case \"tool-input-start\":\n              logger.debug(\"Tool input streaming started\", {\n                chatId,\n                toolName: chunk.toolName,\n                toolCallId: chunk.id,\n              });\n              break;\n\n            case \"tool-input-delta\":\n              logger.debug(\"Tool input delta received\", {\n                chatId,\n                toolCallId: chunk.id,\n                deltaLength: chunk.delta.length,\n              });\n              break;\n\n            case \"tool-result\":\n              logger.info(\"Tool result chunk received\", {\n                chatId,\n                outputSize: JSON.stringify(chunk.output).length,\n              });\n              break;\n\n            case \"raw\":\n              logger.debug(\"Raw chunk received\", { chatId });\n              break;\n          }\n        },\n\n        // AI SDK v5 Beta - Enhanced onFinish with full response handling\n        onFinish: async ({\n          text,\n          usage,\n          response,\n          reasoning,\n          sources,\n          files,\n        }) => {\n          const processingTime = Date.now() - startTime;\n\n          try {\n            const assistantMessageId = generateUUID();\n\n            // Save assistant message with enhanced metadata\n            await chatRepository.addMessage(chatId, {\n              id: assistantMessageId,\n              role: \"assistant\",\n              content: text,\n              metadata: {\n                model: selectedChatModel,\n                modelId: response.modelId,\n                processingTime,\n                tokensUsed: usage?.totalTokens || 0,\n                promptTokens: usage?.promptTokens || 0,\n                completionTokens: usage?.completionTokens || 0,\n                timestamp: new Date().toISOString(),\n                hasReasoning: !!reasoning,\n                reasoningLength: reasoning?.length || 0,\n                sourcesCount: sources?.length || 0,\n                filesCount: files?.length || 0,\n                responseId: response.id,\n              } as unknown as Json,\n              user_id: userId,\n            });\n\n            // Enhanced metrics tracking\n            trackEvent({\n              name: \"chat_message_processed\",\n              properties: {\n                chatId,\n                model: selectedChatModel,\n                modelId: response.modelId,\n                processingTime,\n                tokensUsed: usage?.totalTokens || 0,\n                promptTokens: usage?.promptTokens || 0,\n                completionTokens: usage?.completionTokens || 0,\n                hasReasoning: !!reasoning,\n                sourcesCount: sources?.length || 0,\n                filesCount: files?.length || 0,\n                userId,\n                isGuest,\n              },\n            });\n\n            logger.info(\"Chat message processed\", {\n              chatId,\n              processingTime,\n              tokensUsed: usage?.totalTokens || 0,\n              modelId: response.modelId,\n              hasReasoning: !!reasoning,\n              sourcesCount: sources?.length || 0,\n            });\n          } catch (error) {\n            logger.error(\n              \"Failed to save assistant message\",\n              error instanceof Error ? error : new Error(String(error))\n            );\n          }\n        },\n\n        onError: ({ error }) => {\n          logger.error(\"Streaming error\", new Error(String(error)), { chatId });\n        },\n      });\n\n      // Handle resumable streams if available\n      const streamContext = getStreamContext();\n      if (streamContext) {\n        try {\n          const streamId = generateUUID();\n          const resumableStream = await streamContext.resumableStream(\n            streamId,\n            () =>\n              result.toUIMessageStreamResponse() as unknown as ReadableStream<string>\n          );\n          await chatRepository.storeStreamId(chatId, streamId);\n          return resumableStream;\n        } catch (error) {\n          logger.warn(\n            \"Failed to create resumable stream, using regular stream\",\n            { error }\n          );\n        }\n      }\n\n      // AI SDK v5 Beta - Modern UI message stream response\n      const headers: HeadersInit = {};\n      if (chatId) {\n        headers[\"X-Chat-Id\"] = chatId;\n      }\n\n      return result.toUIMessageStreamResponse({\n        headers,\n        // AI SDK v5 Beta - Enhanced response metadata\n        messageMetadata: ({ part }) => {\n          // Send model information on start\n          if (part.type === \"start\") {\n            return {\n              model: selectedChatModel,\n              chatId,\n              startTime: Date.now(),\n            };\n          }\n\n          // Send step information on finish-step\n          if (part.type === \"finish-step\") {\n            return {\n              model: part.response.modelId,\n              stepDuration: Date.now() - startTime,\n              tokensUsed: part.usage.totalTokens,\n            };\n          }\n\n          // Send final information on finish\n          if (part.type === \"finish\") {\n            return {\n              totalTokens: part.totalUsage.totalTokens,\n              totalDuration: Date.now() - startTime,\n              chatId,\n            };\n          }\n        },\n      });\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n  } catch (error: any) {\n    logger.error(\"Chat API error\", error);\n\n    if (error instanceof z.ZodError) {\n      return new Response(\n        JSON.stringify({\n          error: \"Validation failed\",\n          details: error.errors,\n        }),\n        {\n          status: 400,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    return new Response(JSON.stringify({ error: \"Internal server error\" }), {\n      status: 500,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  }\n}\n\n// Simplified handlers for other operations\nasync function handleGenerateTitle(\n  chatId: string,\n  userId: string,\n  chatRepository: ChatRepository\n) {\n  try {\n    const chat = await chatRepository.getChatById(chatId);\n    if (!chat || chat.userId !== userId) {\n      return new Response(\"Forbidden\", { status: 403 });\n    }\n\n    const messages = await chatRepository.getMessages(chatId);\n    const firstUserMessage = messages.find((m) => m.role === \"user\");\n\n    if (!firstUserMessage) {\n      return new Response(\"No user message found\", { status: 400 });\n    }\n\n    const title =\n      extractTextFromMessage(firstUserMessage)?.substring(0, 100) || \"New Chat\";\n    await chatRepository.update(chatId, { title });\n\n    return Response.json({ success: true, title });\n  } catch (error) {\n    logger.error(\n      \"Failed to generate title\",\n      error instanceof Error ? error : new Error(String(error))\n    );\n    return new Response(\"Failed to generate title\", { status: 500 });\n  }\n}\n\n// GET handler - simplified\nexport async function GET(request: Request) {\n  try {\n    let authResult: AuthResult;\n    try {\n      authResult = await authenticateRequestAdapter(request as any);\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return createAuthErrorResponse(error);\n      }\n      throw error;\n    }\n    const { user } = authResult;\n\n    const chatRepository = new ChatRepository();\n    const { pathname, searchParams } = new URL(request.url);\n    const extractedChatId = extractChatIdFromPath(pathname);\n\n    // Handle stream resume\n    const streamId = searchParams.get(\"streamId\");\n    if (streamId) {\n      const streamContext = getStreamContext();\n      if (streamContext) {\n        try {\n          const resumedStream = await streamContext.resumableStream(\n            streamId,\n            () => new ReadableStream<string>()\n          );\n          return resumedStream;\n        } catch (error) {\n          return new Response(\"Stream not found\", { status: 404 });\n        }\n      }\n      return new Response(\"Stream context not available\", { status: 500 });\n    }\n\n    // Get specific chat\n    if (extractedChatId) {\n      const chat = await chatRepository.getChatById(extractedChatId);\n      if (!chat || chat.userId !== user.id) {\n        return new Response(\"Chat not found\", { status: 404 });\n      }\n      return Response.json({ chat: chat.toObject() });\n    }\n\n    // Get chat list\n    const limit = Math.min(parseInt(searchParams.get(\"limit\") || \"50\"), 100);\n    const offset = Math.max(parseInt(searchParams.get(\"offset\") || \"0\"), 0);\n    const caseId = searchParams.get(\"caseId\") || undefined;\n\n    const chats = await chatRepository.getByUserId(user.id, {\n      limit,\n      offset,\n      case_id: caseId,\n    });\n    const chatEntities = chats.map((c) => Chat.fromDatabase(c));\n\n    return Response.json({\n      chats: chatEntities.map((chat) => chat.toObject()),\n      pagination: { limit, offset, hasMore: chats.length === limit },\n    });\n  } catch (error) {\n    logger.error(\n      \"GET error\",\n      error instanceof Error ? error : new Error(String(error))\n    );\n    return new Response(\"Internal server error\", { status: 500 });\n  }\n}\n\n// PATCH handler - simplified\nexport async function PATCH(request: Request) {\n  try {\n    let authResult: AuthResult;\n    try {\n      authResult = await authenticateRequestAdapter(request as any);\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return createAuthErrorResponse(error);\n      }\n      throw error;\n    }\n    const { user } = authResult;\n\n    const { pathname } = new URL(request.url);\n    const chatId = extractChatIdFromPath(pathname);\n    if (!chatId) return new Response(\"Chat ID required\", { status: 400 });\n\n    const chatRepository = new ChatRepository();\n    const chat = await chatRepository.getChatById(chatId);\n    if (!chat || chat.userId !== user.id) {\n      return new Response(\"Chat not found\", { status: 404 });\n    }\n\n    const body = await request.json();\n    const validatedData = updateChatSchema.parse(body);\n\n    const updatedChat = await chatRepository.update(chatId, {\n      title: validatedData.title,\n      model: validatedData.modelType,\n      visibility: validatedData.visibility,\n      case_id: validatedData.caseId,\n      metadata: {\n        ...chat.metadata,\n        ...(validatedData.description !== undefined && {\n          description: validatedData.description,\n        }),\n        updatedAt: new Date().toISOString(),\n      },\n    });\n\n    return Response.json({ chat: Chat.fromDatabase(updatedChat).toObject() });\n  } catch (error) {\n    logger.error(\n      \"PATCH error\",\n      error instanceof Error ? error : new Error(String(error))\n    );\n    if (error instanceof z.ZodError) {\n      return new Response(\n        JSON.stringify({ error: \"Validation failed\", details: error.errors }),\n        {\n          status: 400,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n    return new Response(\"Internal server error\", { status: 500 });\n  }\n}\n\n// DELETE handler - simplified\nexport async function DELETE(request: Request) {\n  try {\n    let authResult: AuthResult;\n    try {\n      authResult = await authenticateRequestAdapter(request as any);\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return createAuthErrorResponse(error);\n      }\n      throw error;\n    }\n    const { user } = authResult;\n\n    const { pathname } = new URL(request.url);\n    const chatId = extractChatIdFromPath(pathname);\n    if (!chatId) return new Response(\"Chat ID required\", { status: 400 });\n\n    const chatRepository = new ChatRepository();\n    const chat = await chatRepository.getChatById(chatId);\n    if (!chat || chat.userId !== user.id) {\n      return new Response(\"Forbidden\", { status: 403 });\n    }\n\n    await chatRepository.deleteChat(chatId);\n    return Response.json({ success: true });\n  } catch (error) {\n    logger.error(\n      \"DELETE error\",\n      error instanceof Error ? error : new Error(String(error))\n    );\n    return new Response(\"Internal server error\", { status: 500 });\n  }\n}\n","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/(ai-unified)/api/chat',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar middleware_exports = {};\n__export(middleware_exports, {\n  next: () => next,\n  rewrite: () => rewrite\n});\nmodule.exports = __toCommonJS(middleware_exports);\nfunction handleMiddlewareField(init, headers) {\n  if (init?.request?.headers) {\n    if (!(init.request.headers instanceof Headers)) {\n      throw new Error(\"request.headers must be an instance of Headers\");\n    }\n    const keys = [];\n    for (const [key, value] of init.request.headers) {\n      headers.set(\"x-middleware-request-\" + key, value);\n      keys.push(key);\n    }\n    headers.set(\"x-middleware-override-headers\", keys.join(\",\"));\n  }\n}\nfunction rewrite(destination, init) {\n  const headers = new Headers(init?.headers ?? {});\n  headers.set(\"x-middleware-rewrite\", String(destination));\n  handleMiddlewareField(init, headers);\n  return new Response(null, {\n    ...init,\n    headers\n  });\n}\nfunction next(init) {\n  const headers = new Headers(init?.headers ?? {});\n  headers.set(\"x-middleware-next\", \"1\");\n  handleMiddlewareField(init, headers);\n  return new Response(null, {\n    ...init,\n    headers\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  next,\n  rewrite\n});\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar get_context_exports = {};\n__export(get_context_exports, {\n  SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,\n  getContext: () => getContext\n});\nmodule.exports = __toCommonJS(get_context_exports);\nconst SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction getContext() {\n  const fromSymbol = globalThis;\n  return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  SYMBOL_FOR_REQ_CONTEXT,\n  getContext\n});\n","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","import { randomUUID } from 'crypto';\nexport default { randomUUID };\n","import { randomFillSync } from 'crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createSubscriberAdapter = createSubscriberAdapter;\nexports.createPublisherAdapter = createPublisherAdapter;\n/**\n * Creates a Subscriber adapter for a Redis client.\n * @param client - The Redis client to adapt\n * @returns A Subscriber interface compatible with the resumable stream\n */\nfunction createSubscriberAdapter(client) {\n    const adapter = {\n        connect: () => client.connect(),\n        subscribe: async function (channel, callback) {\n            client.on(\"message\", (innerChannel, message) => {\n                if (channel === innerChannel) {\n                    callback(message);\n                }\n            });\n            await client.subscribe(channel);\n        },\n        unsubscribe: (channel) => client.unsubscribe(channel),\n    };\n    return adapter;\n}\n/**\n * Creates a Publisher adapter for a Redis client.\n * @param client - The Redis client to adapt\n * @returns A Publisher interface compatible with the resumable stream\n */\nfunction createPublisherAdapter(client) {\n    const adapter = {\n        connect: () => client.connect(),\n        publish: (channel, message) => client.publish(channel, message),\n        set: (key, value, options) => {\n            if (options === null || options === void 0 ? void 0 : options.EX) {\n                return client.set(key, value, \"EX\", options.EX);\n            }\n            return client.set(key, value);\n        },\n        get: (key) => client.get(key),\n        incr: (key) => client.incr(key),\n    };\n    return adapter;\n}\n//# sourceMappingURL=ioredis-adapters.js.map","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"node:crypto\");","module.exports = require(\"buffer\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar in_memory_cache_exports = {};\n__export(in_memory_cache_exports, {\n  InMemoryCache: () => InMemoryCache\n});\nmodule.exports = __toCommonJS(in_memory_cache_exports);\nclass InMemoryCache {\n  constructor() {\n    this.cache = {};\n  }\n  async get(key, options) {\n    const entry = this.cache[key];\n    if (entry) {\n      if (entry.ttl && entry.lastModified + entry.ttl * 1e3 < Date.now()) {\n        await this.delete(key);\n        return null;\n      }\n      if (options?.tags) {\n        for (const tag of options.tags) {\n          entry.tags.add(tag);\n        }\n      }\n      return entry.value;\n    }\n    return null;\n  }\n  async set(key, value, options) {\n    this.cache[key] = {\n      value,\n      lastModified: Date.now(),\n      ttl: options?.ttl,\n      tags: new Set(options?.tags || [])\n    };\n  }\n  async delete(key) {\n    delete this.cache[key];\n  }\n  async expireTag(tag) {\n    const tags = Array.isArray(tag) ? tag : [tag];\n    for (const key in this.cache) {\n      if (Object.prototype.hasOwnProperty.call(this.cache, key)) {\n        const entry = this.cache[key];\n        if (tags.some((t) => entry.tags.has(t))) {\n          delete this.cache[key];\n        }\n      }\n    }\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  InMemoryCache\n});\n","module.exports = require(\"node:readline\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createResumableStreamContextFactory = createResumableStreamContextFactory;\nexports.resumeStream = resumeStream;\nconst ioredis_adapters_1 = require(\"./ioredis-adapters\");\nfunction createResumableStreamContextFactory(defaults) {\n    return function createResumableStreamContext(options) {\n        const ctx = {\n            keyPrefix: `${options.keyPrefix || \"resumable-stream\"}:rs`,\n            waitUntil: options.waitUntil,\n            subscriber: options.subscriber,\n            publisher: options.publisher,\n        };\n        let initPromises = [];\n        // Check if user has passed a raw ioredis instance\n        if (options.subscriber && options.subscriber.defineCommand) {\n            ctx.subscriber = (0, ioredis_adapters_1.createSubscriberAdapter)(options.subscriber);\n        }\n        if (options.publisher && options.publisher.defineCommand) {\n            ctx.publisher = (0, ioredis_adapters_1.createPublisherAdapter)(options.publisher);\n        }\n        // If user has passed undefined, initialize with defaults\n        if (!ctx.subscriber) {\n            ctx.subscriber = defaults.subscriber();\n            initPromises.push(ctx.subscriber.connect());\n        }\n        if (!ctx.publisher) {\n            ctx.publisher = defaults.publisher();\n            initPromises.push(ctx.publisher.connect());\n        }\n        return {\n            resumeExistingStream: async (streamId, skipCharacters) => {\n                return resumeExistingStream(Promise.all(initPromises), ctx, streamId, skipCharacters);\n            },\n            createNewResumableStream: async (streamId, makeStream, skipCharacters) => {\n                const initPromise = Promise.all(initPromises);\n                await initPromise;\n                await ctx.publisher.set(`${ctx.keyPrefix}:sentinel:${streamId}`, \"1\", {\n                    EX: 24 * 60 * 60,\n                });\n                return createNewResumableStream(initPromise, ctx, streamId, makeStream);\n            },\n            resumableStream: async (streamId, makeStream, skipCharacters) => {\n                return createResumableStream(Promise.all(initPromises), ctx, streamId, makeStream, skipCharacters);\n            },\n        };\n    };\n}\nconst DONE_MESSAGE = \"\\n\\n\\nDONE_SENTINEL_hasdfasudfyge374%$%^$EDSATRTYFtydryrte\\n\";\nconst DONE_VALUE = \"DONE\";\nasync function resumeExistingStream(initPromise, ctx, streamId, skipCharacters) {\n    await initPromise;\n    const state = await ctx.publisher.get(`${ctx.keyPrefix}:sentinel:${streamId}`);\n    if (!state) {\n        return undefined;\n    }\n    if (state === DONE_VALUE) {\n        return null;\n    }\n    return resumeStream(ctx, streamId, skipCharacters);\n}\nasync function createNewResumableStream(initPromise, ctx, streamId, makeStream) {\n    await initPromise;\n    const chunks = [];\n    let listenerChannels = [];\n    let streamDoneResolver;\n    ctx.waitUntil(new Promise((resolve) => {\n        streamDoneResolver = resolve;\n    }));\n    let isDone = false;\n    // This is ultimately racy if two requests for the same ID come at the same time.\n    // But this library is for the case where that would not happen.\n    await ctx.subscriber.subscribe(`${ctx.keyPrefix}:request:${streamId}`, async (message) => {\n        const parsedMessage = JSON.parse(message);\n        debugLog(\"Connected to listener\", parsedMessage.listenerId);\n        listenerChannels.push(parsedMessage.listenerId);\n        debugLog(\"parsedMessage\", chunks.length, parsedMessage.skipCharacters);\n        const chunksToSend = chunks.join(\"\").slice(parsedMessage.skipCharacters || 0);\n        debugLog(\"sending chunks\", chunksToSend.length);\n        const promises = [];\n        promises.push(ctx.publisher.publish(`${ctx.keyPrefix}:chunk:${parsedMessage.listenerId}`, chunksToSend));\n        if (isDone) {\n            promises.push(ctx.publisher.publish(`${ctx.keyPrefix}:chunk:${parsedMessage.listenerId}`, DONE_MESSAGE));\n        }\n        await Promise.all(promises);\n    });\n    return new ReadableStream({\n        start(controller) {\n            const stream = makeStream();\n            const reader = stream.getReader();\n            function read() {\n                reader.read().then(async ({ done, value }) => {\n                    if (done) {\n                        isDone = true;\n                        debugLog(\"Stream done\");\n                        try {\n                            controller.close();\n                        }\n                        catch (e) {\n                            //console.error(e);\n                        }\n                        const promises = [];\n                        debugLog(\"setting sentinel to done\");\n                        promises.push(ctx.publisher.set(`${ctx.keyPrefix}:sentinel:${streamId}`, DONE_VALUE, {\n                            EX: 24 * 60 * 60,\n                        }));\n                        promises.push(ctx.subscriber.unsubscribe(`${ctx.keyPrefix}:request:${streamId}`));\n                        for (const listenerId of listenerChannels) {\n                            debugLog(\"sending done message to\", listenerId);\n                            promises.push(ctx.publisher.publish(`${ctx.keyPrefix}:chunk:${listenerId}`, DONE_MESSAGE));\n                        }\n                        await Promise.all(promises);\n                        streamDoneResolver === null || streamDoneResolver === void 0 ? void 0 : streamDoneResolver();\n                        debugLog(\"Cleanup done\");\n                        return;\n                    }\n                    chunks.push(value);\n                    try {\n                        debugLog(\"Enqueuing line\", value);\n                        controller.enqueue(value);\n                    }\n                    catch (e) {\n                        // If we cannot enqueue, the stream is already closed, but we WANT to continue.\n                    }\n                    const promises = [];\n                    for (const listenerId of listenerChannels) {\n                        debugLog(\"sending line to\", listenerId);\n                        promises.push(ctx.publisher.publish(`${ctx.keyPrefix}:chunk:${listenerId}`, value));\n                    }\n                    await Promise.all(promises);\n                    read();\n                });\n            }\n            read();\n        },\n    });\n}\n/**\n * Creates a resumable stream of strings.\n *\n * @param streamId - The ID of the stream.\n * @param makeStream - A function that returns a stream of strings. It's only executed if the stream it not yet in progress.\n * @returns A stream of strings.\n */\nasync function createResumableStream(initPromise, ctx, streamId, makeStream, skipCharacters) {\n    await initPromise;\n    const currentListenerCount = await incrOrDone(ctx.publisher, `${ctx.keyPrefix}:sentinel:${streamId}`);\n    debugLog(\"currentListenerCount\", currentListenerCount);\n    if (currentListenerCount === DONE_VALUE) {\n        return null;\n    }\n    if (currentListenerCount > 1) {\n        return resumeStream(ctx, streamId, skipCharacters);\n    }\n    return createNewResumableStream(initPromise, ctx, streamId, makeStream);\n}\nasync function resumeStream(ctx, streamId, skipCharacters) {\n    const listenerId = crypto.randomUUID();\n    return new Promise((resolve, reject) => {\n        const readableStream = new ReadableStream({\n            async start(controller) {\n                try {\n                    debugLog(\"STARTING STREAM\", streamId, listenerId);\n                    const cleanup = async () => {\n                        await ctx.subscriber.unsubscribe(`${ctx.keyPrefix}:chunk:${listenerId}`);\n                    };\n                    const start = Date.now();\n                    const timeout = setTimeout(async () => {\n                        await cleanup();\n                        const val = await ctx.publisher.get(`${ctx.keyPrefix}:sentinel:${streamId}`);\n                        if (val === DONE_VALUE) {\n                            resolve(null);\n                        }\n                        if (Date.now() - start > 1000) {\n                            controller.error(new Error(\"Timeout waiting for ack\"));\n                        }\n                    }, 1000);\n                    await ctx.subscriber.subscribe(`${ctx.keyPrefix}:chunk:${listenerId}`, async (message) => {\n                        debugLog(\"Received message\", message);\n                        // The other side always sends a message even if it is the empty string.\n                        clearTimeout(timeout);\n                        resolve(readableStream);\n                        if (message === DONE_MESSAGE) {\n                            try {\n                                controller.close();\n                            }\n                            catch (e) {\n                                console.error(e);\n                            }\n                            await cleanup();\n                            return;\n                        }\n                        try {\n                            controller.enqueue(message);\n                        }\n                        catch (e) {\n                            console.error(e);\n                            await cleanup();\n                        }\n                    });\n                    await ctx.publisher.publish(`${ctx.keyPrefix}:request:${streamId}`, JSON.stringify({\n                        listenerId,\n                        skipCharacters,\n                    }));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            },\n        });\n    });\n}\nfunction incrOrDone(publisher, key) {\n    return publisher.incr(key).catch((reason) => {\n        const errorString = String(reason);\n        if (errorString.includes(\"ERR value is not an integer or out of range\")) {\n            return DONE_VALUE;\n        }\n        throw reason;\n    });\n}\nfunction debugLog(...messages) {\n    if (process.env.DEBUG || process.env.NODE_ENV === \"test\") {\n        console.log(...messages);\n    }\n}\n//# sourceMappingURL=runtime.js.map","module.exports = require(\"http\");","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","module.exports = require(\"redis\");","module.exports = import(\"ai\");;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRedisUrl = getRedisUrl;\nfunction getRedisUrl() {\n    const redisUrl = process.env.REDIS_URL || process.env.KV_URL;\n    if (!redisUrl) {\n        throw new Error(\"REDIS_URL environment variable is not set\");\n    }\n    return redisUrl;\n}\n//# sourceMappingURL=get-redis-url.js.map","module.exports = require(\"node:inspector\");","module.exports = require(\"net\");","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./redis\"), exports);\n//# sourceMappingURL=index.js.map","module.exports = require(\"events\");","/**\r\n * AI SDK Message Adapter\r\n *\r\n * This adapter handles the conversion between Vercel AI SDK message format\r\n * and our database schema format. The AI SDK expects certain fields in\r\n * camelCase format while our database uses snake_case.\r\n */\r\n\r\nimport { type Message as AIMessage } from \"ai\";\r\nimport { DBChatMessageRow } from \"@/_infrastructure/repositories/chat-repository\";\r\n\r\n/**\r\n * Converts a database message row to the format expected by the Vercel AI SDK.\r\n * @param message The message row from the database.\r\n * @returns The message in AI SDK format.\r\n */\r\nexport function dbMessageToAIMessage(message: DBChatMessageRow): AIMessage {\r\n  const parts =\r\n    typeof message.metadata === \"object\" &&\r\n    message.metadata !== null &&\r\n    \"parts\" in message.metadata\r\n      ? (message.metadata.parts as any)\r\n      : [{ type: \"text\", content: message.content }];\r\n\r\n  return {\r\n    id: message.id,\r\n    role: message.role as \"user\" | \"assistant\" | \"system\",\r\n    content: message.content || \"\",\r\n    createdAt: new Date(message.created_at),\r\n    // Re-construct parts and attachments from metadata if they exist, for full compatibility\r\n    ...(parts && {\r\n      parts: parts.map((p: any) => ({\r\n        type: p.type || \"text\",\r\n        ...(p.content && { content: p.content }),\r\n        ...(p.text && { text: p.text }),\r\n      })),\r\n    }),\r\n    ...(message.metadata &&\r\n      \"experimental_attachments\" in message.metadata && {\r\n        experimental_attachments: (message.metadata as any)\r\n          .experimental_attachments,\r\n      }),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert AI SDK message to database format\r\n */\r\nexport function aiMessageToDbFormat(\r\n  message: AIMessage,\r\n  sessionId: string,\r\n  userId: string\r\n): Partial<DBChatMessageRow> {\r\n  return {\r\n    id: message.id,\r\n    session_id: sessionId,\r\n    user_id: userId,\r\n    role: message.role,\r\n    content: message.content,\r\n    // Don't include created_at or updated_at - let the database handle them\r\n    metadata: {} as any,\r\n  };\r\n}\r\n\r\n/**\r\n * Strip any camelCase fields that might cause PostgREST issues\r\n */\r\nexport function sanitizeForPostgREST<T extends Record<string, any>>(obj: T): T {\r\n  const sanitized: any = {};\r\n\r\n  // List of fields that should never be sent to PostgREST\r\n  const blacklistedFields = [\"createdAt\", \"updatedAt\", \"userId\", \"sessionId\"];\r\n\r\n  for (const [key, value] of Object.entries(obj)) {\r\n    // Skip blacklisted fields\r\n    if (blacklistedFields.includes(key)) continue;\r\n\r\n    // Only include snake_case fields\r\n    if (!key.match(/[A-Z]/)) {\r\n      sanitized[key] = value;\r\n    }\r\n  }\r\n\r\n  return sanitized as T;\r\n}\r\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createResumableStreamContext = exports.resumeStream = void 0;\nconst get_redis_url_1 = require(\"./get-redis-url\");\nconst redis_1 = require(\"redis\");\nconst runtime_1 = require(\"./runtime\");\n__exportStar(require(\"./types\"), exports);\nvar runtime_2 = require(\"./runtime\");\nObject.defineProperty(exports, \"resumeStream\", { enumerable: true, get: function () { return runtime_2.resumeStream; } });\n/**\n * Creates a global context for resumable streams from which you can create resumable streams.\n *\n * Call `resumableStream` on the returned context object to create a stream.\n *\n * @param options - The context options.\n * @param options.keyPrefix - The prefix for the keys used by the resumable streams. Defaults to `resumable-stream`.\n * @param options.waitUntil - A function that takes a promise and ensures that the current program stays alive until the promise is resolved.\n * @param options.subscriber - A pubsub subscriber. Designed to be compatible with clients from the `redis` package. If not provided, a new client will be created based on REDIS_URL or KV_URL environment variables.\n * @param options.publisher - A pubsub publisher. Designed to be compatible with clients from the `redis` package. If not provided, a new client will be created based on REDIS_URL or KV_URL environment variables.\n * @returns A resumable stream context.\n */\nexports.createResumableStreamContext = (0, runtime_1.createResumableStreamContextFactory)({\n    publisher: () => (0, redis_1.createClient)({\n        url: (0, get_redis_url_1.getRedisUrl)(),\n    }),\n    subscriber: () => (0, redis_1.createClient)({\n        url: (0, get_redis_url_1.getRedisUrl)(),\n    }),\n});\n//# sourceMappingURL=redis.js.map"],"names":["isTestEnvironment","Boolean","process","env","PLAYWRIGHT_TEST_BASE_URL","PLAYWRIGHT","CI_PLAYWRIGHT","generateDummyPassword","artifactsPrompt","getRequestPromptFromHints","requestHints","latitude","longitude","city","country","selectedChatModel","requestPrompt","regularPrompt","testChatModel","testReasoningModel","testTitleModel","testArtifactModel","mockModel","name","id","doGenerate","text","myProvider","customProvider","languageModels","openai","wrapLanguageModel","model","fireworks","middleware","extractReasoningMiddleware","tagName","imageModels","image","MemoryCache","get","key","item","store","Date","now","expires","delete","value","set","ttl","undefined","clear","Map","eventQueue","batchTimeout","processBatchedEvents","clearTimeout","length","setTimeout","events","EVENT_BATCH_INTERVAL","splice","EVENT_BATCH_SIZE","supabase","getSupabaseClient","from","insert","map","event","event_name","properties","user_id","userId","timestamp","toISOString","session_id","sessionId","error","console","trackEvent","context","datadogRum","getInternalContext","addAction","push","cn","inputs","twMerge","clsx","generateUUID","crypto","randomUUID","replace","c","r","random","v","toString","password","generateIdFromAI","salt","genSaltSync","hashSync","hash","tracer","meter","SpanKind","INTERNAL","OK","ERROR","OTEL_SERVICE_NAME","OTEL_SERVICE_VERSION","OTEL_CONSOLE_EXPORTER","OTEL_METRICS_ENABLED","parseFloat","OTEL_SAMPLE_RATE","initialized","createMockSpan","setAttributes","setStatus","recordException","end","spanContext","traceId","createMockTracer","startSpan","createMockMeter","createCounter","add","createHistogram","record","initializeTracing","getMeter","requestCounter","description","requestDuration","tokenUsage","authCounter","guestSessionCounter","errorCounter","createTracedOperation","options","operation","span","result","code","SpanStatusCode","Error","String","message","authTracing","traceAuthAttempt","method","isGuest","kind","attributes","chatMetrics","is_guest","generateCorrelationId","Math","substring","constructor","correlationId","statusCode","authenticateRequest","request","headers","authHeader","startsWith","authenticateWithBearerToken","cookieAuth","authenticateWithCookies","guestAuth","authenticateGuestSession","AuthenticationError","logger","userAgent","ip","token","split","supabaseSpan","createSupabaseServiceClient","data","user","auth","getUser","userWithGuest","fullName","user_metadata","full_name","email","avatarUrl","avatar_url","role","userType","permissions","getUserPermissions","getAuthenticatedUser","isAuthenticated","warn","guestUser","getGuestSessionFromCookies","cookies","guestSessionId","createAuthErrorResponse","Response","JSON","stringify","status","redis","Redis","fromEnv","rateLimitConfigs","ocr","standard","requests","window","tokens","premium","enterprise","documentQA","batchProcessing","api","caseManagement","documentUpload","createRateLimiter","action","tier","config","Ratelimit","limiter","slidingWindow","analytics","prefix","ephemeralCache","limiters","RateLimitService","isAllowed","identifier","limit","success","remaining","reset","pending","reason","getRemainingLimit","response","getResetTime","checkMultiple","checks","Object","fromEntries","results","Promise","all","getRateLimitHeaders","floor","getTime","Logger","logLevel","buffer","maxBufferSize","envLogLevel","LOG_LEVEL","includes","getInstance","instance","shouldLog","level","levels","debug","info","formatMessage","entry","toUpperCase","addToBuffer","shift","createLogEntry","errorContext","stack","getBuffer","clearBuffer","setLogLevel","fetch","ponyfetch","fetchPonyfill","maxDuration","runtime","getWeatherTool","tool","inputSchema","z","describe","outputSchema","current","temperature_2m","time","daily","sunrise","sunset","hourly","onInputStart","toolCallId","onInputDelta","inputTextDelta","delta","onInputAvailable","input","execute","json","weatherData","createDocumentTool","session","title","content","type","tags","optional","createdAt","documentId","updateDocumentTool","updatedAt","chatVisibilityEnumValues","postRequestSchema","uuid","messages","min","max","ChatModelType","visibility","caseId","countryCode","updateChatSchema","nullable","modelType","globalStreamContext","getStreamContext","createResumableStreamContext","waitUntil","after","extractChatIdFromPath","pathname","parts","potentialId","validateUuid","extractTextFromMessage","textPart","find","p","enhanceWithRAGContext","userMessage","supabaseClient","createClient","SUPABASE_SERVICE_ROLE_KEY","openaiClient","OpenAI","OPENAI_API_KEY","retriever","HybridRetriever","generator","ContextAwareGenerator","searchResults","search","buildContext","userContext","createSystemPrompt","POST","startTime","URL","url","extractedChatId","authResult","authenticateRequestAdapter","userFromAuth","rateLimitResult","chatRepository","ChatRepository","endsWith","handleGenerateTitle","body","normalizedBody","uuidv4","selectedVisibilityType","chatIdFromRequest","clientMessages","parse","chatId","validatedData","userMessageContent","chatEntity","getChatById","newChatData","case_id","metadata","newChatRecord","create","Chat","fromDatabase","allMessages","getMessages","existingMessages","dbMessageToAIMessage","geolocation","systemPrompt","genericSystemPrompt","ragContext","addMessage","streamText","languageModel","system","convertToModelMessages","stopWhen","stepCountIs","hasToolCall","steps","lastStep","tools","GPT_3_5","getWeather","createDocument","updateDocument","onStepFinish","stepType","toolCalls","toolResults","finishReason","usage","reasoning","sources","files","stepTime","textLength","toolCallsCount","toolResultsCount","tokensUsed","totalTokens","hasReasoning","sourcesCount","filesCount","toolNames","tc","toolName","onChunk","chunk","reasoningLength","sourceType","source","sourceId","deltaLength","outputSize","output","onFinish","processingTime","assistantMessageId","modelId","promptTokens","completionTokens","responseId","onError","streamContext","streamId","resumableStream","storeStreamId","toUIMessageStreamResponse","messageMetadata","part","stepDuration","totalUsage","totalDuration","details","errors","chat","firstUserMessage","m","update","GET","searchParams","resumedStream","ReadableStream","toObject","parseInt","offset","chats","getByUserId","chatEntities","pagination","hasMore","PATCH","updatedChat","DELETE","deleteChat","serverComponentModule.GET","serverComponentModule.POST","serverComponentModule.PUT","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS","created_at","experimental_attachments"],"sourceRoot":""}