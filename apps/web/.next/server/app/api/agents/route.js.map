{"version":3,"file":"app/api/agents/route.js","mappings":"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eACA,CAAK,CACL,CACA,aACA,6BACA,OACA,EACA,UACA,CACA,cACA,2BACA,oBAEA,QACA,UC9TA,kBA2OM,EAAoB,OAA2C,CACrE,cACA,CAFuB,GAEvB,cAAqC,EAAM,kBAC3C,sCAA8C,EAAO,OAAO,EAAW,gJACvE,aACA,cACA,eACA,CAAK,CACL,GCpUO,aAEP,kCACA,kCAIA,OAHA,UACA,4BAJA,aAMA,QACA,cACA,uBACA,aACA,qBAIA,6CACA,KACA,aAIA,iBACA,oBACA,uBAMA,cAEA,SAEA,OADA,CAEA,CACA,CACA,gBACA,IAIA,EAJA,kBACA,IAQA,OAEA,WACA,EACA,UACA,kBACA,cACA,eACA,qBAiBA,OAhBA,qCACA,QACA,YAEA,OACA,qCACA,QACA,YACA,aACA,CAAa,CACb,CAAS,CACT,cACA,eACA,CAAK,EACL,0BACA,4BACA,CACA,CAoCA,QACA,eACA,gBACA,CACA,uBACA,uBACA,yBAIA,SAGA,0BACA,uBACA,uBAEA,CACA,UACA,2BACA,uBACA,wBAEA,CACA,CAYA,IAAM,EAAoB,OAA2C,CACrE,cACA,IAFuB,EAEvB,YAAqC,EAAM,kBAC3C,sCAA8C,EAAO,OAAO,EAAW,kJACvE,aACA,cACA,eACA,CAAK,CACL,GACA,cACA,kCACA,kCACA,MAGA,KACA,qBACA,2CAA+D,SAAa,QAAQ,EAAW,+OAC/F,aACA,cACA,eACA,CAAiB,OACH,6BACd,2CAA+D,SAAa,QAAQ,EAAW,wRAC/F,aACA,cACA,eACA,CAAiB,OACH,qBACd,2CAA+D,SAAa,QAAQ,EAAW,kOAC/F,aACA,cACA,eACA,CAAiB,CACjB,CAEA,wBACA,+DAA2E,SAAa,+EAA+E,EAAW,oJAClL,aACA,cACA,eACA,CAAa,EAEb,KACA,0BAEA,2CAAuE,SAAa,OAAO,GAAY,sJACvG,aACA,cACA,eACA,CAAiB,EACjB,0DACA,EAAc,gCAEd,uDACc,gCAEd,eACA,4DAAkF,SAAa,oDAAoD,EAAW,qGAC9J,aACA,cACA,eACA,CAAiB,CAGjB,OAFA,4BACA,4BACA,CACA,CAAoH,CAAtG,CAK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","sources":["webpack://_N_E/","webpack://_N_E/external commonjs \"node:buffer\"","webpack://_N_E/./src/lib/supabase/client.ts","webpack://_N_E/?d120","webpack://_N_E/external commonjs \"node:async_hooks\"","webpack://_N_E/./src/lib/ai/agents/agent-framework.ts","webpack://_N_E/./src/lib/ai/agents/agent-manager.ts","webpack://_N_E/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/esm/server/request/cookies.js","webpack://_N_E/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/esm/server/request/headers.js","webpack://_N_E/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/esm/server/request/draft-mode.js","webpack://_N_E/../../node_modules/.pnpm/next@15.3.0-canary.31_@babe_be67f368de2727c847f3a61f5e6cf4fa/node_modules/next/dist/esm/api/headers.js","webpack://_N_E/./src/lib/auth/nextjs.ts","webpack://_N_E/src/app/api/agents/route.ts","webpack://_N_E/sentry-wrapper-module","webpack://_N_E/./src/app/api/agents/route.ts","webpack://_N_E/?b10e"],"sourcesContent":[null,"module.exports = require(\"node:buffer\");","import {\n  createBrowserClient as _createBrowserClient,\n  createServerClient as _createServerClient,\n} from \"@supabase/ssr\";\nimport {\n  createClient as createSupabaseClient,\n  SupabaseClient,\n  type SupabaseClient as CoreSupabaseClient,\n} from \"@supabase/supabase-js\";\nimport fetchPonyfill from \"fetch-ponyfill\";\nimport { useMemo } from \"react\";\n\nimport type { Database } from \"@/types/database.types\";\n\nimport type { ReadonlyRequestCookies } from \"next/dist/server/web/spec-extension/adapters/request-cookies\";\n\n// Get fetch from ponyfill to avoid undici issues like 'Failed to execute 'fetch' on 'Window': Invalid name'\n// See: https://github.com/vercel/next.js/issues/54827\nconst { fetch: ponyfetch } = fetchPonyfill();\n\n// Environment variables for Supabase\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Type alias for clarity\nexport type TypedSupabaseClient = SupabaseClient<Database>;\nexport type TypedSSRSupabaseClient = CoreSupabaseClient<Database>;\n\n// --------------------------------------\n// Shared header builders\n// --------------------------------------\n\n/**\n * Default headers that must accompany every request made via a browser or server client\n * which authenticates with the anonymous public key.  This prevents 401 responses from\n * PostgREST that indicate the `apikey` header is missing.\n */\nconst anonymousHeaders: Record<string, string> | undefined = supabaseAnonKey\n  ? { apikey: supabaseAnonKey }\n  : undefined;\n\n/**\n * Default headers for the service-role client.  These include the service key as both the\n * `apikey` header and (where relevant) the `Authorization` header is still injected by the\n * libraryʼs internal `fetchWithAuth` helper.\n */\nconst serviceHeaders: Record<string, string> | undefined = serviceRoleKey\n  ? { apikey: serviceRoleKey }\n  : undefined;\n\n// Helper function to check essential env vars\nfunction checkPublicEnvVars() {\n  if (process.env.NODE_ENV === \"development\") {\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_URL present?\",\n      !!supabaseUrl\n    );\n    console.debug(\n      \"[Supabase Env] NEXT_PUBLIC_SUPABASE_ANON_KEY present?\",\n      !!supabaseAnonKey\n    );\n    console.debug(\n      \"[Supabase Env] SUPABASE_SERVICE_ROLE_KEY present?\",\n      !!serviceRoleKey\n    );\n  }\n  if (!supabaseUrl || !supabaseAnonKey) {\n    console.error(\n      \"Missing environment variables NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY\"\n    );\n    throw new Error(\"Supabase URL or Anon Key is missing.\");\n  }\n}\n\n// --------------------------------------\n// Patch global `fetch` on the **server** to use `ponyfetch`.\n// This avoids the infamous Undici \"Socket closed unexpectedly\" bug on\n// Windows/Node 18-20 without relying on fragile Undici internals.\n// The patch is idempotent and NO-OPs in the browser.\n\nif (typeof window === \"undefined\") {\n  const g = globalThis as any;\n  if (!g.__USING_PONYFETCH__) {\n    g.fetch = ponyfetch as unknown as typeof fetch;\n    g.__USING_PONYFETCH__ = true;\n    console.info(\"[Supabase] Server fetch patched to use ponyfetch ✅\");\n  }\n}\n\n// --- Browser Client (Singleton with Hook) ---\nlet browserClientInstance: TypedSSRSupabaseClient | undefined;\n\nfunction getSupabaseBrowserClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  if (browserClientInstance) {\n    return browserClientInstance;\n  }\n\n  // In the browser we rely on the native `fetch` implementation to ensure that\n  // request headers (apikey/Authorization) are preserved. Injecting a ponyfill\n  // here has proven to strip custom headers in certain edge-cases, leading to\n  // 401 \"No API key found\" responses. Therefore we only attach the required\n  // headers and leave `fetch` undefined so @supabase/ssr uses the global one.\n\n  browserClientInstance = _createBrowserClient<Database>(\n    supabaseUrl!,\n    supabaseAnonKey!,\n    {\n      global: {\n        headers: anonymousHeaders,\n      },\n    }\n  );\n\n  if (typeof window !== \"undefined\") {\n    console.debug(\"[Supabase] anon key present?\", !!supabaseAnonKey);\n  }\n\n  return browserClientInstance;\n}\n\n/**\n * Hook to get a Supabase client instance suitable for Browser/Client Components.\n * Uses a singleton pattern to ensure only one client instance is created.\n * Leverages @supabase/ssr for proper session handling with Next.js App Router.\n * @returns Memoized Supabase client instance for browser usage.\n */\nexport function useSupabaseBrowser(): TypedSSRSupabaseClient {\n  return useMemo(getSupabaseBrowserClient, []);\n}\n\n// This is the primary export for creating a browser client directly\nexport function createClient(): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createBrowserClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    global: {\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Server Client (For Server Components, Route Handlers, Server Actions) ---\n\n/**\n * Creates a Supabase client suitable for use in Server Components, Server Actions,\n * and Route Handlers that require access to cookies.\n * @param cookieStore A ReadonlyRequestCookies instance (e.g., from `next/headers`).\n * @returns Supabase client instance for server-side usage with cookie handling.\n */\nexport function createSupabaseServerClient(\n  cookieStore: ReadonlyRequestCookies\n): TypedSSRSupabaseClient {\n  checkPublicEnvVars();\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        return cookieStore.get(name)?.value;\n      },\n      set(name: string, value: string, options) {\n        try {\n          cookieStore.set(name, value, options);\n        } catch (error) {\n          console.warn(`Failed to set cookie '${name}':`, error);\n        }\n      },\n      remove(name: string, options) {\n        try {\n          cookieStore.set(name, \"\", options);\n        } catch (error) {\n          console.warn(`Failed to remove cookie '${name}':`, error);\n        }\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n}\n\n// --- Service Role Client (Admin Operations) ---\n\n/**\n * Creates a Supabase client with the service role key for admin operations.\n * WARNING: This client bypasses RLS. Use only in trusted server-side environments\n * with proper authorization checks. NEVER expose the service role key to the browser.\n * @returns Supabase client instance with service_role privileges.\n */\nexport function createSupabaseServiceClient(): TypedSupabaseClient {\n  if (!supabaseUrl || !serviceRoleKey) {\n    console.error(\"Supabase URL or Service Role Key is missing\");\n    throw new Error(\"Supabase service client configuration is incomplete.\");\n  }\n\n  return createSupabaseClient<Database>(supabaseUrl, serviceRoleKey, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: serviceHeaders,\n    },\n  });\n}\n\n// --- Client with Custom Auth Token ---\n\n/**\n * Creates a Supabase client authenticated with a custom JWT token.\n * Useful for scenarios like testing or specific server-to-server interactions.\n * @param authToken JWT token for authentication.\n * @returns Authenticated Supabase client instance.\n */\nexport function createClientWithAuth(authToken: string): TypedSupabaseClient {\n  checkPublicEnvVars();\n  return createSupabaseClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    auth: {\n      persistSession: false,\n      autoRefreshToken: false,\n      detectSessionInUrl: false,\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: {\n        Authorization: `Bearer ${authToken}`,\n        ...(anonymousHeaders ?? {}),\n      },\n    },\n  });\n}\n\n// ======================================\n// EDGE RUNTIME CLIENT\n// ======================================\n\n/**\n * Creates a Supabase client suitable for Edge Runtime environments (e.g., Edge Functions, Middleware).\n * Reads cookies from the Request headers. Requires manual handling for setting/removing cookies\n * via Response headers in the calling Edge function.\n * @param request The Request object from the Edge Function context.\n */\nexport const createEdgeClient = (request: Request): TypedSSRSupabaseClient => {\n  checkPublicEnvVars();\n  const cookieHeader = request.headers.get(\"cookie\") ?? \"\";\n\n  return _createServerClient<Database>(supabaseUrl!, supabaseAnonKey!, {\n    cookies: {\n      get(name: string) {\n        const match = cookieHeader.match(new RegExp(`(^|;)\\s*${name}=([^;]+)`));\n        return match?.[2];\n      },\n      set(name: string, value: string, options) {\n        console.warn(\n          `Attempted to set cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n      remove(name: string, options) {\n        console.warn(\n          `Attempted to remove cookie '${name}' in createEdgeClient. This must be handled by the caller via Response headers.`\n        );\n      },\n    },\n    global: {\n      fetch: ponyfetch,\n      headers: anonymousHeaders,\n    },\n  });\n};\n\n// --- Remove Deprecated Compatibility Exports ---\n\n/**\n * @deprecated Use `useSupabaseBrowser` in Client Components or `createSupabaseServerClient` in Server Components/Actions/Routes.\n */\nexport const getSupabaseClient = getSupabaseBrowserClient;\n\n/**\n * @deprecated Use `createSupabaseServiceClient` for elevated privilege operations.\n */\nexport const createServiceClient = createSupabaseServiceClient;\n\n/**\n * @deprecated Prefer specific client creation (`useSupabaseBrowser`, `createSupabaseServerClient`, `createSupabaseServiceClient`). Avoid direct default export usage.\n */\nexport const supabase = getSupabaseBrowserClient();\n",null,"module.exports = require(\"node:async_hooks\");","import { nanoid } from \"nanoid\";\r\nimport { z } from \"zod\";\r\n\r\nimport { customModel } from \"@/lib/ai/models\";\r\nimport {\r\n  generatePersonalizationContext,\r\n  getUserPersonalizationProfile,\r\n} from \"@/lib/ai/personalization/user-history\";\r\nimport { tools as aiTools } from \"@/lib/ai/tools\";\r\nimport { getSupabaseClient } from \"@/lib/supabase/client\";\r\nimport { ChatMessage } from \"@/types/chat\";\r\n\r\n// Define the agent state schema\r\nexport const AgentStateSchema = z.object({\r\n  id: z.string(),\r\n  userId: z.string().optional(),\r\n  messages: z.array(z.any()),\r\n  metadata: z.record(z.any()).optional(),\r\n  status: z.enum([\r\n    \"idle\",\r\n    \"thinking\",\r\n    \"executing\",\r\n    \"waiting\",\r\n    \"complete\",\r\n    \"error\",\r\n  ]),\r\n  createdAt: z.string(),\r\n  updatedAt: z.string(),\r\n  isArchived: z.boolean().default(false),\r\n});\r\n\r\nexport type AgentState = z.infer<typeof AgentStateSchema>;\r\n\r\n// Supported agent types\r\nexport enum AgentType {\r\n  VISA_ASSISTANT = \"visa_assistant\",\r\n  DOCUMENT_PREPARER = \"document_preparer\",\r\n  ELIGIBILITY_CHECKER = \"eligibility_checker\",\r\n  IMMIGRATION_ADVISOR = \"immigration_advisor\",\r\n}\r\n\r\n// Agent execution step result\r\nexport interface StepResult {\r\n  output: any;\r\n  error?: string;\r\n  nextAction?: string;\r\n}\r\n\r\n// Base agent class\r\nexport abstract class Agent {\r\n  id: string;\r\n  userId?: string;\r\n  messages: ChatMessage[];\r\n  metadata: Record<string, any>;\r\n  status: AgentState[\"status\"];\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  isArchived: boolean;\r\n  type: AgentType;\r\n\r\n  constructor(initialState?: Partial<AgentState>) {\r\n    this.id = initialState?.id || nanoid();\r\n    this.userId = initialState?.userId;\r\n    this.messages = initialState?.messages || [];\r\n    this.metadata = initialState?.metadata || {};\r\n    this.status = initialState?.status || \"idle\";\r\n    this.createdAt = initialState?.createdAt || new Date().toISOString();\r\n    this.updatedAt = initialState?.updatedAt || new Date().toISOString();\r\n    this.isArchived = initialState?.isArchived || false;\r\n    this.type = AgentType.IMMIGRATION_ADVISOR; // Default type\r\n  }\r\n\r\n  // Convert agent to state object for persistence\r\n  toState(): AgentState {\r\n    return {\r\n      id: this.id,\r\n      userId: this.userId,\r\n      messages: this.messages,\r\n      metadata: this.metadata,\r\n      status: this.status,\r\n      createdAt: this.createdAt,\r\n      updatedAt: new Date().toISOString(),\r\n      isArchived: this.isArchived,\r\n    };\r\n  }\r\n\r\n  // Save agent state to database\r\n  async save(): Promise<void> {\r\n    const supabase = getSupabaseClient();\r\n    const state = this.toState();\r\n\r\n    const { error } = await supabase.from(\"agents\").upsert({\r\n      id: state.id,\r\n      user_id: state.userId,\r\n      messages: state.messages,\r\n      metadata: state.metadata,\r\n      status: state.status,\r\n      created_at: state.createdAt,\r\n      updated_at: state.updatedAt,\r\n      is_archived: state.isArchived,\r\n      agent_type: this.type,\r\n    });\r\n\r\n    if (error) {\r\n      console.error(\"Failed to save agent state:\", error);\r\n      throw new Error(`Failed to save agent state: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Add a message to the agent's history\r\n  async addMessage(message: ChatMessage): Promise<void> {\r\n    this.messages.push(message);\r\n    this.updatedAt = new Date().toISOString();\r\n    await this.save();\r\n  }\r\n\r\n  // Set the agent's status\r\n  async setStatus(status: AgentState[\"status\"]): Promise<void> {\r\n    this.status = status;\r\n    this.updatedAt = new Date().toISOString();\r\n    await this.save();\r\n  }\r\n\r\n  // Archive the agent\r\n  async archive(): Promise<void> {\r\n    this.isArchived = true;\r\n    this.updatedAt = new Date().toISOString();\r\n    await this.save();\r\n  }\r\n\r\n  // Abstract methods to be implemented by specific agent types\r\n  abstract processMessage(message: string): Promise<string | ReadableStream>;\r\n  abstract executeStep(): Promise<StepResult>;\r\n  abstract getContext(): Promise<string>;\r\n}\r\n\r\n// Helper function to load an agent from the database\r\nexport async function loadAgent(agentId: string): Promise<Agent | null> {\r\n  const supabase = getSupabaseClient();\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agents\")\r\n    .select(\"*\")\r\n    .eq(\"id\", agentId)\r\n    .single();\r\n\r\n  if (error || !data) {\r\n    console.error(\"Failed to load agent:\", error);\r\n    return null;\r\n  }\r\n\r\n  // Factory pattern to create the appropriate agent type\r\n  return createAgentFromData(data);\r\n}\r\n\r\n// Helper function to create a new agent for a user\r\nexport async function createAgentForUser(\r\n  userId: string,\r\n  type: AgentType,\r\n  initialMessages: ChatMessage[] = []\r\n): Promise<Agent> {\r\n  const agent = createAgentByType(type, {\r\n    userId,\r\n    messages: initialMessages,\r\n    createdAt: new Date().toISOString(),\r\n    updatedAt: new Date().toISOString(),\r\n  });\r\n\r\n  await agent.save();\r\n  return agent;\r\n}\r\n\r\n// Factory function to create an agent by type\r\nfunction createAgentByType(\r\n  type: AgentType,\r\n  initialState?: Partial<AgentState>\r\n): Agent {\r\n  switch (type) {\r\n    case AgentType.VISA_ASSISTANT:\r\n      return new VisaAssistantAgent(initialState);\r\n    case AgentType.DOCUMENT_PREPARER:\r\n      return new DocumentPreparerAgent(initialState);\r\n    case AgentType.ELIGIBILITY_CHECKER:\r\n      return new EligibilityCheckerAgent(initialState);\r\n    case AgentType.IMMIGRATION_ADVISOR:\r\n    default:\r\n      return new ImmigrationAdvisorAgent(initialState);\r\n  }\r\n}\r\n\r\n// Factory function to create an agent from database data\r\nfunction createAgentFromData(data: any): Agent {\r\n  const agentType = data.agent_type as AgentType;\r\n\r\n  const initialState: Partial<AgentState> = {\r\n    id: data.id,\r\n    userId: data.user_id,\r\n    messages: data.messages,\r\n    metadata: data.metadata,\r\n    status: data.status,\r\n    createdAt: data.created_at,\r\n    updatedAt: data.updated_at,\r\n    isArchived: data.is_archived,\r\n  };\r\n\r\n  return createAgentByType(agentType, initialState);\r\n}\r\n\r\n// List all agents for a user\r\nexport async function listAgentsForUser(userId: string): Promise<Agent[]> {\r\n  const supabase = getSupabaseClient();\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agents\")\r\n    .select(\"*\")\r\n    .eq(\"user_id\", userId)\r\n    .eq(\"is_archived\", false)\r\n    .order(\"updated_at\", { ascending: false });\r\n\r\n  if (error) {\r\n    console.error(\"Failed to list agents:\", error);\r\n    return [];\r\n  }\r\n\r\n  // Create agent instances from data\r\n  return data.map(createAgentFromData);\r\n}\r\n\r\n// Specific agent implementations will be defined in separate files\r\n","import { nanoid } from \"nanoid\";\r\n\r\nimport { getSupabaseClient } from \"@/lib/supabase/client\";\r\nimport { ChatMessage } from \"@/types/chat\";\r\n\r\nimport {\r\n  Agent,\r\n  AgentState,\r\n  AgentType,\r\n  createAgentForUser,\r\n  loadAgent,\r\n  listAgentsForUser,\r\n} from \"./agent-framework\";\r\nimport { DocumentPreparerAgent } from \"./document-preparer\";\r\nimport { EligibilityCheckerAgent } from \"./eligibility-checker\";\r\nimport { ImmigrationAdvisorAgent } from \"./immigration-advisor\";\r\nimport { VisaAssistantAgent } from \"./visa-assistant\";\r\n\r\n/**\r\n * AgentManager coordinates autonomous agents for the immigration platform,\r\n * handling creation, routing, and management of agent interactions.\r\n */\r\nexport class AgentManager {\r\n  private userId?: string;\r\n\r\n  constructor(userId?: string) {\r\n    this.userId = userId;\r\n  }\r\n\r\n  /**\r\n   * Create a new agent of the specified type\r\n   */\r\n  async createAgent(agentType: AgentType): Promise<Agent> {\r\n    if (!this.userId) {\r\n      throw new Error(\"User ID is required to create an agent\");\r\n    }\r\n\r\n    return createAgentForUser(this.userId, agentType);\r\n  }\r\n\r\n  /**\r\n   * Load an existing agent by ID\r\n   */\r\n  async getAgent(agentId: string): Promise<Agent | null> {\r\n    return loadAgent(agentId);\r\n  }\r\n\r\n  /**\r\n   * List all agents for the current user\r\n   */\r\n  async listAgents(): Promise<Agent[]> {\r\n    if (!this.userId) {\r\n      return [];\r\n    }\r\n\r\n    return listAgentsForUser(this.userId);\r\n  }\r\n\r\n  /**\r\n   * Send a message to an agent and get a response\r\n   */\r\n  async sendMessage(\r\n    agentId: string,\r\n    message: string\r\n  ): Promise<string | ReadableStream> {\r\n    const agent = await this.getAgent(agentId);\r\n\r\n    if (!agent) {\r\n      throw new Error(`Agent with ID ${agentId} not found`);\r\n    }\r\n\r\n    return agent.processMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Route a message to the most appropriate agent based on content\r\n   */\r\n  async routeMessage(message: string): Promise<{\r\n    agentId: string;\r\n    response: string | ReadableStream;\r\n    isNewAgent: boolean;\r\n  }> {\r\n    if (!this.userId) {\r\n      throw new Error(\"User ID is required to route messages\");\r\n    }\r\n\r\n    // Get existing agents for the user\r\n    const existingAgents = await this.listAgents();\r\n\r\n    // Simple intent classifier to determine the appropriate agent type\r\n    const agentType = this.classifyMessageIntent(message);\r\n\r\n    // Try to find an existing agent of the appropriate type\r\n    const matchingAgent = existingAgents.find(\r\n      (agent) => agent.type === agentType\r\n    );\r\n\r\n    if (matchingAgent) {\r\n      // Use the existing agent\r\n      const response = await matchingAgent.processMessage(message);\r\n      return {\r\n        agentId: matchingAgent.id,\r\n        response,\r\n        isNewAgent: false,\r\n      };\r\n    } else {\r\n      // Create a new agent of the appropriate type\r\n      const newAgent = await this.createAgent(agentType);\r\n      const response = await newAgent.processMessage(message);\r\n      return {\r\n        agentId: newAgent.id,\r\n        response,\r\n        isNewAgent: true,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Archive an agent by ID\r\n   */\r\n  async archiveAgent(agentId: string): Promise<boolean> {\r\n    const agent = await this.getAgent(agentId);\r\n\r\n    if (!agent) {\r\n      return false;\r\n    }\r\n\r\n    await agent.archive();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Execute a step in an agent's workflow\r\n   */\r\n  async executeAgentStep(agentId: string): Promise<any> {\r\n    const agent = await this.getAgent(agentId);\r\n\r\n    if (!agent) {\r\n      throw new Error(`Agent with ID ${agentId} not found`);\r\n    }\r\n\r\n    return agent.executeStep();\r\n  }\r\n\r\n  /**\r\n   * Save agent feedback for improvement\r\n   */\r\n  async saveAgentFeedback(\r\n    agentId: string,\r\n    feedback: {\r\n      rating: number;\r\n      comments?: string;\r\n      wasHelpful: boolean;\r\n    }\r\n  ): Promise<void> {\r\n    if (!this.userId) {\r\n      throw new Error(\"User ID is required to save feedback\");\r\n    }\r\n\r\n    const supabase = getSupabaseClient();\r\n\r\n    await supabase.from(\"agent_feedback\").insert({\r\n      agent_id: agentId,\r\n      user_id: this.userId,\r\n      rating: feedback.rating,\r\n      comments: feedback.comments,\r\n      was_helpful: feedback.wasHelpful,\r\n      created_at: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Classify the intent of a message to determine the appropriate agent type\r\n   */\r\n  private classifyMessageIntent(message: string): AgentType {\r\n    // Simple rule-based classification\r\n    // In a real system, this could use a trained ML model\r\n\r\n    const lowerMessage = message.toLowerCase();\r\n\r\n    // Check for visa-related content\r\n    if (\r\n      lowerMessage.includes(\"visa\") ||\r\n      lowerMessage.includes(\"permit\") ||\r\n      lowerMessage.includes(\"application status\")\r\n    ) {\r\n      return AgentType.VISA_ASSISTANT;\r\n    }\r\n\r\n    // Check for document-related content\r\n    if (\r\n      lowerMessage.includes(\"document\") ||\r\n      lowerMessage.includes(\"form\") ||\r\n      lowerMessage.includes(\"paperwork\") ||\r\n      lowerMessage.includes(\"certificate\")\r\n    ) {\r\n      return AgentType.DOCUMENT_PREPARER;\r\n    }\r\n\r\n    // Check for eligibility-related content\r\n    if (\r\n      lowerMessage.includes(\"eligible\") ||\r\n      lowerMessage.includes(\"qualify\") ||\r\n      lowerMessage.includes(\"requirements\") ||\r\n      lowerMessage.includes(\"criteria\")\r\n    ) {\r\n      return AgentType.ELIGIBILITY_CHECKER;\r\n    }\r\n\r\n    // Default to general immigration advisor\r\n    return AgentType.IMMIGRATION_ADVISOR;\r\n  }\r\n}\r\n\r\n// Create a helper function to get an agent manager for a user\r\nexport function getAgentManager(userId?: string): AgentManager {\r\n  return new AgentManager(userId);\r\n}\r\n","import { areCookiesMutableInCurrentPhase, RequestCookiesAdapter } from '../web/spec-extension/adapters/request-cookies';\nimport { RequestCookies } from '../web/spec-extension/cookies';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { postponeWithTracking, abortAndThrowOnSynchronousRequestDataAccess, throwToInterruptStaticGeneration, trackDynamicDataInDynamicRender, trackSynchronousRequestDataAccessInDev } from '../app-render/dynamic-rendering';\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { scheduleImmediate } from '../../lib/scheduler';\nimport { isRequestAPICallableInsideAfter } from './utils';\nexport function cookies() {\n    const callingExpression = 'cookies';\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !isRequestAPICallableInsideAfter()) {\n            throw Object.defineProperty(new Error(// TODO(after): clarify that this only applies to pages?\n            `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E88\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic we override all other logic and always just return an empty\n            // cookies object without tracking\n            const underlyingCookies = createEmptyCookies();\n            return makeUntrackedExoticCookies(underlyingCookies);\n        }\n        if (workUnitStore) {\n            if (workUnitStore.type === 'cache') {\n                throw Object.defineProperty(new Error(`Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E398\",\n                    enumerable: false,\n                    configurable: true\n                });\n            } else if (workUnitStore.type === 'unstable-cache') {\n                throw Object.defineProperty(new Error(`Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E157\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E549\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            if (workUnitStore.type === 'prerender') {\n                // dynamicIO Prerender\n                // We don't track dynamic access here because access will be tracked when you access\n                // one of the properties of the cookies object.\n                return makeDynamicallyTrackedExoticCookies(workStore.route, workUnitStore);\n            } else if (workUnitStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                // We are prerendering with PPR. We need track dynamic access here eagerly\n                // to keep continuity with how cookies has worked in PPR without dynamicIO.\n                postponeWithTracking(workStore.route, callingExpression, workUnitStore.dynamicTracking);\n            } else if (workUnitStore.type === 'prerender-legacy') {\n                // Legacy Prerender\n                // We track dynamic access here so we don't need to wrap the cookies in\n                // individual property access tracking.\n                throwToInterruptStaticGeneration(callingExpression, workStore, workUnitStore);\n            }\n        }\n        // We fall through to the dynamic context below but we still track dynamic access\n        // because in dev we can still error for things like using cookies inside a cache context\n        trackDynamicDataInDynamicRender(workStore, workUnitStore);\n    }\n    // cookies is being called in a dynamic context\n    const requestStore = getExpectedRequestStore(callingExpression);\n    let underlyingCookies;\n    if (areCookiesMutableInCurrentPhase(requestStore)) {\n        // We can't conditionally return different types here based on the context.\n        // To avoid confusion, we always return the readonly type here.\n        underlyingCookies = requestStore.userspaceMutableCookies;\n    } else {\n        underlyingCookies = requestStore.cookies;\n    }\n    if (process.env.NODE_ENV === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {\n        return makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, workStore == null ? void 0 : workStore.route);\n    } else {\n        return makeUntrackedExoticCookies(underlyingCookies);\n    }\n}\nfunction createEmptyCookies() {\n    return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})));\n}\nconst CachedCookies = new WeakMap();\nfunction makeDynamicallyTrackedExoticCookies(route, prerenderStore) {\n    const cachedPromise = CachedCookies.get(prerenderStore);\n    if (cachedPromise) {\n        return cachedPromise;\n    }\n    const promise = makeHangingPromise(prerenderStore.renderSignal, '`cookies()`');\n    CachedCookies.set(prerenderStore, promise);\n    Object.defineProperties(promise, {\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`cookies()[Symbol.iterator]()`';\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        size: {\n            get () {\n                const expression = '`cookies().size`';\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        get: {\n            value: function get() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().get()`';\n                } else {\n                    expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``;\n                }\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        getAll: {\n            value: function getAll() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().getAll()`';\n                } else {\n                    expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``;\n                }\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        has: {\n            value: function has() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().has()`';\n                } else {\n                    expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``;\n                }\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        set: {\n            value: function set() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().set()`';\n                } else {\n                    const arg = arguments[0];\n                    if (arg) {\n                        expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``;\n                    } else {\n                        expression = '`cookies().set(...)`';\n                    }\n                }\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        delete: {\n            value: function() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().delete()`';\n                } else if (arguments.length === 1) {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``;\n                } else {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``;\n                }\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        clear: {\n            value: function clear() {\n                const expression = '`cookies().clear()`';\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        toString: {\n            value: function toString() {\n                const expression = '`cookies().toString()`';\n                const error = createCookiesAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticCookies(underlyingCookies) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = Promise.resolve(underlyingCookies);\n    CachedCookies.set(underlyingCookies, promise);\n    Object.defineProperties(promise, {\n        [Symbol.iterator]: {\n            value: underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].bind(underlyingCookies) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.bind(underlyingCookies)\n        },\n        size: {\n            get () {\n                return underlyingCookies.size;\n            }\n        },\n        get: {\n            value: underlyingCookies.get.bind(underlyingCookies)\n        },\n        getAll: {\n            value: underlyingCookies.getAll.bind(underlyingCookies)\n        },\n        has: {\n            value: underlyingCookies.has.bind(underlyingCookies)\n        },\n        set: {\n            value: underlyingCookies.set.bind(underlyingCookies)\n        },\n        delete: {\n            value: underlyingCookies.delete.bind(underlyingCookies)\n        },\n        clear: {\n            value: // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.bind(underlyingCookies) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise)\n        },\n        toString: {\n            value: underlyingCookies.toString.bind(underlyingCookies)\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, route) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = new Promise((resolve)=>scheduleImmediate(()=>resolve(underlyingCookies)));\n    CachedCookies.set(underlyingCookies, promise);\n    Object.defineProperties(promise, {\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`...cookies()` or similar iteration';\n                syncIODev(route, expression);\n                return underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].apply(underlyingCookies, arguments) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n                // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n                // has extra properties not available on RequestCookie instances.\n                polyfilledResponseCookiesIterator.call(underlyingCookies);\n            },\n            writable: false\n        },\n        size: {\n            get () {\n                const expression = '`cookies().size`';\n                syncIODev(route, expression);\n                return underlyingCookies.size;\n            }\n        },\n        get: {\n            value: function get() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().get()`';\n                } else {\n                    expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.get.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        getAll: {\n            value: function getAll() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().getAll()`';\n                } else {\n                    expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.getAll.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        has: {\n            value: function get() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().has()`';\n                } else {\n                    expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.has.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        set: {\n            value: function set() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().set()`';\n                } else {\n                    const arg = arguments[0];\n                    if (arg) {\n                        expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``;\n                    } else {\n                        expression = '`cookies().set(...)`';\n                    }\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.set.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        delete: {\n            value: function() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().delete()`';\n                } else if (arguments.length === 1) {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``;\n                } else {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.delete.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        clear: {\n            value: function clear() {\n                const expression = '`cookies().clear()`';\n                syncIODev(route, expression);\n                // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n                return typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.apply(underlyingCookies, arguments) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n                // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n                // has extra properties not available on RequestCookie instances.\n                polyfilledResponseCookiesClear.call(underlyingCookies, promise);\n            },\n            writable: false\n        },\n        toString: {\n            value: function toString() {\n                const expression = '`cookies().toString()` or implicit casting';\n                syncIODev(route, expression);\n                return underlyingCookies.toString.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        }\n    });\n    return promise;\n}\nfunction describeNameArg(arg) {\n    return typeof arg === 'object' && arg !== null && typeof arg.name === 'string' ? `'${arg.name}'` : typeof arg === 'string' ? `'${arg}'` : '...';\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n        // When we're rendering dynamically in dev we need to advance out of the\n        // Prerender environment when we read Request data synchronously\n        const requestStore = workUnitStore;\n        trackSynchronousRequestDataAccessInDev(requestStore);\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createCookiesAccessError);\nfunction createCookiesAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`cookies()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E223\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction polyfilledResponseCookiesIterator() {\n    return this.getAll().map((c)=>[\n            c.name,\n            c\n        ]).values();\n}\nfunction polyfilledResponseCookiesClear(returnable) {\n    for (const cookie of this.getAll()){\n        this.delete(cookie.name);\n    }\n    return returnable;\n}\n\n//# sourceMappingURL=cookies.js.map","import { HeadersAdapter } from '../web/spec-extension/adapters/headers';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external';\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { postponeWithTracking, abortAndThrowOnSynchronousRequestDataAccess, throwToInterruptStaticGeneration, trackDynamicDataInDynamicRender, trackSynchronousRequestDataAccessInDev } from '../app-render/dynamic-rendering';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { scheduleImmediate } from '../../lib/scheduler';\nimport { isRequestAPICallableInsideAfter } from './utils';\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */ export function headers() {\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !isRequestAPICallableInsideAfter()) {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E367\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic we override all other logic and always just return an empty\n            // headers object without tracking\n            const underlyingHeaders = HeadersAdapter.seal(new Headers({}));\n            return makeUntrackedExoticHeaders(underlyingHeaders);\n        }\n        if (workUnitStore) {\n            if (workUnitStore.type === 'cache') {\n                throw Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E304\",\n                    enumerable: false,\n                    configurable: true\n                });\n            } else if (workUnitStore.type === 'unstable-cache') {\n                throw Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E127\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E525\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            if (workUnitStore.type === 'prerender') {\n                // dynamicIO Prerender\n                // We don't track dynamic access here because access will be tracked when you access\n                // one of the properties of the headers object.\n                return makeDynamicallyTrackedExoticHeaders(workStore.route, workUnitStore);\n            } else if (workUnitStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                // We are prerendering with PPR. We need track dynamic access here eagerly\n                // to keep continuity with how headers has worked in PPR without dynamicIO.\n                // TODO consider switching the semantic to throw on property access instead\n                postponeWithTracking(workStore.route, 'headers', workUnitStore.dynamicTracking);\n            } else if (workUnitStore.type === 'prerender-legacy') {\n                // Legacy Prerender\n                // We are in a legacy static generation mode while prerendering\n                // We track dynamic access here so we don't need to wrap the headers in\n                // individual property access tracking.\n                throwToInterruptStaticGeneration('headers', workStore, workUnitStore);\n            }\n        }\n        // We fall through to the dynamic context below but we still track dynamic access\n        // because in dev we can still error for things like using headers inside a cache context\n        trackDynamicDataInDynamicRender(workStore, workUnitStore);\n    }\n    const requestStore = getExpectedRequestStore('headers');\n    if (process.env.NODE_ENV === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {\n        return makeUntrackedExoticHeadersWithDevWarnings(requestStore.headers, workStore == null ? void 0 : workStore.route);\n    } else {\n        return makeUntrackedExoticHeaders(requestStore.headers);\n    }\n}\nconst CachedHeaders = new WeakMap();\nfunction makeDynamicallyTrackedExoticHeaders(route, prerenderStore) {\n    const cachedHeaders = CachedHeaders.get(prerenderStore);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = makeHangingPromise(prerenderStore.renderSignal, '`headers()`');\n    CachedHeaders.set(prerenderStore, promise);\n    Object.defineProperties(promise, {\n        append: {\n            value: function append() {\n                const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``;\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        delete: {\n            value: function _delete() {\n                const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``;\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        get: {\n            value: function get() {\n                const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``;\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        has: {\n            value: function has() {\n                const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``;\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        set: {\n            value: function set() {\n                const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``;\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        getSetCookie: {\n            value: function getSetCookie() {\n                const expression = '`headers().getSetCookie()`';\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        forEach: {\n            value: function forEach() {\n                const expression = '`headers().forEach(...)`';\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        keys: {\n            value: function keys() {\n                const expression = '`headers().keys()`';\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        values: {\n            value: function values() {\n                const expression = '`headers().values()`';\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        entries: {\n            value: function entries() {\n                const expression = '`headers().entries()`';\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        },\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`headers()[Symbol.iterator]()`';\n                const error = createHeadersAccessError(route, expression);\n                abortAndThrowOnSynchronousRequestDataAccess(route, expression, error, prerenderStore);\n            }\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticHeaders(underlyingHeaders) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = Promise.resolve(underlyingHeaders);\n    CachedHeaders.set(underlyingHeaders, promise);\n    Object.defineProperties(promise, {\n        append: {\n            value: underlyingHeaders.append.bind(underlyingHeaders)\n        },\n        delete: {\n            value: underlyingHeaders.delete.bind(underlyingHeaders)\n        },\n        get: {\n            value: underlyingHeaders.get.bind(underlyingHeaders)\n        },\n        has: {\n            value: underlyingHeaders.has.bind(underlyingHeaders)\n        },\n        set: {\n            value: underlyingHeaders.set.bind(underlyingHeaders)\n        },\n        getSetCookie: {\n            value: underlyingHeaders.getSetCookie.bind(underlyingHeaders)\n        },\n        forEach: {\n            value: underlyingHeaders.forEach.bind(underlyingHeaders)\n        },\n        keys: {\n            value: underlyingHeaders.keys.bind(underlyingHeaders)\n        },\n        values: {\n            value: underlyingHeaders.values.bind(underlyingHeaders)\n        },\n        entries: {\n            value: underlyingHeaders.entries.bind(underlyingHeaders)\n        },\n        [Symbol.iterator]: {\n            value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders)\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticHeadersWithDevWarnings(underlyingHeaders, route) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = new Promise((resolve)=>scheduleImmediate(()=>resolve(underlyingHeaders)));\n    CachedHeaders.set(underlyingHeaders, promise);\n    Object.defineProperties(promise, {\n        append: {\n            value: function append() {\n                const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.append.apply(underlyingHeaders, arguments);\n            }\n        },\n        delete: {\n            value: function _delete() {\n                const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.delete.apply(underlyingHeaders, arguments);\n            }\n        },\n        get: {\n            value: function get() {\n                const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.get.apply(underlyingHeaders, arguments);\n            }\n        },\n        has: {\n            value: function has() {\n                const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.has.apply(underlyingHeaders, arguments);\n            }\n        },\n        set: {\n            value: function set() {\n                const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.set.apply(underlyingHeaders, arguments);\n            }\n        },\n        getSetCookie: {\n            value: function getSetCookie() {\n                const expression = '`headers().getSetCookie()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.getSetCookie.apply(underlyingHeaders, arguments);\n            }\n        },\n        forEach: {\n            value: function forEach() {\n                const expression = '`headers().forEach(...)`';\n                syncIODev(route, expression);\n                return underlyingHeaders.forEach.apply(underlyingHeaders, arguments);\n            }\n        },\n        keys: {\n            value: function keys() {\n                const expression = '`headers().keys()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.keys.apply(underlyingHeaders, arguments);\n            }\n        },\n        values: {\n            value: function values() {\n                const expression = '`headers().values()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.values.apply(underlyingHeaders, arguments);\n            }\n        },\n        entries: {\n            value: function entries() {\n                const expression = '`headers().entries()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.entries.apply(underlyingHeaders, arguments);\n            }\n        },\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`...headers()` or similar iteration';\n                syncIODev(route, expression);\n                return underlyingHeaders[Symbol.iterator].apply(underlyingHeaders, arguments);\n            }\n        }\n    });\n    return promise;\n}\nfunction describeNameArg(arg) {\n    return typeof arg === 'string' ? `'${arg}'` : '...';\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n        // When we're rendering dynamically in dev we need to advance out of the\n        // Prerender environment when we read Request data synchronously\n        const requestStore = workUnitStore;\n        trackSynchronousRequestDataAccessInDev(requestStore);\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createHeadersAccessError);\nfunction createHeadersAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`headers()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E277\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=headers.js.map","import { getDraftModeProviderForCacheScope, throwForMissingRequestStore } from '../app-render/work-unit-async-storage.external';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { abortAndThrowOnSynchronousRequestDataAccess, postponeWithTracking, trackSynchronousRequestDataAccessInDev } from '../app-render/dynamic-rendering';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\nexport function draftMode() {\n    const callingExpression = 'draftMode';\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (!workStore || !workUnitStore) {\n        throwForMissingRequestStore(callingExpression);\n    }\n    switch(workUnitStore.type){\n        case 'request':\n            return createOrGetCachedExoticDraftMode(workUnitStore.draftMode, workStore);\n        case 'cache':\n        case 'unstable-cache':\n            // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n            // the outmost work unit store is a request store, and if draft mode is\n            // enabled.\n            const draftModeProvider = getDraftModeProviderForCacheScope(workStore, workUnitStore);\n            if (draftModeProvider) {\n                return createOrGetCachedExoticDraftMode(draftModeProvider, workStore);\n            }\n        // Otherwise, we fall through to providing an empty draft mode.\n        // eslint-disable-next-line no-fallthrough\n        case 'prerender':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n            // Return empty draft mode\n            if (process.env.NODE_ENV === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {\n                const route = workStore == null ? void 0 : workStore.route;\n                return createExoticDraftModeWithDevWarnings(null, route);\n            } else {\n                return createExoticDraftMode(null);\n            }\n        default:\n            const _exhaustiveCheck = workUnitStore;\n            return _exhaustiveCheck;\n    }\n}\nfunction createOrGetCachedExoticDraftMode(draftModeProvider, workStore) {\n    const cachedDraftMode = CachedDraftModes.get(draftMode);\n    if (cachedDraftMode) {\n        return cachedDraftMode;\n    }\n    let promise;\n    if (process.env.NODE_ENV === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {\n        const route = workStore == null ? void 0 : workStore.route;\n        promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route);\n    } else {\n        promise = createExoticDraftMode(draftModeProvider);\n    }\n    CachedDraftModes.set(draftModeProvider, promise);\n    return promise;\n}\nconst CachedDraftModes = new WeakMap();\nfunction createExoticDraftMode(underlyingProvider) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    Object.defineProperty(promise, 'isEnabled', {\n        get () {\n            return instance.isEnabled;\n        },\n        set (newValue) {\n            Object.defineProperty(promise, 'isEnabled', {\n                value: newValue,\n                writable: true,\n                enumerable: true\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    promise.enable = instance.enable.bind(instance);\n    promise.disable = instance.disable.bind(instance);\n    return promise;\n}\nfunction createExoticDraftModeWithDevWarnings(underlyingProvider, route) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    Object.defineProperty(promise, 'isEnabled', {\n        get () {\n            const expression = '`draftMode().isEnabled`';\n            syncIODev(route, expression);\n            return instance.isEnabled;\n        },\n        set (newValue) {\n            Object.defineProperty(promise, 'isEnabled', {\n                value: newValue,\n                writable: true,\n                enumerable: true\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(promise, 'enable', {\n        value: function get() {\n            const expression = '`draftMode().enable()`';\n            syncIODev(route, expression);\n            return instance.enable.apply(instance, arguments);\n        }\n    });\n    Object.defineProperty(promise, 'disable', {\n        value: function get() {\n            const expression = '`draftMode().disable()`';\n            syncIODev(route, expression);\n            return instance.disable.apply(instance, arguments);\n        }\n    });\n    return promise;\n}\nclass DraftMode {\n    constructor(provider){\n        this._provider = provider;\n    }\n    get isEnabled() {\n        if (this._provider !== null) {\n            return this._provider.isEnabled;\n        }\n        return false;\n    }\n    enable() {\n        // We have a store we want to track dynamic data access to ensure we\n        // don't statically generate routes that manipulate draft mode.\n        trackDynamicDraftMode('draftMode().enable()');\n        if (this._provider !== null) {\n            this._provider.enable();\n        }\n    }\n    disable() {\n        trackDynamicDraftMode('draftMode().disable()');\n        if (this._provider !== null) {\n            this._provider.disable();\n        }\n    }\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n        // When we're rendering dynamically in dev we need to advance out of the\n        // Prerender environment when we read Request data synchronously\n        const requestStore = workUnitStore;\n        trackSynchronousRequestDataAccessInDev(requestStore);\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createDraftModeAccessError);\nfunction createDraftModeAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`draftMode()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E377\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction trackDynamicDraftMode(expression) {\n    const store = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (store) {\n        // We have a store we want to track dynamic data access to ensure we\n        // don't statically generate routes that manipulate draft mode.\n        if (workUnitStore) {\n            if (workUnitStore.type === 'cache') {\n                throw Object.defineProperty(new Error(`Route ${store.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E246\",\n                    enumerable: false,\n                    configurable: true\n                });\n            } else if (workUnitStore.type === 'unstable-cache') {\n                throw Object.defineProperty(new Error(`Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E259\",\n                    enumerable: false,\n                    configurable: true\n                });\n            } else if (workUnitStore.phase === 'after') {\n                throw Object.defineProperty(new Error(`Route ${store.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E348\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if (store.dynamicShouldError) {\n            throw Object.defineProperty(new StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E553\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            if (workUnitStore.type === 'prerender') {\n                // dynamicIO Prerender\n                const error = Object.defineProperty(new Error(`Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E126\",\n                    enumerable: false,\n                    configurable: true\n                });\n                abortAndThrowOnSynchronousRequestDataAccess(store.route, expression, error, workUnitStore);\n            } else if (workUnitStore.type === 'prerender-ppr') {\n                // PPR Prerender\n                postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n            } else if (workUnitStore.type === 'prerender-legacy') {\n                // legacy Prerender\n                workUnitStore.revalidate = 0;\n                const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E558\",\n                    enumerable: false,\n                    configurable: true\n                });\n                store.dynamicUsageDescription = expression;\n                store.dynamicUsageStack = err.stack;\n                throw err;\n            } else if (process.env.NODE_ENV === 'development' && workUnitStore && workUnitStore.type === 'request') {\n                workUnitStore.usedDynamic = true;\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=draft-mode.js.map","export * from '../server/request/cookies';\nexport * from '../server/request/headers';\nexport * from '../server/request/draft-mode';\n\n//# sourceMappingURL=headers.js.map","import { createServerClient, type CookieOptions } from \"@supabase/ssr\";\r\nimport { cookies } from \"next/headers\";\r\n\r\nimport { type Database } from \"@/types/database.types\";\r\n\r\nimport { ExtendedUser } from \"./types\";\r\n\r\nimport type { User } from \"@supabase/supabase-js\";\r\n\r\n/**\r\n * Get the authenticated user from the request\r\n * For Next.js API routes\r\n */\r\nexport async function getAuthenticatedUser(\r\n  request: Request\r\n): Promise<ExtendedUser | null> {\r\n  const supabase = createServerSupabaseClientForApiRoute();\r\n\r\n  const {\r\n    data: { user },\r\n    error: userError,\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (userError || !user) {\r\n    if (userError) {\r\n      console.error(\"Error fetching user in getAuthenticatedUser (API route):\");\r\n    }\r\n    return null;\r\n  }\r\n\r\n  const extendedUser: ExtendedUser = {\r\n    ...user,\r\n    fullName: user.user_metadata?.full_name || user.user_metadata?.name,\r\n    avatarUrl: user.user_metadata?.avatar_url,\r\n    role:\r\n      user.user_metadata?.role === \"admin\" ||\r\n      user.user_metadata?.role === \"user\"\r\n        ? user.user_metadata.role\r\n        : \"user\",\r\n  };\r\n\r\n  return extendedUser;\r\n}\r\n\r\n/**\r\n * Create a Supabase client using @supabase/ssr for server-side API routes.\r\n * NOTE: Provides only the `get` cookie method due to limitations in API routes.\r\n * This client might not handle token refreshes automatically.\r\n */\r\nfunction createServerSupabaseClientForApiRoute() {\r\n  const cookieStore = cookies();\r\n\r\n  return createServerClient<Database>(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        get(name: string) {\r\n          return cookieStore.get(name)?.value;\r\n        },\r\n      },\r\n    }\r\n  );\r\n}\r\n","import { nanoid } from 'nanoid';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { z } from 'zod';\r\n\r\nimport { AgentType } from '@/lib/ai/agents/agent-framework';\r\nimport { getAgentManager } from '@/lib/ai/agents/agent-manager';\r\nimport { getAuthenticatedUser } from '@/lib/auth/nextjs';\r\nimport { getSupabaseClient } from '@/lib/supabase/client';\r\n\r\n// Runtime configuration for edge deployment\r\nexport const runtime = 'edge';\r\nexport const dynamic = 'force-dynamic';\r\nexport const maxDuration = 60; // 60 second timeout\r\n\r\n// Schema for creating a new agent\r\nconst CreateAgentSchema = z.object({\r\n  agentType: z.enum([\r\n    AgentType.VISA_ASSISTANT,\r\n    AgentType.DOCUMENT_PREPARER,\r\n    AgentType.ELIGIBILITY_CHECKER,\r\n    AgentType.IMMIGRATION_ADVISOR,\r\n  ]),\r\n});\r\n\r\n// Schema for sending a message to an agent\r\nconst MessageSchema = z.object({\r\n  agentId: z.string(),\r\n  message: z.string(),\r\n});\r\n\r\n// Schema for automatic routing\r\nconst RouteMessageSchema = z.object({\r\n  message: z.string(),\r\n});\r\n\r\n// Schema for agent feedback\r\nconst FeedbackSchema = z.object({\r\n  agentId: z.string(),\r\n  rating: z.number().min(1).max(5),\r\n  comments: z.string().optional(),\r\n  wasHelpful: z.boolean(),\r\n});\r\n\r\n/**\r\n * GET - List agents for the current user\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // Get the authenticated user\r\n    const user = await getAuthenticatedUser(request);\r\n    \r\n    if (!user) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n    \r\n    // Get the agent manager\r\n    const agentManager = getAgentManager(user.id);\r\n    \r\n    // List agents\r\n    const agents = await agentManager.listAgents();\r\n    \r\n    return NextResponse.json({ agents });\r\n  } catch (error) {\r\n    console.error('Error listing agents:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to list agents' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * POST - Create a new agent or send a message to an agent\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    // Get the authenticated user\r\n    const user = await getAuthenticatedUser(request);\r\n    \r\n    if (!user) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n    \r\n    // Parse the request body\r\n    const body = await request.json();\r\n    \r\n    // Check which action to perform\r\n    if (body.action === 'create') {\r\n      // Create a new agent\r\n      const { agentType } = CreateAgentSchema.parse(body);\r\n      \r\n      const agentManager = getAgentManager(user.id);\r\n      const agent = await agentManager.createAgent(agentType);\r\n      \r\n      return NextResponse.json({ agentId: agent.id });\r\n    } else if (body.action === 'message') {\r\n      // Send a message to an agent\r\n      const { agentId, message } = MessageSchema.parse(body);\r\n      \r\n      const agentManager = getAgentManager(user.id);\r\n      \r\n      // Track the interaction in the database\r\n      const supabase = getSupabaseClient();\r\n      await supabase.from('user_interactions').insert({\r\n        user_id: user.id,\r\n        interaction_type: 'agent_message',\r\n        content: message,\r\n        created_at: new Date().toISOString(),\r\n      });\r\n      \r\n      // Get the response as a stream\r\n      const responseStream = await agentManager.sendMessage(agentId, message);\r\n      \r\n      // If it's a string, return it directly\r\n      if (typeof responseStream === 'string') {\r\n        return NextResponse.json({ response: responseStream });\r\n      }\r\n      \r\n      // Otherwise, create a streamed response\r\n      return new Response(responseStream);\r\n    } else if (body.action === 'route') {\r\n      // Route a message to the most appropriate agent\r\n      const { message } = RouteMessageSchema.parse(body);\r\n      \r\n      const agentManager = getAgentManager(user.id);\r\n      const result = await agentManager.routeMessage(message);\r\n      \r\n      // If the response is a string, return it directly\r\n      if (typeof result.response === 'string') {\r\n        return NextResponse.json({\r\n          agentId: result.agentId,\r\n          response: result.response,\r\n          isNewAgent: result.isNewAgent,\r\n        });\r\n      }\r\n      \r\n      // Otherwise, include the agent ID in the stream's metadata\r\n      const encoder = new TextEncoder();\r\n      const metadataChunk = encoder.encode(\r\n        `data: ${JSON.stringify({ agentId: result.agentId, isNewAgent: result.isNewAgent })}\\n\\n`\r\n      );\r\n      \r\n      // Create a new stream that includes the metadata\r\n      const metadataStream = new ReadableStream({\r\n        start(controller) {\r\n          controller.enqueue(metadataChunk);\r\n        }\r\n      });\r\n      \r\n      // Combine the metadata stream with the response stream\r\n      const combinedStream = new ReadableStream({\r\n        async start(controller) {\r\n          const metadataReader = metadataStream.getReader();\r\n          const responseReader = result.response.getReader();\r\n          \r\n          // First, enqueue the metadata\r\n          const { value, done } = await metadataReader.read();\r\n          if (!done) {\r\n            controller.enqueue(value);\r\n          }\r\n          \r\n          // Then, stream the response\r\n          while (true) {\r\n            const { value, done } = await responseReader.read();\r\n            if (done) break;\r\n            controller.enqueue(value);\r\n          }\r\n          \r\n          controller.close();\r\n        }\r\n      });\r\n      \r\n      return new Response(combinedStream);\r\n    } else if (body.action === 'feedback') {\r\n      // Save feedback for an agent\r\n      const feedback = FeedbackSchema.parse(body);\r\n      \r\n      const agentManager = getAgentManager(user.id);\r\n      await agentManager.saveAgentFeedback(feedback.agentId, {\r\n        rating: feedback.rating,\r\n        comments: feedback.comments,\r\n        wasHelpful: feedback.wasHelpful,\r\n      });\r\n      \r\n      return NextResponse.json({ success: true });\r\n    } else {\r\n      return NextResponse.json(\r\n        { error: 'Invalid action' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error('Error processing agent request:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to process request' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * DELETE - Archive an agent\r\n */\r\nexport async function DELETE(request: NextRequest) {\r\n  try {\r\n    // Get the authenticated user\r\n    const user = await getAuthenticatedUser(request);\r\n    \r\n    if (!user) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n    \r\n    // Parse the URL to get the agent ID\r\n    const { searchParams } = new URL(request.url);\r\n    const agentId = searchParams.get('agentId');\r\n    \r\n    if (!agentId) {\r\n      return NextResponse.json(\r\n        { error: 'Agent ID is required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n    \r\n    // Archive the agent\r\n    const agentManager = getAgentManager(user.id);\r\n    const success = await agentManager.archiveAgent(agentId);\r\n    \r\n    if (success) {\r\n      return NextResponse.json({ success: true });\r\n    } else {\r\n      return NextResponse.json(\r\n        { error: 'Agent not found or could not be archived' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error('Error archiving agent:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to archive agent' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} ","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/agents',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\agents\\\\route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/agents/route\",\n        pathname: \"/api/agents\",\n        filename: \"route\",\n        bundlePath: \"app/api/agents/route\"\n    },\n    resolvedPagePath: \"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\agents\\\\route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","var _self___RSC_MANIFEST;\nimport { createServerModuleMap } from \"next/dist/server/app-render/action-utils\";\nimport { setReferenceManifestsSingleton } from \"next/dist/server/app-render/encryption-utils\";\nimport { EdgeRouteModuleWrapper } from \"next/dist/server/web/edge-route-module-wrapper\";\n// Import the userland code.\nimport * as module from \"next-app-loader?name=app%2Fapi%2Fagents%2Froute&page=%2Fapi%2Fagents%2Froute&pagePath=private-next-app-dir%2Fapi%2Fagents%2Froute.ts&appDir=E%3A%5Cdownloads%5CHijraah%5Capps%5Cweb%5Csrc%5Capp&appPaths=%2Fapi%2Fagents%2Froute&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!private-next-app-dir/api/agents/route.ts?__next_edge_ssr_entry__\";\nconst nextConfig = {\"env\":{\"_sentryRewriteFramesDistDir\":\".next\",\"_sentryRewriteFramesAssetPrefixPath\":\"\",\"_sentryRewritesTunnelPath\":\"/monitoring\",\"_sentryRelease\":\"d92a5e8d8d7c20e1f785b33fde2c15257fdb31d2\"},\"eslint\":{\"ignoreDuringBuilds\":false,\"dirs\":[\"src\",\"app\",\"config\",\"scripts\",\"__tests__\"]},\"typescript\":{\"ignoreBuildErrors\":true,\"tsconfigPath\":\"tsconfig.json\"},\"distDir\":\".next\",\"cleanDistDir\":true,\"assetPrefix\":\"\",\"cacheMaxMemorySize\":52428800,\"configOrigin\":\"next.config.mjs\",\"useFileSystemPublicRoutes\":true,\"generateEtags\":true,\"pageExtensions\":[\"tsx\",\"ts\",\"jsx\",\"js\"],\"poweredByHeader\":false,\"compress\":true,\"images\":{\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"loaderFile\":\"\",\"domains\":[\"images.unsplash.com\",\"cdn.sanity.io\"],\"disableStaticImages\":false,\"minimumCacheTTL\":60,\"formats\":[\"image/webp\"],\"dangerouslyAllowSVG\":false,\"contentSecurityPolicy\":\"script-src 'none'; frame-src 'none'; sandbox;\",\"contentDispositionType\":\"attachment\",\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"**\"}],\"unoptimized\":false},\"devIndicators\":{\"position\":\"bottom-left\"},\"onDemandEntries\":{\"maxInactiveAge\":60000,\"pagesBufferLength\":5},\"amp\":{\"canonicalBase\":\"\"},\"basePath\":\"\",\"sassOptions\":{},\"trailingSlash\":false,\"i18n\":null,\"productionBrowserSourceMaps\":false,\"excludeDefaultMomentLocales\":true,\"serverRuntimeConfig\":{},\"publicRuntimeConfig\":{},\"reactProductionProfiling\":false,\"reactStrictMode\":true,\"reactMaxHeadersLength\":6000,\"httpAgentOptions\":{\"keepAlive\":true},\"logging\":{\"fetches\":{\"fullUrl\":true}},\"expireTime\":31536000,\"staticPageGenerationTimeout\":60,\"modularizeImports\":{\"@mui/icons-material\":{\"transform\":\"@mui/icons-material/{{member}}\"},\"lodash\":{\"transform\":\"lodash/{{member}}\"}},\"outputFileTracingRoot\":\"E:\\\\downloads\\\\Hijraah\",\"experimental\":{\"nodeMiddleware\":false,\"cacheLife\":{\"default\":{\"stale\":300,\"revalidate\":900,\"expire\":4294967294},\"seconds\":{\"stale\":0,\"revalidate\":1,\"expire\":60},\"minutes\":{\"stale\":300,\"revalidate\":60,\"expire\":3600},\"hours\":{\"stale\":300,\"revalidate\":3600,\"expire\":86400},\"days\":{\"stale\":300,\"revalidate\":86400,\"expire\":604800},\"weeks\":{\"stale\":300,\"revalidate\":604800,\"expire\":2592000},\"max\":{\"stale\":300,\"revalidate\":2592000,\"expire\":4294967294}},\"cacheHandlers\":{},\"cssChunking\":true,\"multiZoneDraftMode\":false,\"appNavFailHandling\":false,\"prerenderEarlyExit\":true,\"serverMinification\":true,\"serverSourceMaps\":false,\"linkNoTouchStart\":false,\"caseSensitiveRoutes\":false,\"clientSegmentCache\":false,\"preloadEntriesOnStart\":true,\"clientRouterFilter\":true,\"clientRouterFilterRedirects\":false,\"fetchCacheKeyPrefix\":\"\",\"middlewarePrefetch\":\"flexible\",\"optimisticClientCache\":true,\"manualClientBasePath\":false,\"cpus\":11,\"memoryBasedWorkersCount\":false,\"imgOptConcurrency\":null,\"imgOptTimeoutInSeconds\":7,\"imgOptMaxInputPixels\":268402689,\"imgOptSequentialRead\":null,\"isrFlushToDisk\":true,\"workerThreads\":false,\"optimizeCss\":true,\"nextScriptWorkers\":false,\"scrollRestoration\":false,\"externalDir\":false,\"disableOptimizedLoading\":false,\"gzipSize\":true,\"craCompat\":false,\"esmExternals\":true,\"fullySpecified\":false,\"swcTraceProfiling\":false,\"forceSwcTransforms\":false,\"largePageDataBytes\":128000,\"turbo\":{\"root\":\"E:\\\\downloads\\\\Hijraah\"},\"typedRoutes\":false,\"typedEnv\":false,\"clientTraceMetadata\":[\"baggage\",\"sentry-trace\"],\"parallelServerCompiles\":false,\"parallelServerBuildTraces\":false,\"ppr\":false,\"authInterrupts\":false,\"webpackMemoryOptimizations\":false,\"optimizeServerReact\":true,\"useEarlyImport\":false,\"viewTransition\":false,\"staleTimes\":{\"dynamic\":0,\"static\":300},\"serverComponentsHmrCache\":true,\"staticGenerationMaxConcurrency\":8,\"staticGenerationMinPagesPerWorker\":25,\"dynamicIO\":false,\"inlineCss\":false,\"useCache\":false,\"serverActions\":{\"bodySizeLimit\":\"2mb\",\"allowedOrigins\":[\"localhost:3000\"]},\"optimizePackageImports\":[\"lucide-react\",\"@radix-ui/react-icons\",\"date-fns\",\"lodash\",\"lodash-es\",\"ramda\",\"antd\",\"react-bootstrap\",\"ahooks\",\"@ant-design/icons\",\"@headlessui/react\",\"@headlessui-float/react\",\"@heroicons/react/20/solid\",\"@heroicons/react/24/solid\",\"@heroicons/react/24/outline\",\"@visx/visx\",\"@tremor/react\",\"rxjs\",\"@mui/material\",\"@mui/icons-material\",\"recharts\",\"react-use\",\"effect\",\"@effect/schema\",\"@effect/platform\",\"@effect/platform-node\",\"@effect/platform-browser\",\"@effect/platform-bun\",\"@effect/sql\",\"@effect/sql-mssql\",\"@effect/sql-mysql2\",\"@effect/sql-pg\",\"@effect/sql-squlite-node\",\"@effect/sql-squlite-bun\",\"@effect/sql-squlite-wasm\",\"@effect/sql-squlite-react-native\",\"@effect/rpc\",\"@effect/rpc-http\",\"@effect/typeclass\",\"@effect/experimental\",\"@effect/opentelemetry\",\"@material-ui/core\",\"@material-ui/icons\",\"@tabler/icons-react\",\"mui-core\",\"react-icons/ai\",\"react-icons/bi\",\"react-icons/bs\",\"react-icons/cg\",\"react-icons/ci\",\"react-icons/di\",\"react-icons/fa\",\"react-icons/fa6\",\"react-icons/fc\",\"react-icons/fi\",\"react-icons/gi\",\"react-icons/go\",\"react-icons/gr\",\"react-icons/hi\",\"react-icons/hi2\",\"react-icons/im\",\"react-icons/io\",\"react-icons/io5\",\"react-icons/lia\",\"react-icons/lib\",\"react-icons/lu\",\"react-icons/md\",\"react-icons/pi\",\"react-icons/ri\",\"react-icons/rx\",\"react-icons/si\",\"react-icons/sl\",\"react-icons/tb\",\"react-icons/tfi\",\"react-icons/ti\",\"react-icons/vsc\",\"react-icons/wi\"]},\"htmlLimitedBots\":\"Mediapartners-Google|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti\",\"bundlePagesRouterDependencies\":false,\"configFile\":\"E:\\\\downloads\\\\Hijraah\\\\apps\\\\web\\\\next.config.mjs\",\"configFileName\":\"next.config.mjs\",\"serverExternalPackages\":[\"pdf-parse\",\"ai\",\"amqplib\",\"connect\",\"dataloader\",\"express\",\"generic-pool\",\"graphql\",\"@hapi/hapi\",\"ioredis\",\"kafkajs\",\"koa\",\"lru-memoizer\",\"mongodb\",\"mongoose\",\"mysql\",\"mysql2\",\"knex\",\"pg\",\"pg-pool\",\"@node-redis/client\",\"@redis/client\",\"redis\",\"tedious\"],\"compiler\":{\"removeConsole\":{\"exclude\":[\"error\",\"warn\"]}},\"_originalRewrites\":{\"beforeFiles\":[],\"afterFiles\":[{\"source\":\"/monitoring(/?)\",\"has\":[{\"type\":\"query\",\"key\":\"o\",\"value\":\"(?<orgid>\\\\d*)\"},{\"type\":\"query\",\"key\":\"p\",\"value\":\"(?<projectid>\\\\d*)\"},{\"type\":\"query\",\"key\":\"r\",\"value\":\"(?<region>[a-z]{2})\"}],\"destination\":\"https://o:orgid.ingest.:region.sentry.io/api/:projectid/envelope/?hsts=0\"},{\"source\":\"/monitoring(/?)\",\"has\":[{\"type\":\"query\",\"key\":\"o\",\"value\":\"(?<orgid>\\\\d*)\"},{\"type\":\"query\",\"key\":\"p\",\"value\":\"(?<projectid>\\\\d*)\"}],\"destination\":\"https://o:orgid.ingest.sentry.io/api/:projectid/envelope/?hsts=0\"}],\"fallback\":[]},\"_originalRedirects\":[{\"source\":\"/login\",\"destination\":\"/auth/login\",\"permanent\":true},{\"source\":\"/signup\",\"destination\":\"/auth/signup\",\"permanent\":true}]}\nconst maybeJSONParse = (str)=>str ? JSON.parse(str) : undefined;\nconst rscManifest = (_self___RSC_MANIFEST = self.__RSC_MANIFEST) == null ? void 0 : _self___RSC_MANIFEST[\"/api/agents/route\"];\nconst rscServerManifest = maybeJSONParse(self.__RSC_SERVER_MANIFEST);\nif (rscManifest && rscServerManifest) {\n    setReferenceManifestsSingleton({\n        page: \"/api/agents/route\",\n        clientReferenceManifest: rscManifest,\n        serverActionsManifest: rscServerManifest,\n        serverModuleMap: createServerModuleMap({\n            serverActionsManifest: rscServerManifest\n        })\n    });\n}\nexport const ComponentMod = module;\nexport default EdgeRouteModuleWrapper.wrap(module.routeModule, {\n    nextConfig\n});\n\n//# sourceMappingURL=edge-app-route.js.map"],"names":["browserClientInstance","fetch","ponyfetch","fetchPonyfill","supabaseUrl","process","supabaseAnonKey","serviceRoleKey","env","SUPABASE_SERVICE_ROLE_KEY","anonymousHeaders","apikey","undefined","g","globalThis","__USING_PONYFETCH__","getSupabaseBrowserClient","checkPublicEnvVars","console","error","_createBrowserClient","global","headers","getSupabaseClient","z","id","userId","optional","messages","metadata","status","createdAt","updatedAt","isArchived","default","AgentType","loadAgent","agentId","supabase","data","from","select","eq","single","createAgentFromData","createAgentForUser","type","initialMessages","agent","createAgentByType","Date","toISOString","save","initialState","VisaAssistantAgent","DocumentPreparerAgent","EligibilityCheckerAgent","ImmigrationAdvisorAgent","agent_type","agentType","user_id","created_at","updated_at","is_archived","listAgentsForUser","order","ascending","map","AgentManager","constructor","createAgent","getAgent","listAgents","sendMessage","message","processMessage","routeMessage","existingAgents","classifyMessageIntent","matchingAgent","find","response","isNewAgent","newAgent","archiveAgent","archive","executeAgentStep","executeStep","saveAgentFeedback","feedback","insert","agent_id","rating","comments","was_helpful","wasHelpful","lowerMessage","toLowerCase","includes","VISA_ASSISTANT","DOCUMENT_PREPARER","ELIGIBILITY_CHECKER","IMMIGRATION_ADVISOR","getAgentManager","getAuthenticatedUser","request","createServerSupabaseClientForApiRoute","cookieStore","cookies","createServerClient","get","name","value","user","userError","auth","getUser","fullName","user_metadata","full_name","avatarUrl","avatar_url","role","runtime","dynamic","maxDuration","CreateAgentSchema","MessageSchema","RouteMessageSchema","FeedbackSchema","min","max","GET","NextResponse","json","agentManager","agents","POST","body","action","parse","interaction_type","content","responseStream","Response","result","metadataChunk","TextEncoder","encode","JSON","stringify","metadataStream","ReadableStream","start","controller","enqueue","combinedStream","metadataReader","getReader","responseReader","done","read","success","DELETE","searchParams","URL","url","serverComponentModule.GET","serverComponentModule.POST","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.HEAD","serverComponentModule.OPTIONS"],"sourceRoot":"","ignoreList":[7,8,9,10]}